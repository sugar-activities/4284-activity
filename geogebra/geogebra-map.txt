com.google.gwt.regexp.shared.MatchResult -> a.a.a.a.a.a:
    java.util.List groups -> a
    int index -> a
    java.lang.String input -> a
    java.lang.String getGroup(int) -> a
    int getIndex() -> a
com.google.gwt.regexp.shared.RegExp -> a.a.a.a.a.b:
    java.util.regex.Pattern REPLACEMENT_BACKSLASH -> a
    java.util.regex.Pattern REPLACEMENT_DOLLAR_AMPERSAND -> b
    java.util.regex.Pattern REPLACEMENT_DOLLAR_APOSTROPHE -> c
    java.util.regex.Pattern REPLACEMENT_DOLLAR_DOLLAR -> d
    boolean globalFlag -> a
    int lastIndex -> a
    java.util.regex.Pattern pattern -> e
    java.lang.String source -> a
    com.google.gwt.regexp.shared.RegExp compile(java.lang.String) -> a
    com.google.gwt.regexp.shared.RegExp compile(java.lang.String,java.lang.String) -> a
    java.util.Set parseFlags(java.lang.String) -> a
    com.google.gwt.regexp.shared.MatchResult exec(java.lang.String) -> a
    java.lang.String replace(java.lang.String,java.lang.String) -> a
com.vividsolutions.jts.algorithm.BoundaryNodeRule -> a.b.a.a.a:
    com.vividsolutions.jts.algorithm.BoundaryNodeRule MOD2_BOUNDARY_RULE -> a
    com.vividsolutions.jts.algorithm.BoundaryNodeRule ENDPOINT_BOUNDARY_RULE -> b
    com.vividsolutions.jts.algorithm.BoundaryNodeRule MULTIVALENT_ENDPOINT_BOUNDARY_RULE -> c
    com.vividsolutions.jts.algorithm.BoundaryNodeRule MONOVALENT_ENDPOINT_BOUNDARY_RULE -> d
    com.vividsolutions.jts.algorithm.BoundaryNodeRule OGC_SFS_BOUNDARY_RULE -> e
    boolean isInBoundary(int) -> a
com.vividsolutions.jts.algorithm.BoundaryNodeRule$EndPointBoundaryNodeRule -> a.b.a.a.a$a:
    boolean isInBoundary(int) -> a
com.vividsolutions.jts.algorithm.BoundaryNodeRule$Mod2BoundaryNodeRule -> a.b.a.a.a$b:
    boolean isInBoundary(int) -> a
com.vividsolutions.jts.algorithm.BoundaryNodeRule$MonoValentEndPointBoundaryNodeRule -> a.b.a.a.a$c:
    boolean isInBoundary(int) -> a
com.vividsolutions.jts.algorithm.BoundaryNodeRule$MultiValentEndPointBoundaryNodeRule -> a.b.a.a.a$d:
    boolean isInBoundary(int) -> a
com.vividsolutions.jts.algorithm.CGAlgorithms -> a.b.a.a.b:
    int orientationIndex(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isPointInRing(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> a
    int locatePointInRing(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> a
    boolean isOnLine(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> b
    boolean isCCW(com.vividsolutions.jts.geom.Coordinate[]) -> a
    int computeOrientation(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> b
    double distancePointLine(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.algorithm.CentralEndpointIntersector -> a.b.a.a.c:
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    com.vividsolutions.jts.geom.Coordinate intPt -> a
    com.vividsolutions.jts.geom.Coordinate getIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    void compute() -> a
    com.vividsolutions.jts.geom.Coordinate getIntersection() -> a
    com.vividsolutions.jts.geom.Coordinate average(com.vividsolutions.jts.geom.Coordinate[]) -> a
    com.vividsolutions.jts.geom.Coordinate findNearestPoint(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> a
com.vividsolutions.jts.algorithm.HCoordinate -> a.b.a.a.d:
    double x -> a
    double y -> b
    double w -> c
    com.vividsolutions.jts.geom.Coordinate intersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.algorithm.LineIntersector -> a.b.a.a.e:
    int result -> a
    com.vividsolutions.jts.geom.Coordinate[][] inputLines -> a
    com.vividsolutions.jts.geom.Coordinate[] intPt -> a
    boolean isProper -> a
    com.vividsolutions.jts.geom.Coordinate pa -> a
    com.vividsolutions.jts.geom.Coordinate pb -> b
    com.vividsolutions.jts.geom.PrecisionModel precisionModel -> a
    double computeEdgeDistance(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    void setPrecisionModel(com.vividsolutions.jts.geom.PrecisionModel) -> a
    void computeIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isCollinear() -> a
    void computeIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    int computeIntersect(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    java.lang.String toString() -> toString
    java.lang.String getTopologySummary() -> a
    boolean isEndPoint() -> b
    boolean hasIntersection() -> c
    int getIntersectionNum() -> a
    com.vividsolutions.jts.geom.Coordinate getIntersection(int) -> a
    boolean isIntersection(com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isInteriorIntersection() -> d
    boolean isInteriorIntersection(int) -> a
    boolean isProper() -> e
    double getEdgeDistance(int,int) -> a
com.vividsolutions.jts.algorithm.NotRepresentableException -> a.b.a.a.f:
com.vividsolutions.jts.algorithm.PointLocator -> a.b.a.a.g:
    com.vividsolutions.jts.algorithm.BoundaryNodeRule boundaryRule -> a
    boolean isIn -> a
    int numBoundaries -> a
    int locate(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Geometry) -> a
    void computeLocation(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Geometry) -> a
    void updateLocationInfo(int) -> a
    int locate(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Point) -> a
    int locate(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.LineString) -> a
    int locateInPolygonRing(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.LinearRing) -> a
    int locate(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Polygon) -> a
com.vividsolutions.jts.algorithm.RayCrossingCounter -> a.b.a.a.h:
    com.vividsolutions.jts.geom.Coordinate p -> a
    int crossingCount -> a
    boolean isPointOnSegment -> a
    int locatePointInRing(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> a
    void countSegment(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isOnSegment() -> a
    int getLocation() -> a
com.vividsolutions.jts.algorithm.RobustDeterminant -> a.b.a.a.i:
    int signOfDet2x2(double,double,double,double) -> a
com.vividsolutions.jts.algorithm.RobustLineIntersector -> a.b.a.a.j:
    void computeIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    int computeIntersect(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    int computeCollinearIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> b
    com.vividsolutions.jts.geom.Coordinate intersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    com.vividsolutions.jts.geom.Coordinate intersectionWithNormalization(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> b
    com.vividsolutions.jts.geom.Coordinate safeHCoordinateIntersection(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> c
    void normalizeToEnvCentre(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isInSegmentEnvelopes(com.vividsolutions.jts.geom.Coordinate) -> b
com.vividsolutions.jts.algorithm.locate.PointOnGeometryLocator -> a.b.a.a.a.a:
com.vividsolutions.jts.algorithm.locate.SimplePointInAreaLocator -> a.b.a.a.a.b:
    int locate(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Geometry) -> a
    boolean containsPoint(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Geometry) -> a
    boolean containsPointInPolygon(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Polygon) -> a
    boolean isPointInRing(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.LinearRing) -> a
com.vividsolutions.jts.geom.Coordinate -> a.b.a.b.a:
    double x -> a
    double y -> b
    double z -> c
    boolean equals2D(com.vividsolutions.jts.geom.Coordinate) -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    java.lang.String toString() -> toString
    java.lang.Object clone() -> clone
    double distance(com.vividsolutions.jts.geom.Coordinate) -> a
    int hashCode() -> hashCode
    int hashCode(double) -> a
com.vividsolutions.jts.geom.CoordinateArrays -> a.b.a.b.b:
    com.vividsolutions.jts.geom.Coordinate[] coordArrayType -> a
    int increasingDirection(com.vividsolutions.jts.geom.Coordinate[]) -> a
    boolean hasRepeatedPoints(com.vividsolutions.jts.geom.Coordinate[]) -> a
    com.vividsolutions.jts.geom.Coordinate[] removeRepeatedPoints(com.vividsolutions.jts.geom.Coordinate[]) -> a
com.vividsolutions.jts.geom.CoordinateFilter -> a.b.a.b.c:
    void filter(com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.geom.CoordinateList -> a.b.a.b.d:
    com.vividsolutions.jts.geom.Coordinate[] coordArrayType -> a
    boolean add(com.vividsolutions.jts.geom.Coordinate[],boolean,boolean) -> a
    boolean add(com.vividsolutions.jts.geom.Coordinate[],boolean) -> a
    void add(com.vividsolutions.jts.geom.Coordinate,boolean) -> a
    void add(int,com.vividsolutions.jts.geom.Coordinate,boolean) -> a
    com.vividsolutions.jts.geom.Coordinate[] toCoordinateArray() -> a
    java.lang.Object clone() -> clone
com.vividsolutions.jts.geom.CoordinateSequence -> a.b.a.b.e:
    com.vividsolutions.jts.geom.Coordinate getCoordinate(int) -> a
    double getX(int) -> a
    double getY(int) -> b
    int size() -> a
    com.vividsolutions.jts.geom.Coordinate[] toCoordinateArray() -> a
    com.vividsolutions.jts.geom.Envelope expandEnvelope(com.vividsolutions.jts.geom.Envelope) -> a
    java.lang.Object clone() -> clone
com.vividsolutions.jts.geom.CoordinateSequenceFactory -> a.b.a.b.f:
    com.vividsolutions.jts.geom.CoordinateSequence create(com.vividsolutions.jts.geom.Coordinate[]) -> a
com.vividsolutions.jts.geom.Envelope -> a.b.a.b.g:
    double minx -> a
    double maxx -> b
    double miny -> c
    double maxy -> d
    int hashCode() -> hashCode
    boolean intersects(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    boolean intersects(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    void init() -> a
    void init(double,double,double,double) -> a
    void init(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    void init(com.vividsolutions.jts.geom.Envelope) -> a
    void setToNull() -> b
    boolean isNull() -> a
    double getWidth() -> a
    double getHeight() -> b
    double getMinX() -> c
    double getMaxX() -> d
    double getMinY() -> e
    double getMaxY() -> f
    void expandToInclude(com.vividsolutions.jts.geom.Coordinate) -> a
    void expandToInclude(double,double) -> a
    void expandToInclude(com.vividsolutions.jts.geom.Envelope) -> b
    boolean intersects(com.vividsolutions.jts.geom.Envelope) -> a
    boolean intersects(com.vividsolutions.jts.geom.Coordinate) -> a
    boolean intersects(double,double) -> a
    boolean contains(com.vividsolutions.jts.geom.Envelope) -> b
    boolean contains(com.vividsolutions.jts.geom.Coordinate) -> b
    boolean covers(double,double) -> b
    boolean covers(com.vividsolutions.jts.geom.Coordinate) -> c
    boolean covers(com.vividsolutions.jts.geom.Envelope) -> c
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
com.vividsolutions.jts.geom.Geometry -> a.b.a.b.h:
    java.lang.Class[] sortedClasses -> a
    com.vividsolutions.jts.geom.GeometryComponentFilter geometryChangedFilter -> a
    com.vividsolutions.jts.geom.Envelope envelope -> a
    com.vividsolutions.jts.geom.GeometryFactory factory -> a
    int SRID -> a
    java.lang.Object userData -> a
    java.lang.String getGeometryType() -> a
    boolean hasNonEmptyElements(com.vividsolutions.jts.geom.Geometry[]) -> a
    boolean hasNullElements(java.lang.Object[]) -> a
    com.vividsolutions.jts.geom.GeometryFactory getFactory() -> a
    int getNumGeometries() -> a
    com.vividsolutions.jts.geom.Geometry getGeometryN(int) -> a
    com.vividsolutions.jts.geom.PrecisionModel getPrecisionModel() -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    int getNumPoints() -> b
    boolean isEmpty() -> a
    int getDimension() -> c
    com.vividsolutions.jts.geom.Envelope getEnvelopeInternal() -> a
    void geometryChanged() -> a
    void geometryChangedAction() -> b
    java.lang.String toString() -> toString
    java.lang.String toText() -> b
    com.vividsolutions.jts.geom.Geometry intersection(com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry union(com.vividsolutions.jts.geom.Geometry) -> b
    com.vividsolutions.jts.geom.Geometry difference(com.vividsolutions.jts.geom.Geometry) -> c
    void apply(com.vividsolutions.jts.geom.CoordinateFilter) -> a
    void apply(com.vividsolutions.jts.geom.GeometryComponentFilter) -> a
    java.lang.Object clone() -> clone
    int compareTo(java.lang.Object) -> compareTo
    void checkNotGeometryCollection(com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Envelope computeEnvelopeInternal() -> b
    int compareToSameClass(java.lang.Object) -> a
    int compare(java.util.Collection,java.util.Collection) -> a
    int getClassSortIndex() -> d
    void initSortedClasses() -> c
com.vividsolutions.jts.geom.Geometry$1 -> a.b.a.b.i:
    void filter(com.vividsolutions.jts.geom.Geometry) -> a
com.vividsolutions.jts.geom.GeometryCollection -> a.b.a.b.j:
    com.vividsolutions.jts.geom.Geometry[] geometries -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    boolean isEmpty() -> a
    int getDimension() -> c
    int getNumGeometries() -> a
    com.vividsolutions.jts.geom.Geometry getGeometryN(int) -> a
    int getNumPoints() -> b
    java.lang.String getGeometryType() -> a
    void apply(com.vividsolutions.jts.geom.CoordinateFilter) -> a
    void apply(com.vividsolutions.jts.geom.GeometryComponentFilter) -> a
    java.lang.Object clone() -> clone
    com.vividsolutions.jts.geom.Envelope computeEnvelopeInternal() -> b
    int compareToSameClass(java.lang.Object) -> a
com.vividsolutions.jts.geom.GeometryCollectionIterator -> a.b.a.b.k:
    com.vividsolutions.jts.geom.Geometry parent -> a
    boolean atStart -> a
    int max -> a
    int index -> b
    com.vividsolutions.jts.geom.GeometryCollectionIterator subcollectionIterator -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
com.vividsolutions.jts.geom.GeometryComponentFilter -> a.b.a.b.l:
    void filter(com.vividsolutions.jts.geom.Geometry) -> a
com.vividsolutions.jts.geom.GeometryFactory -> a.b.a.b.m:
    com.vividsolutions.jts.geom.PrecisionModel precisionModel -> a
    com.vividsolutions.jts.geom.CoordinateSequenceFactory coordinateSequenceFactory -> a
    int SRID -> a
    com.vividsolutions.jts.geom.CoordinateSequenceFactory getDefaultCoordinateSequenceFactory() -> b
    com.vividsolutions.jts.geom.Point[] toPointArray(java.util.Collection) -> a
    com.vividsolutions.jts.geom.Geometry[] toGeometryArray(java.util.Collection) -> a
    com.vividsolutions.jts.geom.LineString[] toLineStringArray(java.util.Collection) -> a
    com.vividsolutions.jts.geom.Polygon[] toPolygonArray(java.util.Collection) -> a
    com.vividsolutions.jts.geom.PrecisionModel getPrecisionModel() -> a
    com.vividsolutions.jts.geom.Point createPoint(com.vividsolutions.jts.geom.Coordinate) -> a
    com.vividsolutions.jts.geom.Point createPoint(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    com.vividsolutions.jts.geom.MultiLineString createMultiLineString(com.vividsolutions.jts.geom.LineString[]) -> a
    com.vividsolutions.jts.geom.GeometryCollection createGeometryCollection(com.vividsolutions.jts.geom.Geometry[]) -> a
    com.vividsolutions.jts.geom.MultiPolygon createMultiPolygon(com.vividsolutions.jts.geom.Polygon[]) -> a
    com.vividsolutions.jts.geom.LinearRing createLinearRing(com.vividsolutions.jts.geom.Coordinate[]) -> a
    com.vividsolutions.jts.geom.LinearRing createLinearRing(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    com.vividsolutions.jts.geom.MultiPoint createMultiPoint(com.vividsolutions.jts.geom.Point[]) -> a
    com.vividsolutions.jts.geom.Polygon createPolygon(com.vividsolutions.jts.geom.LinearRing,com.vividsolutions.jts.geom.LinearRing[]) -> a
    com.vividsolutions.jts.geom.Geometry buildGeometry(java.util.Collection) -> a
    com.vividsolutions.jts.geom.LineString createLineString(com.vividsolutions.jts.geom.Coordinate[]) -> a
    com.vividsolutions.jts.geom.LineString createLineString(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    int getSRID() -> a
    com.vividsolutions.jts.geom.CoordinateSequenceFactory getCoordinateSequenceFactory() -> a
com.vividsolutions.jts.geom.LineSegment -> a.b.a.b.n:
    com.vividsolutions.jts.geom.Coordinate p0 -> a
    com.vividsolutions.jts.geom.Coordinate p1 -> b
    double distance(com.vividsolutions.jts.geom.Coordinate) -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    java.lang.String toString() -> toString
com.vividsolutions.jts.geom.LineString -> a.b.a.b.o:
    com.vividsolutions.jts.geom.CoordinateSequence points -> a
    void init(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    com.vividsolutions.jts.geom.CoordinateSequence getCoordinateSequence() -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinateN(int) -> a
    int getDimension() -> c
    boolean isEmpty() -> a
    int getNumPoints() -> b
    boolean isClosed() -> b
    java.lang.String getGeometryType() -> a
    com.vividsolutions.jts.geom.Envelope computeEnvelopeInternal() -> b
    void apply(com.vividsolutions.jts.geom.CoordinateFilter) -> a
    void apply(com.vividsolutions.jts.geom.GeometryComponentFilter) -> a
    java.lang.Object clone() -> clone
    int compareToSameClass(java.lang.Object) -> a
com.vividsolutions.jts.geom.LinearRing -> a.b.a.b.p:
    void validateConstruction() -> c
    java.lang.String getGeometryType() -> a
com.vividsolutions.jts.geom.Location -> a.b.a.b.q:
    char toLocationSymbol(int) -> a
com.vividsolutions.jts.geom.MultiLineString -> a.b.a.b.r:
    int getDimension() -> c
    java.lang.String getGeometryType() -> a
com.vividsolutions.jts.geom.MultiPoint -> a.b.a.b.s:
    int getDimension() -> c
    java.lang.String getGeometryType() -> a
com.vividsolutions.jts.geom.MultiPolygon -> a.b.a.b.t:
    int getDimension() -> c
    java.lang.String getGeometryType() -> a
com.vividsolutions.jts.geom.Point -> a.b.a.b.u:
    com.vividsolutions.jts.geom.CoordinateSequence coordinates -> a
    void init(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    int getNumPoints() -> b
    boolean isEmpty() -> a
    int getDimension() -> c
    com.vividsolutions.jts.geom.Coordinate getCoordinate() -> a
    java.lang.String getGeometryType() -> a
    com.vividsolutions.jts.geom.Envelope computeEnvelopeInternal() -> b
    void apply(com.vividsolutions.jts.geom.CoordinateFilter) -> a
    void apply(com.vividsolutions.jts.geom.GeometryComponentFilter) -> a
    java.lang.Object clone() -> clone
    int compareToSameClass(java.lang.Object) -> a
    com.vividsolutions.jts.geom.CoordinateSequence getCoordinateSequence() -> a
com.vividsolutions.jts.geom.Polygon -> a.b.a.b.v:
    com.vividsolutions.jts.geom.LinearRing shell -> a
    com.vividsolutions.jts.geom.LinearRing[] holes -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    int getNumPoints() -> b
    int getDimension() -> c
    boolean isEmpty() -> a
    com.vividsolutions.jts.geom.LineString getExteriorRing() -> a
    int getNumInteriorRing() -> d
    com.vividsolutions.jts.geom.LineString getInteriorRingN(int) -> a
    java.lang.String getGeometryType() -> a
    com.vividsolutions.jts.geom.Envelope computeEnvelopeInternal() -> b
    void apply(com.vividsolutions.jts.geom.CoordinateFilter) -> a
    void apply(com.vividsolutions.jts.geom.GeometryComponentFilter) -> a
    java.lang.Object clone() -> clone
    int compareToSameClass(java.lang.Object) -> a
com.vividsolutions.jts.geom.PrecisionModel -> a.b.a.b.w:
    com.vividsolutions.jts.geom.PrecisionModel$Type FIXED -> a
    com.vividsolutions.jts.geom.PrecisionModel$Type FLOATING -> b
    com.vividsolutions.jts.geom.PrecisionModel$Type FLOATING_SINGLE -> c
    com.vividsolutions.jts.geom.PrecisionModel$Type modelType -> d
    double scale -> a
    int getMaximumSignificantDigits() -> a
    double getScale() -> a
    com.vividsolutions.jts.geom.PrecisionModel$Type getType() -> a
    double makePrecise(double) -> a
    void makePrecise(com.vividsolutions.jts.geom.Coordinate) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
com.vividsolutions.jts.geom.PrecisionModel$Type -> a.b.a.b.w$a:
    java.util.Map nameToTypeMap -> a
    java.lang.String name -> a
    java.lang.String toString() -> toString
com.vividsolutions.jts.geom.TopologyException -> a.b.a.b.x:
    com.vividsolutions.jts.geom.Coordinate pt -> a
    java.lang.String msgWithCoord(java.lang.String,com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.geom.impl.CoordinateArraySequence -> a.b.a.b.a.a:
    com.vividsolutions.jts.geom.Coordinate[] coordinates -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate(int) -> a
    double getX(int) -> a
    double getY(int) -> b
    java.lang.Object clone() -> clone
    int size() -> a
    com.vividsolutions.jts.geom.Coordinate[] toCoordinateArray() -> a
    com.vividsolutions.jts.geom.Envelope expandEnvelope(com.vividsolutions.jts.geom.Envelope) -> a
    java.lang.String toString() -> toString
com.vividsolutions.jts.geom.impl.CoordinateArraySequenceFactory -> a.b.a.b.a.b:
    com.vividsolutions.jts.geom.impl.CoordinateArraySequenceFactory instanceObject -> a
    com.vividsolutions.jts.geom.impl.CoordinateArraySequenceFactory instance() -> a
    com.vividsolutions.jts.geom.CoordinateSequence create(com.vividsolutions.jts.geom.Coordinate[]) -> a
com.vividsolutions.jts.geom.util.GeometryTransformer -> a.b.a.b.b.a:
    com.vividsolutions.jts.geom.Geometry inputGeom -> a
    com.vividsolutions.jts.geom.GeometryFactory factory -> a
    boolean pruneEmptyGeometry -> a
    boolean preserveGeometryCollectionType -> b
    boolean preserveCollections -> c
    boolean preserveType -> d
    com.vividsolutions.jts.geom.Geometry transform(com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.CoordinateSequence copy(com.vividsolutions.jts.geom.CoordinateSequence) -> a
    com.vividsolutions.jts.geom.CoordinateSequence transformCoordinates(com.vividsolutions.jts.geom.CoordinateSequence,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformPoint(com.vividsolutions.jts.geom.Point,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformMultiPoint(com.vividsolutions.jts.geom.MultiPoint,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformLinearRing(com.vividsolutions.jts.geom.LinearRing,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformLineString(com.vividsolutions.jts.geom.LineString,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformMultiLineString(com.vividsolutions.jts.geom.MultiLineString,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformPolygon(com.vividsolutions.jts.geom.Polygon,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformMultiPolygon(com.vividsolutions.jts.geom.MultiPolygon,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry transformGeometryCollection(com.vividsolutions.jts.geom.GeometryCollection,com.vividsolutions.jts.geom.Geometry) -> a
com.vividsolutions.jts.geomgraph.Depth -> a.b.a.c.a:
    int[][] depth -> a
    int depthAtLocation(int) -> a
    int getLocation(int,int) -> a
    boolean isNull() -> a
    boolean isNull(int) -> a
    boolean isNull(int,int) -> a
    void add(com.vividsolutions.jts.geomgraph.Label) -> a
    int getDelta(int) -> b
    void normalize() -> a
    java.lang.String toString() -> toString
com.vividsolutions.jts.geomgraph.DirectedEdge -> a.b.a.c.b:
    boolean isForward -> a
    boolean isInResult -> b
    boolean isVisited -> c
    com.vividsolutions.jts.geomgraph.DirectedEdge sym -> a
    com.vividsolutions.jts.geomgraph.DirectedEdge next -> b
    com.vividsolutions.jts.geomgraph.DirectedEdge nextMin -> c
    com.vividsolutions.jts.geomgraph.EdgeRing edgeRing -> a
    com.vividsolutions.jts.geomgraph.EdgeRing minEdgeRing -> b
    int[] depth -> a
    com.vividsolutions.jts.geomgraph.Edge getEdge() -> a
    void setInResult(boolean) -> a
    boolean isInResult() -> a
    boolean isVisited() -> b
    void setVisited(boolean) -> b
    void setEdgeRing(com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    com.vividsolutions.jts.geomgraph.EdgeRing getEdgeRing() -> a
    void setMinEdgeRing(com.vividsolutions.jts.geomgraph.EdgeRing) -> b
    com.vividsolutions.jts.geomgraph.EdgeRing getMinEdgeRing() -> b
    void setVisitedEdge(boolean) -> c
    com.vividsolutions.jts.geomgraph.DirectedEdge getSym() -> a
    boolean isForward() -> c
    void setSym(com.vividsolutions.jts.geomgraph.DirectedEdge) -> a
    com.vividsolutions.jts.geomgraph.DirectedEdge getNext() -> b
    void setNext(com.vividsolutions.jts.geomgraph.DirectedEdge) -> b
    com.vividsolutions.jts.geomgraph.DirectedEdge getNextMin() -> c
    void setNextMin(com.vividsolutions.jts.geomgraph.DirectedEdge) -> c
    boolean isLineEdge() -> d
    boolean isInteriorAreaEdge() -> e
    void computeDirectedLabel() -> a
com.vividsolutions.jts.geomgraph.DirectedEdgeStar -> a.b.a.c.c:
    java.util.List resultAreaEdgeList -> b
    com.vividsolutions.jts.geomgraph.Label label -> a
    int SCANNING_FOR_INCOMING -> a
    int LINKING_TO_OUTGOING -> b
    void insert(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    com.vividsolutions.jts.geomgraph.Label getLabel() -> a
    int getOutgoingDegree(com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    void computeLabelling(com.vividsolutions.jts.geomgraph.GeometryGraph[]) -> a
    void mergeSymLabels() -> a
    void updateLabelling(com.vividsolutions.jts.geomgraph.Label) -> a
    java.util.List getResultAreaEdges() -> b
    void linkResultDirectedEdges() -> b
    void linkMinimalDirectedEdges(com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    void findCoveredLineEdges() -> c
com.vividsolutions.jts.geomgraph.Edge -> a.b.a.c.d:
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    com.vividsolutions.jts.geomgraph.EdgeIntersectionList eiList -> a
    com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge mce -> a
    boolean isIsolated -> a
    com.vividsolutions.jts.geomgraph.Depth depth -> a
    int depthDelta -> a
    int getNumPoints() -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate(int) -> a
    com.vividsolutions.jts.geomgraph.Depth getDepth() -> a
    com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge getMonotoneChainEdge() -> a
    boolean isClosed() -> a
    boolean isCollapsed() -> b
    com.vividsolutions.jts.geomgraph.Edge getCollapsedEdge() -> a
    void setIsolated(boolean) -> a
    void addIntersections(com.vividsolutions.jts.algorithm.LineIntersector,int,int) -> a
    void addIntersection(com.vividsolutions.jts.algorithm.LineIntersector,int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    boolean isPointwiseEqual(com.vividsolutions.jts.geomgraph.Edge) -> a
com.vividsolutions.jts.geomgraph.EdgeEnd -> a.b.a.c.e:
    com.vividsolutions.jts.geomgraph.Edge edge -> a
    com.vividsolutions.jts.geomgraph.Label label -> a
    com.vividsolutions.jts.geomgraph.Node node -> a
    com.vividsolutions.jts.geom.Coordinate p0 -> a
    com.vividsolutions.jts.geom.Coordinate p1 -> b
    double dx -> a
    double dy -> b
    int quadrant -> a
    void init(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
    com.vividsolutions.jts.geomgraph.Edge getEdge() -> a
    com.vividsolutions.jts.geomgraph.Label getLabel() -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate() -> a
    void setNode(com.vividsolutions.jts.geomgraph.Node) -> a
    com.vividsolutions.jts.geomgraph.Node getNode() -> a
    int compareTo(java.lang.Object) -> compareTo
    int compareDirection(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    void computeLabel(com.vividsolutions.jts.algorithm.BoundaryNodeRule) -> a
com.vividsolutions.jts.geomgraph.EdgeEndStar -> a.b.a.c.f:
    java.util.Map edgeMap -> a
    java.util.List edgeList -> a
    int[] ptInAreaLocation -> a
    void insert(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    void insertEdgeEnd(com.vividsolutions.jts.geomgraph.EdgeEnd,java.lang.Object) -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate() -> a
    int getDegree() -> a
    java.util.Iterator iterator() -> a
    java.util.List getEdges() -> a
    void computeLabelling(com.vividsolutions.jts.geomgraph.GeometryGraph[]) -> a
    void computeEdgeEndLabels(com.vividsolutions.jts.algorithm.BoundaryNodeRule) -> a
    int getLocation(int,com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geomgraph.GeometryGraph[]) -> a
    void propagateSideLabels(int) -> a
com.vividsolutions.jts.geomgraph.EdgeIntersection -> a.b.a.c.g:
    com.vividsolutions.jts.geom.Coordinate coord -> a
    int segmentIndex -> a
    double dist -> a
    int compareTo(java.lang.Object) -> compareTo
    int compare(int,double) -> a
com.vividsolutions.jts.geomgraph.EdgeIntersectionList -> a.b.a.c.h:
    java.util.Map nodeMap -> a
    com.vividsolutions.jts.geomgraph.Edge edge -> a
    com.vividsolutions.jts.geomgraph.EdgeIntersection add(com.vividsolutions.jts.geom.Coordinate,int,double) -> a
    java.util.Iterator iterator() -> a
    void addEndpoints() -> a
    void addSplitEdges(java.util.List) -> a
    com.vividsolutions.jts.geomgraph.Edge createSplitEdge(com.vividsolutions.jts.geomgraph.EdgeIntersection,com.vividsolutions.jts.geomgraph.EdgeIntersection) -> a
com.vividsolutions.jts.geomgraph.EdgeList -> a.b.a.c.i:
    java.util.List edges -> a
    java.util.Map ocaMap -> a
    void add(com.vividsolutions.jts.geomgraph.Edge) -> a
    void addAll(java.util.Collection) -> a
    java.util.List getEdges() -> a
    com.vividsolutions.jts.geomgraph.Edge findEqualEdge(com.vividsolutions.jts.geomgraph.Edge) -> a
    java.util.Iterator iterator() -> a
com.vividsolutions.jts.geomgraph.EdgeNodingValidator -> a.b.a.c.j:
    com.vividsolutions.jts.noding.FastNodingValidator nv -> a
    void checkValid(java.util.Collection) -> a
    java.util.Collection toSegmentStrings(java.util.Collection) -> a
    void checkValid() -> a
com.vividsolutions.jts.geomgraph.EdgeRing -> a.b.a.c.k:
    com.vividsolutions.jts.geomgraph.DirectedEdge startDe -> a
    int maxNodeDegree -> a
    java.util.List edges -> a
    java.util.List pts -> b
    com.vividsolutions.jts.geomgraph.Label label -> a
    com.vividsolutions.jts.geom.LinearRing ring -> a
    boolean isHole -> a
    com.vividsolutions.jts.geomgraph.EdgeRing shell -> a
    java.util.ArrayList holes -> a
    com.vividsolutions.jts.geom.GeometryFactory geometryFactory -> a
    boolean isHole() -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate(int) -> a
    com.vividsolutions.jts.geom.LinearRing getLinearRing() -> a
    com.vividsolutions.jts.geomgraph.EdgeRing getShell() -> a
    void setShell(com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    void addHole(com.vividsolutions.jts.geomgraph.EdgeRing) -> b
    com.vividsolutions.jts.geom.Polygon toPolygon(com.vividsolutions.jts.geom.GeometryFactory) -> a
    void computeRing() -> a
    com.vividsolutions.jts.geomgraph.DirectedEdge getNext(com.vividsolutions.jts.geomgraph.DirectedEdge) -> a
    void setEdgeRing(com.vividsolutions.jts.geomgraph.DirectedEdge,com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    void computePoints(com.vividsolutions.jts.geomgraph.DirectedEdge) -> a
    int getMaxNodeDegree() -> a
    void computeMaxNodeDegree() -> c
    void setInResult() -> b
    void mergeLabel(com.vividsolutions.jts.geomgraph.Label) -> a
    void mergeLabel(com.vividsolutions.jts.geomgraph.Label,int) -> a
    void addPoints(com.vividsolutions.jts.geomgraph.Edge,boolean,boolean) -> a
com.vividsolutions.jts.geomgraph.GeometryGraph -> a.b.a.c.l:
    com.vividsolutions.jts.geom.Geometry parentGeom -> a
    java.util.Map lineEdgeMap -> a
    com.vividsolutions.jts.algorithm.BoundaryNodeRule boundaryNodeRule -> a
    boolean useBoundaryDeterminationRule -> a
    int argIndex -> a
    java.util.Collection boundaryNodes -> a
    boolean hasTooFewPoints -> b
    com.vividsolutions.jts.geom.Coordinate invalidPoint -> a
    com.vividsolutions.jts.algorithm.locate.PointOnGeometryLocator areaPtLocator -> a
    com.vividsolutions.jts.algorithm.PointLocator ptLocator -> a
    int determineBoundary(com.vividsolutions.jts.algorithm.BoundaryNodeRule,int) -> a
    com.vividsolutions.jts.geomgraph.index.EdgeSetIntersector createEdgeSetIntersector() -> a
    com.vividsolutions.jts.geom.Geometry getGeometry() -> a
    com.vividsolutions.jts.algorithm.BoundaryNodeRule getBoundaryNodeRule() -> a
    java.util.Collection getBoundaryNodes() -> a
    void computeSplitEdges(java.util.List) -> a
    void add(com.vividsolutions.jts.geom.Geometry) -> a
    void addCollection(com.vividsolutions.jts.geom.GeometryCollection) -> a
    void addPoint(com.vividsolutions.jts.geom.Point) -> a
    void addPolygonRing(com.vividsolutions.jts.geom.LinearRing,int,int) -> a
    void addPolygon(com.vividsolutions.jts.geom.Polygon) -> a
    void addLineString(com.vividsolutions.jts.geom.LineString) -> a
    com.vividsolutions.jts.geomgraph.index.SegmentIntersector computeSelfNodes(com.vividsolutions.jts.algorithm.LineIntersector,boolean) -> a
    com.vividsolutions.jts.geomgraph.index.SegmentIntersector computeEdgeIntersections(com.vividsolutions.jts.geomgraph.GeometryGraph,com.vividsolutions.jts.algorithm.LineIntersector,boolean) -> a
    void insertPoint(int,com.vividsolutions.jts.geom.Coordinate,int) -> a
    void insertBoundaryPoint(int,com.vividsolutions.jts.geom.Coordinate) -> a
    void addSelfIntersectionNodes(int) -> a
    void addSelfIntersectionNode(int,com.vividsolutions.jts.geom.Coordinate,int) -> b
com.vividsolutions.jts.geomgraph.GraphComponent -> a.b.a.c.m:
    com.vividsolutions.jts.geomgraph.Label label -> a
    boolean isInResult -> a
    boolean isCovered -> b
    boolean isCoveredSet -> c
    boolean isVisited -> d
    com.vividsolutions.jts.geomgraph.Label getLabel() -> a
    void setInResult(boolean) -> b
    boolean isInResult() -> c
    void setCovered(boolean) -> c
    boolean isCovered() -> d
    boolean isCoveredSet() -> e
com.vividsolutions.jts.geomgraph.Label -> a.b.a.c.n:
    com.vividsolutions.jts.geomgraph.TopologyLocation[] elt -> a
    com.vividsolutions.jts.geomgraph.Label toLineLabel(com.vividsolutions.jts.geomgraph.Label) -> a
    void flip() -> a
    int getLocation(int,int) -> a
    int getLocation(int) -> a
    void setLocation(int,int,int) -> a
    void setLocation(int,int) -> a
    void setAllLocationsIfNull(int,int) -> b
    void merge(com.vividsolutions.jts.geomgraph.Label) -> a
    int getGeometryCount() -> a
    boolean isNull(int) -> a
    boolean isAnyNull(int) -> b
    boolean isArea() -> a
    boolean isArea(int) -> c
    boolean isLine(int) -> d
    boolean allPositionsEqual(int,int) -> a
    void toLine(int) -> a
    java.lang.String toString() -> toString
com.vividsolutions.jts.geomgraph.Node -> a.b.a.c.o:
    com.vividsolutions.jts.geom.Coordinate coord -> a
    com.vividsolutions.jts.geomgraph.EdgeEndStar edges -> a
    com.vividsolutions.jts.geom.Coordinate getCoordinate() -> a
    com.vividsolutions.jts.geomgraph.EdgeEndStar getEdges() -> a
    boolean isIncidentEdgeInResult() -> a
    boolean isIsolated() -> b
    void add(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    void setLabel(int,int) -> a
com.vividsolutions.jts.geomgraph.NodeFactory -> a.b.a.c.p:
    com.vividsolutions.jts.geomgraph.Node createNode(com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.geomgraph.NodeMap -> a.b.a.c.q:
    java.util.Map nodeMap -> a
    com.vividsolutions.jts.geomgraph.NodeFactory nodeFact -> a
    com.vividsolutions.jts.geomgraph.Node addNode(com.vividsolutions.jts.geom.Coordinate) -> a
    void add(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    com.vividsolutions.jts.geomgraph.Node find(com.vividsolutions.jts.geom.Coordinate) -> b
    java.util.Iterator iterator() -> a
    java.util.Collection values() -> a
    java.util.Collection getBoundaryNodes(int) -> a
com.vividsolutions.jts.geomgraph.PlanarGraph -> a.b.a.c.r:
    java.util.List edges -> a
    com.vividsolutions.jts.geomgraph.NodeMap nodes -> a
    java.util.List edgeEndList -> b
    void linkResultDirectedEdges(java.util.Collection) -> a
    java.util.Collection getEdgeEnds() -> b
    boolean isBoundaryNode(int,com.vividsolutions.jts.geom.Coordinate) -> a
    void insertEdge(com.vividsolutions.jts.geomgraph.Edge) -> a
    void add(com.vividsolutions.jts.geomgraph.EdgeEnd) -> a
    java.util.Iterator getNodeIterator() -> a
    java.util.Collection getNodes() -> c
    com.vividsolutions.jts.geomgraph.Node addNode(com.vividsolutions.jts.geom.Coordinate) -> a
    void addEdges(java.util.List) -> b
com.vividsolutions.jts.geomgraph.Quadrant -> a.b.a.c.s:
    int quadrant(double,double) -> a
    int quadrant(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.geomgraph.TopologyLocation -> a.b.a.c.t:
    int[] location -> a
    void init(int) -> d
    int get(int) -> a
    boolean isNull() -> a
    boolean isAnyNull() -> b
    boolean isArea() -> c
    boolean isLine() -> d
    void flip() -> a
    void setAllLocations(int) -> a
    void setAllLocationsIfNull(int) -> b
    void setLocation(int,int) -> a
    void setLocation(int) -> c
    void setLocations(int,int,int) -> a
    boolean allPositionsEqual(int) -> a
    void merge(com.vividsolutions.jts.geomgraph.TopologyLocation) -> a
    java.lang.String toString() -> toString
com.vividsolutions.jts.geomgraph.index.EdgeSetIntersector -> a.b.a.c.a.a:
    void computeIntersections(java.util.List,com.vividsolutions.jts.geomgraph.index.SegmentIntersector,boolean) -> a
    void computeIntersections(java.util.List,java.util.List,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
com.vividsolutions.jts.geomgraph.index.MonotoneChain -> a.b.a.c.a.b:
    com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge mce -> a
    int chainIndex -> a
    void computeIntersections(com.vividsolutions.jts.geomgraph.index.MonotoneChain,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge -> a.b.a.c.a.c:
    com.vividsolutions.jts.geomgraph.Edge e -> a
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    int[] startIndex -> a
    com.vividsolutions.jts.geom.Envelope env1 -> a
    com.vividsolutions.jts.geom.Envelope env2 -> b
    int[] getStartIndexes() -> a
    double getMinX(int) -> a
    double getMaxX(int) -> b
    void computeIntersectsForChain(int,com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge,int,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
    void computeIntersectsForChain(int,int,com.vividsolutions.jts.geomgraph.index.MonotoneChainEdge,int,int,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
com.vividsolutions.jts.geomgraph.index.MonotoneChainIndexer -> a.b.a.c.a.d:
    int[] toIntArray(java.util.List) -> a
    int[] getChainStartIndices(com.vividsolutions.jts.geom.Coordinate[]) -> a
    int findChainEnd(com.vividsolutions.jts.geom.Coordinate[],int) -> a
com.vividsolutions.jts.geomgraph.index.SegmentIntersector -> a.b.a.c.a.e:
    boolean hasIntersection -> a
    boolean hasProper -> b
    boolean hasProperInterior -> c
    com.vividsolutions.jts.geom.Coordinate properIntersectionPoint -> a
    com.vividsolutions.jts.algorithm.LineIntersector li -> a
    boolean includeProper -> d
    boolean recordIsolated -> e
    int numIntersections -> b
    int numTests -> a
    java.util.Collection[] bdyNodes -> a
    boolean isAdjacentSegments(int,int) -> a
    void setBoundaryNodes(java.util.Collection,java.util.Collection) -> a
    boolean isTrivialIntersection(com.vividsolutions.jts.geomgraph.Edge,int,com.vividsolutions.jts.geomgraph.Edge,int) -> a
    void addIntersections(com.vividsolutions.jts.geomgraph.Edge,int,com.vividsolutions.jts.geomgraph.Edge,int) -> a
    boolean isBoundaryPoint(com.vividsolutions.jts.algorithm.LineIntersector,java.util.Collection[]) -> a
    boolean isBoundaryPoint(com.vividsolutions.jts.algorithm.LineIntersector,java.util.Collection) -> a
com.vividsolutions.jts.geomgraph.index.SimpleMCSweepLineIntersector -> a.b.a.c.a.f:
    java.util.List events -> a
    int nOverlaps -> a
    void computeIntersections(java.util.List,com.vividsolutions.jts.geomgraph.index.SegmentIntersector,boolean) -> a
    void computeIntersections(java.util.List,java.util.List,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
    void add(java.util.List) -> a
    void add(java.util.List,java.lang.Object) -> a
    void add(com.vividsolutions.jts.geomgraph.Edge,java.lang.Object) -> a
    void prepareEvents() -> a
    void computeIntersections(com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
    void processOverlaps(int,int,com.vividsolutions.jts.geomgraph.index.SweepLineEvent,com.vividsolutions.jts.geomgraph.index.SegmentIntersector) -> a
com.vividsolutions.jts.geomgraph.index.SweepLineEvent -> a.b.a.c.a.g:
    java.lang.Object edgeSet -> a
    double xValue -> a
    int eventType -> a
    com.vividsolutions.jts.geomgraph.index.SweepLineEvent insertEvent -> a
    int deleteEventIndex -> b
    java.lang.Object obj -> b
    boolean isInsert() -> a
    boolean isDelete() -> b
    com.vividsolutions.jts.geomgraph.index.SweepLineEvent getInsertEvent() -> a
    int getDeleteEventIndex() -> a
    void setDeleteEventIndex(int) -> a
    java.lang.Object getObject() -> a
    int compareTo(java.lang.Object) -> compareTo
com.vividsolutions.jts.index.SpatialIndex -> a.b.a.d.a:
    void insert(com.vividsolutions.jts.geom.Envelope,java.lang.Object) -> a
    java.util.List query(com.vividsolutions.jts.geom.Envelope) -> a
com.vividsolutions.jts.index.chain.MonotoneChain -> a.b.a.d.a.a:
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    int start -> a
    int end -> b
    com.vividsolutions.jts.geom.Envelope env -> a
    java.lang.Object context -> a
    int id -> c
    void setId(int) -> a
    int getId() -> a
    java.lang.Object getContext() -> a
    com.vividsolutions.jts.geom.Envelope getEnvelope() -> a
    void getLineSegment(int,com.vividsolutions.jts.geom.LineSegment) -> a
    void computeOverlaps(com.vividsolutions.jts.index.chain.MonotoneChain,com.vividsolutions.jts.index.chain.MonotoneChainOverlapAction) -> a
    void computeOverlaps(int,int,com.vividsolutions.jts.index.chain.MonotoneChain,int,int,com.vividsolutions.jts.index.chain.MonotoneChainOverlapAction) -> a
com.vividsolutions.jts.index.chain.MonotoneChainBuilder -> a.b.a.d.a.b:
    int[] toIntArray(java.util.List) -> a
    java.util.List getChains(com.vividsolutions.jts.geom.Coordinate[],java.lang.Object) -> a
    int[] getChainStartIndices(com.vividsolutions.jts.geom.Coordinate[]) -> a
    int findChainEnd(com.vividsolutions.jts.geom.Coordinate[],int) -> a
com.vividsolutions.jts.index.chain.MonotoneChainOverlapAction -> a.b.a.d.a.c:
    com.vividsolutions.jts.geom.Envelope tempEnv1 -> a
    com.vividsolutions.jts.geom.Envelope tempEnv2 -> b
    com.vividsolutions.jts.geom.LineSegment overlapSeg1 -> a
    com.vividsolutions.jts.geom.LineSegment overlapSeg2 -> b
    void overlap(com.vividsolutions.jts.index.chain.MonotoneChain,int,com.vividsolutions.jts.index.chain.MonotoneChain,int) -> a
    void overlap(com.vividsolutions.jts.geom.LineSegment,com.vividsolutions.jts.geom.LineSegment) -> a
com.vividsolutions.jts.index.strtree.AbstractNode -> a.b.a.d.b.a:
    java.util.ArrayList childBoundables -> a
    java.lang.Object bounds -> a
    int level -> a
    java.util.List getChildBoundables() -> a
    java.lang.Object computeBounds() -> a
    java.lang.Object getBounds() -> b
    void addChildBoundable(com.vividsolutions.jts.index.strtree.Boundable) -> a
com.vividsolutions.jts.index.strtree.AbstractSTRtree -> a.b.a.d.b.b:
    com.vividsolutions.jts.index.strtree.AbstractNode root -> a
    boolean built -> a
    java.util.ArrayList itemBoundables -> a
    int nodeCapacity -> a
    void build() -> a
    com.vividsolutions.jts.index.strtree.AbstractNode createNode(int) -> a
    java.util.List createParentBoundables(java.util.List,int) -> a
    com.vividsolutions.jts.index.strtree.AbstractNode lastNode(java.util.List) -> a
    int compareDoubles(double,double) -> a
    com.vividsolutions.jts.index.strtree.AbstractNode createHigherLevels(java.util.List,int) -> a
    int getNodeCapacity() -> a
    void insert(java.lang.Object,java.lang.Object) -> a
    java.util.List query(java.lang.Object) -> a
    com.vividsolutions.jts.index.strtree.AbstractSTRtree$IntersectsOp getIntersectsOp() -> a
    void query(java.lang.Object,com.vividsolutions.jts.index.strtree.AbstractNode,java.util.List) -> a
    java.util.Comparator getComparator() -> a
com.vividsolutions.jts.index.strtree.AbstractSTRtree$IntersectsOp -> a.b.a.d.b.b$a:
    boolean intersects(java.lang.Object,java.lang.Object) -> a
com.vividsolutions.jts.index.strtree.Boundable -> a.b.a.d.b.c:
    java.lang.Object getBounds() -> b
com.vividsolutions.jts.index.strtree.ItemBoundable -> a.b.a.d.b.d:
    java.lang.Object bounds -> a
    java.lang.Object item -> b
    java.lang.Object getBounds() -> b
    java.lang.Object getItem() -> a
com.vividsolutions.jts.index.strtree.STRtree -> a.b.a.d.b.e:
    java.util.Comparator xComparator -> a
    java.util.Comparator yComparator -> b
    com.vividsolutions.jts.index.strtree.AbstractSTRtree$IntersectsOp intersectsOp -> a
    double centreX(com.vividsolutions.jts.geom.Envelope) -> a
    double avg(double,double) -> a
    double centreY(com.vividsolutions.jts.geom.Envelope) -> b
    java.util.List createParentBoundables(java.util.List,int) -> a
    java.util.List createParentBoundablesFromVerticalSlices(java.util.List[],int) -> a
    java.util.List createParentBoundablesFromVerticalSlice(java.util.List,int) -> b
    java.util.List[] verticalSlices(java.util.List,int) -> a
    com.vividsolutions.jts.index.strtree.AbstractNode createNode(int) -> a
    com.vividsolutions.jts.index.strtree.AbstractSTRtree$IntersectsOp getIntersectsOp() -> a
    void insert(com.vividsolutions.jts.geom.Envelope,java.lang.Object) -> a
    java.util.List query(com.vividsolutions.jts.geom.Envelope) -> a
    java.util.Comparator getComparator() -> a
    double access$0(com.vividsolutions.jts.index.strtree.STRtree,com.vividsolutions.jts.geom.Envelope) -> a
    double access$1(com.vividsolutions.jts.index.strtree.STRtree,com.vividsolutions.jts.geom.Envelope) -> b
com.vividsolutions.jts.index.strtree.STRtree$1 -> a.b.a.d.b.f:
    com.vividsolutions.jts.index.strtree.STRtree this$0 -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.vividsolutions.jts.index.strtree.STRtree$2 -> a.b.a.d.b.g:
    com.vividsolutions.jts.index.strtree.STRtree this$0 -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.vividsolutions.jts.index.strtree.STRtree$3 -> a.b.a.d.b.h:
    com.vividsolutions.jts.index.strtree.STRtree this$0 -> a
    boolean intersects(java.lang.Object,java.lang.Object) -> a
com.vividsolutions.jts.index.strtree.STRtree$4 -> a.b.a.d.b.i:
    com.vividsolutions.jts.index.strtree.STRtree this$0 -> a
    java.lang.Object computeBounds() -> a
com.vividsolutions.jts.io.WKTWriter -> a.b.a.e.a:
    int INDENT -> a
    int outputDimension -> b
    java.lang.String toLineString(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.noding.BasicSegmentString -> a.b.a.f.a:
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    java.lang.Object data -> a
    int size() -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
com.vividsolutions.jts.noding.FastNodingValidator -> a.b.a.f.b:
    com.vividsolutions.jts.algorithm.LineIntersector li -> a
    java.util.Collection segStrings -> a
    com.vividsolutions.jts.noding.InteriorIntersectionFinder segInt -> a
    boolean isValid -> a
    java.lang.String getErrorMessage() -> a
    void checkValid() -> a
    void execute() -> b
    void checkInteriorIntersections() -> c
com.vividsolutions.jts.noding.InteriorIntersectionFinder -> a.b.a.f.c:
    boolean isCheckEndSegmentsOnly -> a
    com.vividsolutions.jts.algorithm.LineIntersector li -> a
    com.vividsolutions.jts.geom.Coordinate interiorIntersection -> a
    com.vividsolutions.jts.geom.Coordinate[] intSegments -> a
    boolean hasIntersection() -> a
    com.vividsolutions.jts.geom.Coordinate getInteriorIntersection() -> a
    com.vividsolutions.jts.geom.Coordinate[] getIntersectionSegments() -> a
    void processIntersections(com.vividsolutions.jts.noding.SegmentString,int,com.vividsolutions.jts.noding.SegmentString,int) -> a
    boolean isEndSegment(com.vividsolutions.jts.noding.SegmentString,int) -> a
    boolean isDone() -> b
com.vividsolutions.jts.noding.MCIndexNoder -> a.b.a.f.d:
    java.util.List monoChains -> a
    com.vividsolutions.jts.index.SpatialIndex index -> a
    int idCounter -> a
    java.util.Collection nodedSegStrings -> a
    int nOverlaps -> b
    void computeNodes(java.util.Collection) -> a
    void intersectChains() -> a
    void add(com.vividsolutions.jts.noding.SegmentString) -> a
com.vividsolutions.jts.noding.MCIndexNoder$SegmentOverlapAction -> a.b.a.f.d$a:
    com.vividsolutions.jts.noding.SegmentIntersector si -> a
    com.vividsolutions.jts.noding.MCIndexNoder this$0 -> a
    void overlap(com.vividsolutions.jts.index.chain.MonotoneChain,int,com.vividsolutions.jts.index.chain.MonotoneChain,int) -> a
com.vividsolutions.jts.noding.OrientedCoordinateArray -> a.b.a.f.e:
    com.vividsolutions.jts.geom.Coordinate[] pts -> a
    boolean orientation -> a
    boolean orientation(com.vividsolutions.jts.geom.Coordinate[]) -> a
    int compareTo(java.lang.Object) -> compareTo
    int compareOriented(com.vividsolutions.jts.geom.Coordinate[],boolean,com.vividsolutions.jts.geom.Coordinate[],boolean) -> a
com.vividsolutions.jts.noding.SegmentIntersector -> a.b.a.f.f:
    void processIntersections(com.vividsolutions.jts.noding.SegmentString,int,com.vividsolutions.jts.noding.SegmentString,int) -> a
    boolean isDone() -> b
com.vividsolutions.jts.noding.SegmentString -> a.b.a.f.g:
    int size() -> a
    com.vividsolutions.jts.geom.Coordinate[] getCoordinates() -> a
com.vividsolutions.jts.noding.SinglePassNoder -> a.b.a.f.h:
    com.vividsolutions.jts.noding.SegmentIntersector segInt -> a
    void setSegmentIntersector(com.vividsolutions.jts.noding.SegmentIntersector) -> a
com.vividsolutions.jts.operation.GeometryGraphOperation -> a.b.a.g.a:
    com.vividsolutions.jts.algorithm.LineIntersector li -> a
    com.vividsolutions.jts.geom.PrecisionModel resultPrecisionModel -> a
    com.vividsolutions.jts.geomgraph.GeometryGraph[] arg -> a
    void setComputationPrecision(com.vividsolutions.jts.geom.PrecisionModel) -> a
com.vividsolutions.jts.operation.overlay.LineBuilder -> a.b.a.g.a.a:
    com.vividsolutions.jts.operation.overlay.OverlayOp op -> a
    com.vividsolutions.jts.geom.GeometryFactory geometryFactory -> a
    com.vividsolutions.jts.algorithm.PointLocator ptLocator -> a
    java.util.List lineEdgesList -> a
    java.util.List resultLineList -> b
    java.util.List build(int) -> a
    void findCoveredLineEdges() -> a
    void collectLines(int) -> a
    void collectLineEdge(com.vividsolutions.jts.geomgraph.DirectedEdge,int,java.util.List) -> a
    void collectBoundaryTouchEdge(com.vividsolutions.jts.geomgraph.DirectedEdge,int,java.util.List) -> b
    void buildLines(int) -> b
com.vividsolutions.jts.operation.overlay.MaximalEdgeRing -> a.b.a.g.a.b:
    com.vividsolutions.jts.geomgraph.DirectedEdge getNext(com.vividsolutions.jts.geomgraph.DirectedEdge) -> a
    void setEdgeRing(com.vividsolutions.jts.geomgraph.DirectedEdge,com.vividsolutions.jts.geomgraph.EdgeRing) -> a
    void linkDirectedEdgesForMinimalEdgeRings() -> c
    java.util.List buildMinimalRings() -> a
com.vividsolutions.jts.operation.overlay.MinimalEdgeRing -> a.b.a.g.a.c:
    com.vividsolutions.jts.geomgraph.DirectedEdge getNext(com.vividsolutions.jts.geomgraph.DirectedEdge) -> a
    void setEdgeRing(com.vividsolutions.jts.geomgraph.DirectedEdge,com.vividsolutions.jts.geomgraph.EdgeRing) -> a
com.vividsolutions.jts.operation.overlay.OverlayNodeFactory -> a.b.a.g.a.d:
    com.vividsolutions.jts.geomgraph.Node createNode(com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.operation.overlay.OverlayOp -> a.b.a.g.a.e:
    com.vividsolutions.jts.algorithm.PointLocator ptLocator -> a
    com.vividsolutions.jts.geom.GeometryFactory geomFact -> a
    com.vividsolutions.jts.geom.Geometry resultGeom -> a
    com.vividsolutions.jts.geomgraph.PlanarGraph graph -> a
    com.vividsolutions.jts.geomgraph.EdgeList edgeList -> a
    java.util.List resultPolyList -> a
    java.util.List resultLineList -> b
    java.util.List resultPointList -> c
    com.vividsolutions.jts.geom.Geometry overlayOp(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,int) -> a
    boolean isResultOfOp(com.vividsolutions.jts.geomgraph.Label,int) -> a
    boolean isResultOfOp(int,int,int) -> a
    com.vividsolutions.jts.geom.Geometry getResultGeometry(int) -> a
    com.vividsolutions.jts.geomgraph.PlanarGraph getGraph() -> a
    void computeOverlay(int) -> a
    void insertUniqueEdges(java.util.List) -> a
    void insertUniqueEdge(com.vividsolutions.jts.geomgraph.Edge) -> a
    void computeLabelsFromDepths() -> a
    void replaceCollapsedEdges() -> b
    void copyPoints(int) -> b
    void computeLabelling() -> c
    void mergeSymLabels() -> d
    void updateNodeLabelling() -> e
    void labelIncompleteNodes() -> f
    void labelIncompleteNode(com.vividsolutions.jts.geomgraph.Node,int) -> a
    void findResultAreaEdges(int) -> c
    void cancelDuplicateResultEdges() -> g
    boolean isCoveredByLA(com.vividsolutions.jts.geom.Coordinate) -> a
    boolean isCoveredByA(com.vividsolutions.jts.geom.Coordinate) -> b
    boolean isCovered(com.vividsolutions.jts.geom.Coordinate,java.util.List) -> a
    com.vividsolutions.jts.geom.Geometry computeGeometry(java.util.List,java.util.List,java.util.List,int) -> a
com.vividsolutions.jts.operation.overlay.PointBuilder -> a.b.a.g.a.f:
    com.vividsolutions.jts.operation.overlay.OverlayOp op -> a
    com.vividsolutions.jts.geom.GeometryFactory geometryFactory -> a
    java.util.List resultPointList -> a
    java.util.List build(int) -> a
    void extractNonCoveredResultNodes(int) -> a
    void filterCoveredNodeToPoint(com.vividsolutions.jts.geomgraph.Node) -> a
com.vividsolutions.jts.operation.overlay.PolygonBuilder -> a.b.a.g.a.g:
    com.vividsolutions.jts.geom.GeometryFactory geometryFactory -> a
    java.util.List shellList -> a
    void add(com.vividsolutions.jts.geomgraph.PlanarGraph) -> a
    void add(java.util.Collection,java.util.Collection) -> a
    java.util.List getPolygons() -> a
    java.util.List buildMaximalEdgeRings(java.util.Collection) -> a
    java.util.List buildMinimalEdgeRings(java.util.List,java.util.List,java.util.List) -> a
    com.vividsolutions.jts.geomgraph.EdgeRing findShell(java.util.List) -> a
    void placePolygonHoles(com.vividsolutions.jts.geomgraph.EdgeRing,java.util.List) -> a
    void sortShellsAndHoles(java.util.List,java.util.List,java.util.List) -> a
    void placeFreeHoles(java.util.List,java.util.List) -> a
    com.vividsolutions.jts.geomgraph.EdgeRing findEdgeRingContaining(com.vividsolutions.jts.geomgraph.EdgeRing,java.util.List) -> a
    java.util.List computePolygons(java.util.List) -> a
com.vividsolutions.jts.operation.overlay.snap.GeometrySnapper -> a.b.a.g.a.a.a:
    com.vividsolutions.jts.geom.Geometry srcGeom -> a
    double computeOverlaySnapTolerance(com.vividsolutions.jts.geom.Geometry) -> a
    double computeSizeBasedSnapTolerance(com.vividsolutions.jts.geom.Geometry) -> b
    double computeOverlaySnapTolerance(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry[] snap(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,double) -> a
    com.vividsolutions.jts.geom.Geometry snapTo(com.vividsolutions.jts.geom.Geometry,double) -> a
    com.vividsolutions.jts.geom.Coordinate[] extractTargetCoordinates(com.vividsolutions.jts.geom.Geometry) -> a
com.vividsolutions.jts.operation.overlay.snap.LineStringSnapper -> a.b.a.g.a.a.b:
    double snapTolerance -> a
    com.vividsolutions.jts.geom.Coordinate[] srcPts -> a
    com.vividsolutions.jts.geom.LineSegment seg -> a
    boolean isClosed -> a
    com.vividsolutions.jts.geom.Coordinate[] snapTo(com.vividsolutions.jts.geom.Coordinate[]) -> a
    void snapVertices(com.vividsolutions.jts.geom.CoordinateList,com.vividsolutions.jts.geom.Coordinate[]) -> a
    com.vividsolutions.jts.geom.Coordinate findSnapForVertex(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.Coordinate[]) -> a
    void snapSegments(com.vividsolutions.jts.geom.CoordinateList,com.vividsolutions.jts.geom.Coordinate[]) -> b
    int findSegmentIndexToSnap(com.vividsolutions.jts.geom.Coordinate,com.vividsolutions.jts.geom.CoordinateList) -> a
com.vividsolutions.jts.operation.overlay.snap.SnapIfNeededOverlayOp -> a.b.a.g.a.a.c:
    com.vividsolutions.jts.geom.Geometry[] geom -> a
    com.vividsolutions.jts.geom.Geometry overlayOp(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,int) -> a
    com.vividsolutions.jts.geom.Geometry getResultGeometry(int) -> a
com.vividsolutions.jts.operation.overlay.snap.SnapOverlayOp -> a.b.a.g.a.a.d:
    com.vividsolutions.jts.geom.Geometry[] geom -> a
    double snapTolerance -> a
    com.vividsolutions.jts.precision.CommonBitsRemover cbr -> a
    com.vividsolutions.jts.geom.Geometry overlayOp(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,int) -> a
    void computeSnapTolerance() -> a
    com.vividsolutions.jts.geom.Geometry getResultGeometry(int) -> a
    com.vividsolutions.jts.geom.Geometry[] snap() -> a
    com.vividsolutions.jts.geom.Geometry prepareResult(com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry[] removeCommonBits(com.vividsolutions.jts.geom.Geometry[]) -> a
com.vividsolutions.jts.operation.overlay.snap.SnapTransformer -> a.b.a.g.a.a.e:
    double snapTolerance -> a
    com.vividsolutions.jts.geom.Coordinate[] snapPts -> a
    com.vividsolutions.jts.geom.CoordinateSequence transformCoordinates(com.vividsolutions.jts.geom.CoordinateSequence,com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Coordinate[] snapLine(com.vividsolutions.jts.geom.Coordinate[],com.vividsolutions.jts.geom.Coordinate[]) -> a
com.vividsolutions.jts.precision.CommonBits -> a.b.a.h.a:
    boolean isFirst -> a
    int commonMantissaBitsCount -> a
    long commonBits -> a
    long commonSignExp -> b
    long signExpBits(long) -> a
    int numCommonMostSigMantissaBits(long,long) -> a
    long zeroLowerBits(long,int) -> a
    int getBit(long,int) -> a
    void add(double) -> a
    double getCommon() -> a
com.vividsolutions.jts.precision.CommonBitsRemover -> a.b.a.h.b:
    com.vividsolutions.jts.geom.Coordinate commonCoord -> a
    com.vividsolutions.jts.precision.CommonBitsRemover$CommonCoordinateFilter ccFilter -> a
    void add(com.vividsolutions.jts.geom.Geometry) -> a
    com.vividsolutions.jts.geom.Geometry removeCommonBits(com.vividsolutions.jts.geom.Geometry) -> a
    void addCommonBits(com.vividsolutions.jts.geom.Geometry) -> b
com.vividsolutions.jts.precision.CommonBitsRemover$CommonCoordinateFilter -> a.b.a.h.b$a:
    com.vividsolutions.jts.precision.CommonBits commonBitsX -> a
    com.vividsolutions.jts.precision.CommonBits commonBitsY -> b
    com.vividsolutions.jts.precision.CommonBitsRemover this$0 -> a
    void filter(com.vividsolutions.jts.geom.Coordinate) -> a
    com.vividsolutions.jts.geom.Coordinate getCommonCoordinate() -> a
com.vividsolutions.jts.precision.CommonBitsRemover$Translater -> a.b.a.h.b$b:
    com.vividsolutions.jts.geom.Coordinate trans -> a
    com.vividsolutions.jts.precision.CommonBitsRemover this$0 -> a
    void filter(com.vividsolutions.jts.geom.Coordinate) -> a
com.vividsolutions.jts.util.Assert -> a.b.a.i.a:
    void isTrue(boolean) -> a
    void isTrue(boolean,java.lang.String) -> a
    void shouldNeverReachHere() -> a
    void shouldNeverReachHere(java.lang.String) -> a
com.vividsolutions.jts.util.AssertionFailedException -> a.b.a.i.b:
edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance -> b.a.a.a.a.a.a:
    edu.uci.ics.jung.graph.Hypergraph g -> a
    org.apache.commons.collections15.Transformer nev -> a
    java.util.Map sourceMap -> a
    boolean cached -> a
    double max_distance -> a
    int max_targets -> a
    java.util.LinkedHashMap singleSourceShortestPath(java.lang.Object,java.util.Collection,int) -> a
    edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance$SourceData getSourceData(java.lang.Object) -> a
    java.util.Collection getEdgesToCheck(java.lang.Object) -> a
edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance$SourceData -> b.a.a.a.a.a.a$a:
    java.util.LinkedHashMap distances -> a
    java.util.Map estimatedDistances -> a
    edu.uci.ics.jung.algorithms.util.MapBinaryHeap unknownVertices -> a
    boolean reached_max -> a
    double dist_reached -> a
    edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance this$0 -> a
    java.util.Map$Entry getNextVertex() -> a
    void update(java.lang.Object,java.lang.Object,double) -> a
    void createRecord(java.lang.Object,java.lang.Object,double) -> b
    void restoreVertex(java.lang.Object,double) -> a
edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance$VertexComparator -> b.a.a.a.a.a.a$b:
    java.util.Map distances -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath -> b.a.a.a.a.a.b:
    edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance$SourceData getSourceData(java.lang.Object) -> a
    java.util.List getPath(java.lang.Object,java.lang.Object) -> a
edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath$SourcePathData -> b.a.a.a.a.a.b$a:
    java.util.Map tentativeIncomingEdges -> b
    java.util.LinkedHashMap incomingEdges -> b
    edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath this$0 -> a
    void update(java.lang.Object,java.lang.Object,double) -> a
    java.util.Map$Entry getNextVertex() -> a
    void restoreVertex(java.lang.Object,double) -> a
    void createRecord(java.lang.Object,java.lang.Object,double) -> b
edu.uci.ics.jung.algorithms.util.BasicMapEntry -> b.a.a.a.a.b.a:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
edu.uci.ics.jung.algorithms.util.MapBinaryHeap -> b.a.a.a.a.b.b:
    java.util.Vector heap -> a
    java.util.Map object_indices -> a
    java.util.Comparator comp -> a
    void initialize(java.util.Comparator) -> a
    void clear() -> clear
    boolean add(java.lang.Object) -> add
    boolean isEmpty() -> isEmpty
    java.lang.Object peek() -> peek
    int size() -> size
    void update(java.lang.Object) -> a
    boolean contains(java.lang.Object) -> contains
    void percolateDown(int) -> a
    int percolateUp(int,java.lang.Object) -> a
    int lChild(int) -> a
    int rChild(int) -> b
    int parent(int) -> c
    void swap(int,int) -> a
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    java.lang.Object element() -> element
    boolean offer(java.lang.Object) -> offer
    java.lang.Object poll() -> poll
    java.lang.Object remove() -> remove
edu.uci.ics.jung.algorithms.util.MapBinaryHeap$ComparableComparator -> b.a.a.a.a.b.b$a:
    edu.uci.ics.jung.algorithms.util.MapBinaryHeap this$0 -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
edu.uci.ics.jung.graph.AbstractGraph -> b.a.a.a.b.a:
    boolean addEdge(java.lang.Object,java.lang.Object,java.lang.Object,edu.uci.ics.jung.graph.util.EdgeType) -> a
    boolean addEdge(java.lang.Object,edu.uci.ics.jung.graph.util.Pair,edu.uci.ics.jung.graph.util.EdgeType) -> a
    edu.uci.ics.jung.graph.util.Pair getValidatedEndpoints(java.lang.Object,edu.uci.ics.jung.graph.util.Pair) -> a
    java.lang.Object getOpposite(java.lang.Object,java.lang.Object) -> a
    java.util.Collection getIncidentVertices(java.lang.Object) -> a
    java.lang.String toString() -> toString
edu.uci.ics.jung.graph.Graph -> b.a.a.a.b.b:
    java.util.Collection getOutEdges(java.lang.Object) -> b
    edu.uci.ics.jung.graph.util.Pair getEndpoints(java.lang.Object) -> a
    java.lang.Object getOpposite(java.lang.Object,java.lang.Object) -> a
edu.uci.ics.jung.graph.Hypergraph -> b.a.a.a.b.c:
    java.util.Collection getEdges() -> a
    java.util.Collection getVertices() -> b
    boolean containsVertex(java.lang.Object) -> a
    boolean containsEdge(java.lang.Object) -> b
    int getVertexCount() -> a
    java.util.Collection getIncidentEdges(java.lang.Object) -> c
    java.util.Collection getIncidentVertices(java.lang.Object) -> a
edu.uci.ics.jung.graph.SparseMultigraph -> b.a.a.a.b.d:
    java.util.Map vertices -> a
    java.util.Map edges -> b
    java.util.Set directedEdges -> a
    java.util.Collection getEdges() -> a
    java.util.Collection getVertices() -> b
    boolean containsVertex(java.lang.Object) -> a
    boolean containsEdge(java.lang.Object) -> b
    boolean addVertex(java.lang.Object) -> c
    boolean addEdge(java.lang.Object,edu.uci.ics.jung.graph.util.Pair,edu.uci.ics.jung.graph.util.EdgeType) -> a
    java.util.Collection getInEdges(java.lang.Object) -> d
    java.util.Collection getOutEdges(java.lang.Object) -> b
    java.util.Collection getIncidentEdges(java.lang.Object) -> c
    edu.uci.ics.jung.graph.util.Pair getEndpoints(java.lang.Object) -> a
    int getVertexCount() -> a
edu.uci.ics.jung.graph.util.EdgeType -> b.a.a.a.b.a.a:
    edu.uci.ics.jung.graph.util.EdgeType DIRECTED -> a
    edu.uci.ics.jung.graph.util.EdgeType UNDIRECTED -> b
    edu.uci.ics.jung.graph.util.EdgeType[] ENUM$VALUES -> a
    edu.uci.ics.jung.graph.util.EdgeType[] values() -> values
    edu.uci.ics.jung.graph.util.EdgeType valueOf(java.lang.String) -> valueOf
edu.uci.ics.jung.graph.util.Pair -> b.a.a.a.b.a.b:
    java.lang.Object first -> a
    java.lang.Object second -> b
    java.lang.Object getFirst() -> a
    java.lang.Object getSecond() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean add(java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    boolean isEmpty() -> isEmpty
    java.util.Iterator iterator() -> iterator
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    int size() -> size
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    java.lang.Object access$0(edu.uci.ics.jung.graph.util.Pair) -> a
    java.lang.Object access$1(edu.uci.ics.jung.graph.util.Pair) -> b
edu.uci.ics.jung.graph.util.Pair$PairIterator -> b.a.a.a.b.a.b$a:
    int position -> a
    edu.uci.ics.jung.graph.util.Pair this$0 -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
geogebra.AppletImplementationInterface -> geogebra.a:
    void dispose() -> a
    void initInBackground() -> b
geogebra.AppletSplashScreen -> geogebra.b:
    java.awt.Image splashImage -> a
    java.awt.Image progressImage -> b
    java.awt.Image splashScreenImage -> c
    java.awt.Graphics splashScreenImageGraphics -> a
    int width -> a
    int height -> b
    geogebra.GeoGebraApplet parentApplet -> a
    boolean dispose -> a
    void dispose() -> a
    void update() -> b
    java.awt.Image getImage() -> a
    boolean isReady() -> a
    boolean imageUpdate(java.awt.Image,int,int,int,int,int) -> imageUpdate
geogebra.CommandLineArguments -> geogebra.c:
    java.util.HashMap args -> a
    int noOfFiles -> a
    int getNoOfFiles() -> a
    java.lang.String getStringValue(java.lang.String) -> a
    boolean getBooleanValue(java.lang.String,boolean) -> a
    boolean isBoolean(java.lang.String) -> a
    boolean containsArg(java.lang.String) -> b
geogebra.GeoGebra -> geogebra.GeoGebra:
    java.awt.Frame splashFrame -> a
    void main(java.lang.String[]) -> main
    void doMain(java.lang.String[]) -> a
    void startGeoGebra(geogebra.CommandLineArguments) -> a
    java.lang.String getSplashString() -> a
geogebra.GeoGebraApplet -> geogebra.GeoGebraApplet:
    geogebra.AppletImplementationInterface appletImplementation -> a
    boolean animationRunningAtLastStop -> a
    geogebra.AppletSplashScreen splashScreen -> a
    boolean appletIsIniting -> b
    void init() -> init
    void initAppletInBackground() -> a
    void start() -> start
    void stop() -> stop
    void destroy() -> destroy
    geogebra.AppletImplementationInterface getAppletImplementation() -> getAppletImplementation
    void setAppletImplementation(geogebra.AppletImplementationInterface) -> setAppletImplementation
    void initAppletImplementation() -> b
    void paint(java.awt.Graphics) -> paint
    boolean isAppletFullyLoaded() -> a
    void deleteObject(java.lang.String) -> deleteObject
    boolean evalCommand(java.lang.String) -> evalCommand
    boolean evalCommand(java.lang.String,boolean) -> evalCommand
    void evalXML(java.lang.String) -> evalXML
    void debug(java.lang.String) -> debug
    boolean exists(java.lang.String) -> exists
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    java.lang.String getColor(java.lang.String) -> getColor
    double getFilling(java.lang.String) -> getFilling
    int getPointStyle(java.lang.String) -> getPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    int getLineStyle(java.lang.String) -> getLineStyle
    int getLineThickness(java.lang.String) -> getLineThickness
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getHostname() -> getHostname
    java.lang.String getIPAddress() -> getIPAddress
    int getLayer(java.lang.String) -> getLayer
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    double getValue(java.lang.String) -> getValue
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getXML() -> getXML
    java.lang.String getBase64() -> getBase64
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    void openFile(java.lang.String) -> openFile
    void refreshViews() -> refreshViews
    void registerAddListener(java.lang.String) -> registerAddListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    void reset() -> reset
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setColor(java.lang.String,int,int,int) -> setColor
    void setLineThickness(java.lang.String,int) -> setLineThickness
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void setPointSize(java.lang.String,int) -> setPointSize
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setCoords(java.lang.String,double,double) -> setCoords
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void setFixed(java.lang.String,boolean) -> setFixed
    void setGridVisible(boolean) -> setGridVisible
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLayer(java.lang.String,int) -> setLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setMode(int) -> setMode
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setTrace(java.lang.String,boolean) -> setTrace
    void setValue(java.lang.String,double) -> setValue
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    boolean getVisible(java.lang.String,int) -> getVisible
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    boolean isMoveable(java.lang.String) -> isMoveable
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    void setListValue(java.lang.String,int,double) -> setListValue
    double getListValue(java.lang.String,int) -> getListValue
geogebra.GeoGebraApplet$1 -> geogebra.d:
    geogebra.GeoGebraApplet this$0 -> a
    void run() -> run
geogebra.GeoGebraApplet$2 -> geogebra.e:
    geogebra.GeoGebraApplet this$0 -> a
    void run() -> run
    geogebra.GeoGebraApplet access$0(geogebra.GeoGebraApplet$2) -> a
geogebra.GeoGebraApplet$2$1 -> geogebra.f:
    geogebra.GeoGebraApplet$2 this$1 -> a
    void run() -> run
geogebra.GeoGebraApplet$3 -> geogebra.g:
    geogebra.GeoGebraApplet this$0 -> a
    java.lang.String val$cmdString -> a
    void run() -> run
geogebra.GeoGebraAppletPreloader -> geogebra.GeoGebraAppletPreloader:
    void init() -> init
    void loadAllJarFiles(boolean) -> loadAllJarFiles
geogebra.GeoGebraAppletPreloader$1 -> geogebra.h:
    boolean val$loadJavaScriptJAR -> a
    void run() -> run
geogebra.GeoGebraPanel -> geogebra.GeoGebraPanel:
    geogebra.main.AppD app -> a
    void main(java.lang.String[]) -> main
    void openFile(java.net.URL) -> openFile
    void setShowToolbar(boolean) -> setShowToolbar
    void setFontSize(int) -> setFontSize
    void setMaxIconSize(int) -> setMaxIconSize
    void setShowMenubar(boolean) -> setShowMenubar
    void setShowAlgebraInput(boolean) -> setShowAlgebraInput
    void setShowAlgebraView(boolean) -> setShowAlgebraView
    void setShowSpreadsheetView(boolean) -> setShowSpreadsheetView
    javax.swing.JPanel getGraphicsPanel() -> getGraphicsPanel
    void setLanguage(java.util.Locale) -> setLanguage
    void attachView(geogebra.common.kernel.View) -> attachView
    void detachView(geogebra.common.kernel.View) -> detachView
    void buildGUI() -> buildGUI
    geogebra.plugin.GgbAPID getGeoGebraAPI() -> getGeoGebraAPI
geogebra.SplashWindow -> geogebra.i:
    java.awt.Image splashImage -> a
    boolean paintCalled -> a
    void update(java.awt.Graphics) -> update
    void paint(java.awt.Graphics) -> paint
    java.awt.Frame splash(java.awt.Image) -> a
    void access$0(geogebra.SplashWindow,boolean) -> a
geogebra.SplashWindow$1 -> geogebra.j:
    geogebra.SplashWindow this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.awt.GAffineTransformD -> geogebra.awt.a:
    java.awt.geom.AffineTransform at -> a
    java.awt.geom.AffineTransform getImpl() -> a
    void setTransform(geogebra.common.awt.GAffineTransform) -> a
    void setTransform(double,double,double,double,double,double) -> a
    void concatenate(geogebra.common.awt.GAffineTransform) -> b
    double getScaleX() -> a
    double getScaleY() -> b
    double getShearX() -> c
    double getShearY() -> d
    double getTranslateX() -> e
    double getTranslateY() -> f
    java.awt.geom.AffineTransform getAwtAffineTransform(geogebra.common.awt.GAffineTransform) -> a
    geogebra.common.awt.GShape createTransformedShape(geogebra.common.awt.GShape) -> a
    void transform(geogebra.common.awt.GPoint2D,geogebra.common.awt.GPoint2D) -> a
    void transform(double[],int,double[],int,int) -> a
    geogebra.common.awt.GAffineTransform createInverse() -> a
    void scale(double,double) -> a
    void translate(double,double) -> b
geogebra.awt.GAlphaCompositeD -> geogebra.awt.b:
geogebra.awt.GArc2DD -> geogebra.awt.c:
    java.awt.geom.Arc2D$Double impl -> a
    boolean contains(double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.GRectangleD getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    java.awt.Shape getAwtShape() -> a
    void setArc(double,double,double,double,double,double,int) -> a
    geogebra.common.awt.GPoint2D getStartPoint() -> a
    geogebra.common.awt.GPoint2D getEndPoint() -> b
    void setArcByCenter(double,double,double,double,double,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.awt.GAreaD -> geogebra.awt.d:
    java.awt.geom.Area impl -> a
    void subtract(geogebra.common.awt.GArea) -> a
    void add(geogebra.common.awt.GArea) -> b
    void intersect(geogebra.common.awt.GArea) -> c
    void exclusiveOr(geogebra.common.awt.GArea) -> d
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
geogebra.awt.GBasicStrokeD -> geogebra.awt.e:
    java.awt.BasicStroke impl -> a
    java.awt.BasicStroke getAwtStroke(geogebra.common.awt.GBasicStroke) -> a
    int getEndCap() -> a
    float getMiterLimit() -> a
    int getLineJoin() -> b
    geogebra.common.awt.GShape createStrokedShape(geogebra.common.awt.GShape) -> a
    float getLineWidth() -> b
    float[] getDashArray() -> a
geogebra.awt.GBufferedImageD -> geogebra.awt.f:
    int TYPE_INT_ARGB -> a
    java.awt.image.BufferedImage impl -> a
    int getWidth() -> a
    int getHeight() -> b
    java.awt.image.BufferedImage getAwtBufferedImage(geogebra.common.awt.GBufferedImage) -> a
    geogebra.common.awt.GGraphics2D createGraphics() -> a
geogebra.awt.GBufferedImageOpD -> geogebra.awt.g:
    java.awt.image.BufferedImage createCompatibleDestImage(java.awt.image.BufferedImage,java.awt.image.ColorModel) -> createCompatibleDestImage
    java.awt.image.BufferedImage filter(java.awt.image.BufferedImage,java.awt.image.BufferedImage) -> filter
    java.awt.geom.Rectangle2D getBounds2D(java.awt.image.BufferedImage) -> getBounds2D
    java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D,java.awt.geom.Point2D) -> getPoint2D
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
geogebra.awt.GColorD -> geogebra.awt.GColorD:
    double FACTOR -> FACTOR
    java.awt.Color adaptedColor -> adaptedColor
    void getRGBColorComponents(float[]) -> a
    int getBlue() -> a
    int getAlpha() -> b
    int getGreen() -> c
    int getRed() -> d
    java.awt.Color getAwtColor(geogebra.common.awt.GColor) -> a
    geogebra.awt.GColorD darker() -> a
    geogebra.common.awt.GColor brighter() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    geogebra.common.awt.GColor darker() -> b
geogebra.awt.GCompositeD -> geogebra.awt.h:
    java.awt.Composite impl -> a
    java.awt.Composite getAwtComposite(geogebra.common.awt.GComposite) -> a
geogebra.awt.GCubicCurve2DD -> geogebra.awt.i:
    java.awt.geom.CubicCurve2D impl -> a
    int solveCubic(double[],double[]) -> a
geogebra.awt.GDimensionD -> geogebra.awt.j:
    java.awt.Dimension impl -> a
    int getWidth() -> a
    int getHeight() -> b
    java.awt.Dimension getAWTDimension(geogebra.common.awt.GDimension) -> a
geogebra.awt.GEllipse2DDoubleD -> geogebra.awt.k:
    java.awt.geom.Ellipse2D$Double impl -> a
    void setFrame(double,double,double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    java.awt.Shape getAwtShape() -> a
    void setFrameFromCenter(double,double,double,double) -> b
geogebra.awt.GEllipse2DFloatD -> geogebra.awt.l:
    java.awt.geom.Ellipse2D$Float impl -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    java.awt.Shape getAwtShape() -> a
geogebra.awt.GFontD -> geogebra.awt.m:
    java.awt.Font impl -> a
    java.awt.Font getAwtFont(geogebra.common.awt.GFont) -> a
    int getStyle() -> a
    int getSize() -> b
    boolean isItalic() -> a
    boolean isBold() -> b
    int canDisplayUpTo(java.lang.String) -> a
    geogebra.awt.GFontD deriveFont(int,int) -> a
    geogebra.common.awt.GFont deriveFont(int) -> a
    java.lang.String getFontName() -> a
    geogebra.common.awt.GFont deriveFont(int,int) -> a
geogebra.awt.GFontRenderContextD -> geogebra.awt.n:
    java.awt.font.FontRenderContext impl -> a
    java.awt.font.FontRenderContext getAwtFrc(geogebra.common.awt.GFontRenderContext) -> a
geogebra.awt.GGeneralPathD -> geogebra.awt.o:
    java.awt.geom.GeneralPath impl -> a
    java.awt.geom.GeneralPath getAwtGeneralPath(geogebra.common.awt.GGeneralPath) -> a
    void moveTo(float,float) -> a
    void reset() -> a
    void lineTo(float,float) -> b
    void closePath() -> b
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    geogebra.common.awt.GPoint2D getCurrentPoint() -> a
    boolean contains(double,double,double,double) -> a
    void curveTo(float,float,float,float,float,float) -> a
geogebra.awt.GGenericRectangle2DD -> geogebra.awt.p:
    java.awt.geom.Rectangle2D impl -> a
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.GRectangle) -> b
    java.awt.geom.Rectangle2D getAWTRectangle2D(geogebra.common.awt.GRectangle2D) -> a
    boolean contains(double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.GRectangleD getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.awt.GGenericShapeD -> geogebra.awt.q:
    java.awt.Shape impl -> a
    boolean intersects(int,int,int,int) -> a
    java.awt.Shape getAwtShape(geogebra.common.awt.GShape) -> a
    boolean contains(int,int) -> a
    geogebra.awt.GRectangleD getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.awt.GGradientPaintD -> geogebra.awt.r:
    java.awt.GradientPaint impl -> a
    java.awt.GradientPaint getPaint() -> a
geogebra.awt.GGraphics2DD -> geogebra.awt.s:
    java.awt.Graphics2D impl -> a
    void drawString(java.lang.String,int,int) -> a
    void drawString(java.lang.String,float,float) -> a
    void setComposite(geogebra.common.awt.GComposite) -> a
    void setPaint(geogebra.common.awt.GPaint) -> a
    void setRenderingHints(java.util.Map) -> a
    void translate(int,int) -> a
    void translate(double,double) -> a
    void scale(double,double) -> b
    void transform(geogebra.common.awt.GAffineTransform) -> a
    void setTransform(geogebra.common.awt.GAffineTransform) -> b
    geogebra.common.awt.GAffineTransform getTransform() -> a
    geogebra.common.awt.GPaint getPaint() -> a
    geogebra.common.awt.GComposite getComposite() -> a
    geogebra.common.awt.GColor getBackground() -> a
    geogebra.common.awt.GFontRenderContext getFontRenderContext() -> a
    geogebra.common.awt.GColor getColor() -> b
    geogebra.common.awt.GFont getFont() -> a
    java.awt.Graphics2D getAwtGraphics(geogebra.common.awt.GGraphics2D) -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setStroke(geogebra.common.awt.GBasicStroke) -> a
    void setColor(geogebra.common.awt.GColor) -> a
    void clip(geogebra.common.awt.GShape) -> a
    void drawImage(geogebra.common.awt.GBufferedImage,geogebra.common.awt.GBufferedImageOp,int,int) -> a
    void drawImage(geogebra.common.awt.GBufferedImage,int,int) -> a
    void fillRect(int,int,int,int) -> a
    void drawLine(int,int,int,int) -> b
    void setClip(geogebra.common.awt.GShape) -> b
    void draw(geogebra.common.awt.GShape) -> c
    void fill(geogebra.common.awt.GShape) -> d
    geogebra.common.awt.GShape getClip() -> a
    void drawRect(int,int,int,int) -> c
    void setClip(int,int,int,int) -> d
    void setImpl(java.awt.Graphics2D) -> a
    void drawRoundRect(int,int,int,int,int,int) -> a
    void fillRoundRect(int,int,int,int,int,int) -> b
geogebra.awt.GLine2DD -> geogebra.awt.t:
    java.awt.geom.Line2D impl -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    void setLine(double,double,double,double) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    geogebra.common.awt.GPoint2D getP1() -> a
    geogebra.common.awt.GPoint2D getP2() -> b
geogebra.awt.GPathIteratorD -> geogebra.awt.u:
    java.awt.geom.PathIterator impl -> a
    int getWindingRule() -> a
    boolean isDone() -> a
    void next() -> a
    int currentSegment(double[]) -> a
geogebra.awt.GPoint2DD -> geogebra.awt.v:
    java.awt.geom.Point2D$Double impl -> a
    java.awt.geom.Point2D getAwtPoint2D(geogebra.common.awt.GPoint2D) -> a
    double getX() -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.GPoint2D) -> a
    double distance(double,double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
geogebra.awt.GRectangle2DD -> geogebra.awt.w:
    geogebra.awt.GRectangle2DD impl -> a
geogebra.awt.GRectangleD -> geogebra.awt.x:
    java.awt.Rectangle impl -> a
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setBounds(int,int,int,int) -> a
    void setLocation(int,int) -> a
    void setBounds(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Rectangle getAWTRectangle(geogebra.common.awt.GRectangle) -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    void add(geogebra.common.awt.GRectangle) -> b
    double getMinX() -> e
    double getMinY() -> f
    double getMaxX() -> g
    double getMaxY() -> h
    void add(double,double) -> a
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.GRectangle) -> b
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.GRectangleD getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    java.awt.Shape getAwtShape() -> a
    boolean contains(geogebra.common.awt.GPoint2D) -> a
    geogebra.common.awt.GRectangle union(geogebra.common.awt.GRectangle) -> a
    void setSize(int,int) -> b
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.awt.GRectangularShapeD -> geogebra.awt.y:
geogebra.awt.GShapeD -> geogebra.awt.z:
    java.awt.Shape getAwtShape() -> a
geogebra.awt.GTextLayoutD -> geogebra.awt.A:
    java.awt.font.TextLayout impl -> a
    float getAdvance() -> a
    geogebra.awt.GRectangle2DD getBounds() -> a
    float getAscent() -> b
    float getDescent() -> c
    void draw(geogebra.common.awt.GGraphics2D,int,int) -> a
    geogebra.common.awt.GRectangle2D getBounds() -> a
geogebra.cas.mpreduce.CASmpreduceD -> geogebra.a.a.a:
    org.mathpiper.mpreduce.Interpreter2 mpreduce_static -> a
    org.mathpiper.mpreduce.Interpreter2 mpreduce -> b
    java.util.List queue -> a
    java.lang.Thread casThread -> a
    org.mathpiper.mpreduce.Interpreter2 getStaticInterpreter() -> a
    geogebra.common.cas.Evaluate getMPReduce() -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> a
    java.lang.String getVersionString(org.mathpiper.mpreduce.Interpreter2) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.AsynchronousCommand) -> a
geogebra.cas.mpreduce.CASmpreduceD$1 -> geogebra.a.a.b:
    geogebra.cas.mpreduce.CASmpreduceD this$0 -> a
    void run() -> run
geogebra.cas.view.CASInputPanel -> geogebra.a.b.a:
    geogebra.gui.inputfield.AutoCompleteTextFieldD inputArea -> a
    geogebra.main.AppD app -> a
    void setInput(java.lang.String) -> a
    java.lang.String getInput() -> a
    javax.swing.text.JTextComponent getInputArea() -> a
    boolean setInputAreaFocused() -> a
    void setFont(java.awt.Font) -> setFont
    void setCommentColor(java.awt.Color) -> a
    void setLabels() -> a
geogebra.cas.view.CASOutputPanel -> geogebra.a.b.b:
    java.awt.Color ERROR_COLOR -> a
    java.awt.Color OUTPUT_PREFIX_COLOR -> b
    java.lang.String OUTPUT_PREFIX -> a
    javax.swing.JLabel outputSign -> a
    javax.swing.JLabel outputArea -> b
    geogebra.cas.view.LaTeXPanel latexPanel -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setOutput(java.lang.String,java.lang.String,java.lang.String,boolean,geogebra.common.awt.GColor,geogebra.common.main.App) -> a
    void setFont(java.awt.Font) -> setFont
geogebra.cas.view.CASStyleBar -> geogebra.a.b.c:
    geogebra.main.AppD app -> a
    geogebra.cas.view.CASViewD casView -> a
    geogebra.gui.util.MyToggleButton[] toggleBtnList -> a
    geogebra.gui.util.PopupMenuButton[] popupBtnList -> a
    geogebra.gui.color.ColorPopupMenuButton btnTextColor -> a
    geogebra.gui.util.PopupMenuButton btnTextSize -> a
    geogebra.gui.util.MyToggleButton btnBold -> a
    geogebra.gui.util.MyToggleButton btnItalic -> b
    geogebra.gui.util.MyToggleButton btnUseAsText -> c
    geogebra.gui.util.MyToggleButton btnShowKeyboard -> d
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    boolean needUndo -> a
    java.util.ArrayList selectedRows -> a
    void setSelectedRows(java.util.ArrayList) -> a
    void setSelectedRow(geogebra.common.kernel.geos.GeoElement) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void processSource(java.lang.Object,java.util.ArrayList) -> a
    void updateStyleBar() -> a
    void applyTextColor(java.util.ArrayList) -> b
    void applyUseAsText(java.util.ArrayList) -> c
    void applyFontStyle(java.util.ArrayList) -> d
    void applyTextSize(java.util.ArrayList) -> e
    geogebra.gui.util.PopupMenuButton[] newPopupBtnList() -> a
    geogebra.gui.util.MyToggleButton[] newToggleBtnList() -> a
    void initGUI() -> b
    boolean checkGeoText(java.lang.Object[]) -> a
    void createTextButtons() -> c
geogebra.cas.view.CASStyleBar$1 -> geogebra.a.b.d:
    java.awt.Color geoColor -> a
    geogebra.cas.view.CASStyleBar this$0 -> a
    java.awt.Dimension val$textColorIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.cas.view.CASStyleBar$2 -> geogebra.a.b.e:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$3 -> geogebra.a.b.f:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$4 -> geogebra.a.b.g:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$5 -> geogebra.a.b.h:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASSubDialog -> geogebra.a.b.i:
    javax.swing.JButton btSub -> a
    javax.swing.JButton btEval -> b
    javax.swing.JButton btNumeric -> c
    javax.swing.JScrollPane scrollPane -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel btPanel -> b
    javax.swing.JPanel captionPanel -> c
    javax.swing.JTable replaceTable -> a
    java.util.Vector data -> a
    geogebra.cas.view.CASViewD casView -> a
    geogebra.main.AppD app -> a
    int editRow -> a
    java.lang.String prefix -> a
    java.lang.String evalText -> b
    java.lang.String postfix -> c
    void createGUI() -> a
    void initData(geogebra.common.kernel.geos.GeoCasCell) -> a
    void addVariables(geogebra.common.kernel.geos.GeoElement,java.util.HashSet) -> a
    void addRow(boolean) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> setVisible
    boolean apply(java.lang.String) -> a
    geogebra.main.AppD getApp() -> a
geogebra.cas.view.CASSubDialog$1 -> geogebra.a.b.j:
    geogebra.cas.view.CASSubDialog this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.CASSubDialog$2 -> geogebra.a.b.k:
    geogebra.cas.view.CASSubDialog this$0 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASSubDialog$MathTextCellEditor -> geogebra.a.b.i$a:
    boolean editing -> a
    geogebra.gui.inputfield.MathTextField delegate -> a
    geogebra.cas.view.CASSubDialog this$0 -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    boolean stopCellEditing() -> stopCellEditing
    void cancelCellEditing() -> cancelCellEditing
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    geogebra.cas.view.CASSubDialog access$0(geogebra.cas.view.CASSubDialog$MathTextCellEditor) -> a
geogebra.cas.view.CASSubDialog$MathTextCellEditor$1 -> geogebra.a.b.l:
    geogebra.cas.view.CASSubDialog$MathTextCellEditor this$1 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASTableCell -> geogebra.a.b.m:
    geogebra.cas.view.CASInputPanel inputPanel -> a
    geogebra.cas.view.CASOutputPanel outputPanel -> a
    geogebra.gui.inputfield.MyTextField dummyField -> a
    geogebra.main.AppD app -> a
    geogebra.cas.view.CASViewD view -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    int getInputPanelHeight() -> a
    void setInputPanelWidth(int) -> a
    void setValue(geogebra.common.kernel.geos.GeoCasCell) -> a
    void updateTableRowHeight(javax.swing.JTable,int) -> a
    java.lang.String getInput() -> a
    boolean setInputAreaFocused() -> a
    javax.swing.text.JTextComponent getInputArea() -> a
    void setFont(java.awt.Font) -> setFont
    void setLabels() -> a
geogebra.cas.view.CASTableCellController -> geogebra.a.b.n:
    geogebra.cas.view.CASViewD view -> a
    geogebra.cas.view.CASTableD table -> a
    geogebra.main.AppD app -> a
    geogebra.cas.view.CASTableCellEditorD tableCellEditor -> a
    boolean rightClick -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    boolean handleKeyPressedInputTextField(java.awt.event.KeyEvent) -> a
    void handleEnterKey(java.awt.event.KeyEvent) -> a
    boolean isRightClick() -> a
    void setRightClick(boolean) -> a
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.cas.view.CASTableCellEditorD -> geogebra.a.b.o:
    javax.swing.JTable table -> a
    geogebra.common.kernel.geos.GeoCasCell cellValue -> a
    boolean editing -> a
    int editingRow -> a
    java.lang.String inputOnEditingStart -> a
    java.util.ArrayList listeners -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.String getInputSelectedText() -> b
    int getInputSelectionStart() -> b
    int getInputSelectionEnd() -> c
    void setInputSelectionStart(int) -> b
    void setInputSelectionEnd(int) -> c
    int getCaretPosition() -> d
    void setCaretPosition(int) -> d
    void insertText(java.lang.String) -> a
    boolean stopCellEditing() -> stopCellEditing
    void cancelCellEditing() -> cancelCellEditing
    boolean isEditing() -> b
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    void fireEditingCanceled() -> b
    void fireEditingStopped() -> c
    boolean isCellEditable(java.util.EventObject) -> isCellEditable
    void removeCellEditorListener(javax.swing.event.CellEditorListener) -> removeCellEditorListener
    void addCellEditorListener(javax.swing.event.CellEditorListener) -> addCellEditorListener
    boolean shouldSelectCell(java.util.EventObject) -> shouldSelectCell
    int getEditingRow() -> e
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASTableCellRenderer -> geogebra.a.b.p:
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.cas.view.CASTableD -> geogebra.a.b.q:
    geogebra.cas.view.CASTableModel tableModel -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.AppD app -> a
    geogebra.cas.view.CASViewD view -> a
    geogebra.cas.view.CASTableCellEditorD editor -> a
    geogebra.cas.view.CASTableCellRenderer renderer -> a
    int currentWidth -> b
    boolean rightClick -> d
    int clickedRow -> c
    int rollOverRow -> a
    boolean isOutputRollOver -> a
    boolean highlight -> b
    boolean isAltDown -> c
    float[] dash1 -> a
    java.awt.BasicStroke dashed -> a
    geogebra.cas.view.CASViewD getCASView() -> a
    boolean isOutputPanelClicked(java.awt.Point) -> a
    boolean isEditing() -> isEditing
    void stopEditing() -> a
    geogebra.cas.view.CASTableCellEditorD getEditor() -> a
    void insertRow(geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    void insertRow(int,geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    void setRow(int,geogebra.common.kernel.geos.GeoCasCell) -> a
    int getPreferredRowHeight(int) -> a
    void updateRow(int) -> a
    void updateAllRows() -> b
    geogebra.common.kernel.geos.GeoCasCell getGeoCasCell(int) -> a
    boolean isRowEmpty(int) -> a
    void deleteAllRows() -> c
    void deleteRow(int) -> b
    void startEditingRow(int) -> c
    void doEditCellAt(int) -> f
    void setFont(java.awt.Font) -> setFont
    boolean getScrollableTracksViewportWidth() -> getScrollableTracksViewportWidth
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    void setLabels() -> d
    int getClickedRow() -> a
    boolean isRightClick() -> a
    void setRightClick(boolean) -> a
    void setClickedRow(int) -> d
    geogebra.cas.view.CASTableD getTable() -> a
    int getCurrentWidth() -> b
    void setCurrentWidth(int) -> e
    int getOpenRow() -> c
    void paint(java.awt.Graphics) -> paint
    geogebra.common.main.App getApplication() -> a
    geogebra.common.cas.view.CASTableCellEditor getEditor() -> a
geogebra.cas.view.CASTableD$1 -> geogebra.a.b.r:
    geogebra.cas.view.CASTableD this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.cas.view.CASTableD$2 -> geogebra.a.b.s:
    geogebra.cas.view.CASTableD this$0 -> a
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.cas.view.CASTableD$3 -> geogebra.a.b.t:
    geogebra.cas.view.CASTableD this$0 -> a
    int val$editRow -> a
    void run() -> run
geogebra.cas.view.CASTableD$MyMouseListener -> geogebra.a.b.q$a:
    geogebra.cas.view.CASTableD this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.cas.view.CASTableD$RollOverListener -> geogebra.a.b.q$b:
    geogebra.cas.view.CASTableD this$0 -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.cas.view.CASTableD$SelectionListener -> geogebra.a.b.q$c:
    javax.swing.JTable table -> a
    geogebra.cas.view.CASTableD this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.CASTableModel -> geogebra.a.b.u:
    boolean isCellEditable(int,int) -> isCellEditable
geogebra.cas.view.CASViewD -> geogebra.a.b.v:
    javax.swing.JComponent component -> a
    geogebra.cas.view.CASTableD consoleTable -> a
    geogebra.cas.view.CASSubDialog subDialog -> a
    javax.swing.ListSelectionModel listSelModel -> a
    geogebra.main.AppD app -> a
    geogebra.cas.view.RowHeaderD rowHeader -> a
    geogebra.cas.view.CASStyleBar styleBar -> a
    javax.swing.event.ListSelectionListener selectionListener() -> a
    java.awt.event.MouseListener scrollPaneListener() -> a
    void showSubstituteDialog(java.lang.String,java.lang.String,java.lang.String,int) -> a
    void setSubstituteDialog(geogebra.cas.view.CASSubDialog) -> a
    void updateFonts() -> a
    void createCASTable() -> h
    geogebra.cas.view.CASTableD getConsoleTable() -> a
    javax.swing.JComponent getCASViewComponent() -> a
    geogebra.cas.view.RowHeaderD getRowHeader() -> a
    geogebra.main.AppD getApp() -> a
    void repaintView() -> b
    geogebra.main.AppD getApplication() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    geogebra.cas.view.CASStyleBar getCASStyleBar() -> a
    geogebra.cas.view.CASStyleBar newCASStyleBar() -> b
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    boolean isShowing() -> isShowing
    geogebra.common.cas.view.RowHeader getRowHeader() -> a
    geogebra.common.cas.view.CASTable getConsoleTable() -> a
    geogebra.common.main.App getApp() -> a
geogebra.cas.view.CASViewD$1 -> geogebra.a.b.w:
    geogebra.cas.view.CASViewD this$0 -> a
    geogebra.main.AppD val$app -> a
    void run() -> run
geogebra.cas.view.CASViewD$2 -> geogebra.a.b.x:
    geogebra.cas.view.CASViewD this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.CASViewD$3 -> geogebra.a.b.y:
    geogebra.cas.view.CASViewD this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.cas.view.CASViewD$CASComponent -> geogebra.a.b.v$a:
    geogebra.cas.view.CASViewD this$0 -> a
geogebra.cas.view.LaTeXPanel -> geogebra.a.b.z:
    geogebra.main.AppD app -> a
    java.lang.String latex -> a
    java.awt.image.BufferedImage image -> a
    java.awt.Graphics2D g2image -> a
    java.awt.Dimension equSize -> a
    void setLaTeX(java.lang.String) -> a
    void updateLaTeX() -> a
    void setForeground(java.awt.Color) -> setForeground
    java.awt.Dimension drawEquationToImage() -> a
    boolean ensureImageSize(int,int) -> a
    void setFont(java.awt.Font) -> setFont
    void paint(java.awt.Graphics) -> paint
geogebra.cas.view.RowContentPopupMenu -> geogebra.a.b.A:
    geogebra.common.kernel.geos.GeoCasCell value -> a
    geogebra.cas.view.CASTableCellEditorD editor -> a
    geogebra.cas.view.CASTableD table -> a
    geogebra.main.AppD app -> a
    geogebra.cas.view.RowContentPopupMenu$Panel clickedPanel -> a
    int[] $SWITCH_TABLE$geogebra$cas$view$RowContentPopupMenu$Panel -> a
    void initMenu() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void handleCopy(java.awt.event.ActionEvent) -> a
    void handlePaste(java.awt.event.ActionEvent) -> b
    int[] $SWITCH_TABLE$geogebra$cas$view$RowContentPopupMenu$Panel() -> a
geogebra.cas.view.RowContentPopupMenu$Panel -> geogebra.a.b.A$a:
    geogebra.cas.view.RowContentPopupMenu$Panel OUTPUT -> a
    geogebra.cas.view.RowContentPopupMenu$Panel INPUT -> b
    geogebra.cas.view.RowContentPopupMenu$Panel[] ENUM$VALUES -> a
    geogebra.cas.view.RowContentPopupMenu$Panel[] values() -> values
    geogebra.cas.view.RowContentPopupMenu$Panel valueOf(java.lang.String) -> valueOf
geogebra.cas.view.RowHeaderD -> geogebra.a.b.B:
geogebra.cas.view.RowHeaderListModel -> geogebra.a.b.C:
    javax.swing.JTable table -> a
    int size -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.cas.view.RowHeaderListener -> geogebra.a.b.D:
    geogebra.cas.view.CASTableD table -> a
    javax.swing.JList rowHeader -> a
    int mousePressedRow -> a
    boolean rightClick -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.RowHeaderPopupMenu -> geogebra.a.b.E:
    javax.swing.JList rowHeader -> a
    geogebra.cas.view.CASTableD table -> a
    geogebra.main.AppD app -> a
    javax.swing.JMenuItem cbUseAsText -> a
    void initMenu() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.cas.view.RowHeaderRenderer -> geogebra.a.b.F:
    geogebra.cas.view.CASTableD casTable -> a
    javax.swing.JLabel numLabel -> b
    javax.swing.JLabel showHideControl -> a
    javax.swing.ImageIcon iconShown -> a
    javax.swing.ImageIcon iconHidden -> b
    java.awt.GridBagConstraints c -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.common.GeoGebraConstants -> geogebra.common.a:
    boolean IS_FIVE_POINT_ZERO -> a
    java.lang.String PREFERENCES_ROOT -> a
    java.lang.String XML_FILE_FORMAT -> b
    java.lang.String GEOGEBRA_REPORT_BUG_DESKTOP -> c
geogebra.common.awt.GAffineTransform -> geogebra.common.a.a:
    void setTransform(geogebra.common.awt.GAffineTransform) -> a
    void setTransform(double,double,double,double,double,double) -> a
    void concatenate(geogebra.common.awt.GAffineTransform) -> b
    double getScaleX() -> a
    double getScaleY() -> b
    double getShearX() -> c
    double getShearY() -> d
    geogebra.common.awt.GShape createTransformedShape(geogebra.common.awt.GShape) -> a
    void transform(geogebra.common.awt.GPoint2D,geogebra.common.awt.GPoint2D) -> a
    void transform(double[],int,double[],int,int) -> a
    geogebra.common.awt.GAffineTransform createInverse() -> a
    void scale(double,double) -> a
    void translate(double,double) -> b
    double getTranslateX() -> e
    double getTranslateY() -> f
geogebra.common.awt.GAlphaComposite -> geogebra.common.a.b:
geogebra.common.awt.GArc2D -> geogebra.common.a.c:
    void setArc(double,double,double,double,double,double,int) -> a
    geogebra.common.awt.GPoint2D getStartPoint() -> a
    geogebra.common.awt.GPoint2D getEndPoint() -> b
    void setArcByCenter(double,double,double,double,double,int) -> a
geogebra.common.awt.GArea -> geogebra.common.a.d:
    void subtract(geogebra.common.awt.GArea) -> a
    void intersect(geogebra.common.awt.GArea) -> c
    void exclusiveOr(geogebra.common.awt.GArea) -> d
    void add(geogebra.common.awt.GArea) -> b
geogebra.common.awt.GBasicStroke -> geogebra.common.a.e:
    geogebra.common.awt.GShape createStrokedShape(geogebra.common.awt.GShape) -> a
    int getEndCap() -> a
    float getMiterLimit() -> a
    int getLineJoin() -> b
    float getLineWidth() -> b
    float[] getDashArray() -> a
geogebra.common.awt.GBufferedImage -> geogebra.common.a.f:
    int getWidth() -> a
    int getHeight() -> b
    geogebra.common.awt.GGraphics2D createGraphics() -> a
geogebra.common.awt.GBufferedImageOp -> geogebra.common.a.g:
geogebra.common.awt.GColor -> geogebra.common.a.h:
    geogebra.common.awt.GColor white -> white
    geogebra.common.awt.GColor black -> black
    geogebra.common.awt.GColor RED -> RED
    geogebra.common.awt.GColor WHITE -> WHITE
    geogebra.common.awt.GColor BLACK -> BLACK
    geogebra.common.awt.GColor BLUE -> BLUE
    geogebra.common.awt.GColor GRAY -> GRAY
    geogebra.common.awt.GColor GREEN -> GREEN
    geogebra.common.awt.GColor YELLOW -> YELLOW
    geogebra.common.awt.GColor DARK_GRAY -> DARK_GRAY
    geogebra.common.awt.GColor LIGHT_GRAY -> LIGHT_GRAY
    geogebra.common.awt.GColor CYAN -> CYAN
    geogebra.common.awt.GColor MAGENTA -> MAGENTA
    geogebra.common.awt.GColor red -> red
    geogebra.common.awt.GColor yellow -> yellow
    geogebra.common.awt.GColor green -> green
    geogebra.common.awt.GColor blue -> blue
    geogebra.common.awt.GColor cyan -> cyan
    geogebra.common.awt.GColor magenta -> magenta
    geogebra.common.awt.GColor lightGray -> lightGray
    geogebra.common.awt.GColor gray -> gray
    geogebra.common.awt.GColor darkGray -> darkGray
    void initColors(geogebra.common.factories.AwtFactory) -> a
    int getRed() -> d
    int getBlue() -> a
    int getGreen() -> c
    int getAlpha() -> b
    void getRGBColorComponents(float[]) -> a
    int HSBtoRGB(float,float,float) -> a
    geogebra.common.awt.GColor darker() -> b
    geogebra.common.awt.GColor brighter() -> a
    int getRGB() -> e
geogebra.common.awt.GComposite -> geogebra.common.a.i:
geogebra.common.awt.GCubicCurve2D -> geogebra.common.a.j:
    int solveCubic(double[],double[]) -> a
geogebra.common.awt.GDimension -> geogebra.common.a.k:
    int getWidth() -> a
    int getHeight() -> b
geogebra.common.awt.GEllipse2DDouble -> geogebra.common.a.l:
    void setFrame(double,double,double,double) -> a
    void setFrameFromCenter(double,double,double,double) -> b
geogebra.common.awt.GEllipse2DFloat -> geogebra.common.a.m:
geogebra.common.awt.GFont -> geogebra.common.a.n:
    int getStyle() -> a
    int getSize() -> b
    boolean isItalic() -> a
    boolean isBold() -> b
    int canDisplayUpTo(java.lang.String) -> a
    geogebra.common.awt.GFont deriveFont(int,int) -> a
    geogebra.common.awt.GFont deriveFont(int) -> a
    java.lang.String getFontName() -> a
geogebra.common.awt.GFontRenderContext -> geogebra.common.a.o:
geogebra.common.awt.GGeneralPath -> geogebra.common.a.p:
    void moveTo(float,float) -> a
    void reset() -> a
    void lineTo(float,float) -> b
    void closePath() -> b
    geogebra.common.awt.GPoint2D getCurrentPoint() -> a
    boolean contains(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    void curveTo(float,float,float,float,float,float) -> a
geogebra.common.awt.GGradientPaint -> geogebra.common.a.q:
geogebra.common.awt.GGraphics2D -> geogebra.common.a.r:
    void draw(geogebra.common.awt.GShape) -> c
    void drawImage(geogebra.common.awt.GBufferedImage,geogebra.common.awt.GBufferedImageOp,int,int) -> a
    void drawImage(geogebra.common.awt.GBufferedImage,int,int) -> a
    void drawString(java.lang.String,int,int) -> a
    void drawString(java.lang.String,float,float) -> a
    void fill(geogebra.common.awt.GShape) -> d
    void setComposite(geogebra.common.awt.GComposite) -> a
    void setPaint(geogebra.common.awt.GPaint) -> a
    void setStroke(geogebra.common.awt.GBasicStroke) -> a
    void setRenderingHints(java.util.Map) -> a
    void translate(int,int) -> a
    void translate(double,double) -> a
    void scale(double,double) -> b
    void transform(geogebra.common.awt.GAffineTransform) -> a
    void setTransform(geogebra.common.awt.GAffineTransform) -> b
    geogebra.common.awt.GAffineTransform getTransform() -> a
    geogebra.common.awt.GPaint getPaint() -> a
    geogebra.common.awt.GComposite getComposite() -> a
    geogebra.common.awt.GColor getBackground() -> a
    void clip(geogebra.common.awt.GShape) -> a
    geogebra.common.awt.GFontRenderContext getFontRenderContext() -> a
    geogebra.common.awt.GColor getColor() -> b
    geogebra.common.awt.GFont getFont() -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setColor(geogebra.common.awt.GColor) -> a
    void fillRect(int,int,int,int) -> a
    void drawLine(int,int,int,int) -> b
    void setClip(geogebra.common.awt.GShape) -> b
    geogebra.common.awt.GShape getClip() -> a
    void drawRect(int,int,int,int) -> c
    void setClip(int,int,int,int) -> d
    void drawRoundRect(int,int,int,int,int,int) -> a
    void fillRoundRect(int,int,int,int,int,int) -> b
geogebra.common.awt.GLine2D -> geogebra.common.a.s:
    void setLine(double,double,double,double) -> a
    geogebra.common.awt.GPoint2D getP1() -> a
    geogebra.common.awt.GPoint2D getP2() -> b
geogebra.common.awt.GPaint -> geogebra.common.a.t:
geogebra.common.awt.GPathIterator -> geogebra.common.a.u:
    int getWindingRule() -> a
    boolean isDone() -> a
    void next() -> a
    int currentSegment(double[]) -> a
geogebra.common.awt.GPoint -> geogebra.common.a.v:
    int y -> a
    int x -> b
    void setLocation(int,int) -> a
    void setLocation(geogebra.common.awt.GPoint) -> a
    int getY() -> a
    int getX() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    double distance(geogebra.common.awt.GPoint) -> a
geogebra.common.awt.GPoint2D -> geogebra.common.a.w:
    double getX() -> a
    double distance(double,double) -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.GPoint2D) -> a
    double distanceSq(double,double,double,double) -> a
geogebra.common.awt.GPoint2D$Double -> geogebra.common.a.w$a:
    double x -> a
    double y -> b
    void setLocation(double,double) -> a
    double getX() -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.GPoint2D) -> a
    double distance(double,double) -> a
geogebra.common.awt.GRectangle -> geogebra.common.a.x:
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setBounds(int,int,int,int) -> a
    void setLocation(int,int) -> a
    void setBounds(geogebra.common.awt.GRectangle) -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    void add(geogebra.common.awt.GRectangle) -> b
    double getMinX() -> e
    double getMinY() -> f
    double getMaxX() -> g
    double getMaxY() -> h
    boolean contains(double,double) -> a
    void add(double,double) -> a
    boolean contains(geogebra.common.awt.GPoint2D) -> a
    geogebra.common.awt.GRectangle union(geogebra.common.awt.GRectangle) -> a
    void setSize(int,int) -> b
geogebra.common.awt.GRectangle2D -> geogebra.common.a.y:
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.GRectangle) -> b
geogebra.common.awt.GRectangularShape -> geogebra.common.a.z:
geogebra.common.awt.GShape -> geogebra.common.a.A:
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
geogebra.common.awt.font.GTextLayout -> geogebra.common.a.a.a:
    float getAdvance() -> a
    geogebra.common.awt.GRectangle2D getBounds() -> a
    float getAscent() -> b
    void draw(geogebra.common.awt.GGraphics2D,int,int) -> a
    float getDescent() -> c
geogebra.common.cas.AlgoAsymptoteFunction -> geogebra.common.b.a:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.cas.CASparser -> geogebra.common.b.b:
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.parser.cashandlers.ParserFunctions parserFunctions -> a
    java.util.Map rbCasTranslations -> a
    int[] $SWITCH_TABLE$geogebra$common$cas$CASparser$FA -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInput(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> b
    void resolveVariablesForCAS(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    java.lang.String toGeoGebraString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseMPReduce(java.lang.String) -> c
    java.lang.String replaceIndices(java.lang.String) -> a
    void appendcode(java.lang.StringBuilder,int) -> a
    java.lang.String insertSpecialChars(java.lang.String) -> b
    geogebra.common.kernel.parser.cashandlers.ParserFunctions getParserFunctions() -> a
    java.lang.String translateToCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.StringTemplate,geogebra.common.kernel.CASGenericInterface) -> a
    java.lang.String getTranslatedCASCommand(java.lang.String) -> c
    boolean isCommandAvailable(java.lang.String) -> a
    java.util.Map getTranslationRessourceBundle() -> a
    int[] $SWITCH_TABLE$geogebra$common$cas$CASparser$FA() -> a
geogebra.common.cas.CASparser$FA -> geogebra.common.b.b$a:
    geogebra.common.cas.CASparser$FA NORMAL -> a
    geogebra.common.cas.CASparser$FA UNDERSCORE -> b
    geogebra.common.cas.CASparser$FA LONG_INDEX -> c
    geogebra.common.cas.CASparser$FA[] ENUM$VALUES -> a
    geogebra.common.cas.CASparser$FA[] values() -> values
    geogebra.common.cas.CASparser$FA valueOf(java.lang.String) -> valueOf
geogebra.common.cas.CasParserTools -> geogebra.common.b.c:
    java.lang.String convertScientificFloatNotation(java.lang.String) -> a
geogebra.common.cas.CasParserToolsImpl -> geogebra.common.b.d:
    com.google.gwt.regexp.shared.RegExp pattern -> a
    java.lang.String convertScientificFloatNotation(java.lang.String) -> a
geogebra.common.cas.Evaluate -> geogebra.common.b.e:
    java.lang.String evaluate(java.lang.String) -> a
    java.lang.String evaluate(java.lang.String,long) -> a
geogebra.common.cas.GeoGebraCAS -> geogebra.common.b.f:
    geogebra.common.main.App app -> a
    geogebra.common.cas.CASparser casParser -> a
    geogebra.common.kernel.CASGenericInterface cas -> a
    geogebra.common.cas.mpreduce.CASmpreduce casMPReduce -> a
    geogebra.common.main.CasType currentCAS -> a
    java.util.Map getPolynomialCoeffsCache -> a
    java.lang.StringBuilder getPolynomialCoeffsSB -> a
    java.lang.StringBuilder sbPolyCoeffs -> b
    int[] $SWITCH_TABLE$geogebra$common$main$CasType -> a
    geogebra.common.cas.CASparser getCASparser() -> a
    geogebra.common.kernel.CASGenericInterface getCurrentCAS() -> a
    void initCurrentCAS() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getCurrentCASstringType() -> a
    void setCurrentCAS(geogebra.common.main.CasType) -> a
    geogebra.common.cas.mpreduce.CASmpreduce getMPReduce() -> a
    void unbindVariable(java.lang.String) -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateRaw(java.lang.String) -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> b
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getCASCommand(java.lang.String,java.util.ArrayList,boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isCommandAvailable(geogebra.common.kernel.arithmetic.Command) -> a
    java.lang.String toAssignment(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.StringTemplate) -> a
    boolean isStructurallyEqual(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.AsynchronousCommand) -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.util.Set getAvailableCommandNames() -> a
    void clearCache() -> b
    geogebra.common.kernel.CASParserInterface getCASparser() -> a
    int[] $SWITCH_TABLE$geogebra$common$main$CasType() -> a
geogebra.common.cas.error.TimeoutException -> geogebra.common.b.a.a:
    java.lang.String getKey() -> a
geogebra.common.cas.mpreduce.CASmpreduce -> geogebra.common.b.b.a:
    geogebra.common.cas.CasParserTools parserTools -> a
    java.lang.String casPrefix -> a
    geogebra.common.cas.CASparser casParser -> a
    java.lang.StringBuilder varOrder -> a
    boolean initialized -> a
    geogebra.common.cas.Evaluate mpreduce -> a
    long timeoutMillis -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> a
    java.lang.String evaluateRaw(java.lang.String) -> b
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String translateFunctionDeclaration(java.lang.String,java.lang.String[],java.lang.String,geogebra.common.kernel.arithmetic.AssignmentType) -> a
    java.lang.String toGeoGebraString(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant,geogebra.common.kernel.StringTemplate) -> a
    void unbindVariable(java.lang.String) -> a
    geogebra.common.cas.Evaluate getMPReduce() -> a
    void initStaticMyMPReduceFunctions(geogebra.common.cas.Evaluate) -> a
    void initDependentMyMPReduceFunctions(geogebra.common.cas.Evaluate) -> b
    long getTimeoutMilliseconds() -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    java.lang.String translateAssignment(java.lang.String,java.lang.String) -> a
    void CASAsyncFinished(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String,java.lang.Throwable,geogebra.common.kernel.AsynchronousCommand,java.lang.String) -> a
    void appendListStart(java.lang.StringBuilder) -> a
    void appendListEnd(java.lang.StringBuilder) -> b
geogebra.common.cas.mpreduce.Ggb2MPReduce -> geogebra.common.b.b.b:
    java.util.Map commandMap -> a
    void p(java.lang.String,java.lang.String) -> a
    java.util.Map getMap() -> a
geogebra.common.cas.mpreduce.ReduceLibrary -> geogebra.common.b.b.c:
    geogebra.common.cas.Evaluate eval -> a
    java.lang.String eval(java.lang.String) -> a
    void load() -> a
geogebra.common.cas.view.CASInputHandler -> geogebra.common.b.c.a:
    geogebra.common.cas.view.CASView casView -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.cas.view.CASTable consoleTable -> a
    boolean $assertionsDisabled -> a
    void processCurrentRow(java.lang.String,java.lang.String[]) -> a
    boolean meaningfulSelection(java.lang.String) -> a
    void processMultipleRows(java.lang.String) -> a
    java.lang.String resolveButtonParameter(java.lang.String,geogebra.common.kernel.geos.GeoCasCell) -> a
    boolean processRowThenEdit(int,boolean) -> a
    java.lang.String resolveCASrowReferences(java.lang.String,int,char,boolean) -> a
    void handleReference(java.lang.StringBuilder,int,int,boolean,boolean,boolean) -> a
    void appendReference(java.lang.StringBuilder,java.lang.String,boolean,boolean) -> a
    boolean isPositiveNumber(java.lang.String) -> b
    java.lang.String fixInputErrors(java.lang.String) -> a
geogebra.common.cas.view.CASTable -> geogebra.common.b.c.b:
    int getRowCount() -> getRowCount
    void setLabels() -> d
    geogebra.common.kernel.geos.GeoCasCell getGeoCasCell(int) -> a
    geogebra.common.main.App getApplication() -> a
    void deleteAllRows() -> c
    void insertRow(int,geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    int[] getSelectedRows() -> getSelectedRows
    int getSelectedRow() -> getSelectedRow
    void stopEditing() -> a
    void startEditingRow(int) -> c
    geogebra.common.cas.view.CASTableCellEditor getEditor() -> a
    boolean isRowEmpty(int) -> a
    void insertRow(geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    void deleteRow(int) -> b
    void setRow(int,geogebra.common.kernel.geos.GeoCasCell) -> a
geogebra.common.cas.view.CASTableCellEditor -> geogebra.common.b.c.c:
    int getInputSelectionEnd() -> c
    int getInputSelectionStart() -> b
    java.lang.String getInputSelectedText() -> b
    java.lang.String getInput() -> a
    void setInputSelectionStart(int) -> b
    void setInputSelectionEnd(int) -> c
geogebra.common.cas.view.CASView -> geogebra.common.b.c.d:
    geogebra.common.cas.GeoGebraCAS cas -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.cas.view.CASInputHandler casInputHandler -> a
    geogebra.common.cas.view.CASTable getConsoleTable() -> a
    geogebra.common.main.App getApp() -> a
    geogebra.common.cas.view.RowHeader getRowHeader() -> a
    void showSubstituteDialog(java.lang.String,java.lang.String,java.lang.String,int) -> a
    void setLabels() -> c
    int getViewID() -> a
    java.lang.String getRowOutputValue(int) -> a
    java.lang.String getRowInputValue(int) -> b
    int getRowCount() -> b
    geogebra.common.cas.GeoGebraCAS getCAS() -> a
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void clearView() -> d
    void ensureOneEmptyRow() -> a
    void attachView() -> e
    void detachView() -> f
    void reset() -> g
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void processInput(java.lang.String,java.lang.String[]) -> a
    void processRowThenEdit(int,boolean) -> a
    java.lang.String resolveCASrowReferences(java.lang.String,int) -> a
    boolean deleteCasCells(int[]) -> a
    geogebra.common.cas.view.CASInputHandler getInputHandler() -> a
geogebra.common.cas.view.RowHeader -> geogebra.common.b.c.e:
    int[] getSelectedIndices() -> getSelectedIndices
geogebra.common.euclidian.DrawEquationInterface -> geogebra.common.c.a:
    void setUseJavaFontsForLaTeX(geogebra.common.main.App,boolean) -> a
    geogebra.common.awt.GDimension drawEquation(geogebra.common.main.App,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D,int,int,java.lang.String,geogebra.common.awt.GFont,boolean,geogebra.common.awt.GColor,geogebra.common.awt.GColor,boolean) -> a
geogebra.common.euclidian.Drawable -> geogebra.common.c.b:
    boolean forceNoFill -> b
    geogebra.common.awt.GBasicStroke objStroke -> a
    geogebra.common.awt.GBasicStroke selStroke -> b
    geogebra.common.awt.GBasicStroke decoStroke -> c
    int lineThickness -> d
    int lineType -> e
    geogebra.common.euclidian.EuclidianView view -> a
    int hitThreshold -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    int xLabel -> b
    int yLabel -> c
    java.lang.String labelDesc -> a
    java.lang.String oldLabelDesc -> b
    boolean labelHasIndex -> c
    geogebra.common.awt.GRectangle labelRectangle -> a
    geogebra.common.awt.GShape strokedShape -> a
    geogebra.common.awt.GShape strokedShape2 -> b
    geogebra.common.awt.GArea shape -> a
    int lastFontSize -> f
    boolean isTracing -> a
    boolean forcedLineType -> d
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    double getxLabel() -> a
    double getyLabel() -> b
    void updateFontSize() -> c_
    geogebra.common.awt.GRectangle getBounds() -> a
    void drawLabel(geogebra.common.awt.GGraphics2D) -> b
    void ensureLabelDrawsOnScreen() -> b_
    void drawMultilineLaTeX(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GFont,geogebra.common.awt.GColor,geogebra.common.awt.GColor) -> a
    boolean isSerif() -> a
    void drawMultilineText(geogebra.common.awt.GGraphics2D) -> c
    boolean addLabelOffset() -> b
    boolean addLabelOffset(boolean) -> a
    boolean hitLabel(int,int) -> b
    void forceLineType(int) -> a
    void updateStrokes(geogebra.common.kernel.kernelND.GeoElementND) -> a
    void updateStrokesJustLineThickness(geogebra.common.kernel.geos.GeoElement) -> b
    void fill(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GShape,boolean) -> a
    void setForceNoFill(boolean) -> a
    boolean isForceNoFill() -> c
    void setShape(geogebra.common.awt.GArea) -> a
    geogebra.common.awt.GArea getShape() -> a
    boolean isTracing() -> d
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    boolean isFilled() -> e
geogebra.common.euclidian.DrawableList -> geogebra.common.c.c:
    geogebra.common.euclidian.DrawableList$Link head -> a
    geogebra.common.euclidian.DrawableList$Link tail -> b
    int size -> a
    int size() -> a
    void add(geogebra.common.euclidian.Drawable) -> a
    void addUnique(geogebra.common.euclidian.Drawable) -> b
    boolean contains(geogebra.common.euclidian.Drawable) -> a
    void remove(geogebra.common.euclidian.Drawable) -> c
    void drawAll(geogebra.common.awt.GGraphics2D) -> a
    void updateAll() -> a
    void updateFontSizeAll() -> b
    void clear() -> c
    geogebra.common.euclidian.DrawableList$DrawableIterator getIterator() -> a
geogebra.common.euclidian.DrawableList$DrawableIterator -> geogebra.common.c.c$a:
    geogebra.common.euclidian.DrawableList$Link it -> a
    geogebra.common.euclidian.DrawableList this$0 -> a
    geogebra.common.euclidian.Drawable next() -> a
    boolean hasNext() -> hasNext
    void reset() -> a
    void remove() -> remove
    java.lang.Object next() -> next
geogebra.common.euclidian.DrawableList$Link -> geogebra.common.c.c$b:
    geogebra.common.euclidian.Drawable d -> a
    geogebra.common.euclidian.DrawableList$Link next -> a
    geogebra.common.euclidian.DrawableList this$0 -> a
geogebra.common.euclidian.DrawableND -> geogebra.common.c.d:
    boolean createdByDrawList -> a
    boolean createdByDrawListVisible -> b
    geogebra.common.euclidian.DrawableND drawList -> a
    void setCreatedByDrawList(geogebra.common.euclidian.DrawableND) -> a
    void setCreatedByDrawListVisible(boolean) -> b
    boolean createdByDrawList() -> f
    boolean isCreatedByDrawListVisible() -> g
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void update() -> a
    double getxLabel() -> a
    double getyLabel() -> b
geogebra.common.euclidian.EuclidianController -> geogebra.common.c.e:
    int mx -> a
    int my -> b
    double xTemp -> a
    double yTemp -> b
    double xRW -> c
    double yRW -> d
    double xRWold -> e
    double yRWold -> f
    boolean useLineEndPoint -> a
    geogebra.common.kernel.geos.GeoConic tempConic -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly tempImplicitPoly -> a
    java.util.ArrayList moveDependentPoints -> a
    geogebra.common.kernel.geos.GeoFunction tempFunction -> a
    geogebra.common.kernel.kernelND.GeoPointND movedGeoPoint -> a
    boolean movedGeoPointDragged -> b
    geogebra.common.kernel.geos.GeoLine movedGeoLine -> a
    geogebra.common.kernel.geos.GeoConic movedGeoConic -> b
    geogebra.common.kernel.implicit.GeoImplicitPoly movedGeoImplicitPoly -> b
    geogebra.common.kernel.geos.GeoVector movedGeoVector -> a
    geogebra.common.kernel.geos.GeoText movedGeoText -> a
    geogebra.common.kernel.geos.GeoImage oldImage -> a
    geogebra.common.kernel.geos.GeoImage movedGeoImage -> b
    geogebra.common.kernel.geos.GeoFunction movedGeoFunction -> b
    geogebra.common.kernel.geos.GeoNumeric movedGeoNumeric -> a
    boolean movedGeoNumericDragged -> c
    geogebra.common.kernel.geos.GeoBoolean movedGeoBoolean -> a
    geogebra.common.kernel.geos.Furniture movedGeoButton -> a
    geogebra.common.kernel.geos.GeoElement movedLabelGeoElement -> a
    geogebra.common.kernel.geos.GeoElement movedGeoElement -> b
    geogebra.common.kernel.arithmetic.MyDouble tempNum -> a
    double rotationLastAngle -> g
    java.util.ArrayList translateableGeos -> b
    geogebra.common.kernel.Matrix.Coords translationVec -> a
    geogebra.common.euclidian.Hits tempArrayList -> a
    geogebra.common.euclidian.Hits tempArrayList2 -> b
    geogebra.common.euclidian.Hits tempArrayList3 -> c
    java.util.ArrayList selectedPoints -> c
    java.util.ArrayList selectedNumbers -> d
    java.util.ArrayList selectedNumberValues -> e
    java.util.ArrayList selectedLines -> f
    java.util.ArrayList selectedDirections -> g
    java.util.ArrayList selectedSegments -> h
    java.util.ArrayList selectedRegions -> i
    java.util.ArrayList selectedPaths -> j
    java.util.ArrayList selectedConicsND -> k
    java.util.ArrayList selectedImplicitpoly -> l
    java.util.ArrayList selectedFunctions -> m
    java.util.ArrayList selectedCurves -> n
    java.util.ArrayList selectedVectors -> o
    java.util.ArrayList selectedPolygons -> p
    java.util.ArrayList selectedPolyLines -> q
    java.util.ArrayList selectedGeos -> r
    java.util.ArrayList selectedLists -> s
    geogebra.common.euclidian.Hits highlightedGeos -> d
    java.util.ArrayList justCreatedGeos -> t
    boolean selectionPreview -> d
    boolean hideIntersection -> e
    boolean previewFromResultedGeo -> f
    boolean temporaryMode -> g
    boolean dontClearSelection -> h
    boolean draggingOccured -> i
    boolean draggingBeyondThreshold -> j
    boolean pointCreated -> k
    boolean moveModeSelectionHandled -> l
    boolean highlightJustCreatedGeos -> m
    java.util.ArrayList pastePreviewSelected -> u
    java.util.ArrayList pastePreviewSelectedAndDependent -> v
    int mode -> c
    int oldMode -> d
    int moveMode -> e
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.kernel.geos.Test[] macroInput -> a
    int DEFAULT_INITIAL_DELAY -> f
    boolean toggleModeChangedKernel -> n
    boolean altDown -> o
    geogebra.common.kernel.geos.GeoElement rotGeoElement -> c
    geogebra.common.kernel.geos.GeoPoint rotationCenter -> a
    int polygonMode -> g
    double[] transformCoordsOffset -> a
    boolean allowSelectionRectangleForTranslateByVector -> p
    int previousPointCapturing -> h
    java.util.ArrayList persistentStickyPointList -> w
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.awt.GPoint startLoc -> a
    geogebra.common.awt.GPoint mouseLoc -> b
    geogebra.common.awt.GPoint lastMouseLoc -> c
    geogebra.common.awt.GPoint oldLoc -> d
    geogebra.common.awt.GPoint2D$Double startPoint -> a
    geogebra.common.awt.GPoint2D$Double lineEndPoint -> b
    geogebra.common.awt.GPoint selectionStartPoint -> e
    java.util.ArrayList tempDependentPointX -> x
    java.util.ArrayList tempDependentPointY -> y
    boolean mouseIsOverLabel -> q
    geogebra.common.euclidian.EuclidianView view -> a
    geogebra.common.euclidian.EuclidianPen pen -> a
    int deleteToolSize -> i
    geogebra.common.euclidian.Hits handleAddSelectedArrayList -> e
    boolean textfieldHasFocus -> r
    geogebra.common.euclidian.MyButton pressedButton -> a
    double vertexX -> h
    double vertexY -> i
    double initxRW -> j
    double initFactor -> k
    boolean checkBoxOrButtonJustHitted -> s
    boolean penDragged -> t
    boolean wheelZoomingOccurred -> u
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void removeAxes(java.util.ArrayList) -> a
    void updatePastePreviewPosition() -> a
    void setPastePreviewSelected() -> b
    boolean mayPaste() -> a
    void deletePastePreviewSelected() -> c
    void mergeStickyPointsAfterPaste() -> d
    void endOfMode(int) -> a
    void clearSelection(java.util.ArrayList,boolean) -> a
    void clearSelection(java.util.ArrayList) -> b
    geogebra.common.euclidian.Hits getRegionHits(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] getSelectedGeos() -> a
    void getSelectedPointsND(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getSelectedPointsND() -> a
    geogebra.common.kernel.geos.GeoPoint[] getSelectedPoints() -> a
    geogebra.common.kernel.geos.GeoNumeric[] getSelectedNumbers() -> a
    geogebra.common.kernel.geos.GeoList[] getSelectedLists() -> a
    geogebra.common.kernel.geos.GeoPolygon[] getSelectedPolygons() -> a
    geogebra.common.kernel.geos.GeoPolyLine[] getSelectedPolyLines() -> a
    void getSelectedLinesND(geogebra.common.kernel.kernelND.GeoLineND[]) -> a
    geogebra.common.kernel.kernelND.GeoLineND[] getSelectedLinesND() -> a
    geogebra.common.kernel.geos.GeoLine[] getSelectedLines() -> a
    void getSelectedSegmentsND(geogebra.common.kernel.kernelND.GeoSegmentND[]) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND[] getSelectedSegmentsND() -> a
    geogebra.common.kernel.geos.GeoSegment[] getSelectedSegments() -> a
    void getSelectedVectorsND(geogebra.common.kernel.kernelND.GeoVectorND[]) -> a
    geogebra.common.kernel.kernelND.GeoVectorND[] getSelectedVectorsND() -> a
    geogebra.common.kernel.geos.GeoVector[] getSelectedVectors() -> a
    geogebra.common.kernel.geos.GeoConic[] getSelectedConics() -> a
    geogebra.common.kernel.geos.GeoConic[] getSelectedCircles() -> b
    geogebra.common.kernel.kernelND.GeoConicND[] getSelectedConicsND() -> a
    geogebra.common.kernel.Region[] getSelectedRegions() -> a
    geogebra.common.kernel.Path[] getSelectedPaths() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly[] getSelectedImplicitpoly() -> a
    geogebra.common.kernel.geos.GeoFunction[] getSelectedFunctions() -> a
    geogebra.common.kernel.geos.GeoCurveCartesian[] getSelectedCurves() -> a
    boolean allowPointCreation() -> b
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint2D(boolean,geogebra.common.kernel.Path,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint2D(boolean,geogebra.common.kernel.Region,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,double,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    void setKernel(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void clearJustCreatedGeos() -> e
    java.util.ArrayList getJustCreatedGeos() -> a
    void memorizeJustCreatedGeos(java.util.ArrayList) -> c
    void memorizeJustCreatedGeos(geogebra.common.kernel.geos.GeoElement[]) -> a
    void setHighlightedGeos(boolean) -> a
    void doSingleHighlighting(geogebra.common.kernel.geos.GeoElement) -> a
    void removeParentPoints(java.util.ArrayList) -> d
    int addToSelectionList(java.util.ArrayList,geogebra.common.kernel.geos.GeoElement,int) -> a
    int addToHighlightedList(java.util.ArrayList,java.util.ArrayList,int) -> a
    geogebra.common.kernel.geos.GeoElement chooseGeo(java.util.ArrayList,boolean) -> a
    geogebra.common.kernel.geos.GeoElement chooseGeo(geogebra.common.euclidian.Hits,geogebra.common.kernel.geos.Test) -> a
    int addToSelectionList(java.util.ArrayList,java.util.ArrayList,int,boolean,boolean) -> a
    int selGeos() -> a
    int selPoints() -> b
    int selNumbers() -> c
    int selLists() -> d
    int selPolyLines() -> e
    int selPolygons() -> f
    int selLines() -> g
    int selSegments() -> h
    int selVectors() -> i
    int selConics() -> j
    int selPaths() -> k
    int selRegions() -> l
    int selImplicitpoly() -> m
    int selFunctions() -> n
    int selCurves() -> o
    int handleAddSelected(geogebra.common.euclidian.Hits,int,boolean,java.util.ArrayList,geogebra.common.kernel.geos.Test) -> a
    int handleAddSelectedRegions(geogebra.common.euclidian.Hits,int,boolean,java.util.ArrayList) -> a
    int addSelectedGeo(geogebra.common.euclidian.Hits,int,boolean) -> a
    int addSelectedPoint(geogebra.common.euclidian.Hits,int,boolean) -> b
    int addSelectedNumeric(geogebra.common.euclidian.Hits,int,boolean) -> c
    int addSelectedLine(geogebra.common.euclidian.Hits,int,boolean) -> d
    int addSelectedSegment(geogebra.common.euclidian.Hits,int,boolean) -> e
    int addSelectedVector(geogebra.common.euclidian.Hits,int,boolean) -> f
    int addSelectedVector(geogebra.common.euclidian.Hits,int,boolean,geogebra.common.kernel.geos.Test) -> a
    int addSelectedPath(geogebra.common.euclidian.Hits,int,boolean) -> g
    int addSelectedRegion(geogebra.common.euclidian.Hits,int,boolean) -> h
    int addSelectedImplicitpoly(geogebra.common.euclidian.Hits,int,boolean) -> i
    int addSelectedPolygon(geogebra.common.euclidian.Hits,int,boolean) -> j
    int addSelectedPolyLine(geogebra.common.euclidian.Hits,int,boolean) -> k
    int addSelectedList(geogebra.common.euclidian.Hits,int,boolean) -> l
    int addSelectedConic(geogebra.common.euclidian.Hits,int,boolean) -> m
    int addSelectedFunction(geogebra.common.euclidian.Hits,int,boolean) -> n
    int addSelectedCurve(geogebra.common.euclidian.Hits,int,boolean) -> o
    void createNewPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createNewPointIntersection(geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] join(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement[] join() -> b
    void updateMovedGeoPoint(geogebra.common.kernel.kernelND.GeoPointND) -> c
    geogebra.common.kernel.geos.GeoElement[] ray() -> c
    geogebra.common.kernel.geos.GeoElement[] segment(geogebra.common.euclidian.Hits) -> b
    geogebra.common.kernel.geos.GeoElement[] segment() -> d
    geogebra.common.kernel.geos.GeoElement[] vector(geogebra.common.euclidian.Hits) -> c
    geogebra.common.kernel.geos.GeoElement vector(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] ray(geogebra.common.euclidian.Hits) -> d
    geogebra.common.kernel.geos.GeoElement[] polygon(geogebra.common.euclidian.Hits) -> e
    geogebra.common.kernel.geos.GeoElement[] polyline(geogebra.common.euclidian.Hits) -> f
    geogebra.common.kernel.geos.GeoElement[] polygon() -> e
    geogebra.common.kernel.geos.GeoElement[] intersect(geogebra.common.euclidian.Hits) -> g
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialLineSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyLineSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyPolynomialSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyConicSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolysSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,double,double) -> a
    geogebra.common.kernel.geos.GeoElement[] parallel(geogebra.common.euclidian.Hits) -> h
    geogebra.common.kernel.geos.GeoElement[] parabola(geogebra.common.euclidian.Hits) -> i
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.euclidian.Hits) -> j
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.euclidian.Hits,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.geos.GeoElement[] orthogonal2D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.geos.GeoElement[] midpoint(geogebra.common.euclidian.Hits) -> k
    boolean functionInspector(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement[] lineBisector(geogebra.common.euclidian.Hits) -> l
    geogebra.common.kernel.geos.GeoElement[] angularBisector(geogebra.common.euclidian.Hits) -> m
    geogebra.common.kernel.geos.GeoElement[] threePoints(geogebra.common.euclidian.Hits,int) -> a
    geogebra.common.kernel.geos.GeoElement[] switchModeForThreePoints(int) -> a
    boolean relation(geogebra.common.euclidian.Hits) -> b
    geogebra.common.kernel.geos.GeoElement[] locus(geogebra.common.euclidian.Hits) -> n
    geogebra.common.kernel.geos.GeoElement[] conic5(geogebra.common.euclidian.Hits) -> o
    geogebra.common.kernel.geos.GeoElement[] slope(geogebra.common.euclidian.Hits) -> p
    geogebra.common.kernel.geos.GeoElement[] tangents(geogebra.common.euclidian.Hits) -> q
    boolean delete(geogebra.common.euclidian.Hits) -> c
    boolean deleteAll(geogebra.common.euclidian.Hits) -> d
    geogebra.common.kernel.geos.GeoElement[] polarLine(geogebra.common.euclidian.Hits) -> r
    geogebra.common.kernel.geos.GeoLine PolarLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoConic) -> a
    boolean showHideLabel(geogebra.common.euclidian.Hits) -> e
    boolean copyVisualStyle(geogebra.common.euclidian.Hits) -> f
    void textfieldHasFocus(boolean) -> b
    boolean checkBoxOrTextfieldOrButtonJustHitted() -> c
    void initToolTipManager() -> f
    void initShowMouseCoords() -> g
    void wrapMouseEntered() -> h
    boolean move(geogebra.common.euclidian.Hits) -> g
    boolean moveRotate(geogebra.common.euclidian.Hits) -> h
    boolean point(geogebra.common.euclidian.Hits) -> i
    boolean geoElementSelected(geogebra.common.euclidian.Hits,boolean) -> a
    boolean segmentFixed(geogebra.common.euclidian.Hits) -> j
    geogebra.common.kernel.geos.GeoElement[] angleFixed(geogebra.common.euclidian.Hits) -> s
    geogebra.common.kernel.geos.GeoElement[] createCircle2ForPoints3D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] createCircle2(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] switchModeForCircleOrSphere2(int) -> b
    geogebra.common.kernel.geos.GeoElement[] circleOrSphere2(geogebra.common.euclidian.Hits,int) -> b
    boolean showHideObject(geogebra.common.euclidian.Hits) -> k
    boolean text(geogebra.common.euclidian.Hits) -> l
    boolean isAltDown() -> d
    void setAltDown(boolean) -> c
    boolean slider() -> e
    boolean image(geogebra.common.euclidian.Hits) -> m
    geogebra.common.kernel.geos.GeoElement[] mirrorAtPoint(geogebra.common.euclidian.Hits) -> t
    geogebra.common.kernel.geos.GeoElement[] mirrorAtLine(geogebra.common.euclidian.Hits) -> u
    geogebra.common.kernel.geos.GeoElement[] mirrorAtCircle(geogebra.common.euclidian.Hits) -> v
    boolean clearHighlightedGeos() -> o
    boolean refreshHighlighting(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean highlight(geogebra.common.kernel.geos.GeoElement) -> a
    boolean highlight(java.util.ArrayList) -> a
    void clearSelections() -> i
    void clearSelections(boolean,boolean) -> a
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Path) -> a
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Region) -> a
    boolean detach(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean attachDetach(geogebra.common.euclidian.Hits) -> n
    geogebra.common.kernel.geos.GeoElement[] translate(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.geos.GeoElement[] translateByVector(geogebra.common.euclidian.Hits) -> w
    geogebra.common.kernel.geos.GeoElement[] rotateByAngle(geogebra.common.euclidian.Hits) -> x
    geogebra.common.kernel.geos.GeoElement[] dilateFromPoint(geogebra.common.euclidian.Hits) -> y
    geogebra.common.kernel.geos.GeoElement[] fitLine(geogebra.common.euclidian.Hits) -> z
    geogebra.common.kernel.geos.GeoLine FitLineY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] createList(geogebra.common.euclidian.Hits) -> A
    void calcRWcoords() -> j
    void setMouseLocation(geogebra.common.euclidian.event.AbstractEvent) -> a
    void transformCoords() -> k
    double getTransformCoordsOffset(int) -> a
    geogebra.common.kernel.geos.GeoAngle createAngle(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoAngle createLineAngle(geogebra.common.kernel.geos.GeoLine[]) -> a
    geogebra.common.kernel.algos.AlgoDispatcher getAlgoDispatcher() -> a
    java.lang.String removeUnderscores(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoText createDynamicText(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GPoint) -> a
    geogebra.common.kernel.geos.GeoText createDistanceText(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoNumeric) -> a
    void makeLabelNameVisible(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoElement[] area(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> a
    java.lang.String descriptionPoints(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> a
    boolean regularPolygon(geogebra.common.euclidian.Hits) -> o
    geogebra.common.kernel.geos.GeoElement[] angle(geogebra.common.euclidian.Hits) -> B
    geogebra.common.kernel.geos.GeoElement[] distance(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> b
    geogebra.common.kernel.geos.GeoPoint Midpoint(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint ClosestPoint(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> a
    boolean showCheckBox() -> f
    geogebra.common.kernel.geos.GeoElement[] compasses(geogebra.common.euclidian.Hits) -> C
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoConic CircleCompasses(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoElement[] vectorFromPoint(geogebra.common.euclidian.Hits) -> D
    boolean circlePointRadius(geogebra.common.euclidian.Hits) -> p
    geogebra.common.kernel.geos.GeoElement getMovedGeoPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND updateNewPoint(boolean,geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND getNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean) -> a
    boolean createNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean,boolean) -> a
    boolean createNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean) -> a
    boolean macro(geogebra.common.euclidian.Hits) -> q
    boolean button(boolean) -> a
    boolean switchModeForProcessMode(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> b
    void processModeLock(geogebra.common.kernel.Path) -> a
    void processModeLock(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void processModeLock() -> l
    boolean processMode(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> c
    void processReleaseForMovedGeoPoint(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean processRightReleaseFor3D() -> g
    void rotateObject(boolean) -> d
    void moveLabel() -> m
    void movePoint(boolean,geogebra.common.euclidian.event.AbstractEvent) -> a
    void movePointWithOffset(boolean) -> e
    void moveLine(boolean) -> f
    void moveVector(boolean) -> g
    void moveVectorStartPoint(boolean) -> h
    void moveText(boolean) -> i
    void moveTextAbsoluteLocation() -> n
    void moveImage(boolean) -> j
    void moveConic(boolean) -> k
    void moveImplicitPoly(boolean) -> l
    void moveFreehand(boolean) -> m
    void moveFunction(boolean) -> n
    void moveBoolean(boolean) -> o
    void moveButton(boolean) -> p
    double getSliderValue(geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    void moveNumeric(boolean,boolean) -> b
    void moveSlider(boolean) -> q
    void moveDependent(boolean) -> r
    void moveAttached(boolean) -> s
    java.util.ArrayList removeParentsOfView(java.util.ArrayList) -> a
    void moveMultipleObjects(boolean) -> t
    void setMovedGeoPoint(geogebra.common.kernel.geos.GeoElement) -> b
    void switchModeForRemovePolygons(geogebra.common.euclidian.Hits) -> a
    boolean switchModeForMouseReleased(int,geogebra.common.euclidian.Hits,boolean) -> a
    void hitCheckBox(geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.euclidian.Hits addPointCreatedForMouseReleased(geogebra.common.euclidian.Hits) -> b
    boolean moveMode(int) -> a
    boolean hitResetIcon() -> h
    void processMouseMoved(geogebra.common.euclidian.event.AbstractEvent) -> c
    void wrapMouseMoved(geogebra.common.euclidian.event.AbstractEvent) -> d
    void resetToolTipManager() -> o
    void wrapMouseExited(geogebra.common.euclidian.event.AbstractEvent) -> e
    void handleSelectClick(java.util.ArrayList,boolean) -> b
    void mouseClickedMode(geogebra.common.euclidian.event.AbstractEvent,int) -> a
    void wrapMouseclicked(geogebra.common.euclidian.event.AbstractEvent) -> f
    void resetMovedGeoPoint() -> p
    void setStartPointLocation() -> q
    void setStartPointLocationWithOrigin(double,double) -> a
    void handleMovedElement(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    boolean isCheckboxFixed(geogebra.common.kernel.geos.GeoBoolean) -> a
    void updateSelectionRectangle(boolean) -> u
    void handleMouseDragged(boolean,geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean viewHasHitsForMouseDragged() -> i
    boolean processRotate3DView() -> j
    boolean allowSelectionRectangle() -> k
    void handleMousePressedForMoveMode(geogebra.common.euclidian.event.AbstractEvent,boolean) -> a
    void wrapMouseDragged(geogebra.common.euclidian.event.AbstractEvent) -> g
    void handleMouseDraggedForDelete(geogebra.common.euclidian.event.AbstractEvent,int,boolean) -> a
    boolean penMode(int) -> b
    boolean handleMousePressedForViewButtons() -> l
    void processRightPressFor3D() -> r
    void createNewPointForModePoint(geogebra.common.euclidian.Hits,boolean) -> a
    void createNewPointForModeOther(geogebra.common.euclidian.Hits) -> b
    void handleMousePressedForRotateMode() -> s
    void mousePressedTranslatedView() -> t
    void switchModeForMousePressed(geogebra.common.euclidian.event.AbstractEvent) -> h
    void wrapMousePressed(geogebra.common.euclidian.event.AbstractEvent) -> i
    boolean processZoomRectangle() -> m
    void processSelectionRectangleForTransformations(geogebra.common.euclidian.Hits,geogebra.common.kernel.geos.Test) -> a
    void processSelectionRectangle(geogebra.common.euclidian.event.AbstractEvent) -> j
    void processSelection() -> u
    void showDrawingPadPopup(geogebra.common.awt.GPoint) -> a
    void wrapMouseReleased(geogebra.common.euclidian.event.AbstractEvent) -> k
    boolean setJustCreatedGeosSelected() -> n
    void wrapMouseWheelMoved(geogebra.common.euclidian.event.AbstractEvent) -> l
    void setLineEndPoint(geogebra.common.awt.GPoint2D) -> a
    void setLineEndPoint(geogebra.common.awt.GPoint2D$Double) -> a
    geogebra.common.euclidian.Previewable switchPreviewableForInitNewMode(int) -> a
    void initNewMode(int) -> b
    void setMode(int) -> c
    void zoomInOut(boolean,boolean) -> c
    geogebra.common.main.App getApplication() -> a
    void showPopupMenuChooseGeo(java.util.ArrayList,geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.EuclidianPen getPen() -> a
    void resetPen() -> v
    void checkZooming() -> w
    void checkZooming(boolean) -> v
    int getDeleteToolSize() -> p
    void setDeleteToolSize(int) -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.euclidian.EuclidianDraw -> geogebra.common.c.f:
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.euclidian.DrawableND newDrawable(geogebra.common.euclidian.EuclidianView,geogebra.common.kernel.geos.GeoElement) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.euclidian.EuclidianPen -> geogebra.common.c.g:
    geogebra.common.main.App app -> a
    geogebra.common.euclidian.EuclidianView view -> a
    geogebra.common.kernel.algos.AlgoElement lastAlgo -> a
    java.util.ArrayList penPoints -> a
    java.util.ArrayList temp -> b
    int minX -> a
    int maxX -> b
    double CIRCLE_MIN_DET -> a
    double CIRCLE_MAX_SCORE -> b
    double score -> c
    double ARROW_MAXSIZE -> d
    double ARROW_ANGLE_MIN -> e
    double ARROW_ANGLE_MAX -> f
    double ARROW_ASYMMETRY_MAX_ANGLE -> g
    double ARROW_ASYMMETRY_MAX_LINEAR -> h
    double ARROW_TIP_LINEAR_TOLERANCE -> i
    double ARROW_SIDEWAYS_GAP_TOLERANCE -> j
    double ARROW_MAIN_LINEAR_GAP_MIN -> k
    double ARROW_MAIN_LINEAR_GAP_MAX -> l
    int[] brk -> a
    int count -> c
    int recognizer_queue_length -> d
    int MAX_POLYGON_SIDES -> e
    double LINE_MAX_DET -> m
    double SLANT_TOLERANCE -> n
    double RECTANGLE_ANGLE_TOLERANCE -> o
    double RECTANGLE_LINEAR_TOLERANCE -> p
    double POLYGON_LINEAR_TOLERANCE -> q
    geogebra.common.euclidian.EuclidianPen$Inertia a -> a
    geogebra.common.euclidian.EuclidianPen$Inertia b -> b
    geogebra.common.euclidian.EuclidianPen$Inertia c -> c
    geogebra.common.euclidian.EuclidianPen$Inertia d -> d
    geogebra.common.euclidian.EuclidianPen$RecoSegment reco_queue_a -> a
    geogebra.common.euclidian.EuclidianPen$RecoSegment reco_queue_b -> b
    geogebra.common.euclidian.EuclidianPen$RecoSegment reco_queue_c -> c
    geogebra.common.euclidian.EuclidianPen$RecoSegment reco_queue_d -> d
    geogebra.common.euclidian.EuclidianPen$RecoSegment reco_queue_e -> e
    int gridSize -> f
    geogebra.common.awt.GPoint startPoint -> a
    java.lang.StringBuffer gesture -> a
    int deltaX -> g
    int deltaY -> h
    int absDeltaX -> i
    int absDeltaY -> j
    float absTangent -> a
    boolean startNewStroke -> b
    int penSize -> k
    int eraserSize -> l
    int penLineStyle -> m
    geogebra.common.awt.GColor penColor -> a
    boolean freehand -> c
    boolean absoluteScreenPosition -> a
    int getPenSize() -> a
    void setPenSize(int) -> a
    int getPenLineStyle() -> b
    void setPenLineStyle(int) -> b
    geogebra.common.awt.GColor getPenColor() -> a
    geogebra.common.awt.GColor getPenColorCommon() -> b
    void setDefaults() -> a
    boolean isErasingEvent(geogebra.common.euclidian.event.AbstractEvent) -> a
    void resetPenOffsets() -> b
    void handleMouseDraggedForPenMode(geogebra.common.euclidian.event.AbstractEvent) -> a
    void handleMousePressedForPenMode(geogebra.common.euclidian.event.AbstractEvent,geogebra.common.euclidian.Hits) -> a
    void addPointPenMode(geogebra.common.euclidian.event.AbstractEvent,geogebra.common.euclidian.Hits) -> b
    void handleMouseReleasedForPenMode(geogebra.common.euclidian.event.AbstractEvent) -> b
    geogebra.common.kernel.geos.GeoElement checkShapes(geogebra.common.euclidian.event.AbstractEvent) -> a
    void addPointsToPolyLine(java.util.ArrayList) -> a
    geogebra.common.kernel.algos.AlgoPolyLine getAlgoPolyline(geogebra.common.kernel.algos.AlgoElement) -> a
    void mouseReleasedFreehand(geogebra.common.euclidian.event.AbstractEvent) -> c
    void setFreehand(boolean) -> a
    int findPolygonal(int,int,int,int,int) -> a
    void calc_inertia(int,int,geogebra.common.euclidian.EuclidianPen$Inertia) -> a
    double I_det(geogebra.common.euclidian.EuclidianPen$Inertia) -> a
    double I_xx(geogebra.common.euclidian.EuclidianPen$Inertia) -> b
    double I_xy(geogebra.common.euclidian.EuclidianPen$Inertia) -> c
    double I_yy(geogebra.common.euclidian.EuclidianPen$Inertia) -> d
    double score_circle(int,int,geogebra.common.euclidian.EuclidianPen$Inertia) -> a
    double center_x(geogebra.common.euclidian.EuclidianPen$Inertia) -> e
    double center_y(geogebra.common.euclidian.EuclidianPen$Inertia) -> f
    double I_rad(geogebra.common.euclidian.EuclidianPen$Inertia) -> g
    geogebra.common.kernel.geos.GeoConic makeACircle(double,double,double) -> a
    int getDeltaX(geogebra.common.awt.GPoint,geogebra.common.awt.GPoint) -> a
    int getDeltaY(geogebra.common.awt.GPoint,geogebra.common.awt.GPoint) -> b
    void saveMove(java.lang.String) -> a
    java.lang.String getGesture() -> a
    void clearTemporaryInfo() -> c
    void optimize_polygonal(int) -> c
    void incr_inertia(int,geogebra.common.euclidian.EuclidianPen$Inertia,int) -> a
    void get_segment_geometry(int,int,geogebra.common.euclidian.EuclidianPen$Inertia,geogebra.common.euclidian.EuclidianPen$RecoSegment) -> a
    geogebra.common.kernel.geos.GeoElement try_rectangle() -> a
    geogebra.common.kernel.geos.GeoElement try_arrow() -> b
    geogebra.common.kernel.geos.GeoElement try_closed_polygon(int) -> a
    void calc_edge_isect(geogebra.common.euclidian.EuclidianPen$RecoSegment,geogebra.common.euclidian.EuclidianPen$RecoSegment,double[]) -> a
    void setPenColor(geogebra.common.awt.GColor) -> a
    void setAbsoluteScreenPosition(boolean) -> b
geogebra.common.euclidian.EuclidianPen$Inertia -> geogebra.common.c.g$a:
    double mass -> a
    double sx -> b
    double sxx -> c
    double sy -> d
    double sxy -> e
    double syy -> f
    geogebra.common.euclidian.EuclidianPen this$0 -> a
geogebra.common.euclidian.EuclidianPen$RecoSegment -> geogebra.common.c.g$b:
    int startpt -> a
    int endpt -> b
    double xcenter -> a
    double ycenter -> b
    double angle -> c
    double radius -> d
    double x1 -> e
    double y1 -> f
    double x2 -> g
    double y2 -> h
    boolean reversed -> a
    geogebra.common.euclidian.EuclidianPen this$0 -> a
geogebra.common.euclidian.EuclidianStatic -> geogebra.common.c.h:
    geogebra.common.euclidian.EuclidianStatic prototype -> a
    geogebra.common.awt.GBasicStroke standardStroke -> a
    geogebra.common.awt.GBasicStroke selStroke -> b
    geogebra.common.awt.GBasicStroke getDefaultStroke() -> a
    geogebra.common.awt.GBasicStroke getDefaultSelectionStroke() -> b
    float textWidth(java.lang.String,geogebra.common.awt.GFont,geogebra.common.awt.GFontRenderContext) -> a
    geogebra.common.awt.GBasicStroke getStroke(float,int) -> a
    geogebra.common.awt.GRectangle drawMultilineLaTeX(geogebra.common.main.App,geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D,geogebra.common.awt.GFont,geogebra.common.awt.GColor,geogebra.common.awt.GColor,java.lang.String,int,int,boolean) -> a
    geogebra.common.awt.GRectangle doDrawMultilineLaTeX(geogebra.common.main.App,geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D,geogebra.common.awt.GFont,geogebra.common.awt.GColor,geogebra.common.awt.GColor,java.lang.String,int,int,boolean) -> b
    geogebra.common.awt.GFont getIndexFont(geogebra.common.awt.GFont) -> a
    geogebra.common.awt.GPoint drawIndexedString(geogebra.common.main.App,geogebra.common.awt.GGraphics2D,java.lang.String,float,float,boolean) -> a
    void doFillWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> a
    void fillWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> b
    geogebra.common.awt.GRectangle drawMultiLineText(geogebra.common.main.App,java.lang.String,int,int,geogebra.common.awt.GGraphics2D,boolean) -> a
    void drawWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> c
    void doDrawWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> d
    java.lang.Object setInterpolationHint(geogebra.common.awt.GGraphics2D,boolean) -> a
    void resetInterpolationHint(geogebra.common.awt.GGraphics2D,java.lang.Object) -> a
    java.lang.Object doSetInterpolationHint(geogebra.common.awt.GGraphics2D,boolean) -> b
    void doResetInterpolationHint(geogebra.common.awt.GGraphics2D,java.lang.Object) -> b
geogebra.common.euclidian.EuclidianStyleBar -> geogebra.common.c.i:
    void updateButtonPointCapture(int) -> a
    void setMode(int) -> b
    void setLabels() -> a
    void restoreDefaultGeo() -> b
    void updateStyleBar() -> c
    int getPointCaptureSelectedIndex() -> a
geogebra.common.euclidian.EuclidianStyleBarStatic -> geogebra.common.c.j:
    java.lang.String[] bracketArray -> a
    java.lang.String[] bracketArray2 -> b
    java.lang.Integer[] lineStyleArray -> a
    java.lang.Integer[] pointStyleArray -> b
    geogebra.common.kernel.geos.GeoElement applyFixPosition(java.util.ArrayList,boolean,geogebra.common.euclidian.EuclidianViewInterfaceCommon) -> a
    java.lang.String getDefinitonString(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement redefineGeo(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    void applyTableTextFormat(java.util.ArrayList,int,boolean,boolean,int,geogebra.common.main.App) -> a
    boolean applyCaptionStyle(java.util.ArrayList,int,int) -> a
    boolean applyLineStyle(java.util.ArrayList,int,int) -> b
    boolean applyPointStyle(java.util.ArrayList,int,int) -> c
    boolean applyColor(java.util.ArrayList,geogebra.common.awt.GColor,float,geogebra.common.main.App) -> a
    boolean applyBgColor(java.util.ArrayList,geogebra.common.awt.GColor,float) -> a
    boolean applyTextColor(java.util.ArrayList,geogebra.common.awt.GColor) -> a
    boolean applyFontStyle(java.util.ArrayList,int) -> a
    boolean applyTextSize(java.util.ArrayList,int) -> b
    boolean processSourceCommon(java.lang.String,java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon) -> a
    geogebra.common.kernel.algos.AlgoTableText updateTableText(java.lang.Object[],int) -> a
    java.util.HashMap createDefaultMap() -> a
geogebra.common.euclidian.EuclidianView -> geogebra.common.c.k:
    boolean hasMouse -> a
    int EVNO_GENERAL -> a
    int evNo -> b
    double xZeroOld -> b
    double yZeroOld -> c
    int mode -> e
    int SCREEN_BORDER -> c
    geogebra.common.awt.GBufferedImage bgImage -> a
    geogebra.common.awt.GGraphics2D bgGraphics -> a
    geogebra.common.awt.GColor colZoomRectangle -> a
    geogebra.common.awt.GColor colZoomRectangleFill -> b
    geogebra.common.awt.GColor colDeletionSquare -> c
    geogebra.common.awt.GBasicStroke strokeDeletionSquare -> a
    geogebra.common.awt.GRectangle deletionRectangle -> a
    geogebra.common.awt.GColor axesColor -> d
    geogebra.common.awt.GColor gridColor -> e
    geogebra.common.awt.GRectangle selectionRectangle -> b
    geogebra.common.awt.GBasicStroke defAxesStroke -> b
    geogebra.common.awt.GBasicStroke boldAxesStroke -> c
    geogebra.common.awt.GBasicStroke axesStroke -> d
    geogebra.common.awt.GBasicStroke tickStroke -> e
    geogebra.common.awt.GBasicStroke gridStroke -> f
    geogebra.common.kernel.Kernel kernel -> a
    int fontSize -> f
    geogebra.common.awt.GAffineTransform coordTransform -> a
    double[] AxesTickInterval -> a
    geogebra.common.util.NumberFormatAdapter[] axesNumberFormat -> a
    boolean[] showAxes -> a
    boolean automaticGridDistance -> f
    double[] gridDistances -> b
    int gridLineStyle -> g
    int axesLineType -> h
    boolean gridIsBold -> g
    int tooltipsInThisView -> d
    int gridType -> i
    geogebra.common.awt.GFont fontPoint -> a
    geogebra.common.awt.GFont fontLine -> b
    geogebra.common.awt.GFont fontVector -> c
    geogebra.common.awt.GFont fontConic -> d
    geogebra.common.awt.GFont fontCoords -> e
    geogebra.common.awt.GFont fontAxes -> f
    geogebra.common.awt.GFont fontAngle -> g
    geogebra.common.util.NumberFormatAdapter printScaleNF -> a
    boolean showGrid -> b
    boolean antiAliasing -> c
    boolean showMouseCoords -> h
    boolean allowShowMouseCoords -> i
    boolean showAxesRatio -> j
    boolean highlightAnimationButtons -> d
    int pointCapturingMode -> j
    boolean showAxesCornerCoords -> k
    boolean[] showAxesNumbers -> b
    java.lang.String[] axesLabels -> a
    int[] axesLabelsStyle -> a
    java.lang.String[] axesUnitLabels -> b
    geogebra.common.euclidian.Previewable previewDrawable -> a
    boolean firstPaint -> e
    geogebra.common.main.App app -> a
    geogebra.common.main.settings.EuclidianSettings settings -> a
    geogebra.common.euclidian.EuclidianController euclidianController -> a
    geogebra.common.euclidian.Hits hits -> a
    geogebra.common.kernel.arithmetic.NumberValue xminObject -> a
    geogebra.common.kernel.arithmetic.NumberValue xmaxObject -> b
    geogebra.common.kernel.arithmetic.NumberValue yminObject -> c
    geogebra.common.kernel.arithmetic.NumberValue ymaxObject -> d
    boolean updatingBounds -> l
    java.lang.Double lockedAxesRatio -> a
    double xmin -> d
    double xmax -> e
    double ymin -> f
    double ymax -> g
    double invXscale -> h
    double invYscale -> i
    double xZero -> j
    double yZero -> k
    double xscale -> l
    double yscale -> m
    double printingScale -> a
    java.util.HashMap DrawableMap -> a
    java.util.ArrayList stickyPointList -> a
    geogebra.common.euclidian.DrawableList allDrawableList -> a
    geogebra.common.euclidian.DrawableList[] drawLayers -> a
    geogebra.common.euclidian.DrawableList bgImageList -> b
    boolean[] piAxisUnit -> c
    int[] axesTickStyles -> b
    boolean[] automaticAxesNumberingDistances -> d
    double[] axesNumberingDistances -> c
    double[] axisCross -> d
    boolean[] positiveAxes -> e
    boolean[] drawBorderAxes -> f
    boolean reIniting -> m
    geogebra.common.awt.GEllipse2DDouble circle -> a
    geogebra.common.awt.GLine2D tempLine -> a
    geogebra.common.awt.GGeneralPath gp -> a
    geogebra.common.euclidian.EuclidianStyleBar styleBar -> a
    boolean moveAxesLabels -> n
    int widthTemp -> k
    int heightTemp -> l
    double xminTemp -> n
    double xmaxTemp -> o
    double yminTemp -> p
    double ymaxTemp -> q
    geogebra.common.euclidian.Hits tempArrayList -> b
    geogebra.common.euclidian.MyZoomer zoomer -> a
    geogebra.common.euclidian.MyZoomer axesRatioZoomer -> b
    geogebra.common.euclidian.MyZoomer mover -> c
    geogebra.common.euclidian.MyZoomer zoomerRW -> d
    geogebra.common.gui.dialog.options.OptionsEuclidian optionPanel -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> c
    java.lang.Integer[] getLineTypes() -> a
    java.lang.Integer[] getPointStyles() -> b
    void setAxesColor(geogebra.common.awt.GColor) -> a
    void setStandardCoordSystem(boolean) -> o
    void attachView() -> a
    int getPointCapturingMode() -> b
    void setPointCapturing(int) -> a
    void setCapturingThreshold(int) -> b
    int getCapturingThreshold() -> c
    int getMode() -> d
    void setMode(int) -> c
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean clearRectangle(int) -> e
    geogebra.common.kernel.geos.GeoNumeric getXminObject() -> a
    void updateBoundObjects() -> c
    boolean isLockedAxesRatio() -> a
    void setLockedAxesRatio(java.lang.Double) -> a
    void updateBounds() -> e
    boolean isZoomable() -> b
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric getXmaxObject() -> b
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric getYminObject() -> c
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setSizeListeners() -> F
    int toScreenCoordX(double) -> a
    int toScreenCoordY(double) -> b
    double toScreenCoordXd(double) -> a
    double toScreenCoordYd(double) -> b
    int toClippedScreenCoordX(double) -> c
    void rememberOrigins() -> f
    int toClippedScreenCoordY(double) -> d
    boolean toScreenCoords(double[]) -> a
    boolean isOnScreen(double[]) -> b
    double toRealWorldCoordX(double) -> c
    double toRealWorldCoordY(double) -> d
    void setCoordSystem(double,double,double,double) -> a
    void setCoordSystemFromMouseMove(int,int,int) -> a
    void setRealWorldCoordSystem(double,double,double,double) -> b
    void setCoordSystem(double,double,double,double,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric getYmaxObject() -> d
    void setAntialiasing(boolean) -> a
    int getEuclidianViewNo() -> e
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void setXscale(double) -> c
    void setYscale(double) -> d
    void setFontSize(int) -> d
    double getxZero() -> a
    double getyZero() -> b
    double getXZero() -> c
    double getYZero() -> d
    java.lang.String getXYscaleRatioString() -> a
    double getXscale() -> e
    double getYscale() -> f
    double getInvXscale() -> g
    double getInvYscale() -> h
    int getViewWidth() -> f
    int getViewHeight() -> g
    double getScaleRatio() -> i
    double getXmax() -> j
    double getXmin() -> k
    double getYmax() -> l
    double getYmin() -> m
    int getGridType() -> h
    void setGridType(int) -> e
    void setRealWorldBounds() -> h
    void zoomAroundCenter(double) -> a
    void updateAllDrawables(boolean) -> b
    void drawListAsComboBox(geogebra.common.kernel.geos.GeoList,boolean) -> a
    void calcPrintingScale() -> i
    void setAxesIntervals(double,int) -> a
    int getFontSize() -> i
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.euclidian.Hits getHits() -> a
    void setHits(geogebra.common.awt.GPoint) -> a
    double getXAxisCrossingPixel() -> o
    double getYAxisCrossingPixel() -> p
    geogebra.common.euclidian.MyButton getHitButton(geogebra.common.awt.GPoint) -> a
    geogebra.common.kernel.geos.GeoElement getLabelHit(geogebra.common.awt.GPoint) -> a
    geogebra.common.euclidian.DrawableND getDrawable(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.euclidian.DrawableND getDrawableND(geogebra.common.kernel.geos.GeoElement) -> b
    void addToDrawableLists(geogebra.common.euclidian.Drawable) -> a
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.euclidian.DrawableND newDrawable(geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.euclidian.DrawableND createDrawable(geogebra.common.kernel.geos.GeoElement) -> e
    void reset() -> g
    void resetMode() -> j
    void repaintView() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    geogebra.common.euclidian.DrawableND getDrawableFor(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void updateDrawableFontSize() -> k
    geogebra.common.awt.GFont getFontPoint() -> a
    void setFontPoint(geogebra.common.awt.GFont) -> a
    geogebra.common.awt.GFont getFontLine() -> b
    void setFontLine(geogebra.common.awt.GFont) -> b
    geogebra.common.awt.GFont getFontVector() -> c
    void setFontVector(geogebra.common.awt.GFont) -> c
    geogebra.common.awt.GFont getFontConic() -> d
    void setFontConic(geogebra.common.awt.GFont) -> d
    geogebra.common.awt.GFont getFontCoords() -> e
    void setFontCoords(geogebra.common.awt.GFont) -> e
    geogebra.common.awt.GFont getFontAxes() -> f
    void setFontAxes(geogebra.common.awt.GFont) -> f
    geogebra.common.awt.GFont getFontAngle() -> g
    void setFontAngle(geogebra.common.awt.GFont) -> g
    java.util.ArrayList getStickyPointList() -> a
    void setBooleanSize(int) -> f
    int getBooleanSize() -> j
    void setAllowToolTips(int) -> g
    int getAllowToolTips() -> k
    geogebra.common.kernel.Matrix.Coords getCoordsForView(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix getMatrix() -> a
    geogebra.common.awt.GAffineTransform getTransform(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords[]) -> a
    java.lang.String getTranslatedFromPlaneString() -> b
    boolean isDefault2D() -> c
    int getViewID() -> a
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND getPlaneContaining() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND getDirection() -> a
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    void replaceBoundObject(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    void setRightAngleStyle(int) -> h
    int getRightAngleStyle() -> l
    boolean isAutomaticGridDistance() -> d
    double[] getGridDistances() -> a
    void setGridDistances(double[]) -> a
    int getGridLineStyle() -> m
    void setAutomaticGridDistance(boolean) -> c
    int getAxesLineStyle() -> n
    void setAxesLineStyle(int) -> i
    geogebra.common.awt.GAffineTransform getCoordTransform() -> a
    void updateBackground() -> l
    geogebra.common.awt.GGraphics2D getTempGraphics2D(geogebra.common.awt.GFont) -> a
    geogebra.common.awt.GFont getFont() -> h
    void setHeight(int) -> j
    void setWidth(int) -> k
    void initCursor() -> m
    void setStyleBarMode(int) -> l
    boolean usesSelectionAsInput(int) -> a
    geogebra.common.euclidian.draw.DrawAngle newDrawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    boolean usesSelectionRectangleAsInput(int) -> b
    void setSelectionRectangle(geogebra.common.awt.GRectangle) -> a
    double[] getAxesCross() -> b
    void setAxesCross(double[]) -> b
    void setAxisCross(int,double) -> a
    boolean[] getPositiveAxes() -> a
    void setPositiveAxes(boolean[]) -> a
    void setPositiveAxis(int,boolean) -> a
    boolean[] getDrawBorderAxes() -> b
    void setDrawBorderAxes(boolean[]) -> b
    void setAxesCornerCoordsVisible(boolean) -> d
    double getPrintingScale() -> n
    void setPrintingScale(double) -> b
    java.lang.String[] getAxesLabels(boolean) -> a
    void setAxisLabel(int,java.lang.String) -> a
    void setAutomaticAxesNumberingDistance(boolean,int) -> a
    boolean[] isAutomaticAxesNumberingDistance() -> c
    double[] getAxesNumberingDistances() -> c
    void setAxesNumberingDistance(double,int) -> b
    boolean getGridIsBold() -> e
    boolean[] getShowAxesNumbers() -> d
    void setShowAxesNumbers(boolean[]) -> c
    java.lang.String[] getAxesUnitLabels() -> a
    void setAxesUnitLabels(java.lang.String[]) -> a
    int[] getAxesTickStyles() -> a
    void setAxesTickStyles(int[]) -> a
    void setShowMouseCoords(boolean) -> e
    boolean getAllowShowMouseCoords() -> f
    void setAllowShowMouseCoords(boolean) -> f
    boolean getShowMouseCoords() -> g
    void setShowAxesRatio(boolean) -> g
    geogebra.common.euclidian.Previewable getPreviewDrawable() -> a
    double getGridDistances(int) -> a
    boolean getShowGrid() -> h
    boolean isGridOrAxesShown() -> i
    boolean getShowAxis(int) -> c
    boolean getShowXaxis() -> j
    boolean getShowYaxis() -> k
    geogebra.common.euclidian.Previewable createPreviewLine(java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPerpendicularBisector(java.util.ArrayList) -> b
    geogebra.common.euclidian.Previewable createPreviewAngleBisector(java.util.ArrayList) -> c
    geogebra.common.euclidian.Previewable createPreviewSegment(java.util.ArrayList) -> d
    geogebra.common.euclidian.Previewable createPreviewRay(java.util.ArrayList) -> e
    geogebra.common.euclidian.Previewable createPreviewVector(java.util.ArrayList) -> f
    geogebra.common.euclidian.Previewable createPreviewConic(int,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPolygon(java.util.ArrayList) -> g
    geogebra.common.euclidian.Previewable createPreviewAngle(java.util.ArrayList) -> h
    geogebra.common.euclidian.Previewable createPreviewPolyLine(java.util.ArrayList) -> i
    void updatePreviewable() -> n
    void mouseEntered() -> o
    void mouseExited() -> p
    geogebra.common.euclidian.Previewable createPreviewParallelLine(java.util.ArrayList,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPerpendicularLine(java.util.ArrayList,java.util.ArrayList) -> b
    void setApplication(geogebra.common.main.App) -> a
    geogebra.common.main.App getApplication() -> a
    void updateFonts() -> q
    void updateSize() -> r
    boolean requestFocusInWindow() -> l
    void drawGeometricObjects(geogebra.common.awt.GGraphics2D) -> a
    void drawObjects(geogebra.common.awt.GGraphics2D) -> b
    void clearBackground(geogebra.common.awt.GGraphics2D) -> c
    void drawBackgroundWithImages(geogebra.common.awt.GGraphics2D,boolean) -> a
    void drawAxesRatio(geogebra.common.awt.GGraphics2D) -> d
    void paintBackground(geogebra.common.awt.GGraphics2D) -> e
    void paint(geogebra.common.awt.GGraphics2D) -> f
    void updateBackgroundImage() -> s
    void drawZoomRectangle(geogebra.common.awt.GGraphics2D) -> g
    void drawRect(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GColor,geogebra.common.awt.GBasicStroke,geogebra.common.awt.GRectangle) -> a
    void drawMouseCoords(geogebra.common.awt.GGraphics2D) -> h
    void drawBackgroundWithImages(geogebra.common.awt.GGraphics2D) -> p
    void drawBackground(geogebra.common.awt.GGraphics2D,boolean) -> b
    void drawGrid(geogebra.common.awt.GGraphics2D) -> i
    double getLabelLength(double,geogebra.common.awt.GFontRenderContext) -> a
    void drawAxes(geogebra.common.awt.GGraphics2D) -> j
    boolean areAxesBold() -> m
    boolean xAxisOnscreen() -> r
    boolean yAxisOnscreen() -> s
    void drawStringWithBackground(geogebra.common.awt.GGraphics2D,java.lang.String,double,double,geogebra.common.awt.GColor,geogebra.common.awt.font.GTextLayout,int,int) -> a
    void drawResetIcon(geogebra.common.awt.GGraphics2D) -> k
    void drawActionObjects(geogebra.common.awt.GGraphics2D) -> l
    void setDefRenderingHints(geogebra.common.awt.GGraphics2D) -> m
    void setAntialiasing(geogebra.common.awt.GGraphics2D) -> n
    void drawAnimationButtons(geogebra.common.awt.GGraphics2D) -> o
    void setBackground(geogebra.common.awt.GColor) -> b
    void synchronizeMenuBarAndEuclidianStyleBar(geogebra.common.main.settings.EuclidianSettings) -> a
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    void showGrid(boolean) -> h
    void setGridIsBold(boolean) -> i
    void setGridColor(geogebra.common.awt.GColor) -> c
    void setGridLineStyle(int) -> m
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    void setHits(geogebra.common.awt.GRectangle) -> b
    void setIntersectionHits(geogebra.common.awt.GRectangle) -> c
    geogebra.common.awt.GRectangle getSelectionRectangle() -> a
    geogebra.common.euclidian.GeneralPathClipped getBoundingPath() -> a
    void addBackgroundImage(geogebra.common.euclidian.draw.DrawImage) -> a
    void removeBackgroundImage(geogebra.common.euclidian.draw.DrawImage) -> b
    void resetLists() -> t
    geogebra.common.awt.GRectangle getBounds() -> b
    void setPreview(geogebra.common.euclidian.Previewable) -> a
    void setTemporaryCoordSystemForExport() -> u
    geogebra.common.awt.GPoint getMaximumLabelSize(geogebra.common.awt.GGraphics2D) -> a
    void restoreOldCoordSystem() -> v
    void setTemporarySize(int,int) -> a
    void setShowAxis(int,boolean,boolean) -> a
    void setShowAxes(boolean,boolean) -> a
    void setBoldAxes(boolean) -> j
    int getBoldAxes(boolean,int) -> a
    boolean isTracing() -> n
    boolean hasBackgroundImages() -> o
    geogebra.common.awt.GGraphics2D getBackgroundGraphics() -> a
    void getXML(java.lang.StringBuilder,boolean) -> a
    java.lang.String axisLabelForXML(int) -> a
    void drawPoints(geogebra.common.kernel.geos.GeoImage,double[],double[]) -> a
    void doDrawPoints(geogebra.common.kernel.geos.GeoImage,java.util.List,geogebra.common.awt.GColor,int,int) -> a
    void resetXYMinMaxObjects() -> w
    void setViewShowAllObjects(boolean) -> k
    int getSelectedWidth() -> o
    int getSelectedHeight() -> p
    int getExportWidth() -> q
    int getExportHeight() -> r
    void clickedGeo(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.event.AbstractEvent) -> a
    geogebra.common.euclidian.MyZoomer newZoomer() -> a
    void zoom(double,double,double,int,boolean) -> a
    void zoomAxesRatio(double,boolean) -> a
    void setStandardView(boolean) -> l
    void setAnimatedCoordSystem(double,double,double,double,int,boolean) -> a
    void setAnimatedRealWorldCoordSystem(double,double,double,double,int,boolean) -> b
    void mouseMovedOver(geogebra.common.kernel.geos.GeoElement) -> g
    void highlight(geogebra.common.kernel.geos.GeoElement) -> h
    void highlight(java.util.ArrayList) -> a
    void mouseMovedOverList(java.util.ArrayList) -> b
    boolean setAnimationButtonsHighlighted(boolean) -> a
    boolean drawPlayButtonInThisView() -> p
    geogebra.common.awt.GColor getAxesColor() -> a
    geogebra.common.awt.GColor getGridColor() -> b
    void add(geogebra.common.javax.swing.GBox) -> a
    void remove(geogebra.common.javax.swing.GBox) -> b
    void initView(boolean) -> m
    void setShowAxis(boolean) -> n
    void setTransparentCursor() -> x
    geogebra.common.awt.GGraphics2D getGraphicsForPen() -> b
    boolean hasStyleBar() -> q
    boolean isPenMode(int) -> d
    void setOptionPanel(geogebra.common.gui.dialog.options.OptionsEuclidian) -> a
    geogebra.common.awt.GRectangle getDeletionRectangle() -> c
    void setDeletionRectangle(geogebra.common.awt.GRectangle) -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra.common.euclidian.EuclidianViewInterfaceCommon -> geogebra.common.c.l:
    void zoom(double,double,double,int,boolean) -> a
    void resetMode() -> j
    void repaint() -> repaint
    void rememberOrigins() -> f
    geogebra.common.main.App getApplication() -> a
    geogebra.common.euclidian.DrawableND getDrawableFor(geogebra.common.kernel.geos.GeoElement) -> f
    java.lang.String getTranslatedFromPlaneString() -> b
    boolean isLockedAxesRatio() -> a
    boolean isZoomable() -> b
    geogebra.common.awt.GColor getBackgroundCommon() -> c
    int getMode() -> d
    boolean getShowGrid() -> h
    boolean getShowXaxis() -> j
    boolean getShowYaxis() -> k
    double getXZero() -> c
    double getYZero() -> d
    void setCoordSystem(double,double,double,double) -> a
    void setCoordSystemFromMouseMove(int,int,int) -> a
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> b
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> d
    int toScreenCoordX(double) -> a
    int toScreenCoordY(double) -> b
    boolean hitAnimationButton(geogebra.common.euclidian.event.AbstractEvent) -> a
    void setDefaultCursor() -> y
    void setHitCursor() -> z
    boolean requestFocusInWindow() -> l
    geogebra.common.euclidian.EuclidianStyleBar getStyleBar() -> a
    void setDragCursor() -> A
    void setToolTipText(java.lang.String) -> a
    void setResizeXAxisCursor() -> B
    void setResizeYAxisCursor() -> C
    void setMoveCursor() -> D
    int getEuclidianViewNo() -> e
    double toScreenCoordXd(double) -> a
    double toScreenCoordYd(double) -> b
    void setShowAxes(boolean,boolean) -> a
    void showGrid(boolean) -> h
    void clickedGeo(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.event.AbstractEvent) -> a
    void mouseMovedOver(geogebra.common.kernel.geos.GeoElement) -> g
    void highlight(geogebra.common.kernel.geos.GeoElement) -> h
    void highlight(java.util.ArrayList) -> a
    void mouseMovedOverList(java.util.ArrayList) -> b
    boolean hasFocus() -> hasFocus
    void setShowAxis(boolean) -> n
    void setStandardView(boolean) -> l
    void requestFocus() -> E
geogebra.common.euclidian.EuclidianViewInterfaceSlim -> geogebra.common.c.m:
    boolean isDefault2D() -> c
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> b
    int getWidth() -> s
    int getHeight() -> t
    double toRealWorldCoordX(double) -> c
    double toRealWorldCoordY(double) -> d
    void updateBounds() -> e
    void replaceBoundObject(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.euclidian.EuclidianController getEuclidianController() -> a
    double[] getGridDistances() -> a
    double getXmax() -> j
    double getYmax() -> l
    double getXmin() -> k
    double getYmin() -> m
    double getXscale() -> e
    double getYscale() -> f
    geogebra.common.euclidian.DrawableND getDrawableND(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> c
    void zoom(double,double,double,int,boolean) -> a
    int getPointCapturingMode() -> b
    void setPointCapturing(int) -> a
    void setSelectionRectangle(geogebra.common.awt.GRectangle) -> a
    void setRealWorldCoordSystem(double,double,double,double) -> b
geogebra.common.euclidian.GeneralPathClipped -> geogebra.common.c.n:
    java.util.ArrayList pathPoints -> a
    geogebra.common.awt.GGeneralPath gp -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim view -> a
    double largestCoord -> a
    boolean needClosePath -> a
    geogebra.common.awt.GRectangle bounds -> a
    geogebra.common.kernel.MyPoint firstPoint() -> a
    void reset() -> a
    void closePath() -> b
    geogebra.common.awt.GGeneralPath getGeneralPath() -> a
    void addSimpleSegments() -> c
    void addClippedSegments() -> d
    void addClippedLine(geogebra.common.kernel.MyPoint,geogebra.common.kernel.MyPoint,geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GPoint2D getPointCloseToScreen(double,double) -> a
    void addToGeneralPath(geogebra.common.awt.GPoint2D,boolean) -> a
    void moveTo(double,double) -> a
    void lineTo(double,double) -> b
    void addPoint(int,double,double) -> a
    void addPoint(double,double,boolean) -> a
    void updateBounds(geogebra.common.kernel.MyPoint) -> a
    geogebra.common.awt.GPoint2D getCurrentPoint() -> a
    void transform(geogebra.common.awt.GAffineTransform) -> a
    boolean contains(double,double) -> a
    boolean contains(double,double,double,double) -> a
    boolean contains(int,int) -> a
    boolean contains(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GRectangle2D getBounds2D() -> a
    geogebra.common.awt.GPathIterator getPathIterator(geogebra.common.awt.GAffineTransform) -> a
    boolean intersects(geogebra.common.awt.GRectangle2D) -> a
    boolean intersects(int,int,int,int) -> a
geogebra.common.euclidian.GetViewId -> geogebra.common.c.o:
    int getViewId() -> a
geogebra.common.euclidian.HatchingHandler -> geogebra.common.c.p:
    geogebra.common.euclidian.HatchingHandler prototype -> a
    void dosetHatching(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GBasicStroke,geogebra.common.awt.GColor,geogebra.common.awt.GColor,float,double,double) -> a
    void setHatching(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GBasicStroke,geogebra.common.awt.GColor,geogebra.common.awt.GColor,float,double,double) -> b
    void doSetTexture(geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,float) -> a
    void setTexture(geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,float) -> b
geogebra.common.euclidian.Hits -> geogebra.common.c.q:
    int listCount -> a
    int polyCount -> b
    int imageCount -> c
    boolean hasXAxis -> a
    boolean hasYAxis -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$Test -> a
    void init() -> a
    geogebra.common.euclidian.Hits clone() -> a
    geogebra.common.euclidian.Hits newHits() -> b
    boolean add(geogebra.common.kernel.geos.GeoElement) -> a
    int getImageCount() -> a
    int getListCount() -> b
    boolean hasXAxis() -> a
    boolean hasYAxis() -> b
    void removePolygonsIfSideNotPresent() -> b
    void keepOnlyHitsForNewPointMode() -> c
    void removeConicsHittedOnFilling() -> d
    void removePolygonsDependingSidePresent(boolean) -> a
    void removeSegmentsFromPolygons() -> e
    void removePolygons() -> f
    void removeAllPolygons() -> g
    void removeAllButImages() -> h
    void removeImages() -> i
    geogebra.common.euclidian.Hits getMoveableHits(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    geogebra.common.euclidian.Hits getPointRotateableHits(geogebra.common.euclidian.EuclidianViewInterfaceSlim,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.euclidian.Hits getMoveables(geogebra.common.euclidian.EuclidianViewInterfaceSlim,geogebra.common.kernel.geos.Test,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.euclidian.Hits getOtherHits(geogebra.common.kernel.geos.Test,geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.Hits getHits(geogebra.common.kernel.geos.Test,geogebra.common.euclidian.Hits) -> b
    geogebra.common.euclidian.Hits getHits(geogebra.common.kernel.geos.Test,boolean,geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.Hits getRegionHits(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement getFirstHit(geogebra.common.kernel.geos.Test) -> a
    geogebra.common.euclidian.Hits getTopHits() -> c
    boolean containsGeoPoint() -> c
    boolean containsGeoPoint(geogebra.common.euclidian.Hits) -> a
    java.lang.String toString() -> toString
    boolean intersect(java.util.ArrayList) -> a
    java.lang.Object clone() -> clone
    boolean add(java.lang.Object) -> add
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$Test() -> a
geogebra.common.euclidian.MyButton -> geogebra.common.c.r:
    geogebra.common.kernel.geos.GeoButton geoButton -> a
    geogebra.common.euclidian.EuclidianView view -> a
    int x -> a
    int y -> b
    int width -> c
    int height -> d
    boolean selected -> a
    java.lang.String text -> a
    geogebra.common.awt.GFont font -> a
    boolean pressed -> b
    boolean draggedOrContext -> c
    java.lang.String getCaption() -> b
    void paintComponent(geogebra.common.awt.GGraphics2D) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    boolean isSelected() -> b
    int getWidth() -> a
    int getHeight() -> b
    void setBounds(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void setSelected(boolean) -> a
    void setText(java.lang.String) -> a
    java.lang.String getText() -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setPressed(boolean) -> b
    void setDraggedOrContext(boolean) -> c
    boolean getDraggedOrContext() -> a
geogebra.common.euclidian.MyZoomer -> geogebra.common.c.s:
    geogebra.common.euclidian.EuclidianView view -> a
    geogebra.common.euclidian.MyZoomer$ZoomerMode mode -> a
    double px -> a
    double py -> b
    double factor -> c
    int counter -> a
    int steps -> b
    double oldScale -> d
    double newScale -> e
    double add -> f
    double dx -> g
    double dy -> h
    double x0 -> i
    double x1 -> j
    double y0 -> k
    double y1 -> l
    double xminOld -> m
    double yminOld -> n
    double ymaxOld -> o
    double xmaxOld -> p
    long startTime -> a
    boolean storeUndo -> a
    boolean setStandard -> b
    double standardX -> q
    double standardY -> r
    int[] $SWITCH_TABLE$geogebra$common$euclidian$MyZoomer$ZoomerMode -> a
    void init(double,boolean) -> a
    void init(double,double,double,int,boolean) -> a
    void initRW(double,double,double,double,int,boolean) -> a
    void init(double,double,boolean) -> a
    void step() -> a
    void stopAnimation() -> e
    void setStandardViewAfter(double,double) -> a
    void startAnimation() -> b
    void stopTimer() -> c
    void startTimer() -> d
    boolean hasTimer() -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$MyZoomer$ZoomerMode() -> a
geogebra.common.euclidian.MyZoomer$ZoomerMode -> geogebra.common.c.s$a:
    geogebra.common.euclidian.MyZoomer$ZoomerMode ZOOM -> a
    geogebra.common.euclidian.MyZoomer$ZoomerMode ZOOM_RW -> b
    geogebra.common.euclidian.MyZoomer$ZoomerMode AXES -> c
    geogebra.common.euclidian.MyZoomer$ZoomerMode MOVE -> d
    geogebra.common.euclidian.MyZoomer$ZoomerMode[] ENUM$VALUES -> a
    geogebra.common.euclidian.MyZoomer$ZoomerMode[] values() -> values
    geogebra.common.euclidian.MyZoomer$ZoomerMode valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.Previewable -> geogebra.common.c.t:
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
geogebra.common.euclidian.RemoveNeeded -> geogebra.common.c.u:
    void remove() -> b
geogebra.common.euclidian.clipping.ClipLine -> geogebra.common.c.a.a:
    geogebra.common.awt.GPoint2D[] getClipped(double,double,double,double,int,int,int,int) -> a
    geogebra.common.awt.GPoint2D[] getClipped(double,double,int,double,double,int,double,double,double,double) -> a
    geogebra.common.awt.GPoint2D intersect(double,double,double,double,double,double,double,double) -> a
geogebra.common.euclidian.clipping.ClipShape -> geogebra.common.c.a.b:
    geogebra.common.euclidian.clipping.DoubleArrayFactory doubleFactory -> a
    geogebra.common.awt.GGeneralPath clipToRect(geogebra.common.awt.GShape,geogebra.common.awt.GAffineTransform,geogebra.common.awt.GRectangle2D) -> a
    geogebra.common.euclidian.clipping.DoubleArrayFactory access$0() -> a
geogebra.common.euclidian.clipping.ClipShape$CFunction -> geogebra.common.c.a.b$a:
    double a -> a
    double b -> b
    double c -> c
    double d -> d
    double[] t2 -> a
    double[] eqn -> b
    java.lang.String toString() -> toString
    void define(double,double,double,double) -> a
    double evaluate(double) -> a
    double getDerivative(double) -> b
    int evaluateInverse(double,double[],int) -> a
geogebra.common.euclidian.clipping.ClipShape$ClippedPath -> geogebra.common.c.a.b$b:
    geogebra.common.awt.GGeneralPath g -> a
    java.util.Stack uncommittedPoints -> a
    double initialX -> a
    double initialY -> b
    void moveTo(double,double) -> a
    void curveTo(geogebra.common.euclidian.clipping.ClipShape$Function,geogebra.common.euclidian.clipping.ClipShape$Function,double,double) -> a
    void lineTo(double,double) -> b
    void closePath() -> a
    void flush() -> b
geogebra.common.euclidian.clipping.ClipShape$Function -> geogebra.common.c.a.b$c:
    double evaluate(double) -> a
    int evaluateInverse(double,double[],int) -> a
    double getDerivative(double) -> b
geogebra.common.euclidian.clipping.ClipShape$LFunction -> geogebra.common.c.a.b$d:
    double slope -> a
    double intercept -> b
    void define(double,double) -> a
    java.lang.String toString() -> toString
    double evaluate(double) -> a
    int evaluateInverse(double,double[],int) -> a
    double getDerivative(double) -> b
geogebra.common.euclidian.clipping.ClipShape$QFunction -> geogebra.common.c.a.b$e:
    double a -> a
    double b -> b
    double c -> c
    java.lang.String toString() -> toString
    void define(double,double,double) -> a
    double evaluate(double) -> a
    double getDerivative(double) -> b
    int evaluateInverse(double,double[],int) -> a
geogebra.common.euclidian.clipping.DoubleArrayFactory -> geogebra.common.c.a.c:
    geogebra.common.euclidian.clipping.DoubleArrayFactory prototype -> a
    geogebra.common.euclidian.clipping.MutableInteger key -> a
    double[] getArray(int) -> a
    void putArray(double[]) -> a
geogebra.common.euclidian.clipping.MutableInteger -> geogebra.common.c.a.d:
    int value -> a
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    int intValue() -> intValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
geogebra.common.euclidian.draw.DrawAngle -> geogebra.common.c.b.a:
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.kernelND.GeoPointND vertex -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> b
    geogebra.common.kernel.kernelND.GeoPointND point2 -> c
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoLine line2 -> b
    geogebra.common.kernel.geos.GeoVector vector -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    boolean show90degrees -> d
    int angleDrawMode -> d
    geogebra.common.awt.GArc2D drawArc -> a
    geogebra.common.awt.GGeneralPath polygon -> a
    geogebra.common.awt.GEllipse2DDouble dot90degree -> a
    geogebra.common.awt.GShape shape -> c
    double[] m -> a
    double[] coords -> b
    double[] firstVec -> c
    geogebra.common.kernel.geos.GeoPoint tempPoint -> a
    boolean drawDot -> e
    geogebra.common.kernel.geos.GeoPoint[] previewTempPoints -> a
    geogebra.common.awt.GShape shapeArc1 -> d
    geogebra.common.awt.GShape shapeArc2 -> e
    geogebra.common.awt.GArc2D decoArc -> b
    geogebra.common.awt.GLine2D[] tick -> a
    double[] angleTick -> d
    double MAX_TICK_DISTANCE -> a
    geogebra.common.awt.GGeneralPath square -> b
    java.util.ArrayList prevPoints -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos -> a
    void init() -> d
    boolean inView(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInView(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double getRawAngle() -> c
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void updateTick(double,int,int) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void initPreview() -> e
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos() -> a
geogebra.common.euclidian.draw.DrawBarGraph -> geogebra.common.c.b.b:
    int drawType -> d
    int pointType -> e
    boolean isVisible -> b
    boolean labelVisible -> c
    double[] coords -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.algos.AlgoBarChart algo -> a
    geogebra.common.kernel.geos.GeoPoint[] pts -> a
    geogebra.common.euclidian.draw.DrawPoint[] drawPoints -> a
    void init() -> d
    geogebra.common.awt.GRectangle getBounds() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
    void createPts() -> e
geogebra.common.euclidian.draw.DrawBoolean -> geogebra.common.c.b.c:
    geogebra.common.kernel.geos.GeoBoolean geoBool -> a
    boolean isVisible -> b
    java.lang.String oldCaption -> b
    geogebra.common.awt.GPoint textSize -> a
    geogebra.common.euclidian.draw.DrawBoolean$CheckBoxIcon checkBoxIcon -> a
    void update() -> a
    void updateLabel() -> d
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawBoolean$CheckBoxIcon -> geogebra.common.c.b.c$a:
    geogebra.common.euclidian.EuclidianView ev -> a
    geogebra.common.awt.GColor highlightBackground -> a
    void paintIcon(boolean,boolean,geogebra.common.awt.GGraphics2D,int,int) -> a
geogebra.common.euclidian.draw.DrawBoxPlot -> geogebra.common.c.b.d:
    boolean isVisible -> b
    boolean labelVisible -> c
    double[] coords -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.algos.AlgoBoxPlot algo -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    double OUTLIER_SIZE -> a
    void init() -> d
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawButton -> geogebra.common.c.b.e:
    geogebra.common.kernel.geos.GeoButton geoButton -> a
    boolean isVisible -> b
    java.lang.String oldCaption -> b
    geogebra.common.euclidian.MyButton myButton -> a
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void remove() -> b
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawConic -> geogebra.common.c.b.f:
    geogebra.common.kernel.kernelND.GeoConicND conic -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    int type -> d
    double[] labelCoords -> a
    boolean firstPoint -> d
    geogebra.common.kernel.geos.GeoPoint point -> a
    geogebra.common.euclidian.draw.DrawPoint drawPoint -> a
    boolean firstLines -> e
    geogebra.common.kernel.geos.GeoLine[] lines -> a
    geogebra.common.euclidian.draw.DrawLine[] drawLines -> a
    boolean firstCircle -> f
    geogebra.common.kernel.geos.GeoVec2D midpoint -> a
    geogebra.common.awt.GArc2D arc -> a
    geogebra.common.euclidian.GeneralPathClipped arcFiller -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> b
    geogebra.common.awt.GRectangularShape circle -> a
    double mx -> a
    double my -> b
    double radius -> c
    double yradius -> d
    double angSt -> e
    double angEnd -> f
    geogebra.common.awt.GAffineTransform transform -> a
    geogebra.common.awt.GShape shape -> c
    boolean firstEllipse -> g
    double[] halfAxes -> b
    geogebra.common.awt.GEllipse2DDouble ellipse -> a
    boolean firstParabola -> h
    double x0 -> g
    double y0 -> h
    double k2 -> i
    geogebra.common.kernel.geos.GeoVec2D vertex -> b
    geogebra.common.awt.GGeneralPath parabola -> a
    double[] parpoints -> c
    boolean firstHyperbola -> i
    double a -> j
    double b -> k
    double tsq -> l
    double step -> m
    double t -> n
    double denom -> o
    double x -> p
    double y -> q
    int index0 -> e
    int index1 -> f
    int n -> g
    int points -> h
    geogebra.common.euclidian.GeneralPathClipped hypLeft -> c
    geogebra.common.euclidian.GeneralPathClipped hypRight -> d
    boolean hypLeftOnScreen -> j
    boolean hypRightOnScreen -> k
    java.util.ArrayList prevPoints -> a
    java.util.ArrayList prevSegments -> b
    java.util.ArrayList prevConics -> c
    geogebra.common.kernel.geos.GeoPoint[] previewTempPoints -> a
    geogebra.common.kernel.geos.GeoNumeric previewTempRadius -> a
    int previewMode -> i
    int neededPrevPoints -> j
    boolean isPreview -> l
    geogebra.common.awt.GArea getShape() -> a
    void initConic(geogebra.common.kernel.kernelND.GeoConicND) -> a
    void update() -> a
    void updateSinglePoint() -> d
    void updateLines() -> e
    boolean negativeColored() -> h
    void updateCircle() -> f
    void updateEllipse() -> g
    void updateHyperbola() -> h
    void updateParabola() -> i
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void initPreview() -> j
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    geogebra.common.kernel.kernelND.GeoConicND getConic() -> a
geogebra.common.euclidian.draw.DrawConicPart -> geogebra.common.c.b.g:
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.awt.GArc2D arc -> a
    geogebra.common.awt.GShape shape -> c
    double[] halfAxes -> a
    int closure -> d
    int draw_type -> e
    geogebra.common.awt.GAffineTransform transform -> a
    geogebra.common.euclidian.draw.DrawRay drawRay1 -> a
    geogebra.common.euclidian.draw.DrawRay drawRay2 -> b
    geogebra.common.euclidian.draw.DrawSegment drawSegment -> a
    double[] coords -> b
    java.util.ArrayList prevPoints -> a
    geogebra.common.kernel.geos.GeoPoint[] previewTempPoints -> a
    int previewMode -> f
    int neededPrevPoints -> g
    void initConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void update() -> a
    void updateEllipse() -> d
    void updateParallelLines() -> e
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void initPreview() -> f
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawImage -> geogebra.common.c.b.h:
    geogebra.common.kernel.geos.GeoImage geoImage -> a
    boolean isVisible -> b
    geogebra.common.awt.GBufferedImage image -> a
    boolean absoluteLocation -> c
    geogebra.common.awt.GAlphaComposite alphaComp -> a
    float alpha -> a
    boolean isInBackground -> d
    geogebra.common.awt.GAffineTransform at -> a
    geogebra.common.awt.GAffineTransform atInverse -> b
    geogebra.common.awt.GAffineTransform tempAT -> c
    boolean needsInterpolationRenderingHint -> e
    int screenX -> d
    int screenY -> e
    geogebra.common.awt.GRectangle boundingBox -> b
    geogebra.common.awt.GGeneralPath highlighting -> a
    double[] hitCoords -> a
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawHighlighting(geogebra.common.awt.GAffineTransform,geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawImplicitPoly -> geogebra.common.c.b.i:
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    geogebra.common.awt.GArea getShape() -> a
geogebra.common.euclidian.draw.DrawInequality -> geogebra.common.c.b.j:
    boolean isVisible -> c
    boolean labelVisible -> b
    geogebra.common.euclidian.Drawable drawable -> a
    geogebra.common.plugin.Operation operation -> a
    geogebra.common.euclidian.draw.DrawInequality left -> a
    geogebra.common.euclidian.draw.DrawInequality right -> b
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar function -> a
    geogebra.common.euclidian.GeneralPathClipped[] gpAxis -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$Inequality$IneqType -> a
    void update() -> a
    void updateRecursive(geogebra.common.kernel.arithmetic.IneqTree) -> a
    void createDrawable() -> d
    void updateShape() -> e
    void updateTrees(geogebra.common.kernel.arithmetic.IneqTree) -> b
    boolean matchBorder(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.Drawable) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit2(int,int) -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$Inequality$IneqType() -> a
geogebra.common.euclidian.draw.DrawInequality$DrawParametricInequality -> geogebra.common.c.b.j$a:
    geogebra.common.kernel.arithmetic.Inequality paramIneq -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.euclidian.draw.DrawInequality this$0 -> a
    geogebra.common.awt.GArea getShape() -> a
    geogebra.common.kernel.geos.GeoElement getBorder() -> b
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
    boolean isXparametric() -> h
geogebra.common.euclidian.draw.DrawInequality1Var -> geogebra.common.c.b.k:
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.euclidian.GeneralPathClipped[] gp -> a
    geogebra.common.awt.GEllipse2DDouble[] circle -> a
    boolean varIsY -> b
    void draw(geogebra.common.awt.GGraphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
geogebra.common.euclidian.draw.DrawIntegral -> geogebra.common.c.b.l:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    void init() -> d
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawIntegralFunctions -> geogebra.common.c.b.m:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    void init() -> d
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawLine -> geogebra.common.c.b.n:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.awt.GLine2D line -> a
    double y1 -> a
    double y2 -> b
    double x1 -> c
    double x2 -> d
    double k -> e
    double d -> f
    double gx -> g
    double gy -> h
    double gz -> i
    int labelPos -> d
    int p1Pos -> e
    int p2Pos -> f
    int x -> g
    int y -> h
    boolean isVisible -> b
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    java.util.ArrayList lines -> b
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    geogebra.common.kernel.kernelND.GeoPointND previewPoint2 -> b
    boolean[] attr1 -> a
    boolean[] attr2 -> b
    geogebra.common.euclidian.draw.DrawLine$PreviewType previewMode -> a
    geogebra.common.awt.GPoint2D endPoint -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$draw$DrawLine$PreviewType -> a
    void update() -> a
    void setClippedLine() -> d
    void clipTopBottom() -> e
    void clipLeftRight() -> f
    void setLabelPosition() -> g
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GArea getShape() -> a
    geogebra.common.awt.GArea getShape(boolean) -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$draw$DrawLine$PreviewType() -> a
geogebra.common.euclidian.draw.DrawLine$PreviewType -> geogebra.common.c.b.n$a:
    geogebra.common.euclidian.draw.DrawLine$PreviewType NONE -> a
    geogebra.common.euclidian.draw.DrawLine$PreviewType LINE -> b
    geogebra.common.euclidian.draw.DrawLine$PreviewType PARALLEL -> c
    geogebra.common.euclidian.draw.DrawLine$PreviewType PERPENDICULAR -> d
    geogebra.common.euclidian.draw.DrawLine$PreviewType PERPENDICULAR_BISECTOR -> e
    geogebra.common.euclidian.draw.DrawLine$PreviewType ANGLE_BISECTOR -> f
    geogebra.common.euclidian.draw.DrawLine$PreviewType[] ENUM$VALUES -> a
    geogebra.common.euclidian.draw.DrawLine$PreviewType[] values() -> values
    geogebra.common.euclidian.draw.DrawLine$PreviewType valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.draw.DrawList -> geogebra.common.c.b.o:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.euclidian.draw.DrawListArray drawables -> a
    boolean isVisible -> b
    java.lang.String oldCaption -> b
    geogebra.common.javax.swing.AbstractJComboBox comboBox -> a
    geogebra.common.javax.swing.GLabel label -> a
    geogebra.common.javax.swing.GBox box -> a
    void reset() -> e
    void update() -> a
    void remove() -> b
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.awt.GRectangle getBounds() -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void resetDrawType() -> d
geogebra.common.euclidian.draw.DrawList$ActionListener -> geogebra.common.c.b.o$a:
    geogebra.common.euclidian.draw.DrawList this$0 -> a
    void actionPerformed(geogebra.common.euclidian.event.ActionEvent) -> a
geogebra.common.euclidian.draw.DrawListArray -> geogebra.common.c.b.p:
    geogebra.common.euclidian.EuclidianViewInterfaceSlim view -> a
    boolean addToDrawableList(geogebra.common.kernel.geos.GeoElement,int,int,geogebra.common.euclidian.DrawableND) -> a
    void update(geogebra.common.euclidian.DrawableND) -> a
    geogebra.common.euclidian.DrawableND getDrawable(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.draw.DrawLocus -> geogebra.common.c.b.q:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] lastPointCoords -> a
    void update() -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void buildGeneralPath(java.util.ArrayList) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawParametricCurve -> geogebra.common.c.b.r:
    double MAX_BEND -> a
    double MAX_BEND_OFF_SCREEN -> b
    geogebra.common.kernel.geos.ParametricCurve curve -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    boolean fillCurve -> d
    int countPoints -> d
    long countEvaluations -> a
    java.lang.StringBuilder labelSB -> a
    void update() -> a
    geogebra.common.awt.GPoint plotCurve(geogebra.common.kernel.geos.ParametricCurve,double,double,geogebra.common.euclidian.EuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.draw.DrawParametricCurve$Gap) -> a
    boolean isUndefined(double) -> a
    boolean isUndefined(double[]) -> a
    geogebra.common.awt.GPoint plotInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,int,double,geogebra.common.euclidian.EuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.draw.DrawParametricCurve$Gap) -> a
    void corner(geogebra.common.euclidian.GeneralPathClipped,double,double,geogebra.common.euclidian.EuclidianView) -> a
    boolean isContinuous(geogebra.common.kernel.geos.ParametricCurve,double,double,int) -> a
    boolean isDefinedAround(geogebra.common.kernel.geos.ParametricCurve,double,double) -> a
    boolean isDistanceOK(double,double) -> a
    boolean isSegmentOffScreen(geogebra.common.euclidian.EuclidianView,double,double,double,double) -> a
    boolean isAngleOK(double,double,double,double,double) -> a
    geogebra.common.awt.GPoint plotProblemInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,int,double,geogebra.common.euclidian.EuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.draw.DrawParametricCurve$Gap,geogebra.common.awt.GPoint) -> a
    boolean getDefinedInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,double[]) -> a
    void moveTo(geogebra.common.euclidian.GeneralPathClipped,double,double) -> a
    void lineTo(geogebra.common.euclidian.GeneralPathClipped,double,double) -> b
    void drawTo(geogebra.common.euclidian.GeneralPathClipped,double,double,boolean) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    boolean filling(geogebra.common.kernel.geos.ParametricCurve) -> a
geogebra.common.euclidian.draw.DrawParametricCurve$Gap -> geogebra.common.c.b.r$a:
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap LINE_TO -> a
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap MOVE_TO -> b
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap RESET_XMIN -> c
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap RESET_YMIN -> d
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap RESET_XMAX -> e
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap RESET_YMAX -> f
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap CORNER -> g
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap[] ENUM$VALUES -> a
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap[] values() -> values
    geogebra.common.euclidian.draw.DrawParametricCurve$Gap valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.draw.DrawPoint -> geogebra.common.c.b.s:
    int HIGHLIGHT_OFFSET -> d
    int SELECTION_OFFSET -> e
    int SELECTION_DIAMETER_MIN -> f
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    int diameter -> g
    int hightlightDiameter -> h
    int selDiameter -> i
    int pointSize -> j
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.awt.GEllipse2DDouble circle -> a
    geogebra.common.awt.GEllipse2DDouble circleHighlight -> b
    geogebra.common.awt.GEllipse2DDouble circleSel -> c
    geogebra.common.awt.GLine2D line1 -> a
    geogebra.common.awt.GLine2D line2 -> b
    geogebra.common.awt.GLine2D line3 -> c
    geogebra.common.awt.GLine2D line4 -> d
    geogebra.common.awt.GGeneralPath gp -> a
    geogebra.common.awt.GBasicStroke borderStroke -> d
    geogebra.common.awt.GBasicStroke[] fillStrokes -> a
    geogebra.common.awt.GBasicStroke[] emptyStrokes -> b
    boolean isPreview -> d
    geogebra.common.euclidian.Drawable drawable -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void update() -> a
    void drawClippedSection(geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GBasicStroke getEmptyStroke(int) -> a
    geogebra.common.awt.GBasicStroke getFillStroke(int) -> b
    int getSelectionDiamaterMin() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.euclidian.draw.DrawPolyLine -> geogebra.common.c.b.t:
    geogebra.common.kernel.geos.GeoPolyLine poly -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    java.util.ArrayList points -> a
    geogebra.common.awt.GPoint2D endPoint -> a
    void update() -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void addPointsToPath(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawPolygon -> geogebra.common.c.b.u:
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    java.util.ArrayList points -> a
    geogebra.common.awt.GPoint2D endPoint -> a
    void update() -> a
    boolean addPointsToPath(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    geogebra.common.awt.GArea getShape() -> a
geogebra.common.euclidian.draw.DrawRay -> geogebra.common.c.b.v:
    geogebra.common.kernel.kernelND.GeoLineND ray -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    geogebra.common.awt.GLine2D line -> a
    double[] a -> a
    double[] v -> b
    geogebra.common.awt.GPoint2D endPoint -> a
    void update() -> a
    void update(boolean) -> c
    void setClippedLine() -> d
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void setStroke(geogebra.common.awt.GBasicStroke) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
geogebra.common.euclidian.draw.DrawSegment -> geogebra.common.c.b.w:
    geogebra.common.kernel.kernelND.GeoLineND s -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    geogebra.common.awt.GLine2D line -> a
    double[] coordsA -> a
    double[] coordsB -> b
    geogebra.common.awt.GLine2D[] decoTicks -> a
    geogebra.common.awt.GPoint2D endPoint -> a
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawSlider -> geogebra.common.c.b.x:
    geogebra.common.kernel.geos.GeoNumeric number -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    double[] coordsRW -> a
    double[] coordsScreen -> b
    geogebra.common.awt.GLine2D line -> a
    geogebra.common.kernel.geos.GeoPoint geoPoint -> a
    geogebra.common.euclidian.draw.DrawPoint drawPoint -> a
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean hitPoint(int,int) -> c
    boolean hitLabel(int,int) -> b
    boolean hitSlider(int,int) -> d
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
geogebra.common.euclidian.draw.DrawSlope -> geogebra.common.c.b.y:
    geogebra.common.kernel.geos.GeoNumeric slope -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    int xLabelHor -> d
    int yLabelHor -> e
    java.lang.String horLabel -> b
    double[] coords -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.kernel.Kernel kernel -> a
    void init() -> d
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawText -> geogebra.common.c.b.z:
    geogebra.common.kernel.geos.GeoText text -> a
    boolean isVisible -> b
    boolean isLaTeX -> c
    int fontSize -> d
    int fontStyle -> e
    boolean serifFont -> d
    geogebra.common.awt.GFont textFont -> a
    geogebra.common.kernel.kernelND.GeoPointND loc -> a
    int oldXpos -> f
    int oldYpos -> g
    boolean needsBoundingBoxOld -> e
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean doUpdateFontSize() -> h
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawTextField -> geogebra.common.c.b.A:
    geogebra.common.kernel.geos.GeoTextField geoTextField -> a
    boolean isVisible -> b
    java.lang.String oldCaption -> b
    geogebra.common.gui.inputfield.AutoCompleteTextField textField -> a
    geogebra.common.javax.swing.GLabel label -> a
    geogebra.common.euclidian.draw.DrawTextField$InputFieldListener ifListener -> a
    geogebra.common.euclidian.draw.DrawTextField$InputFieldKeyListener ifKeyListener -> a
    geogebra.common.javax.swing.GBox box -> a
    int oldLength -> d
    void update() -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void remove() -> b
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void setFocus(java.lang.String) -> a
    geogebra.common.euclidian.EuclidianView access$0(geogebra.common.euclidian.draw.DrawTextField) -> a
    geogebra.common.kernel.geos.GeoElement access$1(geogebra.common.euclidian.draw.DrawTextField) -> a
geogebra.common.euclidian.draw.DrawTextField$InputFieldKeyListener -> geogebra.common.c.b.A$a:
    geogebra.common.euclidian.draw.DrawTextField this$0 -> a
    void keyReleased(geogebra.common.euclidian.event.KeyEvent) -> a
geogebra.common.euclidian.draw.DrawTextField$InputFieldListener -> geogebra.common.c.b.A$b:
    geogebra.common.euclidian.draw.DrawTextField this$0 -> a
    void focusGained(geogebra.common.euclidian.event.FocusEvent) -> a
    void focusLost(geogebra.common.euclidian.event.FocusEvent) -> b
geogebra.common.euclidian.draw.DrawUpperLowerSum -> geogebra.common.c.b.B:
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    boolean isVisible -> b
    boolean labelVisible -> c
    geogebra.common.kernel.algos.AlgoFunctionAreaSums algo -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    boolean trapeziums -> d
    boolean histogram -> e
    boolean barchartFreqs -> f
    boolean barchartFreqsWidth -> g
    void init() -> d
    void update() -> a
    void updateBarChart() -> e
    void draw(geogebra.common.awt.GGraphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.draw.DrawVector -> geogebra.common.c.b.C:
    geogebra.common.kernel.kernelND.GeoVectorND v -> a
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    boolean isVisible -> b
    boolean labelVisible -> c
    boolean traceDrawingNeeded -> d
    geogebra.common.awt.GLine2D line -> a
    double[] coordsA -> a
    double[] coordsB -> b
    double[] coordsV -> c
    geogebra.common.awt.GGeneralPath gp -> a
    boolean arrowheadVisible -> e
    boolean lineVisible -> f
    java.util.ArrayList points -> a
    geogebra.common.awt.GPoint2D endPoint -> a
    void update() -> a
    void setArrow(float) -> a
    void draw(geogebra.common.awt.GGraphics2D) -> a
    void drawTrace(geogebra.common.awt.GGraphics2D) -> d
    void updatePreview() -> a_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.GGraphics2D) -> a_
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.GRectangle) -> a
    boolean intersectsRectangle(geogebra.common.awt.GRectangle) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.GRectangle getBounds() -> a
geogebra.common.euclidian.event.AbstractEvent -> geogebra.common.c.c.a:
    geogebra.common.awt.GPoint getPoint() -> a
    boolean isAltDown() -> a
    boolean isShiftDown() -> b
    void release() -> a
    int getX() -> a
    int getY() -> b
    boolean isRightClick() -> c
    boolean isControlDown() -> d
    int getClickCount() -> c
    boolean isMetaDown() -> e
    double getWheelRotation() -> a
    boolean isMiddleClick() -> f
    boolean isPopupTrigger() -> g
geogebra.common.euclidian.event.ActionEvent -> geogebra.common.c.c.b:
geogebra.common.euclidian.event.ActionListener -> geogebra.common.c.c.c:
    geogebra.common.euclidian.event.ActionListenerI listenerClass -> a
    void wrapActionPerformed(geogebra.common.euclidian.event.ActionEvent) -> b
    void setListenerClass(geogebra.common.euclidian.event.ActionListenerI) -> a
geogebra.common.euclidian.event.ActionListenerI -> geogebra.common.c.c.d:
    void actionPerformed(geogebra.common.euclidian.event.ActionEvent) -> a
geogebra.common.euclidian.event.FocusEvent -> geogebra.common.c.c.e:
geogebra.common.euclidian.event.FocusListener -> geogebra.common.c.c.f:
    java.lang.Object listenerClass -> a
    void wrapFocusGained(geogebra.common.euclidian.event.FocusEvent) -> c
    void wrapFocusLost(geogebra.common.euclidian.event.FocusEvent) -> d
    void setListenerClass(java.lang.Object) -> a
geogebra.common.euclidian.event.KeyEvent -> geogebra.common.c.c.g:
    char getKeyChar() -> a
geogebra.common.euclidian.event.KeyListener -> geogebra.common.c.c.h:
    java.lang.Object listenerClass -> a
    void setListenerClass(java.lang.Object) -> a
    void wrapKeyReleased(geogebra.common.euclidian.event.KeyEvent) -> b
geogebra.common.export.GeoGebraTubeExport -> geogebra.common.d.a:
    geogebra.common.main.App app -> a
    java.util.ArrayList macros -> a
    java.lang.String getBase64String() -> a
    java.lang.String getBase64Tools(java.util.ArrayList) -> a
    java.lang.StringBuffer getPostData() -> a
    java.lang.String encode(java.lang.String) -> a
geogebra.common.export.GeoGebraTubeExport$UploadResults -> geogebra.common.d.a$a:
    java.lang.String status -> a
    java.lang.String uid -> b
    java.lang.String errorMessage -> c
    geogebra.common.export.GeoGebraTubeExport this$0 -> a
    boolean HasError() -> a
    java.lang.String getUID() -> a
geogebra.common.factories.AwtFactory -> geogebra.common.e.a:
    geogebra.common.factories.AwtFactory prototype -> a
    geogebra.common.awt.GColor newColor(int) -> a
    geogebra.common.awt.GColor newColor(int,int,int) -> a
    geogebra.common.awt.GColor newColor(int,int,int,int) -> a
    geogebra.common.awt.GColor newColor(float,float,float,float) -> a
    geogebra.common.awt.GColor newColor(float,float,float) -> a
    geogebra.common.awt.GAffineTransform newAffineTransform() -> a
    geogebra.common.awt.GRectangle2D newRectangle2D() -> a
    geogebra.common.awt.GRectangle newRectangle(int,int,int,int) -> a
    geogebra.common.awt.GBufferedImage newBufferedImage(int,int,int) -> a
    geogebra.common.awt.GDimension newDimension(int,int) -> a
    geogebra.common.awt.GPoint2D newPoint2D() -> a
    geogebra.common.awt.GRectangle newRectangle(int,int) -> a
    geogebra.common.awt.GRectangle newRectangle() -> a
    geogebra.common.awt.GPoint2D newPoint2D(double,double) -> a
    geogebra.common.awt.GGeneralPath newGeneralPath() -> a
    geogebra.common.awt.GBasicStroke newMyBasicStroke(float) -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float,int,int) -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float,int,int,float,float[],float) -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float) -> b
    geogebra.common.awt.GLine2D newLine2D() -> a
    geogebra.common.awt.GRectangle newRectangle(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GEllipse2DDouble newEllipse2DDouble() -> a
    geogebra.common.awt.GEllipse2DFloat newEllipse2DFloat(int,int,int,int) -> a
    geogebra.common.awt.GArc2D newArc2D() -> a
    geogebra.common.awt.GArea newArea() -> a
    geogebra.common.awt.GArea newArea(geogebra.common.awt.GShape) -> a
    geogebra.common.awt.GGeneralPath newGeneralPath(int) -> a
    geogebra.common.awt.GCubicCurve2D newCubicCurve2D() -> a
    geogebra.common.awt.font.GTextLayout newTextLayout(java.lang.String,geogebra.common.awt.GFont,geogebra.common.awt.GFontRenderContext) -> a
    geogebra.common.awt.GAlphaComposite newAlphaComposite(int,float) -> a
    geogebra.common.awt.GBasicStroke newBasicStrokeJoinMitre(float) -> c
    geogebra.common.awt.GGradientPaint newGradientPaint(int,int,geogebra.common.awt.GColor,int,int,geogebra.common.awt.GColor) -> a
    geogebra.common.euclidian.event.FocusListener newFocusListener(java.lang.Object) -> a
    geogebra.common.euclidian.event.ActionListener newActionListener(geogebra.common.euclidian.event.ActionListenerI) -> a
    geogebra.common.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
geogebra.common.factories.CASFactory -> geogebra.common.e.b:
    geogebra.common.factories.CASFactory prototype -> a
    geogebra.common.factories.CASFactory getPrototype() -> a
    void setPrototype(geogebra.common.factories.CASFactory) -> a
    geogebra.common.cas.mpreduce.CASmpreduce newMPReduce(geogebra.common.cas.CASparser,geogebra.common.cas.CasParserTools,geogebra.common.kernel.Kernel) -> a
geogebra.common.factories.Factory -> geogebra.common.e.c:
    geogebra.common.factories.Factory prototype -> a
    geogebra.common.gui.menubar.RadioButtonMenuBar newRadioButtonMenuBar(geogebra.common.main.App) -> a
    geogebra.common.javax.swing.GOptionPane newGOptionPane() -> a
    geogebra.common.gui.dialog.TextInputDialog newTextInputDialog(geogebra.common.main.App,java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND,int,int,boolean) -> a
    geogebra.common.main.InfoBar newInfoBar(geogebra.common.main.App) -> a
    geogebra.common.factories.Factory getPrototype() -> a
    void setPrototype(geogebra.common.factories.Factory) -> a
geogebra.common.factories.FormatFactory -> geogebra.common.e.d:
    geogebra.common.factories.FormatFactory prototype -> a
    geogebra.common.util.ScientificFormatAdapter getScientificFormat(int,int,boolean) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(int) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(java.lang.String,int) -> a
geogebra.common.factories.LaTeXFactory -> geogebra.common.e.e:
    geogebra.common.factories.LaTeXFactory prototype -> a
    geogebra.common.util.LaTeXCache newLaTeXCache() -> a
geogebra.common.factories.SwingFactory -> geogebra.common.e.f:
    geogebra.common.factories.SwingFactory prototype -> a
    geogebra.common.gui.inputfield.AutoCompleteTextField newAutoCompleteTextField(int,geogebra.common.main.App,geogebra.common.euclidian.Drawable) -> a
    geogebra.common.javax.swing.GLabel newJLabel(java.lang.String) -> a
    geogebra.common.javax.swing.AbstractJComboBox newJComboBox() -> a
    geogebra.common.javax.swing.GBox createHorizontalBox() -> a
    geogebra.common.factories.SwingFactory getPrototype() -> a
    void setPrototype(geogebra.common.factories.SwingFactory) -> a
geogebra.common.factories.UtilFactory -> geogebra.common.e.g:
    geogebra.common.factories.UtilFactory prototype -> a
    geogebra.common.util.HttpRequest newHttpRequest() -> a
geogebra.common.gui.ContextMenuGeoElement -> geogebra.common.f.a:
    double[] zoomFactors -> a
    double[] axesRatios -> b
    java.util.ArrayList geos -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.main.App app -> a
    boolean justOneGeo -> a
    java.lang.String getDescription(geogebra.common.kernel.geos.GeoElement) -> a
    void cartesianCoordsCmd() -> a
    void polarCoorsCmd() -> b
    void equationImplicitEquationCmd() -> c
    void equationExplicitEquationCmd() -> d
    void parametricFormCmd() -> e
    void cartesianCoordsForVectorItemsCmd() -> f
    void polarCoordsForVectorItemsCmd() -> g
    void implicitConicEquationCmd() -> h
    void equationConicEqnCmd() -> i
    void equationExplicitConicEquationCmd() -> j
    void extendedFormCmd(geogebra.common.kernel.geos.GeoUserInputElement) -> a
    void deleteCmd() -> k
    java.util.ArrayList checkOneGeo() -> a
    void editCmd() -> l
    void renameCmd() -> m
    void fixObjectNumericCmd(geogebra.common.kernel.geos.GeoNumeric) -> a
    void fixObjectCmd() -> n
    void showLabelCmd() -> o
    void showObjectCmd() -> p
    void showObjectAuxiliaryCmd() -> q
    void openPropertiesDialogCmd() -> r
    void inputFormCmd(geogebra.common.kernel.geos.GeoUserInputElement) -> b
    void traceCmd() -> s
    void animationCmd() -> t
    void pinCmd(boolean) -> a
    void geoActionCmd(geogebra.common.kernel.geos.GeoElement,java.util.ArrayList,java.util.ArrayList,geogebra.common.euclidian.EuclidianView,geogebra.common.awt.GPoint) -> a
geogebra.common.gui.GuiManager -> geogebra.common.f.b:
    java.lang.String strCustomToolbarDefinition -> a
    geogebra.common.main.App app -> a
    void updateMenubar() -> a
    void updateMenubarSelection() -> b
    geogebra.common.main.DialogManager getDialogManager() -> a
    void showPopupMenu(java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    void showPopupChooseGeo(java.util.ArrayList,java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void redo() -> c
    void undo() -> d
    void setFocusedPanel(geogebra.common.euclidian.event.AbstractEvent,boolean) -> a
    void loadImage(geogebra.common.kernel.geos.GeoPoint,java.lang.Object,boolean) -> a
    boolean hasAlgebraView() -> a
    void updateFonts() -> e
    boolean isUsingConstructionProtocol() -> b
    void getConsProtocolXML(java.lang.StringBuilder) -> a
    boolean isInputFieldSelectionListener() -> c
    geogebra.common.javax.swing.GTextComponent getAlgebraInputTextField() -> a
    void showDrawingPadPopup(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    boolean hasSpreadsheetView() -> d
    void attachSpreadsheetView() -> f
    void setShowView(boolean,int) -> a
    void setShowView(boolean,int,boolean) -> a
    boolean showView(int) -> a
    geogebra.common.kernel.View getConstructionProtocolData() -> a
    geogebra.common.kernel.View getCasView() -> b
    geogebra.common.kernel.View getSpreadsheetView() -> c
    geogebra.common.kernel.View getProbabilityCalculator() -> d
    geogebra.common.kernel.View getDataAnalysisView() -> e
    geogebra.common.kernel.View getPlotPanelView(int) -> a
    geogebra.common.kernel.View getPropertiesView() -> f
    boolean hasProbabilityCalculator() -> e
    void getProbabilityCalculatorXML(java.lang.StringBuilder) -> b
    void getSpreadsheetViewXML(java.lang.StringBuilder,boolean) -> a
    void updateActions() -> g
    void updateSpreadsheetColumnWidths() -> h
    void updateConstructionProtocol() -> i
    void updateAlgebraInput() -> j
    void setShowAuxiliaryObjects(boolean) -> a
    void mousePressedForPropertiesView() -> k
    void mouseReleasedForPropertiesView(boolean) -> b
    boolean save() -> f
    boolean loadURL(java.lang.String) -> a
    void setToolBarDefinition(java.lang.String) -> a
    boolean loadURL(java.lang.String,boolean) -> a
    boolean loadURL_GGB(java.lang.String) -> b
    boolean loadURL_base64(java.lang.String) -> c
    boolean loadFromApplet(java.lang.String) -> d
    void updateGUIafterLoadFile(boolean,boolean) -> a
    void startEditing(geogebra.common.kernel.geos.GeoElement) -> a
    boolean noMenusOpen() -> g
    void openFile() -> l
    geogebra.common.gui.Layout getLayout() -> a
    void showGraphicExport() -> m
    void showPSTricksExport() -> n
    void showWebpageExport() -> o
    void detachPropertiesView() -> p
    void attachPropertiesView() -> q
    void attachAlgebraView() -> r
    void attachCasView() -> s
    void attachConstructionProtocolView() -> t
    void attachProbabilityCalculatorView() -> u
    void attachDataAnalysisView() -> v
    void detachDataAnalysisView() -> w
    void attachView(int) -> a
    geogebra.common.euclidian.EuclidianView getActiveEuclidianView() -> a
    void showAxesCmd() -> x
    void showGridCmd() -> y
    void doAfterRedefine(geogebra.common.kernel.geos.GeoElement) -> b
    void detachView(int) -> b
    void detachProbabilityCalculatorView() -> z
    void detachCasView() -> A
    void detachConstructionProtocolView() -> B
    void detachSpreadsheetView() -> C
    void detachAlgebraView() -> D
    void openCommandHelp(java.lang.String) -> b
    void openHelp(java.lang.String,geogebra.common.gui.GuiManager$Help) -> a
    void openHelp(java.lang.String) -> c
    void setLayout(geogebra.common.gui.Layout) -> a
    void initialize() -> E
    void resetSpreadsheet() -> F
    void setScrollToShow(boolean) -> c
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    void showURLinBrowser(java.lang.String) -> d
    void updateMenuWindow() -> G
    void updateMenuFile() -> H
    void exitAll() -> I
    boolean saveCurrentFile() -> h
    void updateToolbar() -> J
    boolean hasEuclidianView2() -> i
    void allowGUIToRefresh() -> K
    void updateFrameTitle() -> L
    void setLabels() -> M
    void setShowToolBarHelp(boolean) -> d
    void setShowConstructionProtocolNavigation(boolean) -> e
    geogebra.common.kernel.View getEuclidianView2() -> g
    boolean hasEuclidianView2EitherShowingOrNot() -> j
    geogebra.common.kernel.View getAlgebraView() -> h
    void applyAlgebraViewSettings() -> N
    void clearInputbar() -> O
    java.lang.Object createFrame() -> a
    java.lang.Object getInputHelpPanel() -> b
    int getInputHelpPanelMinimumWidth() -> a
    int getActiveToolbarId() -> b
    void getAlgebraViewXML(java.lang.StringBuilder,boolean) -> b
    boolean hasAlgebraViewShowing() -> k
geogebra.common.gui.GuiManager$Help -> geogebra.common.f.b$a:
    geogebra.common.gui.GuiManager$Help COMMAND -> a
    geogebra.common.gui.GuiManager$Help TOOL -> b
    geogebra.common.gui.GuiManager$Help GENERIC -> c
    geogebra.common.gui.GuiManager$Help[] ENUM$VALUES -> a
    geogebra.common.gui.GuiManager$Help[] values() -> values
    geogebra.common.gui.GuiManager$Help valueOf(java.lang.String) -> valueOf
geogebra.common.gui.InputHandler -> geogebra.common.f.c:
    boolean processInput(java.lang.String) -> a
geogebra.common.gui.Layout -> geogebra.common.f.d:
    java.util.ArrayList perspectives -> a
    geogebra.common.main.settings.LayoutSettings settings -> a
    geogebra.common.io.layout.Perspective[] defaultPerspectives -> a
    void initializeDefaultPerspectives(boolean,boolean) -> a
    void setPerspectives(java.util.ArrayList) -> a
    void applyPerspective(geogebra.common.io.layout.Perspective) -> a
    void getXml(java.lang.StringBuilder,boolean) -> a
    boolean isOnlyVisible(int) -> a
    void applyPerspective(java.lang.String) -> a
geogebra.common.gui.SetLabels -> geogebra.common.f.e:
    void setLabels() -> a
geogebra.common.gui.VirtualKeyboardListener -> geogebra.common.f.f:
    void insertString(java.lang.String) -> a
geogebra.common.gui.dialog.InputDialog -> geogebra.common.f.a.a:
    java.lang.String initString -> a
    geogebra.common.gui.InputHandler inputHandler -> a
    java.lang.String inputText -> b
    java.util.ArrayList tempArrayList -> a
    boolean processInputHandler() -> a
geogebra.common.gui.dialog.TextInputDialog -> geogebra.common.f.a.b:
    void reInitEditor(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setVisible(boolean) -> a
geogebra.common.gui.dialog.handler.NumberInputHandler -> geogebra.common.f.a.a.a:
    geogebra.common.kernel.commands.AlgebraProcessor algebraProcessor -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    boolean processInput(java.lang.String) -> a
    void setNum(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.NumberValue getNum() -> a
geogebra.common.gui.dialog.handler.RedefineInputHandler -> geogebra.common.f.a.a.b:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.main.App app -> a
    java.lang.String oldString -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean processInput(java.lang.String) -> a
geogebra.common.gui.dialog.handler.RenameInputHandler -> geogebra.common.f.a.a.c:
    geogebra.common.kernel.geos.GeoElement geo -> a
    boolean storeUndo -> a
    geogebra.common.main.App app -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean processInput(java.lang.String) -> a
geogebra.common.gui.dialog.options.OptionsAdvanced -> geogebra.common.f.a.b.a:
geogebra.common.gui.dialog.options.OptionsCAS -> geogebra.common.f.a.b.b:
geogebra.common.gui.dialog.options.OptionsDefaults -> geogebra.common.f.a.b.c:
geogebra.common.gui.dialog.options.OptionsEuclidian -> geogebra.common.f.a.b.d:
    void updateBounds() -> b
geogebra.common.gui.dialog.options.OptionsLayout -> geogebra.common.f.a.b.e:
geogebra.common.gui.dialog.options.OptionsObject -> geogebra.common.f.a.b.f:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.geos.GeoElement geoAdded -> a
    boolean firstTime -> a
    java.util.ArrayList selection -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.main.App app -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void forgetGeoAdded() -> b
    geogebra.common.kernel.geos.GeoElement consumeGeoAdded() -> a
    java.lang.String getSelectionDescription() -> a
geogebra.common.gui.dialog.options.OptionsSpreadsheet -> geogebra.common.f.a.b.g:
geogebra.common.gui.inputfield.AltKeys -> geogebra.common.f.b.a:
    java.util.HashMap LookupLower -> a
    java.util.HashMap LookupUpper -> b
geogebra.common.gui.inputfield.AutoCompleteTextField -> geogebra.common.f.b.b:
    void showPopupSymbolButton(boolean) -> a
    void setAutoComplete(boolean) -> b
    void enableColoring(boolean) -> c
    void setOpaque(boolean) -> setOpaque
    void setFont(geogebra.common.awt.GFont) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
    void setFocusable(boolean) -> setFocusable
    void setEditable(boolean) -> setEditable
    void requestFocus() -> requestFocus
    void setVisible(boolean) -> setVisible
    void setColumns(int) -> setColumns
    void addFocusListener(geogebra.common.euclidian.event.FocusListener) -> a
    void addKeyListener(geogebra.common.euclidian.event.KeyListener) -> a
    int getCaretPosition() -> getCaretPosition
    void setCaretPosition(int) -> setCaretPosition
    void setFocusTraversalKeysEnabled(boolean) -> setFocusTraversalKeysEnabled
    void setUsedForInputBox(geogebra.common.kernel.geos.GeoTextField) -> a
    boolean hasFocus() -> hasFocus
    boolean usedForInputBox() -> a
geogebra.common.gui.inputfield.MyTextField -> geogebra.common.f.b.c:
    int[] getBracketPositions(java.lang.String,int) -> a
    boolean isCloseBracketOrWhitespace(char) -> a
    boolean isWhiteSpace(char) -> b
geogebra.common.gui.layout.DockComponent -> geogebra.common.f.c.a:
    boolean updateResizeWeight() -> a
    void saveDividerLocation() -> a
    void updateDividerLocation(int,int) -> a
    void setDockPanelsVisible(boolean) -> a
geogebra.common.gui.layout.DockPanel -> geogebra.common.f.c.b:
    java.lang.String getToolbarString() -> a
    java.lang.String getDefaultToolbarString() -> b
    int getViewId() -> a
geogebra.common.gui.menubar.MenuInterface -> geogebra.common.f.d.a:
geogebra.common.gui.menubar.MyActionListener -> geogebra.common.f.d.b:
    void actionPerformed(java.lang.String) -> a
geogebra.common.gui.menubar.OptionsMenu -> geogebra.common.f.d.c:
    geogebra.common.gui.menubar.RadioButtonMenuBar menuAlgebraStyle -> a
    geogebra.common.gui.menubar.RadioButtonMenuBar menuDecimalPlaces -> b
    geogebra.common.gui.menubar.RadioButtonMenuBar menuLabeling -> c
    geogebra.common.gui.menubar.RadioButtonMenuBar menuPointCapturing -> d
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernel -> a
    int[] capturingMenuOrder -> a
    void processActionPerformed(java.lang.String) -> a
    void addAlgebraDescriptionMenu(geogebra.common.gui.menubar.MenuInterface) -> a
    void updateMenuViewDescription() -> a
    void updateMenuDecimalPlaces() -> b
    void addDecimalPlacesMenu(geogebra.common.gui.menubar.MenuInterface) -> b
    void addLabelingMenu(geogebra.common.gui.menubar.MenuInterface) -> c
    void updateMenuLabeling() -> e
    void addPointCapturingMenu(geogebra.common.gui.menubar.MenuInterface) -> d
    void updateMenuPointCapturing() -> c
    void addFontSizeMenu(geogebra.common.gui.menubar.MenuInterface) -> e
    void update() -> d
geogebra.common.gui.menubar.OptionsMenu$1 -> geogebra.common.f.d.d:
    geogebra.common.gui.menubar.OptionsMenu this$0 -> a
    void actionPerformed(java.lang.String) -> a
geogebra.common.gui.menubar.RadioButtonMenuBar -> geogebra.common.f.d.e:
    void addRadioButtonMenuItems(geogebra.common.gui.menubar.MyActionListener,java.lang.String[],java.lang.String[],int,boolean) -> a
    void setSelected(int) -> a
    int getItemCount() -> getItemCount
geogebra.common.gui.toolbar.ToolBar -> geogebra.common.f.e.a:
    java.lang.Integer SEPARATOR -> a
    java.lang.String getAllToolsNoMacros(boolean,boolean) -> a
    java.util.Vector parseToolbarString(java.lang.String) -> a
geogebra.common.gui.toolbar.ToolbarItem -> geogebra.common.f.e.b:
    java.util.Vector menu -> a
    java.lang.Integer mode -> a
    java.util.Vector getMenu() -> a
    java.lang.Integer getMode() -> a
geogebra.common.gui.util.TableSymbols -> geogebra.common.f.f.a:
    java.lang.String[] functions -> A
    java.lang.String[] greekLowerCase -> a
    java.lang.String[] greekUpperCaseFull -> b
    java.lang.String[] analysis -> c
    java.lang.String[] logical -> d
    java.lang.String[] sets -> e
    java.lang.String[] operators -> f
    java.lang.String[] sub_superscripts -> g
    java.lang.String[] basic_arrows -> h
    java.lang.String[] otherArrows -> i
    java.lang.String[] geometricShapes -> j
    java.lang.String[] games_music -> k
    java.lang.String[] handPointers -> l
    java.lang.String[] UNICODEotherarrows -> m
    java.lang.String[] UNICODEmisc -> n
    java.lang.String[] UNICODEweather_astrology -> o
    java.lang.String[] UNICODEgames_music -> p
    java.lang.String[] UNICODEwriting -> q
    java.lang.String[] UNICODEbullets -> r
    java.lang.String[] otherdingbats -> s
    java.lang.String[] UNICODEgeometricShapes -> t
    java.lang.String[] letterLikeSymbols -> u
    java.lang.String[] currency -> v
    java.lang.String[] JLatex -> w
    java.lang.String[] displayChars -> x
    java.lang.String[] specialChars -> y
    java.lang.String[] symbols -> z
    java.lang.String[][] basicSymbolsMap(geogebra.common.main.App) -> a
    java.lang.String[] basicSymbols(geogebra.common.main.App) -> a
    java.lang.String[] basicSymbolsToolTips(geogebra.common.main.App) -> b
    java.lang.String[] getTranslatedFunctions(geogebra.common.main.App) -> c
    java.lang.String[] greekLettersPlusVariants() -> a
geogebra.common.gui.view.algebra.AlgebraController -> geogebra.common.f.g.a.a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    geogebra.common.gui.view.algebra.AlgebraView view -> a
    geogebra.common.kernel.geos.GeoElement lastSelectedGeo -> a
    boolean skipSelection -> a
    geogebra.common.main.App getApplication() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.gui.view.algebra.AlgebraView -> geogebra.common.f.g.a.b:
    boolean isVisible() -> isVisible
    void startEditing(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void cancelEditing() -> cancelEditing
    boolean isEditing() -> isEditing
geogebra.common.gui.view.algebra.AlgebraView$SortMode -> geogebra.common.f.g.a.b$a:
    geogebra.common.gui.view.algebra.AlgebraView$SortMode DEPENDENCY -> a
    geogebra.common.gui.view.algebra.AlgebraView$SortMode TYPE -> b
    geogebra.common.gui.view.algebra.AlgebraView$SortMode VIEW -> c
    geogebra.common.gui.view.algebra.AlgebraView$SortMode ORDER -> d
    geogebra.common.gui.view.algebra.AlgebraView$SortMode LAYER -> e
    geogebra.common.gui.view.algebra.AlgebraView$SortMode[] ENUM$VALUES -> a
    geogebra.common.gui.view.algebra.AlgebraView$SortMode[] values() -> values
    geogebra.common.gui.view.algebra.AlgebraView$SortMode valueOf(java.lang.String) -> valueOf
geogebra.common.gui.view.algebra.DialogType -> geogebra.common.f.g.a.c:
    geogebra.common.gui.view.algebra.DialogType TextArea -> a
    geogebra.common.gui.view.algebra.DialogType DynamicText -> b
    geogebra.common.gui.view.algebra.DialogType GeoGebraEditor -> c
    geogebra.common.gui.view.algebra.DialogType[] ENUM$VALUES -> a
    geogebra.common.gui.view.algebra.DialogType[] values() -> values
    geogebra.common.gui.view.algebra.DialogType valueOf(java.lang.String) -> valueOf
geogebra.common.gui.view.properties.PropertiesStyleBar -> geogebra.common.f.g.b.a:
geogebra.common.gui.view.properties.PropertiesView -> geogebra.common.f.g.b.b:
    java.util.HashMap viewMap -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean attached -> a
    geogebra.common.main.App app -> a
    geogebra.common.main.OptionType selectedOptionType -> a
    geogebra.common.gui.dialog.options.OptionsObject objectPanel -> a
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType -> a
    void updateSelection() -> a
    void setOptionPanel(geogebra.common.main.OptionType) -> a
    java.lang.String getTypeString(geogebra.common.main.OptionType) -> a
    java.lang.String getTypeStringSimple(geogebra.common.main.App,geogebra.common.main.OptionType) -> a
    geogebra.common.main.OptionType getSelectedOptionType() -> a
    boolean isOptionPanelAvailable(geogebra.common.main.App,geogebra.common.main.OptionType) -> a
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType() -> a
geogebra.common.gui.view.spreadsheet.CellFormat -> geogebra.common.f.g.c.a:
    geogebra.common.gui.view.spreadsheet.MyTable table -> a
    geogebra.common.gui.view.spreadsheet.CellFormat$MyHashMap[] formatMapArray -> a
    int formatCount -> a
    java.util.HashMap formatTokenMap -> a
    void clearAll() -> a
    java.util.HashMap getFormatMap(int) -> a
    java.lang.Object getCellFormat(geogebra.common.awt.GPoint,int) -> a
    java.lang.Object getCellFormat(geogebra.common.gui.view.spreadsheet.CellRange,int) -> a
    void setFormat(geogebra.common.awt.GPoint,int,java.lang.Object) -> a
    void setFormat(geogebra.common.gui.view.spreadsheet.CellRange,int,java.lang.Object) -> a
    void setFormat(java.util.ArrayList,int,java.lang.Object) -> a
    void setCellFormatString() -> b
    void setBorderStyle(java.util.ArrayList,int) -> a
    void setBorderStyle(geogebra.common.gui.view.spreadsheet.CellRange,int) -> a
    void getXML(java.lang.StringBuilder) -> a
    java.lang.StringBuilder encodeFormats() -> a
    void processXMLString(java.lang.String) -> a
    void processCellFormatString(java.lang.String) -> b
geogebra.common.gui.view.spreadsheet.CellFormat$MyHashMap -> geogebra.common.f.g.c.a$a:
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
geogebra.common.gui.view.spreadsheet.CellFormatInterface -> geogebra.common.f.g.c.b:
    java.lang.Object getCellFormat(geogebra.common.awt.GPoint,int) -> a
    java.util.HashMap getFormatMap(int) -> a
    void getXML(java.lang.StringBuilder) -> a
    void processXMLString(java.lang.String) -> a
geogebra.common.gui.view.spreadsheet.CellRange -> geogebra.common.f.g.c.c:
    int minColumn -> a
    int minRow -> b
    int maxColumn -> c
    int maxRow -> d
    int anchorColumn -> e
    int anchorRow -> f
    geogebra.common.main.App app -> a
    geogebra.common.main.SpreadsheetTableModel tableModel -> a
    void setCellRange(int,int,int,int) -> a
    int getMinColumn() -> a
    int getMinRow() -> b
    int getMaxColumn() -> c
    int getMaxRow() -> d
    boolean isSingleCell() -> a
    boolean isColumn() -> b
    boolean isRow() -> c
    int[] getActualDimensions() -> a
    boolean is2D() -> d
    boolean is1D() -> e
    boolean isPartialRow() -> f
    boolean isPartialColumn() -> g
    boolean isEmpty() -> h
    boolean isEmptyRange() -> i
    boolean isPointList() -> j
    geogebra.common.gui.view.spreadsheet.CellRange getActualRange() -> a
    void setActualRange() -> a
    int getWidth() -> e
    java.util.ArrayList toGeoList() -> a
    java.util.ArrayList toPartialColumnList() -> b
    java.util.ArrayList toPartialRowList() -> c
    java.util.ArrayList toCellList(boolean) -> a
    boolean hasSameAnchor(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean hasEmptyCells() -> k
    int getGeoCount(geogebra.common.plugin.GeoClass) -> a
    boolean containsGeoClass(geogebra.common.plugin.GeoClass) -> a
    boolean isValid() -> l
    geogebra.common.gui.view.spreadsheet.CellRange clone() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean contains(java.lang.Object) -> a
    java.lang.Object clone() -> clone
geogebra.common.gui.view.spreadsheet.CellRangeProcessor -> geogebra.common.f.g.c.d:
    geogebra.common.gui.view.spreadsheet.MyTable table -> a
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.main.SpreadsheetTableModel tableModel -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface getView() -> a
    java.util.ArrayList clone(java.util.ArrayList) -> a
    boolean isCreatePointListPossible(java.util.ArrayList) -> a
    boolean isCreateOperationTablePossible(java.util.ArrayList) -> b
    boolean isCreateMatrixPossible(java.util.ArrayList) -> c
    boolean containsGeoClass(java.util.ArrayList,geogebra.common.plugin.GeoClass) -> a
    geogebra.common.kernel.geos.GeoElement createPolyLine(java.util.ArrayList,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createPolyLine(java.util.ArrayList,boolean,boolean,boolean,boolean) -> a
    void getPointListDimensions(java.util.ArrayList,geogebra.common.gui.view.spreadsheet.CellRangeProcessor$PointDimension) -> a
    geogebra.common.kernel.geos.GeoList createPointGeoList(java.util.ArrayList,boolean,boolean,boolean,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createList(java.util.ArrayList,boolean,boolean) -> b
    geogebra.common.kernel.geos.GeoList createList(java.util.ArrayList,boolean,boolean,boolean,boolean,geogebra.common.plugin.GeoClass,boolean) -> a
    java.lang.String createMatrixExpression(int,int,int,int,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createMatrix(int,int,int,int,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createMatrix(int,int,int,int,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createTableText(int,int,int,int,boolean,boolean) -> b
    void InsertLeft(int,int) -> a
    void InsertRight(int,int) -> b
    void InsertAbove(int,int) -> c
    void InsertBelow(int,int) -> d
    void createOperationTable(geogebra.common.gui.view.spreadsheet.CellRange,geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    java.lang.String getCellRangeString(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    java.lang.String getCellRangeString(geogebra.common.gui.view.spreadsheet.CellRange,boolean) -> a
    java.lang.String getCellRangeString(java.util.ArrayList) -> a
geogebra.common.gui.view.spreadsheet.CellRangeProcessor$PointDimension -> geogebra.common.f.g.c.d$a:
    boolean doHorizontalPairs -> a
    int c1 -> a
    int c2 -> b
    int r1 -> c
    int r2 -> d
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor this$0 -> a
geogebra.common.gui.view.spreadsheet.CopyPasteCut -> geogebra.common.f.g.c.e:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    geogebra.common.main.SpreadsheetTableModel tableModel -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface view -> a
    geogebra.common.gui.view.spreadsheet.MyTableInterface table -> a
    java.lang.StringBuilder cellBufferStr -> a
    geogebra.common.kernel.geos.GeoElement[][] cellBufferGeo -> a
    int sourceColumn1 -> a
    int sourceRow1 -> b
    java.lang.Object[] constructionIndexes -> a
    java.util.Comparator comparator -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface getView() -> a
    geogebra.common.gui.view.spreadsheet.MyTableInterface getTable() -> a
    void copy(int,int,int,int,boolean) -> a
    boolean cut(int,int,int,int) -> a
    boolean pasteInternalMultiple(int,int,int,int) -> b
    boolean pasteInternal(int,int,int,int) -> c
    boolean pasteExternalMultiple(java.lang.String[][],geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean pasteExternalMultiple(java.lang.String[][],int,int,int,int) -> a
    boolean pasteExternal(java.lang.String[][],int,int,int,int) -> b
    boolean delete(int,int,int,int) -> d
    void deleteAll() -> a
    boolean delete(geogebra.common.main.App,int,int,int,int,int) -> a
    java.util.Comparator getComparator() -> a
geogebra.common.gui.view.spreadsheet.CopyPasteCut$1 -> geogebra.common.f.g.c.f:
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.gui.view.spreadsheet.CopyPasteCut$Record -> geogebra.common.f.g.c.e$a:
    int id -> a
    int x1 -> b
    int y1 -> c
    int x2 -> d
    int y2 -> e
    int getx1() -> a
    int getx2() -> b
    int gety1() -> c
    int gety2() -> d
geogebra.common.gui.view.spreadsheet.MyTable -> geogebra.common.f.g.c.g:
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.main.App getApplication() -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface getView() -> a
    geogebra.common.gui.view.spreadsheet.CopyPasteCut getCopyPasteCut() -> a
    int getColumnCount() -> getColumnCount
    int getRowCount() -> getRowCount
    boolean isSelectAll() -> a
geogebra.common.gui.view.spreadsheet.MyTableInterface -> geogebra.common.f.g.c.h:
    int getSelectionType() -> a
    boolean editCellAt(int,int) -> editCellAt
    geogebra.common.gui.view.spreadsheet.CellFormatInterface getCellFormatHandler() -> a
    boolean isSelectNone() -> b
    void repaint() -> repaint
    void selectionChanged() -> a
    boolean setSelection(int,int) -> a
    void updateEditor(java.lang.String) -> a
geogebra.common.gui.view.spreadsheet.RelativeCopy -> geogebra.common.f.g.c.i:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    com.google.gwt.regexp.shared.RegExp pattern2 -> a
    boolean doDragCopy(int,int,int,int,int,int,int,int) -> a
    boolean isPatternSource(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void doCopyVerticalNoStoringUndoInfo1(int,int,int,int,int) -> a
    void doCopyHorizontalNoStoringUndoInfo1(int,int,int,int,int) -> b
    geogebra.common.kernel.geos.GeoElement doCopyNoStoringUndoInfo0(geogebra.common.kernel.Kernel,geogebra.common.main.App,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    java.lang.String updateCellReferences(geogebra.common.kernel.geos.GeoElement,java.lang.String,int,int) -> a
    void doCopyNoStoringUndoInfo1(geogebra.common.kernel.Kernel,geogebra.common.main.App,java.lang.String,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    java.lang.String replaceAll(com.google.gwt.regexp.shared.RegExp,java.lang.String,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] getDependentObjects(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[][] getValues(geogebra.common.main.App,int,int,int,int) -> a
    geogebra.common.kernel.geos.GeoElement getValue(geogebra.common.main.App,int,int) -> a
    geogebra.common.kernel.geos.GeoElement prepareNewValue(geogebra.common.kernel.Kernel,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement updateOldValue(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoElement,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement prepareAddingValueToTableNoStoringUndoInfo(geogebra.common.kernel.Kernel,geogebra.common.main.App,java.lang.String,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    boolean isNumber(java.lang.String) -> a
    boolean isStandardNumber(java.lang.String) -> b
geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface -> geogebra.common.f.g.c.j:
    geogebra.common.gui.view.spreadsheet.MyTableInterface getSpreadsheetTable() -> a
    void rowHeaderRevalidate() -> a
    void columnHeaderRevalidate() -> c
    void updateCellFormat(java.lang.String) -> a
geogebra.common.io.DocHandler -> geogebra.common.g.a:
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    void startDocument() -> a
    void endDocument() -> b
    void text(java.lang.String) -> b
    int getConsStep() -> a
geogebra.common.io.MyXMLHandler -> geogebra.common.g.b:
    double FORMAT -> a
    int[] menuFontSizes -> a
    java.lang.String[] tooltipTimeouts -> a
    java.lang.Integer[] cbTimeoutOptions -> a
    int mode -> a
    int constMode -> b
    int casMode -> c
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoCasCell geoCasCell -> a
    geogebra.common.kernel.arithmetic.Command cmd -> a
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.main.App app -> a
    java.lang.String[] macroInputLabels -> b
    java.lang.String[] macroOutputLabels -> c
    geogebra.common.kernel.geos.GeoElement[] cmdOutput -> a
    boolean startAnimation -> a
    int docPointStyle -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Kernel origKernel -> b
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Construction origCons -> b
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.parser.Parser origParser -> b
    java.util.LinkedList startPointList -> a
    java.util.LinkedList linkedGeoList -> b
    java.util.LinkedList showObjectConditionList -> c
    java.util.LinkedList dynamicColorList -> d
    java.util.LinkedList animationSpeedList -> e
    java.util.LinkedList animationStepList -> f
    java.util.LinkedList animatingList -> g
    java.util.LinkedList minMaxList -> h
    int consStep -> e
    double ggbFileFormat -> b
    boolean hasGuiElement -> b
    geogebra.common.io.layout.Perspective tmp_perspective -> a
    java.util.ArrayList tmp_perspectives -> a
    java.util.ArrayList tmp_panes -> b
    java.util.ArrayList tmp_views -> c
    int tmp_sp1 -> f
    int tmp_sp2 -> g
    boolean tmp_spHorizontal -> c
    boolean tmp_showAlgebra -> d
    boolean tmp_showSpreadsheet -> e
    int viewNo -> h
    boolean resetEVsettingsNeeded -> f
    java.util.HashMap xmin -> a
    java.util.HashMap xmax -> b
    java.util.HashMap ymin -> c
    java.util.HashMap ymax -> d
    void reset(boolean) -> a
    void initKernelVars() -> c
    int getConsStep() -> a
    java.lang.Integer getTimeoutOption(long) -> a
    void text(java.lang.String) -> b
    void startDocument() -> a
    void endDocument() -> b
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void startScriptingElement(java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    void startGeoGebraElement(java.lang.String,java.util.LinkedHashMap) -> d
    void handleKeyboard(java.util.LinkedHashMap) -> b
    void startMacroElement(java.lang.String,java.util.LinkedHashMap) -> e
    void startEuclidianView3DElement(java.lang.String,java.util.LinkedHashMap) -> b
    void startEuclidianViewElement(java.lang.String,java.util.LinkedHashMap) -> f
    void startSpreadsheetViewElement(java.lang.String,java.util.LinkedHashMap) -> g
    void startProbabilityCalculatorElement(java.lang.String,java.util.LinkedHashMap) -> h
    boolean handleProbabilityDistribution(java.util.LinkedHashMap) -> a
    void startAlgebraViewElement(java.lang.String,java.util.LinkedHashMap) -> i
    boolean handleAlgebraViewCollapsedNodes(java.util.LinkedHashMap) -> b
    boolean handleAlgebraViewMode(java.util.LinkedHashMap) -> c
    boolean handleAlgebraViewShowAuxiliaryObjects(java.util.LinkedHashMap) -> d
    boolean handleCoordSystem(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> b
    boolean handleEvSettings(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> c
    boolean handleEvSize(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> d
    boolean handleSpreadsheetSize(java.util.LinkedHashMap) -> e
    boolean handleSpreadsheetColumn(java.util.LinkedHashMap) -> f
    boolean handleSpreadsheetCellSize(java.util.LinkedHashMap) -> g
    boolean handleSpreadsheetFormat(java.util.LinkedHashMap) -> h
    boolean handleSpreadsheetRow(java.util.LinkedHashMap) -> i
    boolean handleSpreadsheetLayout(java.util.LinkedHashMap) -> j
    boolean handleSpreadsheetInitalSelection(java.util.LinkedHashMap) -> k
    boolean handleSpreadsheetBrowser(java.util.LinkedHashMap) -> l
    boolean handleBgColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> e
    boolean handleAxesColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> f
    boolean handleGridColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> g
    boolean handleLineStyle(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> h
    boolean handleGrid(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> i
    boolean handleAxis(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> a
    void startKernelElement(java.lang.String,java.util.LinkedHashMap) -> j
    boolean handleAngleUnit(java.util.LinkedHashMap) -> m
    boolean handleAlgebraStyle(java.util.LinkedHashMap) -> n
    boolean handleKernelCoordStyle(java.util.LinkedHashMap) -> o
    boolean handleKernelInvTrig(java.util.LinkedHashMap) -> p
    boolean handleKernelDecimals(java.util.LinkedHashMap) -> q
    boolean handleKernelStartAnimation(java.util.LinkedHashMap) -> r
    boolean handleKernelLocalization(java.util.LinkedHashMap) -> s
    boolean handleCasSettings(java.util.LinkedHashMap) -> t
    boolean handleKernelFigures(java.util.LinkedHashMap) -> u
    boolean handleKernelContinuous(java.util.LinkedHashMap) -> v
    boolean handleKernelUsePathAndRegionParameters(java.util.LinkedHashMap) -> w
    void startGuiElement(java.lang.String,java.util.LinkedHashMap) -> k
    void createCompabilityLayout() -> d
    boolean handleConsProtColumns(geogebra.common.main.App,java.util.LinkedHashMap) -> a
    boolean handleConsProtocol(java.util.LinkedHashMap) -> x
    boolean handleConsProtNavigationBar(geogebra.common.main.App,java.util.LinkedHashMap) -> b
    boolean handleGuiShow(geogebra.common.main.App,java.util.LinkedHashMap) -> c
    boolean handleGuiSettings(geogebra.common.main.App,java.util.LinkedHashMap) -> d
    boolean handleGraphicsSettings(java.util.LinkedHashMap) -> y
    boolean handleSplitDivider(java.util.LinkedHashMap) -> z
    boolean handleToolbar(java.util.LinkedHashMap) -> A
    boolean handleWindowSize(geogebra.common.main.App,java.util.LinkedHashMap) -> e
    boolean handleFont(geogebra.common.main.App,java.util.LinkedHashMap) -> f
    boolean handleMenuFont(geogebra.common.main.App,java.util.LinkedHashMap) -> g
    boolean handleTooltipSettings(geogebra.common.main.App,java.util.LinkedHashMap) -> h
    boolean handleMouse(geogebra.common.main.App,java.util.LinkedHashMap) -> i
    boolean handleLabelingStyle(geogebra.common.main.App,java.util.LinkedHashMap) -> j
    void startGuiPerspectivesElement(java.lang.String,java.util.LinkedHashMap) -> l
    boolean handlePerspective(java.util.LinkedHashMap) -> B
    void endGuiPerspectivesElement() -> e
    void startGuiPerspectiveElement(java.lang.String,java.util.LinkedHashMap) -> m
    boolean handleDockBar(java.util.LinkedHashMap) -> C
    boolean handleAlgebraInput(java.util.LinkedHashMap) -> D
    void endGuiPerspectiveElement() -> f
    void startGuiViewsElement(java.lang.String,java.util.LinkedHashMap) -> n
    boolean handleView(java.util.LinkedHashMap) -> E
    void startGuiPanesElement(java.lang.String,java.util.LinkedHashMap) -> o
    boolean handlePane(java.util.LinkedHashMap) -> F
    void handleConstruction(java.util.LinkedHashMap) -> c
    void initMacro(java.util.LinkedHashMap) -> d
    void endMacro() -> g
    void handleWorksheetText(java.util.LinkedHashMap) -> e
    void startCasCell(java.lang.String,java.util.LinkedHashMap) -> p
    void endCasCell(java.lang.String) -> c
    void startCellPair() -> h
    void endCellPair(java.lang.String) -> d
    void startCellOutputElement(java.lang.String,java.util.LinkedHashMap) -> q
    void startCellInputElement(java.lang.String,java.util.LinkedHashMap) -> r
    void startCellTextElement(java.lang.String,java.util.LinkedHashMap) -> s
    void startConstructionElement(java.lang.String,java.util.LinkedHashMap) -> t
    void endConstructionElement(java.lang.String) -> e
    void processEvSizes() -> i
    geogebra.common.kernel.geos.GeoElement getGeoElement(java.util.LinkedHashMap) -> a
    void startGeoElement(java.lang.String,java.util.LinkedHashMap) -> c
    boolean handleCurveParam(java.util.LinkedHashMap) -> G
    char firstChar(java.lang.String) -> a
    boolean handleShow(java.util.LinkedHashMap) -> H
    boolean handleShowOnAxis(java.util.LinkedHashMap) -> I
    boolean handleObjColor(java.util.LinkedHashMap) -> J
    boolean handleBgColor(java.util.LinkedHashMap) -> K
    geogebra.common.awt.GColor handleColorAttrs(java.util.LinkedHashMap) -> a
    geogebra.common.awt.GColor handleColorAlphaAttrs(java.util.LinkedHashMap) -> b
    boolean handleLineStyle(java.util.LinkedHashMap) -> L
    boolean handleDecoration(java.util.LinkedHashMap) -> M
    boolean handleEqnStyle(java.util.LinkedHashMap) -> N
    boolean handleCoords(java.util.LinkedHashMap) -> O
    boolean handleCoordStyle(java.util.LinkedHashMap) -> P
    boolean handleCaption(java.util.LinkedHashMap) -> Q
    boolean handleScript(java.util.LinkedHashMap,geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    boolean handleCondition(java.util.LinkedHashMap) -> R
    boolean handleCheckbox(java.util.LinkedHashMap) -> S
    boolean handleValue(java.util.LinkedHashMap) -> T
    boolean handlePointSize(java.util.LinkedHashMap) -> U
    boolean handlePointStyle(java.util.LinkedHashMap) -> V
    boolean handleLayer(java.util.LinkedHashMap) -> W
    boolean handleCasCellInput(java.util.LinkedHashMap) -> X
    boolean handleCasCellOutput(java.util.LinkedHashMap) -> Y
    boolean handleSlider(java.util.LinkedHashMap) -> Z
    boolean handleTrace(java.util.LinkedHashMap) -> aa
    boolean handleSpreadsheetTrace(java.util.LinkedHashMap) -> ab
    boolean handleShowTrimmed(java.util.LinkedHashMap) -> ac
    boolean handleSelectionAllowed(java.util.LinkedHashMap) -> ad
    boolean handleSelectedIndex(java.util.LinkedHashMap) -> ae
    boolean handleAnimation(java.util.LinkedHashMap) -> af
    boolean handleFixed(java.util.LinkedHashMap) -> ag
    boolean handleBreakpoint(java.util.LinkedHashMap) -> ah
    boolean handleFile(java.util.LinkedHashMap) -> ai
    boolean handleTextFont(java.util.LinkedHashMap) -> aj
    boolean handleTextDecimals(java.util.LinkedHashMap) -> ak
    boolean handleTextFigures(java.util.LinkedHashMap) -> al
    boolean handleInBackground(java.util.LinkedHashMap) -> am
    boolean handleInterpolate(java.util.LinkedHashMap) -> an
    boolean handleAuxiliary(java.util.LinkedHashMap) -> ao
    boolean handleIsLaTeX(java.util.LinkedHashMap) -> ap
    boolean handleArcSize(java.util.LinkedHashMap) -> aq
    boolean handleAbsoluteScreenLocation(java.util.LinkedHashMap) -> ar
    boolean handleAllowReflexAngle(java.util.LinkedHashMap) -> as
    boolean handleEmphasizeRightAngle(java.util.LinkedHashMap) -> at
    boolean handleComboBox(java.util.LinkedHashMap) -> au
    boolean handleForceReflexAngle(java.util.LinkedHashMap) -> av
    boolean handleOutlyingIntersections(java.util.LinkedHashMap) -> aw
    boolean handleKeepTypeOnTransform(java.util.LinkedHashMap) -> ax
    boolean handleSlopeTriangleSize(java.util.LinkedHashMap) -> ay
    boolean handleStartPoint(java.util.LinkedHashMap) -> az
    geogebra.common.kernel.kernelND.GeoPointND handleAbsoluteStartPoint(java.util.LinkedHashMap) -> a
    void processStartPointList() -> j
    boolean handleLength(java.util.LinkedHashMap) -> aA
    boolean handleListType(java.util.LinkedHashMap) -> aB
    boolean handleLinkedGeo(java.util.LinkedHashMap) -> aC
    void processLinkedGeoList() -> k
    void processShowObjectConditionList() -> l
    void processAnimationSpeedList() -> m
    void processAnimationStepList() -> n
    void processAnimatingList() -> o
    void processMinMaxList() -> p
    void processDynamicColorList() -> q
    boolean handleEigenvectors(java.util.LinkedHashMap) -> aD
    boolean handleMatrix(java.util.LinkedHashMap) -> aE
    boolean handleLabelOffset(java.util.LinkedHashMap) -> aF
    boolean handleLabelMode(java.util.LinkedHashMap) -> aG
    boolean handleTooltipMode(java.util.LinkedHashMap) -> aH
    boolean handleCoefficients(java.util.LinkedHashMap) -> aI
    boolean handleUserInput(java.util.LinkedHashMap) -> aJ
    geogebra.common.kernel.arithmetic.Command getCommand(java.util.LinkedHashMap) -> a
    void startCommandElement(java.lang.String,java.util.LinkedHashMap) -> u
    boolean handleCmdInput(java.util.LinkedHashMap) -> aK
    boolean handleCmdOutput(java.util.LinkedHashMap) -> aL
    java.lang.String[] getAttributeStrings(java.util.LinkedHashMap) -> a
    void startExpressionElement(java.util.LinkedHashMap) -> f
    boolean parseBoolean(java.lang.String) -> a
geogebra.common.io.MyXMLHandler$GeoExpPair -> geogebra.common.g.b$a:
    geogebra.common.kernel.geos.GeoElement geoElement -> a
    java.lang.String exp -> a
    geogebra.common.io.MyXMLHandler this$0 -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void setGeo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.io.MyXMLHandler$GeoNumericMinMax -> geogebra.common.g.b$b:
    geogebra.common.kernel.geos.GeoElement geoElement -> a
    java.lang.String min -> a
    java.lang.String max -> b
    geogebra.common.io.MyXMLHandler this$0 -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void setGeo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.io.MyXMLHandler$LocateableExpPair -> geogebra.common.g.b$c:
    geogebra.common.kernel.Locateable locateable -> a
    java.lang.String exp -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    int number -> a
    geogebra.common.io.MyXMLHandler this$0 -> a
geogebra.common.io.MyXMLio -> geogebra.common.g.c:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.StringBuilder getUndoXML(geogebra.common.kernel.Construction) -> a
    void processXMLString(java.lang.String,boolean,boolean) -> a
    void processXMLString(java.lang.String,boolean,boolean,boolean) -> a
    void addGeoGebraHeader(java.lang.StringBuilder,boolean,java.lang.String,geogebra.common.main.App) -> a
    void addXMLHeader(java.lang.StringBuilder) -> a
    java.lang.String getFullXML() -> a
    java.lang.String getFullMacroXML(java.util.ArrayList) -> a
    java.lang.String getPreferencesXML() -> b
    java.lang.String getConstructionRegressionOut() -> c
geogebra.common.io.QDParser -> geogebra.common.g.d:
    java.util.LinkedHashMap attrs -> a
    java.util.Stack stack -> a
    java.lang.StringBuilder sb -> a
    java.lang.StringBuilder etag -> b
    int CHAR_SPACE -> a
    int CHAR_TAB -> b
    int CHAR_CR -> c
    int CHAR_NL -> d
    boolean isWhitespace(char) -> a
    void reset() -> a
    int popMode(java.util.Stack) -> a
    void parse(geogebra.common.io.DocHandler,java.io.Reader) -> a
    void exc(java.lang.String,int,int) -> a
geogebra.common.io.layout.DockPanelData -> geogebra.common.g.a.a:
    int viewId -> a
    boolean isVisible -> a
    boolean openInFrame -> b
    boolean showStyleBar -> c
    geogebra.common.awt.GRectangle frameBounds -> a
    java.lang.String embeddedDef -> a
    java.lang.String toolbarString -> b
    int embeddedSize -> b
    int getViewId() -> a
    java.lang.String getToolbarString() -> a
    boolean isVisible() -> a
    boolean isOpenInFrame() -> b
    boolean showStyleBar() -> c
    geogebra.common.awt.GRectangle getFrameBounds() -> a
    java.lang.String getEmbeddedDef() -> b
    int getEmbeddedSize() -> b
    java.lang.String getXml() -> c
    java.lang.Object clone() -> clone
geogebra.common.io.layout.DockSplitPaneData -> geogebra.common.g.a.b:
    java.lang.String location -> a
    double dividerLocation -> a
    int orientation -> a
    java.lang.String getLocation() -> a
    double getDividerLocation() -> a
    int getOrientation() -> a
    java.lang.String getXml() -> b
geogebra.common.io.layout.Perspective -> geogebra.common.g.a.c:
    java.lang.String id -> a
    geogebra.common.io.layout.DockSplitPaneData[] splitPaneData -> a
    geogebra.common.io.layout.DockPanelData[] dockPanelData -> a
    java.lang.String toolbarDefinition -> b
    boolean showToolBar -> a
    boolean showGrid -> b
    boolean showAxes -> c
    boolean unitAxesRatio -> d
    boolean showInputPanel -> e
    boolean showInputPanelCommands -> f
    boolean showInputPanelOnTop -> g
    int toolBarPosition -> a
    boolean showToolBarHelp -> h
    boolean showDockBar -> i
    boolean isDockBarEast -> j
    java.lang.String iconString -> c
    java.lang.String getId() -> a
    void setSplitPaneData(geogebra.common.io.layout.DockSplitPaneData[]) -> a
    geogebra.common.io.layout.DockSplitPaneData[] getSplitPaneData() -> a
    geogebra.common.io.layout.DockPanelData[] getDockPanelData() -> a
    void setDockPanelData(geogebra.common.io.layout.DockPanelData[]) -> a
    void setShowToolBar(boolean) -> a
    boolean getShowToolBar() -> a
    void setToolbarDefinition(java.lang.String) -> a
    java.lang.String getToolbarDefinition() -> b
    void setShowGrid(boolean) -> b
    boolean getShowGrid() -> b
    void setShowAxes(boolean) -> c
    boolean getShowAxes() -> c
    void setShowInputPanel(boolean) -> d
    boolean getShowInputPanel() -> d
    void setShowInputPanelCommands(boolean) -> e
    boolean getShowInputPanelCommands() -> e
    void setShowInputPanelOnTop(boolean) -> f
    boolean getShowInputPanelOnTop() -> f
    int getToolBarPosition() -> a
    void setToolBarPosition(int) -> a
    boolean getShowToolBarHelp() -> g
    void setShowToolBarHelp(boolean) -> g
    boolean getShowDockBar() -> h
    void setShowDockBar(boolean) -> h
    boolean isDockBarEast() -> i
    void setDockBarEast(boolean) -> i
    java.lang.String getXml() -> c
    void setUnitAxesRatio(boolean) -> j
    boolean isUnitAxesRatio() -> j
    java.lang.String getIconString() -> d
    void setIconString(java.lang.String) -> b
geogebra.common.javax.swing.AbstractJComboBox -> geogebra.common.h.a.a:
    void setVisible(boolean) -> a
    java.lang.Object getItemAt(int) -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
    void setFocusable(boolean) -> b
    void setEditable(boolean) -> c
    void addItem(java.lang.String) -> a
    void setSelectedIndex(int) -> a
    int getSelectedIndex() -> a
    void addActionListener(geogebra.common.euclidian.event.ActionListener) -> a
    void removeAllItems() -> a
    int getItemCount() -> b
geogebra.common.javax.swing.GBox -> geogebra.common.h.a.b:
    void add(geogebra.common.javax.swing.GLabel) -> a
    void add(geogebra.common.gui.inputfield.AutoCompleteTextField) -> a
    void setVisible(boolean) -> a
    void setBounds(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GDimension getPreferredSize() -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void validate() -> a
    void revalidate() -> b
    void add(geogebra.common.javax.swing.AbstractJComboBox) -> a
geogebra.common.javax.swing.GLabel -> geogebra.common.h.a.c:
    void setVisible(boolean) -> a
    void setText(java.lang.String) -> a
    void setOpaque(boolean) -> b
    void setFont(geogebra.common.awt.GFont) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
geogebra.common.javax.swing.GOptionPane -> geogebra.common.h.a.d:
    int showConfirmDialog(java.lang.Object,java.lang.String,java.lang.String,int,int) -> a
geogebra.common.javax.swing.GPopupMenu -> geogebra.common.h.a.e:
geogebra.common.javax.swing.GSplitPane -> geogebra.common.h.a.f:
    int HORIZONTAL_SPLIT -> a
geogebra.common.javax.swing.GTextComponent -> geogebra.common.h.a.g:
    void replaceSelection(java.lang.String) -> a
geogebra.common.kernel.AnimationManager -> geogebra.common.i.a:
    geogebra.common.kernel.Kernel kernel -> a
    java.util.ArrayList animatedGeos -> a
    java.util.ArrayList changedGeos -> b
    double frameRate -> a
    boolean needToShowAnimationButton -> a
    java.util.TreeSet tempSet -> a
    boolean needToShowAnimationButton() -> a
    void updateNeedToShowAnimationButton() -> a
    void addAnimatedGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void removeAnimatedGeo(geogebra.common.kernel.geos.GeoElement) -> b
    void startAnimation() -> b
    void stopAnimation() -> c
    boolean isPaused() -> b
    void clearAnimatedGeos() -> d
    void adaptFrameRate(long) -> a
    java.util.TreeSet getTempSet() -> a
    void sliderStep() -> e
    boolean isRunning() -> c
    void setTimerDelay(int) -> a
    void stopTimer() -> f
    void startTimer() -> g
geogebra.common.kernel.AsynchronousCommand -> geogebra.common.i.b:
    void handleCASoutput(java.lang.String,int) -> a
    void handleException(java.lang.Throwable,int) -> a
    boolean useCacheing() -> a
    java.lang.String getCasInput() -> a
geogebra.common.kernel.CASException -> geogebra.common.i.c:
    java.lang.String key -> a
    java.lang.String getKey() -> a
    void setKey(java.lang.String) -> a
geogebra.common.kernel.CASGenericInterface -> geogebra.common.i.d:
    java.lang.String translateAssignment(java.lang.String,java.lang.String) -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String evaluateRaw(java.lang.String) -> b
    void unbindVariable(java.lang.String) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.AsynchronousCommand) -> a
    java.lang.String translateFunctionDeclaration(java.lang.String,java.lang.String[],java.lang.String,geogebra.common.kernel.arithmetic.AssignmentType) -> a
    void appendListStart(java.lang.StringBuilder) -> a
    void appendListEnd(java.lang.StringBuilder) -> b
geogebra.common.kernel.CASParserInterface -> geogebra.common.i.e:
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> b
    java.lang.String getTranslatedCASCommand(java.lang.String) -> c
geogebra.common.kernel.CircularDefinitionException -> geogebra.common.i.f:
geogebra.common.kernel.Construction -> geogebra.common.i.g:
    java.util.Map constsM -> a
    java.util.Map intsM -> b
    java.util.Map complexNumbersM -> c
    java.util.ArrayList usedMacros -> a
    geogebra.common.kernel.UndoManager undoManager -> a
    geogebra.common.kernel.ConstructionDefaults consDefaults -> a
    java.lang.String title -> a
    java.lang.String author -> b
    java.lang.String date -> c
    java.lang.String[] worksheetText -> a
    boolean showOnlyBreakpoints -> a
    geogebra.common.kernel.Kernel kernel -> a
    int step -> a
    boolean supressLabelCreation -> b
    java.util.HashMap geoSetsTypeMap -> d
    java.util.ArrayList ceList -> b
    java.util.ArrayList algoList -> c
    java.util.HashMap geoTable -> a
    java.util.ArrayList euclidianViewCE -> d
    java.util.HashMap localVariableTable -> b
    java.util.TreeSet geoSetConsOrder -> a
    java.util.TreeSet geoSetLabelOrder -> b
    java.util.TreeSet geoSetWithCasCells -> c
    java.util.TreeSet randomElements -> d
    java.util.HashMap geoCasCellTable -> c
    boolean collectRedefineCalls -> c
    java.util.HashMap redefineMap -> e
    geogebra.common.kernel.geos.GeoElement keepGeo -> a
    geogebra.common.kernel.geos.GeoAxis xAxis -> a
    geogebra.common.kernel.geos.GeoAxis yAxis -> b
    java.lang.String xAxisLocalName -> d
    java.lang.String yAxisLocalName -> e
    geogebra.common.kernel.geos.GeoPoint origin -> a
    boolean undoEnabled -> d
    boolean isRemovingGeoToReplaceIt -> e
    geogebra.common.io.MyXMLio xmlio -> a
    geogebra.common.kernel.geos.GeoElement outputGeo -> b
    java.util.TreeSet registredFV -> e
    boolean fileLoading -> f
    boolean updateConstructionRunning -> g
    java.util.TreeSet casDummies -> f
    geogebra.common.kernel.algos.AlgorithmSet algoSetCurrentlyUpdated -> a
    void newConstructionDefaults() -> a
    geogebra.common.kernel.geos.GeoPoint getOrigin() -> a
    geogebra.common.kernel.geos.GeoAxis getXAxis() -> a
    geogebra.common.kernel.geos.GeoAxis getYAxis() -> b
    void initAxis() -> b
    geogebra.common.kernel.Construction$Constants isConstantElement(geogebra.common.kernel.geos.GeoElement) -> a
    void updateLocalAxesNames() -> c
    geogebra.common.kernel.ConstructionDefaults getConstructionDefaults() -> a
    java.lang.String getAuthor() -> a
    java.lang.String getDate() -> b
    java.lang.String getTitle() -> c
    void setAuthor(java.lang.String) -> a
    void setDate(java.lang.String) -> b
    void setTitle(java.lang.String) -> c
    java.lang.String getWorksheetText(int) -> a
    void setWorksheetText(java.lang.String,int) -> a
    boolean worksheetTextDefined() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void setSuppressLabelCreation(boolean) -> a
    boolean isSuppressLabelsActive() -> b
    geogebra.common.main.App getApplication() -> a
    boolean isEmpty() -> c
    int steps() -> a
    geogebra.common.kernel.geos.GeoElement getLastGeoElement() -> a
    geogebra.common.kernel.geos.GeoCasCell getCasCell(int) -> a
    geogebra.common.kernel.geos.GeoCasCell getLastCasCell() -> a
    void setCasCellRow(geogebra.common.kernel.geos.GeoCasCell,int) -> a
    void addLocalVariable(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    void removeLocalVariable(java.lang.String) -> d
    geogebra.common.kernel.geos.GeoElement geoTableVarLookup(java.lang.String) -> a
    void setShowOnlyBreakpoints(boolean) -> b
    boolean showOnlyBreakpoints() -> d
    void updateConstructionIndex(int) -> a
    boolean updateAllConstructionProtocolAlgorithms() -> e
    void addToConstructionList(geogebra.common.kernel.algos.ConstructionElement,int) -> a
    void updateCasCellRows() -> d
    boolean moveInConstructionList(int,int) -> a
    void addToConstructionList(geogebra.common.kernel.algos.ConstructionElement,boolean) -> a
    void removeFromConstructionList(geogebra.common.kernel.algos.ConstructionElement) -> a
    void addToAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> b
    boolean moveInConstructionList(geogebra.common.kernel.geos.GeoElement,int) -> a
    void updateAllAlgorithms() -> e
    void registerEuclidianViewCE(geogebra.common.kernel.EuclidianViewCE) -> a
    void unregisterEuclidianViewCE(geogebra.common.kernel.EuclidianViewCE) -> b
    boolean notifyEuclidianViewCE() -> f
    boolean hasEuclidianViewCE() -> g
    void updateAllRandomGeos() -> f
    void addRandomGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void removeRandomGeo(geogebra.common.kernel.geos.GeoElement) -> b
    void updateConstruction() -> g
    void updateCasCells() -> h
    void getConstructionXML(java.lang.StringBuilder) -> a
    void getConstructionElementsXML(java.lang.StringBuilder) -> b
    void getConstructionRegressionOut(java.lang.StringBuilder) -> c
    boolean isUndoEnabled() -> h
    void setUndoEnabled(boolean) -> c
    geogebra.common.kernel.algos.ConstructionElement getConstructionElement(int) -> a
    geogebra.common.kernel.geos.GeoElement getFirstGeo() -> b
    java.util.TreeSet getGeoSetConstructionOrder() -> a
    java.util.TreeSet getGeoSetWithCasCellsConstructionOrder() -> b
    java.util.TreeSet getGeoSetLabelOrder() -> c
    void startCollectingRedefineCalls() -> i
    void stopCollectingRedefineCalls() -> j
    void replace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    boolean isRemovingGeoToReplaceIt() -> i
    void processCollectedRedefineCalls() -> k
    void changeCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    void doReplaceInXML(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void setStep(int) -> b
    int getStep() -> b
    void putLabel(geogebra.common.kernel.geos.GeoElement) -> c
    void removeLabel(geogebra.common.kernel.geos.GeoElement) -> d
    void addToGeoSets(geogebra.common.kernel.geos.GeoElement) -> e
    java.util.TreeSet getGeoSetLabelOrder(geogebra.common.plugin.GeoClass) -> a
    java.util.TreeSet createTypeSet(geogebra.common.plugin.GeoClass) -> b
    void removeFromGeoSets(geogebra.common.kernel.geos.GeoElement) -> f
    void putCasCellLabel(geogebra.common.kernel.geos.GeoCasCell,java.lang.String) -> a
    void removeCasCellLabel(java.lang.String) -> e
    void removeCasCellLabel(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoCasCell lookupCasCellLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasRowReference(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement checkConstructionStep(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFreeLabel(java.lang.String) -> a
    boolean isFreeLabel(java.lang.String,boolean,boolean) -> a
    void updateConstructionOrder(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> c
    boolean updateConstructionOrder(geogebra.common.kernel.geos.GeoCasCell) -> a
    void prepareReplace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    void addToGeoSetWithCasCells(geogebra.common.kernel.geos.GeoCasCell) -> b
    void removeFromGeoSetWithCasCells(geogebra.common.kernel.geos.GeoCasCell) -> c
    geogebra.common.kernel.geos.GeoElement createSpreadsheetGeoElement(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    java.lang.String getIndexLabel(java.lang.String,int) -> a
    java.lang.String getIndexLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement autoCreateGeoElement(java.lang.String) -> c
    geogebra.common.kernel.geos.GeoFunction createFunction(geogebra.common.plugin.Operation) -> a
    void initGeoTables() -> l
    java.util.TreeSet getGeoSetNameDescriptionOrder() -> d
    geogebra.common.kernel.optimization.ExtremumFinder getExtremumFinder() -> a
    void storeUndoInfo() -> m
    void restoreCurrentUndoInfo() -> n
    void redo() -> o
    void undo() -> p
    boolean undoPossible() -> j
    boolean redoPossible() -> k
    void addUsedMacro(geogebra.common.kernel.Macro) -> a
    java.util.ArrayList getUsedMacros() -> a
    void clearConstruction() -> q
    java.lang.StringBuilder getCurrentUndoXML() -> a
    geogebra.common.io.MyXMLio getXMLio() -> a
    void initUndoInfo() -> r
    void buildConstruction(java.lang.StringBuilder) -> d
    geogebra.common.kernel.UndoManager getUndoManager() -> a
    void setOutputGeo(java.lang.String) -> f
    geogebra.common.kernel.geos.GeoElement getOutputGeo() -> c
    void registerFunctionVariable(java.lang.String) -> g
    boolean isRegistredFunctionVariable(java.lang.String) -> b
    java.lang.String getRegistredFunctionVariable() -> d
    void setFileLoading(boolean) -> d
    boolean isFileLoading() -> l
    boolean isUpdateConstructionRunning() -> m
    java.util.TreeSet getCASdummies() -> e
    void setAlgoSetCurrentlyUpdated(geogebra.common.kernel.algos.AlgorithmSet) -> a
    geogebra.common.kernel.algos.AlgorithmSet getAlgoSetCurrentlyUpdated() -> a
geogebra.common.kernel.Construction$Constants -> geogebra.common.i.g$a:
    geogebra.common.kernel.Construction$Constants NOT -> a
    geogebra.common.kernel.Construction$Constants X_AXIS -> b
    geogebra.common.kernel.Construction$Constants Y_AXIS -> c
    geogebra.common.kernel.Construction$Constants[] ENUM$VALUES -> a
    geogebra.common.kernel.Construction$Constants[] values() -> values
    geogebra.common.kernel.Construction$Constants valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.Construction$LabelComparator -> geogebra.common.i.g$b:
    geogebra.common.kernel.Construction this$0 -> a
    int compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.ConstructionDefaults -> geogebra.common.i.h:
    geogebra.common.awt.GColor colPoint -> a
    geogebra.common.awt.GColor colDepPoint -> b
    geogebra.common.awt.GColor colPathPoint -> c
    geogebra.common.awt.GColor colRegionPoint -> d
    geogebra.common.awt.GColor colComplexPoint -> e
    geogebra.common.awt.GColor colLine -> j
    geogebra.common.awt.GColor colInequality -> k
    geogebra.common.awt.GColor colConic -> l
    geogebra.common.awt.GColor colPolygon -> f
    geogebra.common.awt.GColor colAngle -> m
    geogebra.common.awt.GColor colLocus -> n
    geogebra.common.awt.GColor colFunction -> o
    geogebra.common.awt.GColor colList -> p
    geogebra.common.awt.GColor colQuadric -> g
    geogebra.common.awt.GColor colPreview -> h
    geogebra.common.awt.GColor colPreviewFill -> i
    geogebra.common.kernel.Construction cons -> a
    java.util.HashMap defaultGeoElements -> a
    int lineThickness -> a
    int pointSize -> b
    int angleSize -> c
    float filling -> a
    boolean blackWhiteMode -> a
    java.lang.String strFree -> a
    java.lang.String strDependent -> b
    java.lang.String strIntersection -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void createDefaultGeoElementsFromScratch() -> a
    void createDefaultGeoElements() -> b
    java.lang.String getCDXML() -> a
    geogebra.common.kernel.geos.GeoElement getDefaultGeo(int) -> a
    void addDefaultGeo(java.lang.Integer,geogebra.common.kernel.geos.GeoElement) -> a
    int getDefaultType(geogebra.common.kernel.geos.GeoElement) -> a
    void setMaxLayerUsed(geogebra.common.kernel.geos.GeoElement,geogebra.common.main.App) -> a
    void setDefaultVisualStyles(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setBlackWhiteMode(boolean) -> a
    void resetDefaults() -> c
    void setDefaultAngleSize(int) -> a
    void setDefaultPointSize(int) -> b
    void setDefaultLineThickness(int) -> c
    void setDefaultFilling(float) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.EquationSolver -> geogebra.common.i.i:
    org.apache.commons.math.analysis.solvers.LaguerreSolver laguerreSolver -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinderBrent -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinderNewton -> b
    java.util.Comparator comparatorReal -> a
    int polynomialRoots(double[],boolean) -> a
    int polynomialComplexRoots(double[],double[]) -> a
    int solveQuadratic(double[]) -> a
    int solveQuadratic(double[],double[]) -> b
    int solveQuadraticComplex(double[],double[]) -> c
    int solveCubic(double[],double[]) -> d
    void fixRoots(double[],double[]) -> a
    double solveEqn(double[],int,double) -> a
    double findZero(double,double,double[]) -> a
    int getTag(double,double,double) -> a
    int laguerreAll(double[]) -> b
    int laguerreAllComplex(double[],double[]) -> f
    int solveQuartic(double[],double[]) -> e
    java.util.Comparator getComparatorReal() -> a
geogebra.common.kernel.EquationSolver$1 -> geogebra.common.i.j:
    int compare(org.apache.commons.math.complex.Complex,org.apache.commons.math.complex.Complex) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.EquationSolverInterface -> geogebra.common.i.k:
    int solveCubic(double[],double[]) -> d
    int solveQuadratic(double[],double[]) -> b
    int polynomialRoots(double[],boolean) -> a
    int polynomialComplexRoots(double[],double[]) -> a
geogebra.common.kernel.EuclidianViewCE -> geogebra.common.i.l:
    boolean euclidianViewUpdate() -> b
geogebra.common.kernel.GeoGebraCasInterface -> geogebra.common.i.m:
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getCurrentCASstringType() -> a
    java.lang.String evaluateRaw(java.lang.String) -> a
    geogebra.common.kernel.CASParserInterface getCASparser() -> a
    boolean isStructurallyEqual(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String) -> a
    boolean isCommandAvailable(geogebra.common.kernel.arithmetic.Command) -> a
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant,geogebra.common.kernel.StringTemplate) -> a
    void unbindVariable(java.lang.String) -> a
    java.lang.String getCASCommand(java.lang.String,java.util.ArrayList,boolean,geogebra.common.kernel.StringTemplate) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.AsynchronousCommand) -> a
    java.lang.String toAssignment(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.StringTemplate) -> a
    java.util.Set getAvailableCommandNames() -> a
    void clearCache() -> b
geogebra.common.kernel.GraphAlgo -> geogebra.common.i.n:
geogebra.common.kernel.Kernel -> geogebra.common.i.o:
    int MAX_SPREADSHEET_COLUMNS -> a
    int MAX_SPREADSHEET_ROWS -> b
    int algebraStyle -> e
    geogebra.common.kernel.MacroManager macroManager -> a
    boolean insertLineBreaks -> a
    int angleUnit -> f
    boolean viewReiniting -> c
    boolean undoActive -> d
    geogebra.common.kernel.View[] views -> a
    int viewCnt -> c
    java.util.ArrayList userAwarenessListeners -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator expressionNodeEvaluator -> a
    int kernelInstances -> g
    boolean continuous -> e
    geogebra.common.kernel.PathRegionHandling usePathAndRegionParameters -> a
    int kernelID -> h
    java.lang.String casVariablePrefix -> a
    geogebra.common.kernel.GeoGebraCasInterface ggbCAS -> a
    double SQRT_2_HALF -> a
    int GEOGEBRA_CAS_CACHE_SIZE -> d
    geogebra.common.util.NumberFormatAdapter nf -> a
    geogebra.common.util.ScientificFormatAdapter sf -> a
    boolean useSignificantFigures -> b
    int coordStyle -> i
    double EPSILON -> b
    double EPSILON_SQRT -> c
    double ROUND_HALF_UP_FACTOR -> d
    boolean useInternalCommandNames -> f
    boolean notifyConstructionProtocolViewAboutAddRemoveActive -> g
    boolean allowVisibilitySideEffects -> h
    boolean saveScriptsToXML -> i
    boolean elementDefaultAllowed -> j
    boolean silentMode -> k
    boolean wantAnimationStarted -> l
    boolean resolveUnkownVarsAsDummyGeos -> m
    boolean updateEVAgain -> n
    boolean forceUpdatingBoundingBox -> o
    java.lang.StringBuilder sbBuildExplicitLineEquation -> a
    geogebra.common.main.App app -> a
    geogebra.common.kernel.EquationSolver eqnSolver -> a
    geogebra.common.kernel.SystemOfEquationsSolver sysEqSolv -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.Manager3DInterface manager3D -> a
    geogebra.common.kernel.AnimationManager animationManager -> a
    boolean loadingMode -> p
    geogebra.common.main.CasType DEFAULT_CAS -> a
    double[] temp -> a
    java.lang.StringBuilder sbFormat -> b
    java.lang.StringBuilder formatSB -> c
    java.lang.StringBuilder sbBuildImplicitEquation -> d
    java.lang.StringBuilder sbBuildLHS -> e
    java.lang.StringBuilder sbBuildExplicitConicEquation -> f
    java.lang.StringBuilder sbBuildImplicitVarPart -> g
    java.lang.StringBuilder sbFormatSF -> h
    java.lang.String libraryJavaScript -> b
    boolean isSaving -> q
    java.lang.StringBuilder sbFormatAngle -> i
    boolean arcusFunctionCreatesAngle -> r
    geogebra.common.util.MaxSizeHashMap ggbCasCache -> a
    double xmin -> e
    double xmax -> f
    double ymin -> g
    double ymax -> h
    double xscale -> i
    double yscale -> j
    double xmin2 -> k
    double xmax2 -> l
    double ymin2 -> m
    double ymax2 -> n
    double xscale2 -> o
    double yscale2 -> p
    boolean graphicsView2showing -> s
    boolean notifyRepaint -> t
    int oldViewCnt -> j
    boolean notifyViewsActive -> u
    java.util.ArrayList renameListenerAlgos -> b
    java.util.ArrayList selectedGeosNames -> c
    geogebra.common.kernel.geos.GeoVec2D imaginaryUnit -> a
    geogebra.common.kernel.geos.GeoElementSpreadsheet ges -> a
    geogebra.common.kernel.algos.AlgoDispatcher algoDispatcher -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> b
    geogebra.common.kernel.commands.AlgebraProcessor getAlgebraProcessor() -> a
    geogebra.common.kernel.commands.AlgebraProcessor newAlgebraProcessor(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.Manager3DInterface newManager3D(geogebra.common.kernel.Kernel) -> a
    void setManager3D(geogebra.common.kernel.Manager3DInterface) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND getDefaultPlane() -> a
    geogebra.common.kernel.Manager3DInterface getManager3D() -> a
    void newConstruction() -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Construction) -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Kernel,geogebra.common.kernel.Construction) -> a
    geogebra.common.main.App getApplication() -> a
    geogebra.common.kernel.EquationSolver getEquationSolver() -> a
    geogebra.common.kernel.SystemOfEquationsSolver getSystemOfEquationsSolver(geogebra.common.kernel.EquationSolverInterface) -> a
    geogebra.common.kernel.optimization.ExtremumFinder getExtremumFinder() -> a
    geogebra.common.kernel.parser.Parser getParser() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator newExpressionNodeEvaluator() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator getExpressionNodeEvaluator() -> b
    java.util.Comparator DoubleComparator(double) -> a
    boolean isAnimationRunning() -> a
    boolean isAnimationPaused() -> b
    boolean needToShowAnimationButton() -> c
    void udpateNeedToShowAnimationButton() -> b
    boolean handleCoords(geogebra.common.kernel.geos.GeoElement,java.util.LinkedHashMap) -> a
    geogebra.common.kernel.Construction getConstruction() -> a
    geogebra.common.kernel.algos.ConstructionElement getConstructionElement(int) -> a
    geogebra.common.kernel.geos.GeoElement getFirstGeo() -> a
    void setConstructionStep(int) -> a
    int getConstructionStep() -> a
    int getLastConstructionStep() -> b
    void firstStep() -> c
    void lastStep() -> d
    void nextStep() -> e
    int getNextBreakpoint(int) -> a
    void previousStep() -> f
    int getPreviousBreakpoint(int) -> b
    boolean moveInConstructionList(int,int) -> a
    void setSaveScriptsToXML(boolean) -> a
    boolean getSaveScriptsToXML() -> d
    void setElementDefaultAllowed(boolean) -> b
    boolean getElementDefaultAllowed() -> e
    boolean isContinuous() -> f
    void setContinuous(boolean) -> c
    boolean usePathAndRegionParameters(geogebra.common.kernel.geos.GeoElement) -> a
    void setUsePathAndRegionParameters(geogebra.common.kernel.PathRegionHandling) -> a
    void setLoadingMode(boolean) -> d
    boolean getLoadingMode() -> g
    char sign(double) -> a
    void setNotifyConstructionProtocolViewAboutAddRemoveActive(boolean) -> e
    boolean isNotifyConstructionProtocolViewAboutAddRemoveActive() -> h
    java.lang.StringBuilder buildImplicitEquation(double[],java.lang.String[],boolean,boolean,char,geogebra.common.kernel.StringTemplate) -> a
    void formatSignedCoefficient(double,java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    void formatSigned(double,java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String formatPiERaw(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String formatRaw(double,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatNF(double,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String format(double,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String internationalizeDigits(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatPiE(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.kernel.StringTemplate) -> a
    void copy(double[],double[]) -> a
    void negative(double[],double[]) -> b
    void divide(double[],double,double[]) -> a
    long gcd(long,long) -> a
    double gcd(double[]) -> a
    double roundToScale(double,double) -> a
    void unbindVariableInGeoGebraCAS(java.lang.String) -> a
    java.lang.StringBuilder buildLHS(double[],java.lang.String[],boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    char oppositeSign(char) -> a
    java.lang.StringBuilder buildImplicitVarPart(double[],java.lang.String[],boolean,boolean,geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildExplicitConicEquation(double[],java.lang.String[],int,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatSF(double,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String formatCoeff(double,geogebra.common.kernel.StringTemplate) -> e
    java.lang.StringBuilder buildExplicitLineEquation(double[],java.lang.String[],char,geogebra.common.kernel.StringTemplate) -> a
    boolean isZero(double) -> a
    boolean isInteger(double) -> b
    boolean isEqual(double,double) -> a
    boolean isEqual(double,double,double) -> a
    boolean isGreater(double,double) -> b
    boolean isGreater(double,double,double) -> b
    boolean isGreaterEqual(double,double) -> c
    double convertToAngleValue(double) -> a
    double checkDecimalFraction(double,double) -> b
    double checkDecimalFraction(double) -> b
    double checkInteger(double) -> c
    java.lang.StringBuilder formatAngle(double,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String convertScientificNotation(java.lang.String,geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder formatAngle(double,double,geogebra.common.kernel.StringTemplate) -> a
    void resetLibraryJavaScript() -> g
    void setLibraryJavaScript(java.lang.String) -> b
    java.lang.String getLibraryJavaScript() -> a
    java.util.TreeSet getPointSet() -> a
    boolean isSaving() -> i
    void setSaving(boolean) -> f
    void setInverseTrigReturnsAngle(boolean) -> g
    boolean getInverseTrigReturnsAngle() -> j
    void setAngleUnit(int) -> b
    int getAngleUnit() -> c
    boolean isZvarAllowed() -> k
    void setEpsilon(double) -> a
    void setEpsilonForPrintPrecision(double) -> b
    double getEpsilon() -> a
    void setMinPrecision() -> h
    void resetPrecision() -> i
    java.lang.String printVariableName(java.lang.String,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String printVariableName(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,java.lang.String) -> a
    java.lang.String getCasVariablePrefix() -> b
    java.lang.String addTempVariablePrefix(java.lang.String) -> b
    java.lang.String addCASVariablePrefix(java.lang.String) -> c
    java.lang.String removeCASVariablePrefix(java.lang.String) -> a
    java.lang.String removeCASVariablePrefix(java.lang.String,java.lang.String) -> a
    void setPrintFigures(int) -> c
    void setPrintDecimals(int) -> d
    int getPrintDecimals() -> d
    int getPrintFigures() -> e
    boolean isUsingInternalCommandNames() -> l
    void setUseInternalCommandNames(boolean) -> h
    boolean isAllowVisibilitySideEffects() -> m
    void setAllowVisibilitySideEffects(boolean) -> i
    boolean isMacroKernel() -> n
    boolean isSilentMode() -> o
    boolean isGeoGebraCASready() -> p
    void setSilentMode(boolean) -> j
    void setResolveUnkownVarsAsDummyGeos(boolean) -> k
    boolean isResolveUnkownVarsAsDummyGeos() -> q
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateCachedGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> b
    java.lang.String evaluateGeoGebraCAS(java.lang.String,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.AsynchronousCommand) -> a
    void putToCasCache(java.lang.String,java.lang.String) -> a
    void resetGeoGebraCAS() -> j
    void setAlgebraStyle(int) -> e
    int getAlgebraStyle() -> f
    geogebra.common.util.MaxSizeHashMap getCasCache() -> a
    boolean hasCasCache() -> r
    void setEuclidianViewBounds(int,double,double,double,double,double,double) -> a
    double getViewsXMin(geogebra.common.kernel.geos.GeoElement) -> a
    double getViewsXMax(geogebra.common.kernel.geos.GeoElement) -> b
    double getViewsYMin(geogebra.common.kernel.geos.GeoElement) -> c
    double getViewsYMax(geogebra.common.kernel.geos.GeoElement) -> d
    void notifyEuclidianViewCE() -> k
    void clearConstruction(boolean) -> l
    double getXmax() -> b
    double getXmin() -> c
    double getXscale() -> d
    double getYmax() -> e
    double getYmin() -> f
    double getYscale() -> g
    geogebra.common.kernel.GeoGebraCasInterface getGeoGebraCAS() -> a
    int getCoordStyle() -> g
    void setCoordStyle(int) -> f
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasCellLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasRowReference(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    java.lang.String getModeText(int) -> a
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement getGeoAt(int,int) -> a
    geogebra.common.kernel.AnimationManager getAnimatonManager() -> a
    double[] getViewBoundsForGeo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoAxis getXAxis() -> a
    geogebra.common.kernel.geos.GeoAxis getYAxis() -> b
    boolean isAxis(geogebra.common.kernel.geos.GeoElement) -> b
    void updateLocalAxesNames() -> l
    void setNotifyRepaintActive(boolean) -> m
    void notifyRepaint() -> m
    void notifyReset() -> n
    void notifyClearView() -> o
    void clearJustCreatedGeosInViews() -> p
    void setNotifyViewsActive(boolean) -> n
    void attach(geogebra.common.kernel.View) -> a
    void printAttachedViews() -> z
    void detach(geogebra.common.kernel.View) -> b
    void notifyModeChanged(int,geogebra.common.kernel.ModeSetter) -> a
    void notifyAddAll(geogebra.common.kernel.View) -> c
    void registerRenameListenerAlgo(geogebra.common.kernel.algos.AlgoElement) -> a
    void notifyRenameListenerAlgos() -> A
    void notifyAddAll(geogebra.common.kernel.View,int) -> a
    void notifyAdd(geogebra.common.kernel.geos.GeoElement) -> a
    void notifyRemove(geogebra.common.kernel.geos.GeoElement) -> b
    void notifyUpdate(geogebra.common.kernel.geos.GeoElement) -> c
    void notifyUpdateLocation(geogebra.common.kernel.geos.GeoElement) -> d
    void notifyUpdateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> e
    void notifyUpdateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void notifyRename(geogebra.common.kernel.geos.GeoElement) -> g
    boolean isNotifyViewsActive() -> s
    boolean isViewReiniting() -> t
    void addUserAwarenessListener(geogebra.common.kernel.UserAwarenessListener) -> a
    void removeUserAwarenessListener(geogebra.common.kernel.UserAwarenessListener) -> b
    void updateConstruction() -> q
    boolean isEmpty() -> u
    void setUndoActive(boolean) -> o
    boolean isUndoActive() -> v
    void storeUndoInfo() -> r
    void initUndoInfo() -> s
    void storeSelectedGeosNames() -> B
    void recallSelectedGeosNames() -> C
    void redo() -> t
    void undo() -> u
    boolean undoPossible() -> w
    boolean redoPossible() -> x
    boolean isInsertLineBreaks() -> y
    geogebra.common.kernel.arithmetic.ExpressionNode handleTrigPower(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,java.lang.String) -> a
    geogebra.common.kernel.arithmetic.MyDouble convertIndexToNumber(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoVec2D getImaginaryUnit() -> a
    geogebra.common.kernel.geos.GeoElement[] useMacro(java.lang.String[],geogebra.common.kernel.Macro,geogebra.common.kernel.geos.GeoElement[]) -> a
    void getKernelXML(java.lang.StringBuilder,boolean) -> a
    void addMacro(geogebra.common.kernel.Macro) -> a
    void removeMacro(geogebra.common.kernel.Macro) -> b
    void removeAllMacros() -> v
    boolean setMacroCommandName(geogebra.common.kernel.Macro,java.lang.String) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    java.lang.String getMacroXML(java.util.ArrayList) -> a
    boolean hasMacros() -> z
    int getMacroNumber() -> h
    java.util.ArrayList getAllMacros() -> a
    geogebra.common.kernel.Macro getMacro(int) -> a
    int getMacroID(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.geos.GeoElement createGeoElement(geogebra.common.kernel.Construction,java.lang.String) -> a
    void setWantAnimationStarted() -> w
    boolean wantAnimationStarted() -> A
    geogebra.common.kernel.arithmetic.ExpressionNode convertNumberValueToExpressionNode(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] VectorPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint[]) -> a
    geogebra.common.kernel.geos.GeoElement[] RigidPolygon(geogebra.common.kernel.geos.GeoPolygon,double,double) -> a
    geogebra.common.kernel.geos.GeoElement[] RigidPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint[]) -> b
    geogebra.common.kernel.geos.GeoLine Tangent(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoElementSpreadsheet getGeoElementSpreadsheet() -> a
    geogebra.common.kernel.MacroKernel newMacroKernel() -> a
    void notifyChangeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    double getXmaxForFunctions() -> h
    double getXminForFunctions() -> i
    void clearCasCache() -> x
    void refreshCASCommands() -> y
    geogebra.common.kernel.geos.GeoElement[] PolygonND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLineND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    geogebra.common.kernel.kernelND.GeoRayND RayND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND SegmentND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.algos.AlgoDispatcher getAlgoDispatcher() -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> c
    geogebra.common.kernel.geos.GeoElement[] PolyLine(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[],boolean) -> a
    void setUpdateAgain(boolean) -> p
    boolean getUpdateAgain() -> B
    boolean getForceUpdatingBoundingBox() -> C
    boolean useCASforDerivatives() -> D
    boolean useCASforIntegrals() -> E
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> b
geogebra.common.kernel.Kernel$1 -> geogebra.common.i.p:
    double val$eps -> a
    int compare(java.lang.Double,java.lang.Double) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.KernelCAS -> geogebra.common.i.q:
    geogebra.common.kernel.geos.GeoCasCell DependentCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    geogebra.common.kernel.geos.GeoLine Tangent(geogebra.common.kernel.Construction,java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoLine Tangent(geogebra.common.kernel.Construction,java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
geogebra.common.kernel.LayerView -> geogebra.common.i.r:
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
geogebra.common.kernel.Locateable -> geogebra.common.i.s:
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    boolean isAlwaysFixed() -> a
    void setWaitForStartPoint() -> a
    void updateLocation() -> e_
geogebra.common.kernel.LocateableList -> geogebra.common.i.t:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    void registerLocateable(geogebra.common.kernel.Locateable) -> a
    void unregisterLocateable(geogebra.common.kernel.Locateable) -> b
    void doRemove() -> a
geogebra.common.kernel.LocusEquation -> geogebra.common.i.u:
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos -> a
    geogebra.common.kernel.algos.EquationElementInterface buildEquationElementForGeo(geogebra.common.kernel.algos.AlgoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.algos.EquationScopeInterface) -> a
    geogebra.common.kernel.commands.CommandProcessor newCmdLocusEquation(geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos() -> a
geogebra.common.kernel.Macro -> geogebra.common.i.v:
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.String cmdName -> a
    java.lang.String toolName -> b
    java.lang.String toolHelp -> c
    java.lang.String iconFileName -> d
    boolean showInToolBar -> a
    geogebra.common.kernel.Construction macroCons -> a
    geogebra.common.kernel.geos.GeoElement[] macroInput -> a
    geogebra.common.kernel.geos.GeoElement[] macroOutput -> b
    java.lang.String[] macroInputLabels -> a
    java.lang.String[] macroOutputLabels -> b
    geogebra.common.kernel.geos.Test[] inputTypes -> a
    java.util.LinkedList usingAlgos -> a
    boolean copyCaptions -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.kernel.geos.GeoElement[] getMacroInput() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.geos.GeoElement[] getMacroOutput() -> b
    boolean isInMacroConstruction(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.Construction getMacroConstruction() -> a
    void initMacro(geogebra.common.kernel.Construction,java.lang.String[],java.lang.String[]) -> a
    void initInputOutput() -> b
    void initMacro(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void addDependentElement(geogebra.common.kernel.geos.GeoElement,java.util.Set,java.util.Set) -> a
    void addSpecialInputElement(geogebra.common.kernel.geos.GeoElement,java.util.Set) -> a
    java.lang.String buildMacroXML(geogebra.common.kernel.Kernel,java.util.Set) -> a
    geogebra.common.kernel.Construction createMacroConstruction(java.lang.String) -> a
    void registerAlgorithm(geogebra.common.kernel.algos.AlgoMacroInterface) -> a
    void unregisterAlgorithm(geogebra.common.kernel.algos.AlgoMacroInterface) -> b
    boolean isUsed() -> a
    void setUnused() -> a
    geogebra.common.kernel.geos.Test[] getInputTypes() -> a
    java.lang.String getToolHelp() -> a
    java.lang.String getNeededTypesString() -> b
    void setToolHelp(java.lang.String) -> a
    java.lang.String getCommandName() -> c
    void setCommandName(java.lang.String) -> b
    java.lang.String getToolName() -> d
    java.lang.String getToolOrCommandName() -> e
    void setToolName(java.lang.String) -> c
    void setIconFileName(java.lang.String) -> d
    java.lang.String getIconFileName() -> f
    java.lang.String toString() -> toString
    void getXML(java.lang.StringBuilder) -> a
    boolean isShowInToolBar() -> b
    void setShowInToolBar(boolean) -> a
    java.util.ArrayList getUsedMacros() -> a
    java.util.ArrayList getDependentGeos() -> b
    void setCopyCaptionsAndVisibility(boolean) -> b
    boolean isCopyCaptionsAndVisibility() -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.MacroConstruction -> geogebra.common.i.w:
    geogebra.common.kernel.Construction parentCons -> a
    java.util.HashSet reservedLabels -> a
    boolean globalVariableLookup -> a
    void loadXML(java.lang.String) -> h
    void addReservedLabel(java.lang.String) -> i
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    boolean isReservedLabel(java.lang.String) -> c
    void setGlobalVariableLookup(boolean) -> e
geogebra.common.kernel.MacroKernel -> geogebra.common.i.x:
    geogebra.common.kernel.Kernel parentKernel -> a
    geogebra.common.kernel.MacroConstruction macroCons -> a
    boolean isMacroKernel() -> n
    geogebra.common.kernel.Kernel getParentKernel() -> a
    void addReservedLabel(java.lang.String) -> c
    void setGlobalVariableLookup(boolean) -> q
    void loadXML(java.lang.String) -> d
    double getXmax() -> b
    double getXmin() -> c
    double getXscale() -> d
    double getYmax() -> e
    double getYmin() -> f
    double getYscale() -> g
    void addMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.commands.AlgebraProcessor newAlgebraProcessor(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator newExpressionNodeEvaluator() -> a
    geogebra.common.kernel.geos.GeoElement createGeoElement(geogebra.common.kernel.Construction,java.lang.String) -> a
    boolean handleCoords(geogebra.common.kernel.geos.GeoElement,java.util.LinkedHashMap) -> a
    geogebra.common.kernel.GeoGebraCasInterface getGeoGebraCAS() -> a
    boolean isGeoGebraCASready() -> p
    void resetGeoGebraCAS() -> j
    void unbindVariableInGeoGebraCAS(java.lang.String) -> a
    geogebra.common.util.MaxSizeHashMap getCasCache() -> a
    boolean hasCasCache() -> r
geogebra.common.kernel.MacroManager -> geogebra.common.i.y:
    java.util.HashMap macroMap -> a
    java.util.ArrayList macroList -> a
    void addMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    void removeMacro(geogebra.common.kernel.Macro) -> b
    void removeAllMacros() -> a
    void setMacroCommandName(geogebra.common.kernel.Macro,java.lang.String) -> a
    geogebra.common.kernel.Macro getMacro(int) -> a
    int getMacroID(geogebra.common.kernel.Macro) -> a
    void setAllMacrosUnused() -> b
    int getMacroNumber() -> a
    java.util.ArrayList getAllMacros() -> a
    void notifyEuclidianViewCE() -> c
    java.lang.String getMacroXML(java.util.ArrayList) -> a
geogebra.common.kernel.Manager3DInterface -> geogebra.common.i.z:
    geogebra.common.kernel.geos.GeoElement Vector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3DIn(java.lang.String,geogebra.common.kernel.Region,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3D(java.lang.String,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND Segment3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.GeoRayND Ray3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon3D(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.kernelND.Geo3DVec newGeo3DVec(double,double,double) -> a
geogebra.common.kernel.Matrix.CoordMatrix -> geogebra.common.i.a.a:
    double[] val -> a
    int rows -> a
    int columns -> b
    boolean transpose -> a
    boolean isSingular -> b
    geogebra.common.kernel.Matrix.CoordMatrix GgbMatrixOrVector(int,int) -> a
    void initialise(int,int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix Identity(int) -> a
    double[] get() -> a
    double get(int,int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix subMatrix(int,int) -> b
    geogebra.common.kernel.Matrix.Coords getColumn(int) -> a
    void set(geogebra.common.kernel.Matrix.Coords,int) -> a
    void set(geogebra.common.kernel.Matrix.Coords[]) -> a
    void set(int,int,double) -> a
    void set(double) -> a
    void set(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    int getRows() -> a
    int getColumns() -> b
    java.lang.String toString() -> toString
    geogebra.common.kernel.Matrix.CoordMatrix mul(double) -> a
    geogebra.common.kernel.Matrix.CoordMatrix add(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords mul(geogebra.common.kernel.Matrix.Coords) -> a
    double det() -> a
    geogebra.common.kernel.Matrix.CoordMatrix inverse() -> a
    geogebra.common.kernel.Matrix.Coords solve(geogebra.common.kernel.Matrix.Coords) -> b
    void setIsSingular(boolean) -> a
    geogebra.common.kernel.Matrix.Coords getOrigin() -> a
    geogebra.common.kernel.Matrix.Coords getVx() -> b
    geogebra.common.kernel.Matrix.Coords getVy() -> c
    geogebra.common.kernel.Matrix.Coords getVz() -> d
    void setOrigin(geogebra.common.kernel.Matrix.Coords) -> a
    void setVx(geogebra.common.kernel.Matrix.Coords) -> b
    void setVy(geogebra.common.kernel.Matrix.Coords) -> c
    void setVz(geogebra.common.kernel.Matrix.Coords) -> d
geogebra.common.kernel.Matrix.CoordMatrix4x4 -> geogebra.common.i.a.b:
    geogebra.common.kernel.Matrix.CoordMatrix4x4 IDENTITY -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 MIRROR_Y -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 ROTATION_OZ_90 -> c
    geogebra.common.kernel.Matrix.CoordMatrix4x4 ROTATION_OZ_M90 -> d
    geogebra.common.kernel.Matrix.CoordMatrix4x4 Identity() -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 RotationOz(double) -> a
    geogebra.common.kernel.Matrix.Coords[] getOrthoVectors(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 mirrorY() -> b
geogebra.common.kernel.Matrix.CoordMatrixUtil -> geogebra.common.i.a.c:
    geogebra.common.kernel.Matrix.Coords lineEquationVector(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords lineEquationVector(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
geogebra.common.kernel.Matrix.CoordNearest -> geogebra.common.i.a.d:
    geogebra.common.kernel.Matrix.Coords point -> a
    double currentDistance -> a
    geogebra.common.kernel.Matrix.Coords currentNearest -> b
    boolean check(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords get() -> a
geogebra.common.kernel.Matrix.CoordSys -> geogebra.common.i.a.e:
    geogebra.common.kernel.Matrix.CoordMatrix matrix -> a
    int dimension -> a
    int madeCoordSys -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 matrixOrthonormal -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 drawingMatrix -> b
    geogebra.common.kernel.Matrix.Coords equationVector -> a
    geogebra.common.kernel.Matrix.Coords origin -> b
    geogebra.common.kernel.Matrix.Coords[] vectors -> a
    int spaceDimension -> c
    geogebra.common.kernel.Matrix.CoordSys Identity3D() -> a
    void setOrigin(geogebra.common.kernel.Matrix.Coords) -> a
    void setVx(geogebra.common.kernel.Matrix.Coords) -> b
    void setVy(geogebra.common.kernel.Matrix.Coords) -> c
    void setVz(geogebra.common.kernel.Matrix.Coords) -> d
    void setV(geogebra.common.kernel.Matrix.Coords,int) -> a
    geogebra.common.kernel.Matrix.Coords getV(int) -> a
    geogebra.common.kernel.Matrix.Coords getOrigin() -> a
    geogebra.common.kernel.Matrix.Coords getVx() -> b
    geogebra.common.kernel.Matrix.Coords getVy() -> c
    geogebra.common.kernel.Matrix.Coords getVz() -> d
    void setMadeCoordSys(int) -> a
    void resetCoordSys() -> a
    int getMadeCoordSys() -> a
    boolean isMadeCoordSys() -> a
    void addPoint(geogebra.common.kernel.Matrix.Coords) -> e
    void addVectorWithoutCheckMadeCoordSys(geogebra.common.kernel.Matrix.Coords) -> f
    void makeCoordSys(double[]) -> a
    boolean makeOrthoMatrix(boolean,boolean) -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getMatrixOrthonormal() -> a
geogebra.common.kernel.Matrix.Coords -> geogebra.common.i.a.f:
    double norm -> a
    double sqNorm -> b
    boolean calcNorm -> b
    boolean calcSqNorm -> c
    void set(int,double) -> a
    void set(double[]) -> a
    void set(double) -> a
    double get(int) -> a
    double getX() -> b
    double getY() -> c
    double getZ() -> d
    double getLast() -> e
    void setX(double) -> b
    void setY(double) -> c
    void setZ(double) -> d
    void setW(double) -> e
    int getLength() -> c
    geogebra.common.kernel.Matrix.Coords copyVector() -> e
    double dotproduct(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords crossProduct(geogebra.common.kernel.Matrix.Coords) -> c
    void setCrossProduct(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    double norm() -> f
    void calcNorm() -> a
    double getNorm() -> g
    geogebra.common.kernel.Matrix.Coords normalized() -> f
    geogebra.common.kernel.Matrix.Coords normalized(boolean) -> a
    geogebra.common.kernel.Matrix.Coords normalize() -> g
    geogebra.common.kernel.Matrix.Coords normalize(boolean) -> b
    double distance(geogebra.common.kernel.Matrix.Coords) -> b
    geogebra.common.kernel.Matrix.Coords[] projectPlane(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords[] projectLine(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords sub(geogebra.common.kernel.Matrix.Coords) -> d
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> h
    geogebra.common.kernel.Matrix.Coords projectInfDim() -> i
    boolean equalsForKernel(geogebra.common.kernel.Matrix.Coords,double) -> a
    boolean isEqual(geogebra.common.kernel.Matrix.Coords) -> a
    boolean equalsForKernel(double,double) -> a
    geogebra.common.kernel.Matrix.Coords[] completeOrthonormal() -> a
    geogebra.common.kernel.Matrix.Coords add(geogebra.common.kernel.Matrix.Coords) -> e
    geogebra.common.kernel.Matrix.Coords mul(double) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsIn2DView() -> j
    geogebra.common.kernel.Matrix.CoordMatrix mul(double) -> a
geogebra.common.kernel.MatrixTransformable -> geogebra.common.i.A:
    void matrixTransform(double,double,double,double) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
geogebra.common.kernel.ModeSetter -> geogebra.common.i.B:
    geogebra.common.kernel.ModeSetter DOCK_PANEL -> a
    geogebra.common.kernel.ModeSetter TOOLBAR -> b
    geogebra.common.kernel.ModeSetter CAS_VIEW -> c
    geogebra.common.kernel.ModeSetter[] ENUM$VALUES -> a
    geogebra.common.kernel.ModeSetter[] values() -> values
    geogebra.common.kernel.ModeSetter valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.MyPoint -> geogebra.common.i.C:
    double x -> a
    double y -> b
    boolean lineTo -> a
    boolean isEqual(double,double) -> a
    java.lang.String toString() -> toString
    double distance(geogebra.common.kernel.MyPoint) -> a
    geogebra.common.kernel.geos.GeoPoint getGeoPoint(geogebra.common.kernel.Construction) -> a
    boolean getLineTo() -> a
    double getX() -> a
    double getY() -> b
    double distance(double,double) -> a
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.GPoint2D) -> a
geogebra.common.kernel.NameDescriptionComparator -> geogebra.common.i.D:
    int compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.ParametricCurveDistanceFunction -> geogebra.common.i.E:
    double px -> a
    double py -> b
    geogebra.common.kernel.roots.RealRootFunction funX -> a
    geogebra.common.kernel.roots.RealRootFunction funY -> b
    double mint -> c
    double maxt -> d
    void setDistantPoint(double,double) -> a
    double evaluate(double) -> a
geogebra.common.kernel.Path -> geogebra.common.i.F:
geogebra.common.kernel.PathAlgo -> geogebra.common.i.G:
    boolean isChangeable() -> a
geogebra.common.kernel.PathMover -> geogebra.common.i.H:
    void init(geogebra.common.kernel.geos.GeoPoint,int) -> a
    boolean getNext(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean hasNext() -> a
    void resetStartParameter() -> a
    boolean hasPositiveOrientation() -> b
    boolean smallerStep() -> c
    boolean biggerStep() -> d
    void stepBack() -> b
geogebra.common.kernel.PathMoverGeneric -> geogebra.common.i.I:
    int MIN_STEPS_INSTANCE -> a
    geogebra.common.kernel.Path path -> a
    double start_param -> a
    double start_paramUP -> b
    double start_paramDOWN -> c
    double curr_param -> d
    double last_param -> e
    double param_extent -> f
    double min_param -> g
    double max_param -> h
    double max_step_width -> i
    double step_width -> j
    double offset -> k
    int mode -> b
    boolean posOrientation -> a
    boolean maxBorderSet -> b
    boolean minBorderSet -> c
    boolean lastMaxBorderSet -> d
    boolean lastMinBorderSet -> e
    void init(geogebra.common.kernel.geos.GeoPoint,int) -> a
    void init(double) -> a
    void resetStartParameter() -> a
    boolean getNext(geogebra.common.kernel.geos.GeoPoint) -> a
    void calcPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean hasNext() -> a
    boolean hasPositiveOrientation() -> b
    boolean smallerStep() -> c
    boolean biggerStep() -> d
    boolean changeStep(double) -> a
    void stepBack() -> b
geogebra.common.kernel.PathMoverLocus -> geogebra.common.i.J:
    java.util.ArrayList myPointList -> a
    boolean noLineToSet -> f
    boolean lastNoLineToSet -> g
    void init(geogebra.common.kernel.geos.GeoPoint,int) -> a
    void resetStartParameter() -> a
    void calcPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean getNext(geogebra.common.kernel.geos.GeoPoint) -> a
    void stepBack() -> b
    boolean noLineTo(double) -> a
    double borderParam(double) -> a
    boolean hasNext() -> a
geogebra.common.kernel.PathNormalizer -> geogebra.common.i.K:
    geogebra.common.kernel.Path parentPath -> a
    double toParentPathParameter(double,double,double) -> a
    double toNormalizedPathParameter(double,double,double) -> b
    void toParentPathParameter(geogebra.common.kernel.PathParameter) -> a
    void toNormalizedPathParameter(geogebra.common.kernel.PathParameter) -> b
    double infFunction(double) -> a
    double inverseInfFunction(double) -> b
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> w_
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.PathOrPoint -> geogebra.common.i.L:
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> w_
    geogebra.common.kernel.PathMover createPathMover() -> a
geogebra.common.kernel.PathParameter -> geogebra.common.i.M:
    double t -> a
    int pathType -> a
    void set(geogebra.common.kernel.PathParameter) -> a
    int getPathType() -> a
    void setPathType(int) -> a
    double getT() -> a
    void setT(double) -> a
geogebra.common.kernel.PathRegionHandling -> geogebra.common.i.N:
    geogebra.common.kernel.PathRegionHandling OFF -> a
    geogebra.common.kernel.PathRegionHandling ON -> b
    geogebra.common.kernel.PathRegionHandling AUTO -> c
    java.lang.String xml -> a
    geogebra.common.kernel.PathRegionHandling[] ENUM$VALUES -> a
    java.lang.String getXML() -> a
    geogebra.common.kernel.PathRegionHandling parse(java.lang.String) -> a
    geogebra.common.kernel.PathRegionHandling[] values() -> values
    geogebra.common.kernel.PathRegionHandling valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.PointPair -> geogebra.common.i.O:
    int indexP -> a
    boolean isPalive -> a
    int indexQ -> b
    boolean isQonPath -> b
    double dist -> a
    geogebra.common.kernel.PointPair next -> a
geogebra.common.kernel.PointPairList -> geogebra.common.i.P:
    geogebra.common.kernel.PointPair head -> a
    int size -> a
    boolean isStrict -> a
    boolean isEmpty() -> a
    void clear() -> a
    void insertPointPair(int,boolean,int,boolean,double) -> a
    boolean smallerThan(geogebra.common.kernel.PointPair,geogebra.common.kernel.PointPair) -> a
    boolean smallerThan2(geogebra.common.kernel.PointPair,geogebra.common.kernel.PointPair) -> b
    void removeAllPairs(geogebra.common.kernel.PointPair) -> a
    geogebra.common.kernel.PointPair getHead() -> a
    int size() -> a
    int getClosestPWithindexQ(int) -> a
    int getClosestQWithindexP(int) -> b
geogebra.common.kernel.Region -> geogebra.common.i.Q:
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean isInRegion(double,double) -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.RegionParameters -> geogebra.common.i.R:
    double t1 -> a
    double t2 -> b
    geogebra.common.kernel.Matrix.Coords normal -> a
    boolean isOnPath -> a
    double getT1() -> a
    void setT1(double) -> a
    double getT2() -> b
    void setT2(double) -> b
    boolean isNaN(double) -> a
    void setIsOnPath(boolean) -> a
    boolean isOnPath() -> a
geogebra.common.kernel.Relation -> geogebra.common.i.S:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    java.lang.String relation(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoSegment,geogebra.common.kernel.geos.GeoSegment) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoVector) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPolygon) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.Path) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoConicPart,geogebra.common.kernel.geos.GeoConicPart) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String equalityString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> a
    java.lang.String linDependencyString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> b
    java.lang.String incidenceString(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoElement,boolean) -> a
    java.lang.String incidencePerimeterString(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoElement,boolean) -> b
    java.lang.String parallelString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> b
    java.lang.String perpendicularString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> c
    java.lang.String intersectString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> c
    java.lang.String lineConicString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,int) -> a
    java.lang.String getPlainNumerical(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlainNumerical(java.lang.String,java.lang.String) -> a
geogebra.common.kernel.RestrictionAlgoForLocusEquation -> geogebra.common.i.T:
geogebra.common.kernel.SetRandomValue -> geogebra.common.i.U:
    void setRandomValue(double) -> a
geogebra.common.kernel.SliderMover -> geogebra.common.i.V:
    geogebra.common.kernel.geos.GeoNumeric slider -> a
    void init(geogebra.common.kernel.geos.GeoNumeric) -> a
    void init(double) -> a
    boolean getNext(geogebra.common.kernel.geos.GeoNumeric) -> a
    void calcPoint(geogebra.common.kernel.geos.GeoNumeric) -> b
geogebra.common.kernel.StringTemplate -> geogebra.common.i.W:
    geogebra.common.kernel.StringTemplate noLocalDefault -> a
    geogebra.common.kernel.StringTemplate prefixedDefault -> b
    geogebra.common.kernel.StringTemplate defaultTemplate -> c
    geogebra.common.kernel.StringTemplate latexTemplate -> d
    geogebra.common.kernel.StringTemplate mathmlTemplate -> e
    geogebra.common.kernel.StringTemplate libreofficeTemplate -> f
    geogebra.common.kernel.StringTemplate casTemplate -> g
    geogebra.common.kernel.StringTemplate xmlTemplate -> h
    geogebra.common.kernel.StringTemplate editTemplate -> i
    geogebra.common.kernel.StringTemplate regression -> j
    geogebra.common.kernel.StringTemplate ogpTemplate -> k
    geogebra.common.kernel.StringTemplate maxPrecision -> l
    geogebra.common.kernel.StringTemplate numericDefault -> m
    geogebra.common.kernel.StringTemplate numericNoLocal -> n
    geogebra.common.kernel.StringTemplate numericLatex -> o
    geogebra.common.kernel.StringTemplate testTemplate -> p
    geogebra.common.kernel.StringTemplate testNumeric -> q
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType stringType -> a
    boolean internationalizeDigits -> a
    java.lang.String casPrintFormPI -> a
    geogebra.common.util.ScientificFormatAdapter sf -> a
    geogebra.common.util.NumberFormatAdapter nf -> a
    boolean forceSF -> b
    boolean forceNF -> c
    boolean allowMoreDigits -> d
    boolean localizeCmds -> e
    boolean usePrefix -> f
    double[] precisions -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getStringType() -> a
    boolean internationalizeDigits() -> a
    java.lang.String getPi() -> a
    geogebra.common.kernel.StringTemplate get(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    void setType(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    boolean useScientific(boolean) -> a
    boolean hasType(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    geogebra.common.kernel.StringTemplate printDecimals(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,int,boolean) -> a
    geogebra.common.kernel.StringTemplate printFigures(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,int,boolean) -> b
    geogebra.common.kernel.StringTemplate fullFigures(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> b
    geogebra.common.kernel.StringTemplate printScientific(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,int,boolean) -> c
    geogebra.common.util.ScientificFormatAdapter getSF(geogebra.common.util.ScientificFormatAdapter) -> a
    geogebra.common.util.NumberFormatAdapter getNF(geogebra.common.util.NumberFormatAdapter) -> a
    boolean isPrintLocalizedCommandNames() -> b
    int getCoordStyle(int) -> a
    boolean isUseTempVariablePrefix() -> c
    boolean allowsRoundHack(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.util.ScientificFormatAdapter) -> a
    boolean allowMoreDigits() -> d
    double getPrecision(geogebra.common.util.NumberFormatAdapter) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.StringTemplate$1 -> geogebra.common.i.X:
    boolean allowsRoundHack(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.util.ScientificFormatAdapter) -> a
geogebra.common.kernel.StringTemplate$2 -> geogebra.common.i.Y:
    int getCoordStyle(int) -> a
geogebra.common.kernel.SystemOfEquationsSolver -> geogebra.common.i.Z:
    double epsilon -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    int solveSystemOfQuadraticEquations(double[],double[],double[][]) -> a
geogebra.common.kernel.Transform -> geogebra.common.i.aa:
    geogebra.common.kernel.Construction cons -> a
    java.lang.String transformedGeoLabel(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement doTransform(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] transform(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] transformPoly(java.lang.String,geogebra.common.kernel.geos.GeoPoly,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] transformPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoConic getTransformedConic(geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement getTransformedLine(geogebra.common.kernel.kernelND.GeoLineND) -> a
    boolean isAffine() -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformDilate -> geogebra.common.i.ab:
    geogebra.common.kernel.arithmetic.NumberValue ratio -> a
    geogebra.common.kernel.geos.GeoPoint center -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.TransformMirror -> geogebra.common.i.ac:
    geogebra.common.kernel.geos.GeoElement mirror -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isAffine() -> a
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformRotate -> geogebra.common.i.ad:
    geogebra.common.kernel.geos.GeoPoint center -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.TransformShearOrStretch -> geogebra.common.i.ae:
    boolean shear -> a
    geogebra.common.kernel.geos.GeoVec3D line -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformTranslate -> geogebra.common.i.af:
    geogebra.common.kernel.geos.GeoVec3D transVec -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.UndoManager -> geogebra.common.i.ag:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Construction construction -> a
    java.util.LinkedList undoInfoList -> a
    java.util.ListIterator iterator -> a
    void processXML(java.lang.String) -> a
    void undo() -> a
    void redo() -> b
    void updateUndoActions() -> c
    geogebra.common.kernel.UndoManager$AppState getCurrentUndoInfo() -> a
    void storeUndoInfo() -> d
    void restoreCurrentUndoInfo() -> e
    void initUndoInfo() -> f
    boolean undoPossible() -> a
    boolean redoPossible() -> b
    void storeUndoInfoAfterPasteOrAdd() -> g
    void storeUndoInfo(boolean) -> a
    void loadUndoInfo(geogebra.common.kernel.UndoManager$AppState) -> a
    void clearUndoInfo() -> h
    void pruneStateList() -> i
geogebra.common.kernel.UndoManager$AppState -> geogebra.common.i.ag$a:
    void delete() -> a
geogebra.common.kernel.UpdateLocationView -> geogebra.common.i.ah:
    void updateLocation(geogebra.common.kernel.geos.GeoElement) -> g
geogebra.common.kernel.UserAwarenessListener -> geogebra.common.i.ai:
    void addMacro(geogebra.common.kernel.Macro) -> a
    void removeMacro(geogebra.common.kernel.Macro) -> b
    void removeAllMacros() -> a
    void setMacroCommandName(geogebra.common.kernel.Macro,java.lang.String) -> a
    void fileLoading() -> b
    void fileLoadComplete() -> c
geogebra.common.kernel.VarString -> geogebra.common.i.aj:
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.View -> geogebra.common.i.ak:
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void repaintView() -> b
    void reset() -> g
    void clearView() -> d
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    int getViewID() -> a
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    boolean isShowing() -> isShowing
geogebra.common.kernel.advanced.AlgoAffineRatio -> geogebra.common.i.b.a:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoNumeric M -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoApplyMatrix -> geogebra.common.i.b.b:
    geogebra.common.kernel.MatrixTransformable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoList matrix -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    boolean swapOrientation(boolean) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
geogebra.common.kernel.advanced.AlgoAsymptote -> geogebra.common.i.b.c:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] asymptotes -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    double[] halfAxes -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getAsymptotes() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoAxisFirst -> geogebra.common.i.b.d:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine axis -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getAxis() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoAxisFirstLength -> geogebra.common.i.b.e:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoAxisSecond -> geogebra.common.i.b.f:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine axis -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getAxis() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoAxisSecondLength -> geogebra.common.i.b.g:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoAxisStepX -> geogebra.common.i.b.h:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean euclidianViewUpdate() -> b
    void compute() -> b
geogebra.common.kernel.advanced.AlgoAxisStepY -> geogebra.common.i.b.i:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean euclidianViewUpdate() -> b
    void compute() -> b
geogebra.common.kernel.advanced.AlgoCentroidPolygon -> geogebra.common.i.b.j:
    geogebra.common.kernel.geos.GeoPolygon p -> a
    geogebra.common.kernel.geos.GeoPoint centroid -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoClosestPointLines -> geogebra.common.i.b.k:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoCommonDenominator -> geogebra.common.i.b.l:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoCompleteSquare -> geogebra.common.i.b.m:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction square -> b
    geogebra.common.kernel.arithmetic.FunctionVariable fv -> a
    geogebra.common.kernel.arithmetic.MyDouble a -> a
    geogebra.common.kernel.arithmetic.MyDouble h -> b
    geogebra.common.kernel.arithmetic.MyDouble k -> c
    int lastDeg -> a
    geogebra.common.kernel.cas.AlgoCoefficients algoCoef -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoComplexRootsPolynomial -> geogebra.common.i.b.n:
    double[] curComplexRoots -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void computeComplexRoots() -> f
    void calcComplexRoots(geogebra.common.kernel.arithmetic.Function) -> a
    void addToCurrentRoots(double[],double[],int) -> a
    void setRootPoints(double[],double[],int) -> b
geogebra.common.kernel.advanced.AlgoConstructionStep -> geogebra.common.i.b.o:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean wantsConstructionProtocolUpdate() -> c_
    void compute() -> b
geogebra.common.kernel.advanced.AlgoContinuedFraction -> geogebra.common.i.b.p:
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.arithmetic.NumberValue level -> b
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoBoolean shorthand -> a
    long[] denominators -> a
    java.lang.StringBuilder sb -> b
    boolean dotsNeeded -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    void appendLongLatex(int,geogebra.common.kernel.StringTemplate) -> a
    int DecimalToFraction(double,double,long[],int) -> a
    boolean isLaTeXTextCommand() -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.advanced.AlgoCrossRatio -> geogebra.common.i.b.q:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoPoint D -> d
    geogebra.common.kernel.geos.GeoNumeric M -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoCurvature -> geogebra.common.i.b.r:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoNumeric K -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.advanced.AlgoCurvatureCurve -> geogebra.common.i.b.s:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoNumeric K -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoCurvatureVector -> geogebra.common.i.b.t:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction f1 -> b
    geogebra.common.kernel.geos.GeoFunction f2 -> c
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.advanced.AlgoCurvatureVectorCurve -> geogebra.common.i.b.u:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f1 -> b
    geogebra.common.kernel.geos.GeoCurveCartesian f2 -> c
    geogebra.common.kernel.geos.GeoVector v -> a
    double[] f1eval -> a
    double[] f2eval -> b
    geogebra.common.kernel.cas.AlgoDerivative algoCAS -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.advanced.AlgoDeterminant -> geogebra.common.i.b.v:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoDimension -> geogebra.common.i.b.w:
    geogebra.common.kernel.geos.GeoList matrixDimension -> a
    geogebra.common.kernel.geos.GeoNumeric firstDimension -> a
    geogebra.common.kernel.geos.GeoNumeric secondDimension -> b
    boolean matrix -> c
    geogebra.common.kernel.geos.GeoList list -> b
    geogebra.common.kernel.geos.GeoElement point -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoDirectrix -> geogebra.common.i.b.x:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine directrix -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getDirectrix() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoDivision -> geogebra.common.i.b.y:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.geos.GeoNumeric mod -> b
    geogebra.common.kernel.geos.GeoList result -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.advanced.AlgoDivisorsList -> geogebra.common.i.b.z:
    geogebra.common.kernel.geos.GeoList result -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.cas.AlgoPrimeFactorization factors -> a
    geogebra.common.kernel.geos.GeoList factorList -> b
    java.util.List factList -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
geogebra.common.kernel.advanced.AlgoDivisorsSum -> geogebra.common.i.b.A:
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.cas.AlgoPrimeFactorization factors -> a
    geogebra.common.kernel.geos.GeoList factorList -> a
    boolean sum -> c
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoDynamicCoordinates -> geogebra.common.i.b.B:
    geogebra.common.kernel.arithmetic.NumberValue x -> a
    geogebra.common.kernel.arithmetic.NumberValue y -> b
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoPoint M -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.geos.GeoPoint getParentPoint() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoEccentricity -> geogebra.common.i.b.C:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getEccentricity() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoExcentricity -> geogebra.common.i.b.D:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLinearEccentricity() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoFlatten -> geogebra.common.i.b.E:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void flatten(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoFromBase -> geogebra.common.i.b.F:
    geogebra.common.kernel.arithmetic.NumberValue base -> a
    geogebra.common.kernel.geos.GeoText number -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoFunctionInvert -> geogebra.common.i.b.G:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    geogebra.common.plugin.Operation inverse(geogebra.common.plugin.Operation) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.advanced.AlgoIdentity -> geogebra.common.i.b.H:
    geogebra.common.kernel.geos.GeoNumberValue n -> a
    geogebra.common.kernel.geos.GeoList result -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoList getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoIncircle -> geogebra.common.i.b.I:
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoPointND C -> c
    geogebra.common.kernel.kernelND.GeoConicND circle -> a
    geogebra.common.kernel.geos.GeoLine bisectorC -> a
    geogebra.common.kernel.geos.GeoLine bisectorB -> b
    geogebra.common.kernel.geos.GeoLine sideBC -> c
    geogebra.common.kernel.geos.GeoLine heightBC -> d
    geogebra.common.kernel.geos.GeoPoint heightFoot -> a
    geogebra.common.kernel.geos.GeoPoint incenter -> b
    geogebra.common.kernel.geos.GeoPoint A1 -> c
    geogebra.common.kernel.geos.GeoPoint B1 -> d
    geogebra.common.kernel.geos.GeoPoint C1 -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoConicND getCircle() -> a
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoPoint getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoIndexOf -> geogebra.common.i.b.J:
    geogebra.common.kernel.geos.GeoElement hayStack -> a
    geogebra.common.kernel.geos.GeoElement needle -> b
    geogebra.common.kernel.geos.GeoNumeric index -> a
    geogebra.common.kernel.arithmetic.NumberValue start -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoInsert -> geogebra.common.i.b.K:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int insertPoint -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoInvert -> geogebra.common.i.b.L:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoIsInRegion -> geogebra.common.i.b.M:
    geogebra.common.kernel.kernelND.GeoPointND pi -> a
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.geos.GeoBoolean result -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoIsPrime -> geogebra.common.i.b.N:
    geogebra.common.kernel.geos.GeoBoolean result -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
geogebra.common.kernel.advanced.AlgoLeftRightSide -> geogebra.common.i.b.O:
    geogebra.common.kernel.geos.GeoElement equation -> a
    geogebra.common.kernel.geos.GeoFunctionNVar side -> a
    boolean left -> c
    geogebra.common.kernel.arithmetic.FunctionVariable[] fv -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoFunctionNVar getResult() -> a
geogebra.common.kernel.advanced.AlgoMatrixRank -> geogebra.common.i.b.P:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric rank -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.advanced.AlgoMaximize -> geogebra.common.i.b.Q:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoMinimize -> geogebra.common.i.b.R:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoOptimize -> geogebra.common.i.b.S:
    geogebra.common.kernel.Construction optCons -> b
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.optimization.RealRootFunctionVariable i_am_not_a_real_function -> a
    geogebra.common.kernel.geos.GeoElement dep -> a
    geogebra.common.kernel.geos.GeoNumeric indep -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType type -> a
    boolean isrunning -> c
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType -> geogebra.common.i.b.S$a:
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType MINIMIZE -> a
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType MAXIMIZE -> b
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType[] ENUM$VALUES -> a
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType[] values() -> values
    geogebra.common.kernel.advanced.AlgoOptimize$OptimizationType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.advanced.AlgoOrdinal -> geogebra.common.i.b.T:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoOsculatingCircle -> geogebra.common.i.b.U:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint R -> b
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoNumeric curv -> a
    geogebra.common.kernel.geos.GeoConic circle -> a
    geogebra.common.kernel.advanced.AlgoCurvature algo -> a
    geogebra.common.kernel.advanced.AlgoCurvatureVector cv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.advanced.AlgoOsculatingCircleCurve -> geogebra.common.i.b.V:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint R -> b
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoNumeric curv -> a
    geogebra.common.kernel.geos.GeoConic circle -> a
    geogebra.common.kernel.advanced.AlgoCurvatureCurve algo -> a
    geogebra.common.kernel.advanced.AlgoCurvatureVectorCurve cv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.advanced.AlgoParabolaParameter -> geogebra.common.i.b.W:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getParameter() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoPathParameter -> geogebra.common.i.b.X:
    geogebra.common.kernel.geos.GeoPoint point -> a
    geogebra.common.kernel.geos.GeoNumeric value -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.advanced.AlgoPrimeFactors -> geogebra.common.i.b.Y:
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    double LARGEST_INTEGER -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.advanced.AlgoReducedRowEchelonForm -> geogebra.common.i.b.Z:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoRotateText -> geogebra.common.i.b.aa:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    geogebra.common.kernel.geos.GeoNumeric angle -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    void appendRotatedText(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoText,double) -> a
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.advanced.AlgoScientificText -> geogebra.common.i.b.ab:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.arithmetic.NumberValue precision -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.advanced.AlgoSelectedElement -> geogebra.common.i.b.ac:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement element -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoSelectedIndex -> geogebra.common.i.b.ad:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric index -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoSlopeField -> geogebra.common.i.b.ae:
    geogebra.common.kernel.arithmetic.FunctionalNVar func -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric lengthRatio -> b
    geogebra.common.kernel.geos.GeoNumeric minX -> c
    geogebra.common.kernel.geos.GeoNumeric minY -> d
    geogebra.common.kernel.geos.GeoNumeric maxX -> e
    geogebra.common.kernel.geos.GeoNumeric maxY -> f
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    geogebra.common.kernel.algos.AlgoNumerator numAlgo -> a
    geogebra.common.kernel.algos.AlgoDenominator denAlgo -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar num -> b
    geogebra.common.kernel.arithmetic.FunctionalNVar den -> c
    boolean quotient -> c
    geogebra.common.euclidian.EuclidianView mainView -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    void drawLine(double,double,double,double,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void remove() -> c
geogebra.common.kernel.advanced.AlgoStepObject -> geogebra.common.i.b.af:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean wantsConstructionProtocolUpdate() -> c_
    void compute() -> b
geogebra.common.kernel.advanced.AlgoTaylorSeries -> geogebra.common.i.b.ag:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement ngeo -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.AlgoToBase -> geogebra.common.i.b.ah:
    geogebra.common.kernel.arithmetic.NumberValue base -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> b
    geogebra.common.kernel.geos.GeoText result -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.advanced.AlgoToComplexPolar -> geogebra.common.i.b.ai:
    int coordStyle -> a
    geogebra.common.kernel.geos.GeoPoint inPoint -> a
    geogebra.common.kernel.geos.GeoVector inVector -> a
    geogebra.common.kernel.geos.GeoPoint outPoint -> b
    geogebra.common.kernel.geos.GeoList inList -> a
    geogebra.common.kernel.geos.GeoVector outVector -> b
    void init(int,geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.advanced.AlgoTranspose -> geogebra.common.i.b.aj:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoUnion -> geogebra.common.i.b.ak:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList inputList2 -> b
    geogebra.common.kernel.geos.GeoList outputList -> c
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void addToOutputList(geogebra.common.kernel.geos.GeoElement) -> d
geogebra.common.kernel.advanced.AlgoUnique -> geogebra.common.i.b.al:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList uniqueList -> b
    org.apache.commons.math.stat.Frequency f -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.advanced.AlgoVerticalText -> geogebra.common.i.b.am:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint startPointCopy -> b
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.advanced.AlgoZip -> geogebra.common.i.b.an:
    geogebra.common.kernel.geos.GeoElement expression -> a
    geogebra.common.kernel.geos.GeoElement[] vars -> b
    int varCount -> a
    geogebra.common.kernel.geos.GeoList[] over -> a
    geogebra.common.kernel.geos.GeoList list -> a
    int last_length -> b
    boolean expIsFunctionOrCurve -> c
    boolean isEmpty -> d
    geogebra.common.kernel.algos.AlgoElement expressionParentAlgo -> a
    boolean updateRunning -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a
    void compute() -> b
    void createNewList() -> e
    void addElement(int) -> a
    geogebra.common.kernel.geos.GeoElement createNewListElement() -> a
    void updateListItems() -> f
    int minOverSize() -> c
    void updateLocalVar(int) -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.advanced.CmdAffineRatio -> geogebra.common.i.b.ao:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdApplyMatrix -> geogebra.common.i.b.ap:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] ApplyMatrix(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.advanced.CmdAsymptote -> geogebra.common.i.b.aq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdAttachCopyToView -> geogebra.common.i.b.ar:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdAxes -> geogebra.common.i.b.as:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdAxisStepX -> geogebra.common.i.b.at:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdAxisStepY -> geogebra.common.i.b.au:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdCentroid -> geogebra.common.i.b.av:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdClosestPoint -> geogebra.common.i.b.aw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPoint ClosestPoint(java.lang.String,geogebra.common.kernel.Path,geogebra.common.kernel.geos.GeoPoint) -> a
geogebra.common.kernel.advanced.CmdCommonDenominator -> geogebra.common.i.b.ax:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdCompleteSquare -> geogebra.common.i.b.ay:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdComplexRoot -> geogebra.common.i.b.az:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdConstructionStep -> geogebra.common.i.b.aA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdContinuedFraction -> geogebra.common.i.b.aB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText ContinuedFraction(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
geogebra.common.kernel.advanced.CmdCrossRatio -> geogebra.common.i.b.aC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdCurvature -> geogebra.common.i.b.aD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdCurvatureVector -> geogebra.common.i.b.aE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdDenominator -> geogebra.common.i.b.aF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdDeterminant -> geogebra.common.i.b.aG:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.advanced.CmdDimension -> geogebra.common.i.b.aH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdDirection -> geogebra.common.i.b.aI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoVector Direction(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> a
geogebra.common.kernel.advanced.CmdDirectrix -> geogebra.common.i.b.aJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdDivision -> geogebra.common.i.b.aK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdDivisorsList -> geogebra.common.i.b.aL:
    geogebra.common.kernel.geos.GeoElement getResult(geogebra.common.kernel.arithmetic.NumberValue,java.lang.String) -> a
geogebra.common.kernel.advanced.CmdDivisorsOrDivisorsSum -> geogebra.common.i.b.aM:
    boolean sum -> a
    geogebra.common.kernel.geos.GeoElement getResult(geogebra.common.kernel.arithmetic.NumberValue,java.lang.String) -> a
geogebra.common.kernel.advanced.CmdDynamicCoordinates -> geogebra.common.i.b.aN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdEccentricity -> geogebra.common.i.b.aO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdExcentricity -> geogebra.common.i.b.aP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdFactors -> geogebra.common.i.b.aQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdFirstAxis -> geogebra.common.i.b.aR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdFirstAxisLength -> geogebra.common.i.b.aS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdFlatten -> geogebra.common.i.b.aT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdFromBase -> geogebra.common.i.b.aU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIdentity -> geogebra.common.i.b.aV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdImplicitPoly -> geogebra.common.i.b.aW:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIncircle -> geogebra.common.i.b.aX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIndexOf -> geogebra.common.i.b.aY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdInsert -> geogebra.common.i.b.aZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIntersectRegion -> geogebra.common.i.b.ba:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIntersection -> geogebra.common.i.b.bb:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdInvert -> geogebra.common.i.b.bc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIsInRegion -> geogebra.common.i.b.bd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIsPrime -> geogebra.common.i.b.be:
    geogebra.common.kernel.geos.GeoElement getResult(geogebra.common.kernel.arithmetic.NumberValue,java.lang.String) -> a
geogebra.common.kernel.advanced.CmdIteration -> geogebra.common.i.b.bf:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdIterationList -> geogebra.common.i.b.bg:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdLeftRightSide -> geogebra.common.i.b.bh:
    boolean left -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdMatrixRank -> geogebra.common.i.b.bi:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdMaximize -> geogebra.common.i.b.bj:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdMinimize -> geogebra.common.i.b.bk:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdNumerator -> geogebra.common.i.b.bl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdOrdinal -> geogebra.common.i.b.bm:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdOsculatingCircle -> geogebra.common.i.b.bn:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdParameter -> geogebra.common.i.b.bo:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdPathParameter -> geogebra.common.i.b.bp:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdPolar -> geogebra.common.i.b.bq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoLine PolarLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoConic) -> a
geogebra.common.kernel.advanced.CmdPrimeFactors -> geogebra.common.i.b.br:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdReducedRowEchelonForm -> geogebra.common.i.b.bs:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.advanced.CmdRootList -> geogebra.common.i.b.bt:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.advanced.CmdRoots -> geogebra.common.i.b.bu:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdRotateText -> geogebra.common.i.b.bv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdScientificText -> geogebra.common.i.b.bw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText ScientificText(java.lang.String,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.advanced.CmdSecondAxis -> geogebra.common.i.b.bx:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdSecondAxisLength -> geogebra.common.i.b.by:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdSelectedElement -> geogebra.common.i.b.bz:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdSelectedIndex -> geogebra.common.i.b.bA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdSlopeField -> geogebra.common.i.b.bB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoLocus SlopeField(java.lang.String,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.advanced.CmdTaylorSeries -> geogebra.common.i.b.bC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdToBase -> geogebra.common.i.b.bD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdToComplexPolar -> geogebra.common.i.b.bE:
    int coordStyle -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdTranspose -> geogebra.common.i.b.bF:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.advanced.CmdUnion -> geogebra.common.i.b.bG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdUnique -> geogebra.common.i.b.bH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdVerticalText -> geogebra.common.i.b.bI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.CmdZip -> geogebra.common.i.b.bJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.advanced.TransformApplyMatrix -> geogebra.common.i.b.bK:
    geogebra.common.kernel.geos.GeoList matrix -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.algos.AlgoAngleConic -> geogebra.common.i.c.a:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngleLines -> geogebra.common.i.c.b:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.AlgoAngleLines copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> a
    geogebra.common.kernel.geos.GeoLine geth() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoAngleNumeric -> geogebra.common.i.c.c:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAnglePoints -> geogebra.common.i.c.d:
    geogebra.common.kernel.kernelND.GeoPointND An -> a
    geogebra.common.kernel.kernelND.GeoPointND Bn -> b
    geogebra.common.kernel.kernelND.GeoPointND Cn -> c
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.Matrix.Coords STANDARD_VN -> a
    geogebra.common.kernel.algos.AlgoAnglePolygon algoAnglePoly -> a
    double bx -> a
    double by -> b
    double vx -> c
    double vy -> d
    double wx -> e
    double wy -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoAngle newGeoAngle(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.AlgoAnglePoints copy() -> a
    void setInputOutput() -> a
    void remove() -> c
    int getConstructionIndex() -> b
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.kernelND.GeoPointND getA() -> a
    geogebra.common.kernel.kernelND.GeoPointND getB() -> b
    geogebra.common.kernel.kernelND.GeoPointND getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoAnglePolygon -> geogebra.common.i.c.e:
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputAngles -> a
    geogebra.common.kernel.algos.AlgoAnglePoints algoAngle -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getAngles() -> b
    geogebra.common.kernel.geos.GeoPolygon getPolygon() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
geogebra.common.kernel.algos.AlgoAnglePolygon$1 -> geogebra.common.i.c.f:
    geogebra.common.kernel.algos.AlgoAnglePolygon this$0 -> a
    geogebra.common.kernel.geos.GeoAngle newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoAngleVector -> geogebra.common.i.c.g:
    geogebra.common.kernel.geos.GeoVec3D vec -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    double[] coords -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoVec3D getVec3D() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngleVectors -> geogebra.common.i.c.h:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector w -> b
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoVector getv() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngularBisectorLines -> geogebra.common.i.c.i:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoLine[] bisector -> a
    double gx -> a
    double gy -> b
    double hx -> c
    double hy -> d
    double wx -> e
    double wy -> f
    double bx -> g
    double by -> h
    double lenH -> i
    double lenG -> j
    double length -> k
    double ip -> l
    geogebra.common.kernel.geos.GeoVector[] wv -> a
    geogebra.common.kernel.geos.GeoPoint B -> a
    boolean infiniteB -> c
    int index -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getLines() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> a
    geogebra.common.kernel.geos.GeoLine geth() -> b
    geogebra.common.kernel.geos.GeoPoint getB() -> a
    boolean isNearToAlgorithm() -> d
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoAngularBisectorPoints -> geogebra.common.i.c.j:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoLine bisector -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    geogebra.common.kernel.geos.GeoLine h -> c
    geogebra.common.kernel.geos.GeoVector wv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoPoint getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoAppend -> geogebra.common.i.c.k:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int order -> b
    int ADD_OBJECT_AT_START -> c
    int ADD_OBJECT_AT_END -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoArcLength -> geogebra.common.i.c.l:
    geogebra.common.kernel.geos.GeoConicPart arc -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArcLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAreaConic -> geogebra.common.i.c.m:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAreaPoints -> geogebra.common.i.c.n:
    geogebra.common.kernel.geos.GeoPoint[] P -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAreaPolygon -> geogebra.common.i.c.o:
    geogebra.common.kernel.geos.GeoPolygon polygon -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAttachCopyToView -> geogebra.common.i.c.p:
    geogebra.common.kernel.MatrixTransformable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.arithmetic.NumberValue viewID -> a
    geogebra.common.kernel.kernelND.GeoPointND corner1 -> a
    geogebra.common.kernel.kernelND.GeoPointND corner3 -> b
    geogebra.common.kernel.kernelND.GeoPointND screenCorner1 -> c
    geogebra.common.kernel.kernelND.GeoPointND screenCorner3 -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void transformFunction(double,double,double,double) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    boolean swapOrientation(boolean) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    void setEV(int) -> a
geogebra.common.kernel.algos.AlgoAxes -> geogebra.common.i.c.q:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] axes -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getAxes() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoBarChart -> geogebra.common.i.c.r:
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue p1 -> c
    geogebra.common.kernel.arithmetic.NumberValue p2 -> d
    geogebra.common.kernel.arithmetic.NumberValue p3 -> e
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoElement ngeo -> c
    geogebra.common.kernel.geos.GeoElement widthGeo -> d
    geogebra.common.kernel.geos.GeoElement isCumulative -> e
    geogebra.common.kernel.geos.GeoElement isHorizontal -> f
    geogebra.common.kernel.geos.GeoElement p1geo -> g
    geogebra.common.kernel.geos.GeoElement p2geo -> h
    geogebra.common.kernel.geos.GeoElement p3geo -> i
    geogebra.common.kernel.geos.GeoElement hasJoin -> j
    geogebra.common.kernel.geos.GeoElement pointType -> k
    int type -> a
    int N -> b
    double[] yval -> a
    double[] leftBorder -> b
    java.lang.String[] value -> a
    double barWidth -> a
    double freqMax -> b
    boolean isAreaSum -> c
    geogebra.common.kernel.advanced.AlgoUnique algoUnique -> a
    geogebra.common.kernel.statistics.AlgoFrequency algoFreq -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoNumeric getSum() -> a
    geogebra.common.kernel.geos.GeoElement getIsCumulative() -> a
    double getFreqMax() -> a
    double[] getYValue() -> a
    double[] getLeftBorder() -> b
    java.lang.String[] getValue() -> a
    int getType() -> c
    geogebra.common.kernel.arithmetic.NumberValue getA() -> a
    geogebra.common.kernel.arithmetic.NumberValue getB() -> b
    double[] getValues() -> c
    geogebra.common.kernel.geos.GeoNumeric getN() -> b
    int getIntervals() -> d
    double getWidth() -> b
    geogebra.common.kernel.arithmetic.NumberValue getP1() -> c
    geogebra.common.kernel.arithmetic.NumberValue getP2() -> d
    geogebra.common.kernel.arithmetic.NumberValue getP3() -> e
    int getDrawType() -> e
    boolean hasPoints() -> f
    int getPointType() -> f
    void compute() -> b
    void computeWithExp() -> d
    void computeWithRawData() -> e
    void computeWithFrequency() -> f
    void computeFromValueFrequencyLists(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    void computeFromPointList(geogebra.common.kernel.geos.GeoList) -> a
    boolean prepareDistributionLists() -> n
    void loadDistributionLists(int,int,org.apache.commons.math.distribution.IntegerDistribution) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
    void remove() -> c
geogebra.common.kernel.algos.AlgoBinomial -> geogebra.common.i.c.s:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoBoxPlot -> geogebra.common.i.c.t:
    int type -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoElement minGeo -> c
    geogebra.common.kernel.geos.GeoElement Q1geo -> d
    geogebra.common.kernel.geos.GeoElement medianGeo -> e
    geogebra.common.kernel.geos.GeoElement Q3geo -> f
    geogebra.common.kernel.geos.GeoElement maxGeo -> g
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.geos.GeoBoolean useOutliersGeo -> a
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    java.util.ArrayList tempList -> a
    int N -> b
    double[] yval -> a
    double[] leftBorder -> b
    java.util.ArrayList outliers -> b
    geogebra.common.kernel.arithmetic.NumberValue getB() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoBoxPlot copy() -> a
    void compute() -> b
    void calcBoxPlot() -> e
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getSum() -> a
    double[] getLeftBorders() -> a
    java.util.ArrayList getOutliers() -> a
    void addOutlier(double) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoCasBase -> geogebra.common.i.c.u:
    geogebra.common.kernel.geos.CasEvaluableFunction f -> a
    geogebra.common.kernel.geos.CasEvaluableFunction g -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void clearCasEvalMap(java.lang.String) -> a
geogebra.common.kernel.algos.AlgoCenterConic -> geogebra.common.i.c.v:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint midpoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCirclePointRadius -> geogebra.common.i.c.w:
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoCirclePointRadiusInterface -> geogebra.common.i.c.x:
geogebra.common.kernel.algos.AlgoCircleThreePoints -> geogebra.common.i.c.y:
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoPointND C -> c
    geogebra.common.kernel.kernelND.GeoConicND circle -> a
    geogebra.common.kernel.geos.GeoLine s0 -> a
    geogebra.common.kernel.geos.GeoLine s1 -> b
    geogebra.common.kernel.geos.GeoPoint center -> a
    double[] det -> a
    double ax -> a
    double ay -> b
    double bx -> c
    double by -> d
    double cx -> e
    double cy -> f
    double ABx -> g
    double ABy -> h
    double ACx -> i
    double ACy -> j
    double BCx -> k
    double BCy -> l
    double maxDet -> m
    int casenr -> a
    void setIncidence() -> n
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createCircle() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> d
    void setInput() -> e
    void setOutput() -> f
    geogebra.common.kernel.kernelND.GeoConicND getCircle() -> a
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoPoint getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoCircleTwoPoints -> geogebra.common.i.c.z:
    void setIncidence() -> e
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoCircumferenceConic -> geogebra.common.i.c.A:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.integration.EllipticArcLength ellipticArcLength -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getCircumference() -> a
geogebra.common.kernel.algos.AlgoClosestPoint -> geogebra.common.i.c.B:
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.geos.GeoPoint point -> a
    geogebra.common.kernel.geos.GeoPoint P -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void addIncidence() -> e
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isChangeable() -> a
geogebra.common.kernel.algos.AlgoCommonTangents -> geogebra.common.i.c.C:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoPoint P2 -> b
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoConic c2 -> b
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.geos.GeoLine polar2 -> b
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect2 -> b
    geogebra.common.kernel.geos.GeoPoint[] tangentPoints -> a
    geogebra.common.kernel.geos.GeoPoint[] tangentPoints2 -> b
    boolean equalLines -> c
    boolean equalLines2 -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    void initForNearToRelationship() -> d_
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicFivePoints -> geogebra.common.i.c.D:
    geogebra.common.kernel.geos.GeoPoint[] P -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    boolean criticalCase -> c
    double[][] A -> a
    double[][] B -> b
    double[][] C -> c
    double[][] Cpert -> d
    double[][] Cmin -> e
    double l -> a
    double m -> b
    geogebra.common.kernel.geos.GeoVec3D[] line -> a
    int i -> a
    int j -> b
    void checkCriticalCase() -> e
    void addIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoPoint[] getPoints() -> a
    geogebra.common.kernel.geos.GeoPoint[] getAllPoints() -> b
    void compute() -> b
    void degCone(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D,double[][]) -> a
    double evalMatrix(double[][],geogebra.common.kernel.geos.GeoPoint) -> a
    void linComb(double[][],double[][],double,double,double[][]) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoConicFociLength -> geogebra.common.i.c.E:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus1() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus2() -> b
    geogebra.common.kernel.arithmetic.NumberValue getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoConicFromCoeffList -> geogebra.common.i.c.F:
    geogebra.common.kernel.geos.GeoList L -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicPart -> geogebra.common.i.c.G:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.arithmetic.NumberValue startParam -> a
    geogebra.common.kernel.arithmetic.NumberValue endParam -> b
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    int type -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoConicPart getConicPart() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicPartCircle -> geogebra.common.i.c.H:
    geogebra.common.kernel.geos.GeoPoint center -> a
    geogebra.common.kernel.geos.GeoPoint startPoint -> b
    geogebra.common.kernel.geos.GeoPoint endPoint -> c
    geogebra.common.kernel.geos.GeoPoint P -> d
    geogebra.common.kernel.geos.GeoPoint Q -> e
    void setIncidence() -> e
    geogebra.common.kernel.geos.GeoPoint getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint getEndPoint() -> b
    geogebra.common.kernel.geos.GeoPoint getCenter() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoConicPartCircumcircle -> geogebra.common.i.c.I:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoLine line -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    void computeDegenerate() -> f
    void computeCircle() -> n
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoPoint getC() -> c
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoConicPartConicParameters -> geogebra.common.i.c.J:
    void setInputOutput() -> a
geogebra.common.kernel.algos.AlgoConicPartConicPoints -> geogebra.common.i.c.K:
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint endPoint -> b
    geogebra.common.kernel.geos.GeoPoint P -> c
    geogebra.common.kernel.geos.GeoPoint Q -> d
    void setIncidence() -> e
    geogebra.common.kernel.geos.GeoPoint getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint getEndPoint() -> b
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoCountIf -> geogebra.common.i.c.L:
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCountIf3 -> geogebra.common.i.c.M:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.geos.GeoBoolean bool -> a
    geogebra.common.kernel.geos.GeoElement var -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoCurveCartesian -> geogebra.common.i.c.N:
    geogebra.common.kernel.arithmetic.NumberValue[] coords -> a
    geogebra.common.kernel.arithmetic.NumberValue from -> a
    geogebra.common.kernel.arithmetic.NumberValue to -> b
    geogebra.common.kernel.geos.GeoNumeric localVar -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND curve -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND createCurve(geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.Function[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND getCurve() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDefined -> geogebra.common.i.c.O:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDenominator -> geogebra.common.i.c.P:
    geogebra.common.kernel.arithmetic.ExpressionValue getPart(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoDependentBoolean -> geogebra.common.i.c.Q:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoBoolean bool -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getGeoBoolean() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentConic -> geogebra.common.i.c.R:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[] ev -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentFunction -> geogebra.common.i.c.S:
    geogebra.common.kernel.arithmetic.Function fun -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.Function expandedFun -> b
    geogebra.common.kernel.arithmetic.ExpressionNode expression -> a
    boolean expContainsFunctions -> c
    java.lang.StringBuilder sb -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue expandFunctionDerivativeNodes(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean containsFunctions(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getDerivativeLabel(geogebra.common.kernel.arithmetic.Function) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.algos.AlgoDependentFunctionNVar -> geogebra.common.i.c.T:
    geogebra.common.kernel.arithmetic.FunctionNVar fun -> a
    geogebra.common.kernel.geos.GeoFunctionNVar f -> a
    geogebra.common.kernel.arithmetic.ExpressionNode expression -> a
    geogebra.common.kernel.arithmetic.FunctionNVar expandedFun -> b
    boolean expContainsFunctions -> c
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunctionNVar getFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentGeoCopy -> geogebra.common.i.c.U:
    geogebra.common.kernel.arithmetic.ExpressionNode origGeoNode -> a
    geogebra.common.kernel.geos.GeoElement origGeo -> a
    geogebra.common.kernel.geos.GeoElement copyGeo -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDependentInterval -> geogebra.common.i.c.V:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDependentLine -> geogebra.common.i.c.W:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[] ev -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentList -> geogebra.common.i.c.X:
    java.util.ArrayList listItems -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void remove() -> c
    geogebra.common.kernel.geos.GeoList getGeoList() -> a
    int getRelatedModeID() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentListExpression -> geogebra.common.i.c.Y:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getList() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentNumber -> geogebra.common.i.c.Z:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoNumeric number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getNumber() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpression() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentPoint -> geogebra.common.i.c.aa:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVec2D temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpressionNode() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDependentText -> geogebra.common.i.c.ab:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.StringTemplate oldTpl -> a
    geogebra.common.kernel.arithmetic.ExpressionValue numToTrace -> a
    boolean numToTraceSet -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getRoot() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
    void nodeToGeoText(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
    void setSpreadsheetTraceableText() -> e
    geogebra.common.kernel.arithmetic.ExpressionNode getSpecialCopy(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue copy(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    void setNumToTrace(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.algos.AlgoDependentVector -> geogebra.common.i.c.ac:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVec2D temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.algos.AlgoDiameterLine -> geogebra.common.i.c.ad:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine diameter -> b
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoLine getDiameter() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoDiameterVector -> geogebra.common.i.c.ae:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine diameter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getDiameter() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDilate -> geogebra.common.i.c.af:
    geogebra.common.kernel.geos.GeoPoint S -> a
    geogebra.common.kernel.geos.Dilateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue r -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement rgeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
geogebra.common.kernel.algos.AlgoDirection -> geogebra.common.i.c.ag:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDispatcher -> geogebra.common.i.c.ah:
    geogebra.common.kernel.Construction cons -> a
    java.util.ArrayList intersectionAlgos -> a
    void removeIntersectionAlgorithm(geogebra.common.kernel.algos.AlgoIntersectAbstract) -> a
    geogebra.common.kernel.geos.GeoPoint Point(java.lang.String,double,double,boolean) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,double,double) -> a
    geogebra.common.kernel.geos.GeoVector Vector(double,double) -> a
    geogebra.common.kernel.geos.GeoPoint Point(java.lang.String,geogebra.common.kernel.Path,double,double,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint Point(java.lang.String,geogebra.common.kernel.Path,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoRay Ray(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoRay Ray(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoLine OrthogonalLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoLine OrthogonalLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> b
    geogebra.common.kernel.geos.GeoLine LineBisector(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> b
    geogebra.common.kernel.geos.GeoLine LineBisector(java.lang.String,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoLine AngularBisector(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoLine[] AngularBisector(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoNumeric Slope(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoSegment Segment(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoList List(java.lang.String,java.util.ArrayList,boolean) -> a
    geogebra.common.kernel.geos.GeoFunction DependentFunction(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoTextField textfield(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoVector) -> b
    geogebra.common.kernel.geos.GeoElement[] Segment(java.lang.String[],geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Angle(java.lang.String[],geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] Rotate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoElement[] Angles(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoNumeric getDefaultNumber(boolean) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoConicPart CircumcircleArc(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoConicPart CircumcircleSector(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> b
    geogebra.common.kernel.geos.GeoConicPart CircleArc(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> c
    geogebra.common.kernel.geos.GeoConicPart CircleSector(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> d
    geogebra.common.kernel.geos.GeoPoint Center(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoConicPart Semicircle(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoConic Parabola(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoConic Ellipse(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConic Ellipse(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> b
    geogebra.common.kernel.geos.GeoConic Hyperbola(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoConic Hyperbola(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> c
    geogebra.common.kernel.geos.GeoConic Conic(java.lang.String,geogebra.common.kernel.geos.GeoPoint[]) -> a
    geogebra.common.kernel.geos.GeoLine DiameterLine(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine DiameterLine(java.lang.String,geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement[] RegularPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Area(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoNumeric Perimeter(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoNumeric Circumference(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoElement[] Dilate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly ImplicitPoly(java.lang.String,geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    geogebra.common.kernel.geos.GeoPoint PointIn(java.lang.String,geogebra.common.kernel.Region,double,double,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint Midpoint(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint Midpoint(java.lang.String,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoLocus) -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLine(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[],boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectPolygons(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoElement[] Union(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> b
    geogebra.common.kernel.geos.GeoLocus Locus(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoLocus Locus(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLines(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLinePolyLine(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPolyLine) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLineCurve(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLinePolygon(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectFunctions(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectFunctionLine(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectLineConic(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectPolynomials(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialsSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectPolynomialLine(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectPolynomialConic(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectImplicitpolyLine(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectImplicitpolyPolynomial(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectImplicitpolys(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectImplicitpolyConic(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomialConic getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectConics getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomials getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomialLine getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoElement findExistingIntersectionAlgorithm(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine[] CommonTangents(java.lang.String[],geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine Tangent(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoElement[] Translate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoLine) -> a
geogebra.common.kernel.algos.AlgoDistanceLineLine -> geogebra.common.i.c.ai:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDistancePointObject -> geogebra.common.i.c.aj:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoElement g -> a
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.AlgoClosestPoint closePt -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDistancePoints -> geogebra.common.i.c.ak:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDiv -> geogebra.common.i.c.al:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDrawingPadCorner -> geogebra.common.i.c.am:
    geogebra.common.kernel.geos.GeoPoint corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.arithmetic.NumberValue evNum -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getCorner() -> a
    void compute() -> b
    boolean euclidianViewUpdate() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDynamicCoordinatesInterface -> geogebra.common.i.c.an:
    geogebra.common.kernel.geos.GeoPoint getParentPoint() -> b
geogebra.common.kernel.algos.AlgoElement -> geogebra.common.i.c.ao:
    geogebra.common.kernel.geos.GeoElement[] input -> a
    geogebra.common.kernel.geos.GeoElement[] output -> b
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> c
    geogebra.common.kernel.geos.GeoNumeric[] randomUnlabeledInput -> a
    boolean isPrintedInXML -> c
    boolean stopUpdateCascade -> d
    java.util.List outputHandler -> a
    java.util.TreeSet tempSet -> a
    boolean removed -> a
    boolean protectedInput -> b
    java.util.ArrayList freeInputPoints -> a
    java.util.ArrayList inputPoints -> b
    java.lang.StringBuilder sbAE -> a
    geogebra.common.kernel.algos.AlgoElement updateAfterAlgo -> a
    void addToConstructionList() -> g
    void setOutputLength(int) -> b
    void setOnlyOutput(geogebra.common.kernel.geos.ToGeoElement) -> a
    void setOutput(int,geogebra.common.kernel.geos.GeoElement) -> a
    void setOutput(geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoElement getOutput(int) -> a
    int getOutputLength() -> g
    void refreshOutput() -> h
    java.lang.String getCommandString(geogebra.common.kernel.algos.Algos) -> a
    void compute() -> b
    void initForNearToRelationship() -> d_
    boolean isNearToAlgorithm() -> d
    void update() -> i
    void updateCascadeAlgos(java.util.ArrayList) -> a
    java.util.TreeSet getTempSet() -> b
    geogebra.common.kernel.geos.GeoElement[] getOutput() -> c
    geogebra.common.kernel.geos.GeoElement[] getInput() -> d
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a
    void setDependencies() -> j
    void doSetDependencies() -> k
    void setRandomUnlabeledInput() -> a
    void setEfficientDependencies(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void setOutputDependencies() -> e
    void setOutputDependencies(geogebra.common.kernel.geos.GeoElement) -> a
    boolean euclidianViewUpdate() -> b
    void remove() -> c
    void setProtectedInput(boolean) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void removeOutputExcept(geogebra.common.kernel.geos.GeoElement) -> c
    void notifyAdd() -> l
    void notifyRemove() -> m
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> e
    boolean hasSingleOutputType() -> g
    boolean isAlgoElement() -> h
    boolean isGeoElement() -> i
    boolean isConsProtocolBreakpoint() -> j
    int compareTo(geogebra.common.kernel.algos.ConstructionElement) -> a
    int getConstructionIndex() -> b
    int getMinConstructionIndex() -> h
    int getMaxConstructionIndex() -> i
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void addPredecessorsToSet(java.util.TreeSet,boolean) -> a
    java.util.ArrayList getFreeInputPoints() -> b
    java.util.ArrayList getInputPoints() -> c
    boolean isIndependent() -> k
    java.lang.String getNameDescription() -> b
    java.lang.String getAlgebraDescriptionRegrOut(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> d
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate,boolean) -> a
    void appendCheckVector(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoElement,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString() -> toString
    java.lang.String getCommandName(geogebra.common.kernel.StringTemplate) -> e
    void getXML(java.lang.StringBuilder) -> a
    java.lang.String getXML() -> c
    void getXML(java.lang.StringBuilder,boolean) -> a
    void getOutputXML(java.lang.StringBuilder) -> b
    java.lang.String getExpXML(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getCmdXML(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setPrintedInXML(boolean) -> b
    boolean isPrintedInXML() -> l
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toExpString(geogebra.common.kernel.StringTemplate) -> g
    boolean doStopUpdateCascade() -> m
    void setStopUpdateCascade(boolean) -> c
    boolean wantsConstructionProtocolUpdate() -> c_
    void setUpdateAfterAlgo(geogebra.common.kernel.algos.AlgoElement) -> a
    geogebra.common.kernel.algos.AlgoElement getUpdateAfterAlgo() -> a
    java.util.List getOutputHandler() -> a
    void setOutputHandler(java.util.List) -> a
    boolean isLaTeXTextCommand() -> c
    geogebra.common.kernel.algos.EquationElementInterface buildEquationElementForGeo(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.algos.EquationScopeInterface) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoElement$OutputHandler -> geogebra.common.i.c.ao$a:
    geogebra.common.kernel.algos.AlgoElement$elementFactory fac -> a
    java.util.ArrayList outputList -> a
    java.lang.String[] labels -> a
    java.lang.String indexLabel -> a
    boolean setLabels -> a
    int labelsSetLength -> a
    geogebra.common.kernel.algos.AlgoElement this$0 -> a
    void removeFromHandler() -> a
    void adjustOutputSize(int) -> a
    void augmentOutputSize(int,boolean) -> a
    void setLabels(java.lang.String[]) -> a
    void setIndexLabels(java.lang.String) -> a
    void updateLabels() -> b
    geogebra.common.kernel.geos.GeoElement getElement(int) -> a
    geogebra.common.kernel.geos.GeoElement[] getOutput(geogebra.common.kernel.geos.GeoElement[]) -> a
    int size() -> a
geogebra.common.kernel.algos.AlgoElement$elementFactory -> geogebra.common.i.c.ao$b:
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoEllipseFociLength -> geogebra.common.i.c.ap:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoEllipseFociPoint -> geogebra.common.i.c.aq:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoConic ellipse -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getEllipse() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus1() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus2() -> b
    geogebra.common.kernel.geos.GeoPoint getExternalPoint() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoExtremumMulti -> geogebra.common.i.c.ar:
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint[] getExtremumPoints() -> a
    void setInputOutput() -> a
    void compute() -> b
    double[] findExtremums(geogebra.common.kernel.roots.RealRootFunction,double,double,int) -> a
    int findNumberOfSamples(double,double) -> a
    double gradient(geogebra.common.kernel.roots.RealRootFunction,double,double,double) -> a
geogebra.common.kernel.algos.AlgoExtremumPolynomial -> geogebra.common.i.c.as:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFirst -> geogebra.common.i.c.at:
    geogebra.common.kernel.geos.GeoElement inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFirstLocus -> geogebra.common.i.c.au:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFirstString -> geogebra.common.i.c.av:
    geogebra.common.kernel.geos.GeoText inputText -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoText outputText -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFocus -> geogebra.common.i.c.aw:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint[] focus -> a
    double temp1 -> a
    double temp2 -> b
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint[] getFocus() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFractionText -> geogebra.common.i.c.ax:
    geogebra.common.kernel.geos.GeoNumberValue num -> a
    geogebra.common.kernel.geos.GeoText text -> a
    double[] frac -> a
    java.lang.StringBuilder sb -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    double[] DecimalToFraction(double,double) -> a
    boolean isLaTeXTextCommand() -> c
    void appendLaTeX(java.lang.StringBuilder,double[],geogebra.common.kernel.StringTemplate,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.algos.AlgoFractionTextPoint -> geogebra.common.i.c.ay:
    geogebra.common.kernel.kernelND.GeoPointND p -> a
    geogebra.common.kernel.geos.GeoText text -> a
    double[] xCoord -> a
    double[] yCoord -> b
    double[] zCoord -> c
    java.lang.StringBuilder sb -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.algos.AlgoFunctionAreaSums -> geogebra.common.i.c.az:
    double CHECKPOINTS -> a
    int type -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue n -> c
    geogebra.common.kernel.arithmetic.NumberValue width -> d
    geogebra.common.kernel.arithmetic.NumberValue density -> e
    geogebra.common.kernel.arithmetic.NumberValue p1 -> f
    geogebra.common.kernel.arithmetic.NumberValue p2 -> g
    geogebra.common.kernel.arithmetic.NumberValue p3 -> h
    geogebra.common.kernel.arithmetic.NumberValue d -> i
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoList list3 -> c
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoElement ngeo -> c
    geogebra.common.kernel.geos.GeoElement dgeo -> d
    geogebra.common.kernel.geos.GeoElement widthGeo -> e
    geogebra.common.kernel.geos.GeoElement densityGeo -> f
    geogebra.common.kernel.geos.GeoElement useDensityGeo -> g
    geogebra.common.kernel.geos.GeoElement isCumulative -> h
    geogebra.common.kernel.geos.GeoElement p1geo -> i
    geogebra.common.kernel.geos.GeoElement p2geo -> j
    geogebra.common.kernel.geos.GeoElement p3geo -> k
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    int N -> b
    double STEP -> b
    double[] yval -> a
    double[] leftBorder -> b
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    double freqMax -> c
    boolean histogramRight -> c
    geogebra.common.kernel.arithmetic.NumberValue getP1() -> a
    geogebra.common.kernel.geos.GeoElement getDensityGeo() -> a
    geogebra.common.kernel.geos.GeoElement getUseDensityGeo() -> b
    geogebra.common.kernel.geos.GeoElement getIsCumulative() -> c
    double getFreqMax() -> a
    double[] getYValue() -> a
    double[] getLeftBorder() -> b
    boolean isRight() -> f
    boolean euclidianViewUpdate() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getF() -> a
    int getIntervals() -> c
    double getStep() -> b
    double[] getValues() -> c
    geogebra.common.kernel.geos.GeoNumeric getSum() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> b
    geogebra.common.kernel.arithmetic.NumberValue getB() -> c
    geogebra.common.kernel.geos.GeoNumeric getN() -> b
    geogebra.common.kernel.geos.GeoNumeric getD() -> c
    void compute() -> b
    void compute(boolean) -> d
    boolean functionDefined(double,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean useTrapeziums() -> n
    boolean isHistogram() -> o
    int getType() -> d
    boolean prepareDistributionLists() -> q
    void loadDistributionLists(int,int,org.apache.commons.math.distribution.IntegerDistribution) -> a
    void update() -> i
geogebra.common.kernel.algos.AlgoFunctionFreehand -> geogebra.common.i.c.aA:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunction g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoList getList() -> a
geogebra.common.kernel.algos.AlgoFunctionInterval -> geogebra.common.i.c.aB:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.ExpressionNode exp -> a
    geogebra.common.kernel.arithmetic.ExpressionNode exp2 -> b
    geogebra.common.kernel.arithmetic.ExpressionNode expCond -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    boolean hasEqualExpressions(geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFunctionMax -> geogebra.common.i.c.aC:
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.geos.GeoPoint E -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFunctionMin -> geogebra.common.i.c.aD:
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.geos.GeoPoint E -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoGCD -> geogebra.common.i.c.aE:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoGeoPointsFunction -> geogebra.common.i.c.aF:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    java.lang.String[] labels -> a
    boolean initLabels -> d
    boolean setLabels -> c
    geogebra.common.kernel.geos.GeoPoint[] getPoints() -> b
    void showOneRootInAlgebraView() -> e
    void removeDuplicates(double[]) -> a
    void setPoints(double[],int) -> a
    double yAt(double) -> a
    void updateLabels(int) -> a
    void noUndefinedPointsInAlgebraView(geogebra.common.kernel.geos.GeoPoint[]) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initPoints(int) -> c
    void removePoint(int) -> e
geogebra.common.kernel.algos.AlgoHyperbolaFociLength -> geogebra.common.i.c.aG:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoHyperbolaFociPoint -> geogebra.common.i.c.aH:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoConic hyperbola -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getHyperbola() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus1() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus2() -> b
    geogebra.common.kernel.geos.GeoPoint getExternalPoint() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoIf -> geogebra.common.i.c.aI:
    geogebra.common.kernel.geos.GeoBoolean condition -> a
    geogebra.common.kernel.geos.GeoElement ifGeo -> a
    geogebra.common.kernel.geos.GeoElement elseGeo -> b
    geogebra.common.kernel.geos.GeoElement result -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIfFunction -> geogebra.common.i.c.aJ:
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> b
    geogebra.common.kernel.geos.GeoFunction elseFun -> c
    geogebra.common.kernel.geos.GeoFunctionConditional result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoImageCorner -> geogebra.common.i.c.aK:
    geogebra.common.kernel.geos.GeoImage img -> a
    geogebra.common.kernel.geos.GeoPoint corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getCorner() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntegralFunctions -> geogebra.common.i.c.aL:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoBoolean evaluate -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric intF -> b
    geogebra.common.kernel.geos.GeoNumeric intG -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoIntegralFunctions copy() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getIntegral() -> a
    geogebra.common.kernel.geos.GeoFunction getF() -> a
    geogebra.common.kernel.geos.GeoFunction getG() -> b
    geogebra.common.kernel.arithmetic.NumberValue getA() -> a
    geogebra.common.kernel.arithmetic.NumberValue getB() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoIntegralODE -> geogebra.common.i.c.aM:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoPoint p -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar f0 -> a
    geogebra.common.kernel.algos.AlgoNumerator numAlgo -> a
    geogebra.common.kernel.algos.AlgoDenominator denAlgo -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar num -> b
    geogebra.common.kernel.arithmetic.FunctionalNVar den -> c
    boolean quotient -> c
    java.util.ArrayList al -> a
    org.apache.commons.math.ode.sampling.StepHandler stepHandler -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void remove() -> c
geogebra.common.kernel.algos.AlgoIntegralODE$1 -> geogebra.common.i.c.aN:
    geogebra.common.kernel.algos.AlgoIntegralODE this$0 -> a
    void reset() -> a
    boolean requiresDenseOutput() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
geogebra.common.kernel.algos.AlgoIntegralODE$ODE -> geogebra.common.i.c.aM$a:
    geogebra.common.kernel.arithmetic.FunctionalNVar f -> a
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.algos.AlgoIntegralODE$ODE2 -> geogebra.common.i.c.aM$b:
    geogebra.common.kernel.arithmetic.FunctionalNVar y0 -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar y1 -> b
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.algos.AlgoIntersect -> geogebra.common.i.c.aO:
    void avoidDoubleTangentPoint() -> a
    int getClosestPointIndex(double,double) -> a
    int getClosestPointIndex(geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint[] getCopyOfIntersectionPoints() -> b
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getLastDefinedIntersectionPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getIntersectionPoints() -> b
geogebra.common.kernel.algos.AlgoIntersectAbstract -> geogebra.common.i.c.aP:
geogebra.common.kernel.algos.AlgoIntersectConics -> geogebra.common.i.c.aQ:
    geogebra.common.kernel.geos.GeoConic A -> a
    geogebra.common.kernel.geos.GeoConic B -> b
    geogebra.common.kernel.geos.GeoPoint[] P -> a
    geogebra.common.kernel.geos.GeoPoint[] D -> b
    geogebra.common.kernel.geos.GeoPoint[] Q -> c
    java.util.ArrayList preexistPoints -> a
    java.util.ArrayList newPoints -> b
    geogebra.common.kernel.geos.GeoConic degConic -> c
    geogebra.common.kernel.geos.GeoLine tempLine -> a
    int[] age -> a
    int[] originalPermutation -> b
    int[] permutation -> c
    double[][] distTable -> a
    boolean[] isQonPath -> a
    boolean[] isPalive -> b
    boolean firstIntersection -> c
    boolean isLimitedPathSituation -> d
    boolean isPermutationNeeded -> e
    boolean possibleSpecialCase -> f
    int specialCasePointOnCircleIndex -> a
    geogebra.common.kernel.PointPairList pointList -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    geogebra.common.kernel.SystemOfEquationsSolver sysSolver -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void addIncidence() -> f
    void setInputOutput() -> e
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoConic getA() -> a
    geogebra.common.kernel.geos.GeoConic getB() -> b
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    boolean isNearToAlgorithm() -> d
    void initForNearToRelationship() -> d_
    void compute() -> b
    void matchExistingIntersections() -> q
    boolean handleSpecialCase() -> f
    geogebra.common.kernel.geos.GeoPoint getPointFrom1on2(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    void computeNonContinous() -> r
    void computeContinuous() -> s
    void handleLimitedPaths() -> t
    void updateQonPath() -> u
    boolean pointLiesOnBothPaths(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isSingularitySituation() -> n
    void intersectConics(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[]) -> a
    void moveDefinedPointsToFront(geogebra.common.kernel.geos.GeoPoint[]) -> a
    void intersectWithDegenerate(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[]) -> b
    boolean testPoints(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[],double) -> a
    boolean calcIntersectionPoints(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[],double) -> b
    boolean intersectConicsWithEqualSubmatrixS(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[]) -> a
    void normalizeArray(double[]) -> a
    void distanceTable(geogebra.common.kernel.geos.GeoPoint[],int[],geogebra.common.kernel.geos.GeoPoint[],double[][]) -> a
    void setNearTo(geogebra.common.kernel.geos.GeoPoint[],boolean[],geogebra.common.kernel.geos.GeoPoint[],boolean[],double[][],geogebra.common.kernel.PointPairList,int[],boolean,double) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoIntersectFunctionLineNewton -> geogebra.common.i.c.aR:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint rootPoint -> b
    geogebra.common.kernel.arithmetic.Function diffFunction -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoPoint getIntersectionPoint() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectFunctions -> geogebra.common.i.c.aS:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
geogebra.common.kernel.algos.AlgoIntersectFunctionsNewton -> geogebra.common.i.c.aT:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint rootPoint -> b
    geogebra.common.kernel.arithmetic.Function diffFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoPoint getIntersectionPoint() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectLineConic -> geogebra.common.i.c.aU:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint[] D -> c
    geogebra.common.kernel.geos.GeoPoint[] P -> a
    geogebra.common.kernel.geos.GeoPoint[] Q -> b
    int intersectionType -> a
    int[] age -> a
    int[] permutation -> b
    double[][] distTable -> a
    boolean[] isQonPath -> a
    boolean[] isPalive -> b
    int i -> c
    boolean isDefinedAsTangent -> e
    boolean firstIntersection -> f
    boolean isPermutationNeeded -> g
    geogebra.common.kernel.geos.GeoPoint tangentPoint -> a
    geogebra.common.kernel.PointPairList pointList -> a
    boolean isLimitedPathSituation -> h
    boolean possibleSpecialCase -> c
    boolean handlingSpecialCase -> d
    int specialCasePointOnCircleIndex -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void addIncidence() -> q
    void initElements() -> e
    void setInputOutput() -> f
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    boolean isNearToAlgorithm() -> d
    void initForNearToRelationship() -> d_
    void compute() -> b
    boolean handleSpecialCase() -> f
    void computeNonContinous() -> r
    void computeContinous() -> s
    void handleLimitedPaths() -> t
    void updateQonPath() -> u
    boolean pointLiesOnBothPaths(geogebra.common.kernel.geos.GeoPoint) -> a
    int intersect(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[]) -> a
    int intersectLineConic(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.geos.GeoPoint[]) -> a
    boolean testPoints(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint[],double) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoIntersectLineCurve -> geogebra.common.i.c.aV:
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoCurveCartesian curve -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectLineCurve$1 -> geogebra.common.i.c.aW:
    geogebra.common.kernel.algos.AlgoIntersectLineCurve this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolyLine -> geogebra.common.i.c.aX:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.geos.GeoPolyLine p -> a
    geogebra.common.kernel.geos.GeoPoly pi -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    java.util.TreeMap newCoords -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void intersectionsCoords(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolyLine,java.util.TreeMap) -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolyLine$1 -> geogebra.common.i.c.aY:
    geogebra.common.kernel.algos.AlgoIntersectLinePolyLine this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoIntersectLines -> geogebra.common.i.c.aZ:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoPoint S -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.geos.GeoLine geth() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoIntersectPolynomialConic -> geogebra.common.i.c.ba:
    geogebra.common.kernel.geos.GeoFunction h -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    double getYValue(double) -> a
geogebra.common.kernel.algos.AlgoIntersectPolynomialLine -> geogebra.common.i.c.bb:
    void addIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectPolynomials -> geogebra.common.i.c.bc:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectSingle -> geogebra.common.i.c.bd:
    geogebra.common.kernel.algos.AlgoIntersect algo -> a
    geogebra.common.kernel.geos.GeoNumberValue index -> a
    geogebra.common.kernel.geos.GeoPoint refPoint -> a
    geogebra.common.kernel.geos.GeoPoint point -> b
    geogebra.common.kernel.geos.GeoPoint[] parentOutput -> a
    int idx -> a
    void addIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra.common.kernel.algos.AlgoIntersect getAlgo() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    boolean isNearToAlgorithm() -> d
    void initForNearToRelationship() -> d_
    void compute() -> b
    void remove() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoIntersection -> geogebra.common.i.c.be:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList inputList2 -> b
    geogebra.common.kernel.geos.GeoList outputList -> c
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalAbstract -> geogebra.common.i.c.bf:
    geogebra.common.kernel.geos.GeoInterval interval -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.algos.AlgoIntervalMax -> geogebra.common.i.c.bg:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalMidpoint -> geogebra.common.i.c.bh:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalMin -> geogebra.common.i.c.bi:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIsInteger -> geogebra.common.i.c.bj:
    geogebra.common.kernel.geos.GeoNumeric inputGeo -> a
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIteration -> geogebra.common.i.c.bk:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue startValue -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoElement startValueGeo -> a
    geogebra.common.kernel.geos.GeoElement nGeo -> b
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIterationList -> geogebra.common.i.c.bl:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue startValue -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoElement startValueGeo -> a
    geogebra.common.kernel.geos.GeoElement nGeo -> b
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.algos.AlgoJoin -> geogebra.common.i.c.bm:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoJoinPoints -> geogebra.common.i.c.bn:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoPoint Q -> b
    geogebra.common.kernel.geos.GeoLine g -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoPoint getQ() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoJoinPointsRay -> geogebra.common.i.c.bo:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoPoint Q -> b
    geogebra.common.kernel.geos.GeoRay ray -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoRay getRay() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoPoint getQ() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoJoinPointsSegment -> geogebra.common.i.c.bp:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoPoint Q -> b
    geogebra.common.kernel.geos.GeoSegment s -> a
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    void setIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void modifyInputPoints(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoSegment getSegment() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoPoint getQ() -> b
    geogebra.common.kernel.geos.GeoPolygon getPoly() -> a
    void compute() -> b
    void remove() -> c
    void removeSegmentOnly() -> e
    int getConstructionIndex() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoKeepIf -> geogebra.common.i.c.bq:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoKeepIf3 -> geogebra.common.i.c.br:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.geos.GeoBoolean bool -> a
    geogebra.common.kernel.geos.GeoElement var -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLCM -> geogebra.common.i.c.bs:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLaTeX -> geogebra.common.i.c.bt:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoBoolean substituteVars -> a
    geogebra.common.kernel.geos.GeoBoolean showName -> b
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.algos.AlgoLast -> geogebra.common.i.c.bu:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLastString -> geogebra.common.i.c.bv:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLengthLocus -> geogebra.common.i.c.bw:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLengthSegment -> geogebra.common.i.c.bx:
    geogebra.common.kernel.kernelND.GeoSegmentND seg -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLengthVector -> geogebra.common.i.c.by:
    geogebra.common.kernel.geos.GeoVec3D v -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    double[] coords -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLetterToUnicode -> geogebra.common.i.c.bz:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLineBisector -> geogebra.common.i.c.bA:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint midPoint -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoPoint getMidPoint() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoLineBisectorSegment -> geogebra.common.i.c.bB:
    geogebra.common.kernel.geos.GeoSegment s -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint midPoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoSegment getSegment() -> a
    geogebra.common.kernel.geos.GeoPoint getMidPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoLinePointLine -> geogebra.common.i.c.bC:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoLine getl() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLinePointVector -> geogebra.common.i.c.bD:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoListElement -> geogebra.common.i.c.bE:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.arithmetic.NumberValue[] num2 -> a
    geogebra.common.kernel.geos.GeoElement numGeo -> a
    geogebra.common.kernel.geos.GeoElement element -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.kernel.algos.AlgoListGCD -> geogebra.common.i.c.bF:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getGCD() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListLCM -> geogebra.common.i.c.bG:
    java.math.BigInteger bigZero -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLCM() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListLength -> geogebra.common.i.c.bH:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListMax -> geogebra.common.i.c.bI:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    geogebra.common.kernel.geos.GeoNumeric max -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMax() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListMin -> geogebra.common.i.c.bJ:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    geogebra.common.kernel.geos.GeoNumeric min -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMin() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLocus -> geogebra.common.i.c.bK:
    int MAX_TIME_FOR_ONE_STEP -> a
    int MIN_STEPS_INSTANCE -> b
    int MAX_X_PIXEL_DIST -> c
    int MAX_Y_PIXEL_DIST -> d
    geogebra.common.kernel.geos.GeoPoint movingPoint -> a
    geogebra.common.kernel.geos.GeoPoint locusPoint -> b
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.PathMover pathMover -> a
    int pointCount -> e
    geogebra.common.kernel.geos.GeoPoint Pcopy -> c
    geogebra.common.kernel.geos.GeoPoint Qcopy -> d
    geogebra.common.kernel.geos.GeoPoint PstartPos -> e
    geogebra.common.kernel.geos.GeoPoint QstartPos -> f
    double lastX -> a
    double lastY -> b
    double maxXdist -> c
    double maxYdist -> d
    double xmin -> e
    double xmax -> f
    double ymin -> g
    double ymax -> h
    double farXmin -> i
    double farXmax -> j
    double farYmin -> k
    double farYmax -> l
    geogebra.common.awt.GRectangle2D nearToScreenRect -> a
    boolean continuous -> c
    boolean lastFarAway -> d
    boolean foundDefined -> e
    boolean maxTimeExceeded -> f
    geogebra.common.kernel.Construction macroCons -> b
    geogebra.common.kernel.MacroKernel macroKernel -> a
    java.util.TreeSet locusConsOrigElements -> a
    java.util.TreeSet Qin -> b
    long countUpdates -> a
    double[] paramCache -> a
    geogebra.common.awt.GPoint2D[] qcopyCache -> a
    int cacheIndex -> f
    long useCache -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint getLocusPoint() -> a
    geogebra.common.kernel.geos.GeoPoint getMovingPoint() -> b
    void init() -> e
    void setInputOutput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    void buildLocusMacroConstruction(java.util.TreeSet) -> a
    void resetMacroConstruction() -> f
    void compute() -> b
    boolean isPathIterable(geogebra.common.kernel.geos.GeoElement) -> a
    void pcopyUpdateCascade() -> n
    void clearCache() -> o
    geogebra.common.awt.GPoint2D getCachedPoint(double) -> a
    void putCachedPoint(double,geogebra.common.kernel.geos.GeoPoint) -> a
    void insertPoint(double,double,boolean) -> a
    boolean isFarAway(double,double) -> a
    boolean distanceOK(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean distanceSmall(geogebra.common.kernel.geos.GeoPoint) -> b
    void updateScreenBorders() -> p
    boolean euclidianViewUpdate() -> b
geogebra.common.kernel.algos.AlgoLocusList -> geogebra.common.i.c.bL:
    int MIN_STEPS_REALLY -> a
    java.util.ArrayList arrLocus -> a
    geogebra.common.kernel.geos.GeoPoint movingPoint -> a
    geogebra.common.kernel.geos.GeoPoint locusPoint -> b
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    geogebra.common.kernel.Path path -> a
    boolean foundDefined -> c
    java.util.TreeSet Qin -> a
    void fillLocusArray(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint getMovingPoint() -> a
    void setInputOutput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    void compute() -> b
    boolean isPathIterable(geogebra.common.kernel.geos.GeoElement) -> a
    void insertPoint(double,double,boolean) -> a
geogebra.common.kernel.algos.AlgoLocusSlider -> geogebra.common.i.c.bM:
    int MAX_TIME_FOR_ONE_STEP -> a
    int MAX_X_PIXEL_DIST -> b
    int MAX_Y_PIXEL_DIST -> c
    geogebra.common.kernel.geos.GeoPoint locusPoint -> a
    geogebra.common.kernel.geos.GeoNumeric movingSlider -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    geogebra.common.kernel.SliderMover sliderMover -> a
    int pointCount -> d
    geogebra.common.kernel.geos.GeoPoint Qcopy -> b
    geogebra.common.kernel.geos.GeoPoint QstartPos -> c
    geogebra.common.kernel.geos.GeoNumeric Pcopy -> b
    geogebra.common.kernel.geos.GeoNumeric PstartPos -> c
    double lastX -> a
    double lastY -> b
    double maxXdist -> c
    double maxYdist -> d
    double xmin -> e
    double xmax -> f
    double ymin -> g
    double ymax -> h
    double farXmin -> i
    double farXmax -> j
    double farYmin -> k
    double farYmax -> l
    geogebra.common.awt.GRectangle2D nearToScreenRect -> a
    boolean continuous -> c
    boolean lastFarAway -> d
    boolean foundDefined -> e
    boolean maxTimeExceeded -> f
    geogebra.common.kernel.Construction macroCons -> b
    geogebra.common.kernel.MacroKernel macroKernel -> a
    java.util.TreeSet locusConsOrigElements -> a
    java.util.TreeSet Qin -> b
    long countUpdates -> a
    double[] paramCache -> a
    geogebra.common.awt.GPoint2D[] qcopyCache -> a
    int cacheIndex -> e
    long useCache -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void init() -> e
    void setInputOutput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    void buildLocusMacroConstruction(java.util.TreeSet) -> a
    void resetMacroConstruction() -> f
    void compute() -> b
    void pcopyUpdateCascade() -> n
    void clearCache() -> o
    geogebra.common.awt.GPoint2D getCachedPoint(double) -> a
    void putCachedPoint(double,geogebra.common.kernel.geos.GeoPoint) -> a
    void insertPoint(double,double,boolean) -> a
    boolean isFarAway(double,double) -> a
    boolean distanceOK(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean distanceSmall(geogebra.common.kernel.geos.GeoPoint) -> b
    void updateScreenBorders() -> p
    boolean euclidianViewUpdate() -> b
geogebra.common.kernel.algos.AlgoLocusSliderInterface -> geogebra.common.i.c.bN:
geogebra.common.kernel.algos.AlgoMacro -> geogebra.common.i.c.bO:
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.kernel.geos.GeoElement[] macroInput -> b
    geogebra.common.kernel.geos.GeoElement[] macroOutput -> c
    java.util.HashMap macroToAlgoMap -> a
    java.util.ArrayList macroOutputAndReferencedGeos -> a
    java.util.ArrayList algoOutputAndReferencedGeos -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void remove() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String getCommandName(geogebra.common.kernel.StringTemplate) -> e
    void setInputOutput() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isMacroInputObject(geogebra.common.kernel.geos.GeoElement) -> a
    void setMacroConstructionState() -> e
    void getMacroConstructionState() -> f
    void createOutputObjects() -> n
    void initMap() -> o
    void map(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getAlgoGeo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement createAlgoCopy(geogebra.common.kernel.geos.GeoElement) -> b
    void initSpecialReferences(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    void initLine(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    void initConic(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    void initLocateable(geogebra.common.kernel.Locateable,geogebra.common.kernel.Locateable) -> a
    void initPolygon(geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> a
    void initList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    void initFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    void replaceReferencedMacroObjects(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.algos.AlgoMacroInterface -> geogebra.common.i.c.bP:
    void initFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    void initList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.algos.AlgoMax -> geogebra.common.i.c.bQ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoMedian -> geogebra.common.i.c.bR:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    geogebra.common.kernel.geos.GeoNumeric median -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMedian() -> a
    void compute() -> b
    java.lang.Double getValueAt(int,java.lang.Double[],java.lang.Integer[]) -> a
    java.lang.Object[] convertValueFreqListToArrays(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.algos.AlgoMidpoint -> geogebra.common.i.c.bS:
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    void copyCoords(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> b
    geogebra.common.kernel.geos.GeoPoint getQ() -> c
    void computeMidCoords() -> a
    boolean isLocusEquable() -> e
    geogebra.common.kernel.kernelND.GeoPointND getQ() -> a
    geogebra.common.kernel.kernelND.GeoPointND getP() -> b
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> c
geogebra.common.kernel.algos.AlgoMidpointSegment -> geogebra.common.i.c.bT:
    geogebra.common.kernel.geos.GeoSegment segment -> a
    geogebra.common.kernel.geos.GeoPoint M -> a
    geogebra.common.kernel.geos.GeoPoint P -> b
    geogebra.common.kernel.geos.GeoPoint Q -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoPoint getQ() -> b
    geogebra.common.kernel.geos.GeoPoint getPoint() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoMin -> geogebra.common.i.c.bU:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoMirror -> geogebra.common.i.c.bV:
    geogebra.common.kernel.geos.Mirrorable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoLine mirrorLine -> a
    geogebra.common.kernel.geos.GeoPoint mirrorPoint -> a
    geogebra.common.kernel.geos.GeoConic mirrorConic -> a
    geogebra.common.kernel.geos.GeoElement mirror -> c
    geogebra.common.kernel.geos.GeoPoint transformedPoint -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
geogebra.common.kernel.algos.AlgoMod -> geogebra.common.i.c.bW:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoName -> geogebra.common.i.c.bX:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoNumerator -> geogebra.common.i.c.bY:
    geogebra.common.kernel.arithmetic.FunctionalNVar f -> a
    geogebra.common.kernel.geos.GeoElement g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue getPart(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoObject -> geogebra.common.i.c.bZ:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.String currentLabel -> a
    geogebra.common.kernel.geos.GeoElement refObject -> b
    geogebra.common.kernel.geos.GeoElement[] inputForUpdateSetPropagation -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void updateReferencedObject() -> e
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a
geogebra.common.kernel.algos.AlgoOrthoLinePointConic -> geogebra.common.i.c.ca:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoConic l -> a
    geogebra.common.kernel.geos.GeoLine[] g -> a
    geogebra.common.kernel.geos.GeoNumeric[] n -> a
    geogebra.common.kernel.algos.AlgoPointOnPath[] algoPoint -> a
    geogebra.common.kernel.algos.AlgoClosestPoint closestPoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void addIncidence() -> e
    void setInputOutput() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoLinePointLine -> geogebra.common.i.c.cb:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.geos.GeoLine getl() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoOrthoLinePointVector -> geogebra.common.i.c.cc:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoVectorLine -> geogebra.common.i.c.cd:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector n -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoVectorVector -> geogebra.common.i.c.ce:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector n -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoParabolaPointLine -> geogebra.common.i.c.cf:
    geogebra.common.kernel.geos.GeoPoint F -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoConic parabola -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getParabola() -> a
    geogebra.common.kernel.geos.GeoPoint getFocus() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoPerimeterLocus -> geogebra.common.i.c.cg:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.algos.AlgoPerimeterPoly -> geogebra.common.i.c.ch:
    geogebra.common.kernel.geos.GeoPolygon polygon -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getCircumference() -> a
geogebra.common.kernel.algos.AlgoPointInRegion -> geogebra.common.i.c.ci:
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPointList -> geogebra.common.i.c.cj:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoPointOnPath -> geogebra.common.i.c.ck:
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.arithmetic.NumberValue param -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    geogebra.common.kernel.Path getPath() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isChangeable() -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoPointVector -> geogebra.common.i.c.cl:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoPoint Q -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getQ() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPointsFromList -> geogebra.common.i.c.cm:
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    java.lang.String[] labels -> a
    boolean initLabels -> c
    boolean setLabels -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint[] getPoints() -> a
    void compute() -> b
    void setPoints(double[],double[],int) -> a
    void updateLabels(int) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initPoints(int) -> c
    void removeRootPoint(int) -> e
geogebra.common.kernel.algos.AlgoPolarLine -> geogebra.common.i.c.cn:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoPolyLine -> geogebra.common.i.c.co:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoPolyLine poly -> a
    boolean penStroke -> c
    java.lang.StringBuilder sb -> b
    void createPolyLine() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void updatePointArray(geogebra.common.kernel.geos.GeoList) -> a
    void setInputOutput() -> e
    void update() -> i
    geogebra.common.kernel.geos.GeoPoint[] getPoints() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement[] getPoints() -> b
geogebra.common.kernel.algos.AlgoPolygon -> geogebra.common.i.c.cp:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    geogebra.common.kernel.Matrix.CoordSys cs2D -> a
    geogebra.common.kernel.geos.GeoElement polyhedron -> a
    geogebra.common.kernel.kernelND.GeoDirectionND direction -> a
    java.lang.StringBuilder sb -> b
    void createPolygon(boolean) -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void updatePointArray(geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] createEfficientInput() -> b
    void setInputOutput() -> a
    void setOutput() -> e
    void update() -> i
    geogebra.common.kernel.geos.GeoPoint[] getPoints() -> a
    void remove() -> c
    void compute() -> b
    void createStringBuilder(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoPolygonIntersection -> geogebra.common.i.c.cq:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoPolygonOperation -> geogebra.common.i.c.cr:
    geogebra.common.kernel.geos.GeoPolygon inPoly0 -> a
    geogebra.common.kernel.geos.GeoPolygon inPoly1 -> b
    geogebra.common.kernel.geos.GeoPolygon poly -> c
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation operationType -> a
    boolean labelPointsAndSegments -> c
    boolean labelsNeedIniting -> d
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$AlgoPolygonOperation$PolyOperation -> a
    void setInputOutput() -> a
    void setOutput() -> e
    void compute() -> b
    void updateSegmentsAndPointsLabels() -> f
    void updatePointsArray(int) -> a
    void removePoint(geogebra.common.kernel.geos.GeoPoint) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$AlgoPolygonOperation$PolyOperation() -> a
geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation -> geogebra.common.i.c.cr$a:
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation INTERSECTION -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation UNION -> b
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation DIFFERENCE -> c
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation[] ENUM$VALUES -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation[] values() -> values
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.algos.AlgoPolygonRegular -> geogebra.common.i.c.cs:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    int numOld -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygon -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegments -> c
    geogebra.common.kernel.geos.GeoPoint centerPoint -> c
    geogebra.common.kernel.arithmetic.MyDouble rotAngle -> a
    boolean labelPointsAndSegments -> e
    boolean showNewSegmentsLabels -> c
    boolean showNewPointsLabels -> d
    boolean labelsNeedIniting -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPolygon getPoly() -> a
    void compute() -> b
    void compute(int) -> a
    void updateOutput(int) -> c
    void removePoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void removeOutputExcept(geogebra.common.kernel.geos.GeoElement) -> c
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoPolygonRegular$1 -> geogebra.common.i.c.ct:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoPolygon newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonRegular$2 -> geogebra.common.i.c.cu:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoSegment newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonRegular$3 -> geogebra.common.i.c.cv:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonUnion -> geogebra.common.i.c.cw:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoPolynomialFromCoordinates -> geogebra.common.i.c.cx:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunction g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.Function buildPolyFunctionExpression(geogebra.common.kernel.Kernel,double[]) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void polcoe(double[],double[],int,double[]) -> a
    void polcoeBig(double[],double[],int,double[]) -> b
geogebra.common.kernel.algos.AlgoPolynomialFromFunction -> geogebra.common.i.c.cy:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoProduct -> geogebra.common.i.c.cz:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoQ1 -> geogebra.common.i.c.cA:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    geogebra.common.kernel.geos.GeoNumeric Q1 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getQ1() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoQ3 -> geogebra.common.i.c.cB:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList freqList -> b
    geogebra.common.kernel.geos.GeoNumeric Q3 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getQ3() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRadius -> geogebra.common.i.c.cC:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getRadius() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRandom -> geogebra.common.i.c.cD:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    void setRandomValue(double) -> a
geogebra.common.kernel.algos.AlgoRandomFixed -> geogebra.common.i.c.cE:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoNumeric num -> a
    double random -> a
    double aLast -> b
    double bLast -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRayPointVector -> geogebra.common.i.c.cF:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoRay ray -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoRay getRay() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRemoveUndefined -> geogebra.common.i.c.cG:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoReverse -> geogebra.common.i.c.cH:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRootInterval -> geogebra.common.i.c.cI:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoPoint rootPoint -> a
    geogebra.common.kernel.geos.GeoElement aGeo -> a
    geogebra.common.kernel.geos.GeoElement bGeo -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getRootPoint() -> a
    void compute() -> b
    double calcRoot() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRootList -> geogebra.common.i.c.cJ:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRootNewton -> geogebra.common.i.c.cK:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue start -> a
    geogebra.common.kernel.geos.GeoPoint rootPoint -> a
    geogebra.common.kernel.geos.GeoElement startGeo -> a
    org.apache.commons.math.analysis.solvers.NewtonSolver rootFinderNewton -> a
    org.apache.commons.math.analysis.solvers.BrentSolver rootFinderBrent -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getRootPoint() -> b
    void compute() -> b
    double calcRoot(geogebra.common.kernel.arithmetic.Function,double) -> a
    boolean checkRoot(geogebra.common.kernel.arithmetic.Function,double) -> a
    double[] getDomain(geogebra.common.kernel.arithmetic.Function,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRoots -> geogebra.common.i.c.cL:
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> c
    geogebra.common.kernel.geos.GeoFunction f2 -> d
    geogebra.common.kernel.geos.GeoFunction diff -> e
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    int type -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint[] getRootPoints() -> c
    void setInputOutput() -> a
    void compute() -> b
    void compute2(geogebra.common.kernel.geos.GeoFunction) -> a
    double[] findRoots(geogebra.common.kernel.geos.GeoFunction,double,double,int) -> a
    double calcSingleRoot(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    int findNumberOfSamples(double,double) -> a
    boolean signChanged(geogebra.common.kernel.geos.GeoFunction,double) -> a
    double yAt(double) -> a
geogebra.common.kernel.algos.AlgoRootsPolynomial -> geogebra.common.i.c.cM:
    int mode -> b
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoPoint[] rootPoints -> a
    java.lang.String[] labels -> a
    boolean initLabels -> d
    boolean setLabels -> c
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    double[] curRoots -> b
    int curRealRoots -> a
    geogebra.common.kernel.arithmetic.Function yValFunction -> a
    geogebra.common.kernel.arithmetic.Function diffFunction -> b
    geogebra.common.kernel.geos.GeoPoint tempPoint -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e
    geogebra.common.kernel.geos.GeoPoint[] getRootPoints() -> d
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    void compute() -> b
    void computeRoots() -> f
    void computePolynomialIntersection() -> q
    void computePolyLineIntersection() -> r
    void calcRoots(geogebra.common.kernel.arithmetic.Function,int) -> a
    geogebra.common.kernel.roots.RealRootFunction calcRootsMultiple(geogebra.common.kernel.arithmetic.Function,int) -> a
    void ensureSignChanged(geogebra.common.kernel.roots.RealRootFunction) -> a
    void addToCurrentRoots(double[],int) -> b
    void removeRoot(int) -> e
    void setRootPoints(double[],int) -> a
    void updateLabels(int) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initRootPoints(int) -> c
    void removeRootPoint(int) -> f
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRotate -> geogebra.common.i.c.cN:
    geogebra.common.kernel.geos.Rotateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement angleGeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.algos.AlgoRotatePoint -> geogebra.common.i.c.cO:
    geogebra.common.kernel.geos.GeoPoint Q -> a
    geogebra.common.kernel.geos.PointRotateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement angleGeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.algos.AlgoSemicircle -> geogebra.common.i.c.cP:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    geogebra.common.kernel.geos.GeoPoint M -> c
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConicPart getSemicircle() -> a
    geogebra.common.kernel.geos.GeoPoint getA() -> a
    geogebra.common.kernel.geos.GeoPoint getB() -> b
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoSequence -> geogebra.common.i.c.cQ:
    geogebra.common.kernel.geos.GeoElement expression -> a
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.NumberValue var_from -> a
    geogebra.common.kernel.arithmetic.NumberValue var_to -> b
    geogebra.common.kernel.arithmetic.NumberValue var_step -> c
    geogebra.common.kernel.geos.GeoElement var_from_geo -> b
    geogebra.common.kernel.geos.GeoElement var_to_geo -> c
    geogebra.common.kernel.geos.GeoElement var_step_geo -> d
    geogebra.common.kernel.geos.GeoList list -> a
    boolean isSimple -> c
    double last_from -> a
    double last_to -> b
    double last_step -> c
    boolean expIsFunctionOrCurve -> d
    boolean isEmpty -> e
    geogebra.common.kernel.algos.AlgoElement expressionParentAlgo -> a
    boolean updateRunning -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a
    void compute() -> b
    void computeSimple() -> e
    void createNewList(double,double,double) -> a
    void addElement(int) -> a
    geogebra.common.kernel.geos.GeoElement createNewListElement() -> a
    void updateListItems(double,double,double) -> b
    void updateLocalVar(double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoShearOrStretch -> geogebra.common.i.c.cR:
    geogebra.common.kernel.MatrixTransformable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoVec3D l -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    boolean shear -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial -> geogebra.common.i.c.cS:
    boolean setLabels -> c
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    geogebra.common.kernel.geos.GeoElement[] geos -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler points -> a
    void setRootsPolynomial(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    void setRootsPolynomialWithinRange(org.apache.commons.math.analysis.polynomials.PolynomialFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint[] getLastDefinedIntersectionPoints() -> c
    void setInputOutput() -> e
    int getRoots(double[],geogebra.common.kernel.EquationSolverInterface) -> a
    void doCalc(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> b
    void doCalc(org.apache.commons.math.analysis.polynomials.PolynomialFunction,double,double) -> b
    double distancePairSq(double[],double[]) -> a
    void makePoints(double[],int) -> a
    void setLabels(java.lang.String[]) -> a
    void setPoints(java.util.List) -> b
    int getNrPoints(double) -> a
    double getYValue(double,int) -> a
    double getYValue(double) -> a
    double getXValue(double) -> b
    double getXValue(double,int) -> b
    double[] getXYPair(double,int) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial$1 -> geogebra.common.i.c.cT:
    geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoSlope -> geogebra.common.i.c.cU:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoNumeric slope -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getSlope() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoSort -> geogebra.common.i.c.cV:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.geos.GeoList valueList -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSphereNDPointRadius -> geogebra.common.i.c.cW:
    geogebra.common.kernel.kernelND.GeoPointND M -> a
    geogebra.common.kernel.arithmetic.NumberValue r -> a
    geogebra.common.kernel.geos.GeoElement rgeo -> a
    geogebra.common.kernel.kernelND.GeoQuadricND sphereND -> a
    int type -> a
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoQuadricND getSphereND() -> a
    geogebra.common.kernel.kernelND.GeoPointND getM() -> a
    geogebra.common.kernel.kernelND.GeoPointND getCenter() -> b
    geogebra.common.kernel.geos.GeoElement getRGeo() -> a
    geogebra.common.kernel.geos.GeoElement getRadiusGeo() -> b
    void compute() -> b
    int getType() -> c
geogebra.common.kernel.algos.AlgoSphereNDTwoPoints -> geogebra.common.i.c.cX:
    geogebra.common.kernel.kernelND.GeoPointND M -> a
    geogebra.common.kernel.kernelND.GeoPointND P -> b
    geogebra.common.kernel.kernelND.GeoQuadricND sphereND -> a
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoQuadricND getSphereND() -> a
    geogebra.common.kernel.kernelND.GeoPointND getCenter() -> a
    geogebra.common.kernel.kernelND.GeoPointND getM() -> b
    geogebra.common.kernel.kernelND.GeoPointND getExternalPoint() -> c
    geogebra.common.kernel.kernelND.GeoPointND getP() -> d
    void compute() -> b
geogebra.common.kernel.algos.AlgoStepGraph -> geogebra.common.i.c.cY:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoStickGraph -> geogebra.common.i.c.cZ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoSum -> geogebra.common.i.c.da:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoSumFunctions -> geogebra.common.i.c.db:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric truncate -> a
    geogebra.common.kernel.geos.GeoFunction resultFun -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumLeft -> geogebra.common.i.c.dc:
    geogebra.common.kernel.algos.AlgoSumLeft copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoSumLower -> geogebra.common.i.c.dd:
    geogebra.common.kernel.algos.AlgoSumLower copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoSumPoints -> geogebra.common.i.c.de:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoElement result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumRectangle -> geogebra.common.i.c.df:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumRectangle copy() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoSumText -> geogebra.common.i.c.dg:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoText result -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumTrapezoidal -> geogebra.common.i.c.dh:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumTrapezoidal copy() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoSumUpper -> geogebra.common.i.c.di:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumUpper copy() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.AlgoTableText -> geogebra.common.i.c.dj:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    geogebra.common.kernel.geos.GeoList[] geoLists -> a
    java.lang.StringBuffer sb -> a
    int VERTICAL -> a
    int HORIZONTAL -> b
    int alignment -> c
    boolean verticalLines -> c
    boolean horizontalLines -> d
    java.lang.String justification -> a
    java.lang.String openBracket -> b
    java.lang.String closeBracket -> c
    java.lang.String openString -> d
    java.lang.String closeString -> e
    int columns -> d
    int rows -> e
    boolean isVerticalLines() -> f
    boolean isHorizontalLines() -> n
    java.lang.String getJustification() -> a
    java.lang.String getOpenSymbol() -> d
    java.lang.String getCloseSymbol() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void parseArgs() -> e
    void compute() -> b
    void mathml() -> f
    void latex() -> n
    void addCellLaTeX(int,int,boolean,geogebra.common.kernel.StringTemplate) -> a
    void addCellMathML(int,int,geogebra.common.kernel.StringTemplate) -> a
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.algos.AlgoTake -> geogebra.common.i.c.dk:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric m -> a
    geogebra.common.kernel.geos.GeoNumeric n -> b
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTakeString -> geogebra.common.i.c.dl:
    geogebra.common.kernel.geos.GeoText inputText -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric m -> b
    geogebra.common.kernel.geos.GeoText outputText -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTangentLine -> geogebra.common.i.c.dm:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine diameter -> b
    geogebra.common.kernel.geos.GeoVector direction -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.geos.GeoPoint[] tangentPoints -> a
    int i -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    geogebra.common.kernel.geos.GeoPoint getTangentPoint(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoLine) -> a
    void initForNearToRelationship() -> d_
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTangentPoint -> geogebra.common.i.c.dn:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.geos.GeoPoint[] tangentPoints -> a
    boolean equalLines -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoPoint getTangentPoint(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoLine) -> a
    void initForNearToRelationship() -> d_
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isLocusEquable() -> e
geogebra.common.kernel.algos.AlgoText -> geogebra.common.i.c.do:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoBoolean substituteVars -> a
    geogebra.common.kernel.geos.GeoBoolean latex -> b
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint startPointCopy -> b
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextCorner -> geogebra.common.i.c.dp:
    geogebra.common.kernel.geos.GeoText txt -> a
    geogebra.common.kernel.geos.GeoPoint corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getCorner() -> a
    void compute() -> b
    boolean euclidianViewUpdate() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTextLength -> geogebra.common.i.c.dq:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextToUnicode -> geogebra.common.i.c.dr:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextfield -> geogebra.common.i.c.ds:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoTextField textfield -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoTextField getResult() -> a
    void compute() -> b
    int getRelatedModeID() -> a
geogebra.common.kernel.algos.AlgoTransformation -> geogebra.common.i.c.dt:
    geogebra.common.kernel.algos.AlgoClosestPoint pt -> a
    geogebra.common.kernel.geos.GeoPoint transformedPoint -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void transformList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement copy(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
    void transformLimitedConic(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> c
geogebra.common.kernel.algos.AlgoTranslate -> geogebra.common.i.c.du:
    geogebra.common.kernel.geos.Translateable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> b
    geogebra.common.kernel.geos.GeoElement outGeo -> c
    geogebra.common.kernel.geos.GeoElement v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getVectorCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.algos.AlgoTranslateVector -> geogebra.common.i.c.dv:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoVec3D v -> a
    geogebra.common.kernel.geos.GeoVector w -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getTranslatedVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTurningPointPolynomial -> geogebra.common.i.c.dw:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTwoNumFunction -> geogebra.common.i.c.dx:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoNumeric num -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnicodeToLetter -> geogebra.common.i.c.dy:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnicodeToText -> geogebra.common.i.c.dz:
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnitOrthoVectorLine -> geogebra.common.i.c.dA:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector n -> a
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitOrthoVectorVector -> geogebra.common.i.c.dB:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector n -> b
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitVectorLine -> geogebra.common.i.c.dC:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector u -> a
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitVectorVector -> geogebra.common.i.c.dD:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector u -> b
    double length -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoVector -> geogebra.common.i.c.dE:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.kernelND.GeoVectorND v -> a
    geogebra.common.kernel.kernelND.GeoVectorND createNewVector() -> a
    geogebra.common.kernel.kernelND.GeoPointND newStartPoint() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoVectorND getVector() -> b
    void compute() -> b
    void setCoords() -> e
geogebra.common.kernel.algos.AlgoVectorPoint -> geogebra.common.i.c.dF:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    geogebra.common.kernel.geos.GeoPoint getP() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoVertex -> geogebra.common.i.c.dG:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint[] vertex -> a
    double temp1 -> a
    double temp2 -> b
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint[] getVertex() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoVertexIneq -> geogebra.common.i.c.dH:
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    geogebra.common.kernel.geos.GeoFunctionNVar p -> a
    java.util.List vertices -> a
    geogebra.common.kernel.algos.AlgoElement[][] helpers -> a
    int validVertices -> a
    geogebra.common.kernel.geos.GeoLine helperLine -> a
    geogebra.common.kernel.geos.GeoFunction helperFunction -> a
    double[] co -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$Inequality$IneqType -> a
    void setLabels(java.lang.String[]) -> a
    void setInputOutput() -> a
    void compute() -> b
    void typeSwitch(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> a
    void intParamOneVar(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int,boolean) -> a
    void intParamYX(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> a
    void intParamYLinear(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> b
    void intParamParam(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int,boolean) -> b
    void intParamXY(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> b
    void intParamConic(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int,boolean) -> c
    void intParamXLinear(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> c
    void intParamXParamY(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> d
    void intXY(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> c
    void intConicY(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> d
    void intConicX(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> e
    void intConicConic(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> e
    void intLinearY(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> f
    void intLinearX(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> g
    void intLinearConic(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality,int,int) -> f
    void setHelper(int,int,geogebra.common.kernel.algos.AlgoElement) -> a
    void addVertices(geogebra.common.kernel.algos.AlgoElement,boolean,boolean) -> a
    void addVertices(geogebra.common.kernel.algos.AlgoElement,boolean) -> a
    void intLinearLinear(geogebra.common.kernel.arithmetic.Inequality,geogebra.common.kernel.arithmetic.Inequality) -> h
    void initHelpers() -> e
    void ensurePoint() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoElement[] getVertex() -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$Inequality$IneqType() -> a
geogebra.common.kernel.algos.AlgoVertexIneq$1 -> geogebra.common.i.c.dI:
    geogebra.common.kernel.algos.AlgoVertexIneq this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoVertexPolygon -> geogebra.common.i.c.dJ:
    geogebra.common.kernel.geos.GeoPoly p -> a
    geogebra.common.kernel.arithmetic.NumberValue index -> a
    geogebra.common.kernel.geos.GeoPoint oneVertex -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    int getOutputLength() -> g
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement[] getVertex() -> b
    geogebra.common.kernel.geos.GeoElement getOutput(int) -> a
    geogebra.common.kernel.geos.GeoPoint getOneVertex() -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
geogebra.common.kernel.algos.AlgoVertexPolygon$1 -> geogebra.common.i.c.dK:
    geogebra.common.kernel.algos.AlgoVertexPolygon this$0 -> a
    geogebra.common.kernel.geos.GeoPoint newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgorithmSet -> geogebra.common.i.c.dL:
    java.util.HashMap hashMap -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link head -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link tail -> b
    int size -> a
    int getSize() -> a
    boolean add(geogebra.common.kernel.algos.AlgoElement) -> a
    void addAll(geogebra.common.kernel.algos.AlgorithmSet) -> a
    boolean contains(geogebra.common.kernel.algos.AlgoElement) -> b
    boolean remove(geogebra.common.kernel.algos.AlgoElement) -> c
    void updateAll() -> a
    void updateAllUntil(geogebra.common.kernel.algos.AlgoElement) -> a
    void addAllToCollection(java.util.Collection) -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.algos.AlgorithmSet$AlgorithmSetIterator getIterator() -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link getHead() -> a
    void setHead(geogebra.common.kernel.algos.AlgorithmSet$Link) -> a
    void removeAllFromCollection(java.util.Collection) -> b
geogebra.common.kernel.algos.AlgorithmSet$AlgorithmSetIterator -> geogebra.common.i.c.dL$a:
    geogebra.common.kernel.algos.AlgorithmSet$Link cur -> a
    geogebra.common.kernel.algos.AlgorithmSet this$0 -> a
    void remove() -> remove
    boolean hasNext() -> hasNext
    geogebra.common.kernel.algos.AlgoElement next() -> a
    java.lang.Object next() -> next
geogebra.common.kernel.algos.AlgorithmSet$Link -> geogebra.common.i.c.dL$b:
    geogebra.common.kernel.algos.AlgoElement algo -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link next -> a
    geogebra.common.kernel.algos.AlgorithmSet this$0 -> a
geogebra.common.kernel.algos.Algos -> geogebra.common.i.c.dM:
    geogebra.common.kernel.algos.Algos AlgoAngleConic -> a
    geogebra.common.kernel.algos.Algos AlgoAngleLines -> b
    geogebra.common.kernel.algos.Algos AlgoAngleNumeric -> c
    geogebra.common.kernel.algos.Algos AlgoAnglePoints -> d
    geogebra.common.kernel.algos.Algos AlgoAnglePolygon -> e
    geogebra.common.kernel.algos.Algos AlgoAngleVector -> f
    geogebra.common.kernel.algos.Algos AlgoAngleVectors -> g
    geogebra.common.kernel.algos.Algos AlgoAngularBisector -> h
    geogebra.common.kernel.algos.Algos AlgoAngularBisectorLines -> i
    geogebra.common.kernel.algos.Algos AlgoAngularBisectorPoints -> j
    geogebra.common.kernel.algos.Algos AlgoAreaConic -> k
    geogebra.common.kernel.algos.Algos AlgoAreaPoints -> l
    geogebra.common.kernel.algos.Algos AlgoAreaPolygon -> m
    geogebra.common.kernel.algos.Algos AlgoAsymptote -> n
    geogebra.common.kernel.algos.Algos AlgoAxes -> o
    geogebra.common.kernel.algos.Algos AlgoAxisFirst -> p
    geogebra.common.kernel.algos.Algos AlgoAxisFirstLength -> q
    geogebra.common.kernel.algos.Algos AlgoAxisSecond -> r
    geogebra.common.kernel.algos.Algos AlgoAxisSecondLength -> s
    geogebra.common.kernel.algos.Algos AlgoCubic -> t
    geogebra.common.kernel.algos.Algos AlgoBarycenter -> u
    geogebra.common.kernel.algos.Algos AlgoTrilinear -> v
    geogebra.common.kernel.algos.Algos AlgoCellRange -> w
    geogebra.common.kernel.algos.Algos AlgoCenterConic -> x
    geogebra.common.kernel.algos.Algos AlgoCentroidPolygon -> y
    geogebra.common.kernel.algos.Algos AlgoCirclePointRadius -> z
    geogebra.common.kernel.algos.Algos AlgoCircleThreePoints -> A
    geogebra.common.kernel.algos.Algos AlgoIncircle -> B
    geogebra.common.kernel.algos.Algos AlgoCircleTwoPoints -> C
    geogebra.common.kernel.algos.Algos AlgoConicFivePoints -> D
    geogebra.common.kernel.algos.Algos AlgoConicArc -> E
    geogebra.common.kernel.algos.Algos AlgoConicSector -> F
    geogebra.common.kernel.algos.Algos AlgoCircleArc -> G
    geogebra.common.kernel.algos.Algos AlgoCircleSector -> H
    geogebra.common.kernel.algos.Algos AlgoCircumcircleArc -> I
    geogebra.common.kernel.algos.Algos AlgoCircumcircleSector -> J
    geogebra.common.kernel.algos.Algos AlgoCurveCartesian -> K
    geogebra.common.kernel.algos.Algos AlgoDerivative -> L
    geogebra.common.kernel.algos.Algos AlgoDiameterLine -> M
    geogebra.common.kernel.algos.Algos AlgoDiameterVector -> N
    geogebra.common.kernel.algos.Algos AlgoDilate -> O
    geogebra.common.kernel.algos.Algos AlgoDirection -> P
    geogebra.common.kernel.algos.Algos AlgoDirectrix -> Q
    geogebra.common.kernel.algos.Algos AlgoDistanceLineLine -> R
    geogebra.common.kernel.algos.Algos AlgoDistanceLines3D -> S
    geogebra.common.kernel.algos.Algos AlgoDistancePointObject -> T
    geogebra.common.kernel.algos.Algos AlgoDistancePoints -> U
    geogebra.common.kernel.algos.Algos AlgoEllipseFociLength -> V
    geogebra.common.kernel.algos.Algos AlgoEllipseFociPoint -> W
    geogebra.common.kernel.algos.Algos AlgoExcentricity -> X
    geogebra.common.kernel.algos.Algos AlgoEccentricity -> Y
    geogebra.common.kernel.algos.Algos AlgoExtremumPolynomial -> Z
    geogebra.common.kernel.algos.Algos AlgoExtremumMulti -> aa
    geogebra.common.kernel.algos.Algos AlgoFocus -> ab
    geogebra.common.kernel.algos.Algos AlgoFunctionInterval -> ac
    geogebra.common.kernel.algos.Algos AlgoHyperbolaFociLength -> ad
    geogebra.common.kernel.algos.Algos AlgoHyperbolaFociPoint -> ae
    geogebra.common.kernel.algos.Algos AlgoIf -> af
    geogebra.common.kernel.algos.Algos AlgoIfFunction -> ag
    geogebra.common.kernel.algos.Algos AlgoIntegral -> ah
    geogebra.common.kernel.algos.Algos AlgoIntegralDefinite -> ai
    geogebra.common.kernel.algos.Algos AlgoIntegralFunctions -> aj
    geogebra.common.kernel.algos.Algos AlgoIntersectConics -> ak
    geogebra.common.kernel.algos.Algos AlgoIntersectCS1D1D -> al
    geogebra.common.kernel.algos.Algos AlgoIntersectCS1D2D -> am
    geogebra.common.kernel.algos.Algos AlgoIntersectCS2D2D -> an
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctionLineNewton -> ao
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctionsNewton -> ap
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConic -> aq
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConic3D -> ar
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConicRegion -> as
    geogebra.common.kernel.algos.Algos AlgoIntersectLines -> at
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolyLine -> au
    geogebra.common.kernel.algos.Algos AlgoIntersectLineCurve -> av
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygon -> aw
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygon3D -> ax
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygonalRegion -> ay
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygonalRegion3D -> az
    geogebra.common.kernel.algos.Algos AlgoIntersectLineQuadric3D -> aA
    geogebra.common.kernel.algos.Algos AlgoIntersectPlaneConic -> aB
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanePolygon -> aC
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanePolygonalRegion -> aD
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomialLine -> aE
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomials -> aF
    geogebra.common.kernel.algos.Algos AlgoIntersectSingle -> aG
    geogebra.common.kernel.algos.Algos AlgoIntersectSingle3D -> aH
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomialConic -> aI
    geogebra.common.kernel.algos.Algos AlgoIntersectImplicitpolyParametric -> aJ
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctions -> aK
    geogebra.common.kernel.algos.Algos AlgoIntersectImplicitpolys -> aL
    geogebra.common.kernel.algos.Algos AlgoImageCorner -> aM
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyThroughPoints -> aN
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyFunction -> aO
    geogebra.common.kernel.algos.Algos AlgoTextCorner -> aP
    geogebra.common.kernel.algos.Algos AlgoDrawingPadCorner -> aQ
    geogebra.common.kernel.algos.Algos AlgoJoinPoints -> aR
    geogebra.common.kernel.algos.Algos AlgoJoinPointsRay -> aS
    geogebra.common.kernel.algos.Algos AlgoJoinPointsSegment -> aT
    geogebra.common.kernel.algos.Algos AlgoArcLength -> aU
    geogebra.common.kernel.algos.Algos AlgoLengthSegment -> aV
    geogebra.common.kernel.algos.Algos AlgoLengthVector -> aW
    geogebra.common.kernel.algos.Algos AlgoLineBisector -> aX
    geogebra.common.kernel.algos.Algos AlgoLineBisectorSegment -> aY
    geogebra.common.kernel.algos.Algos AlgoLinePointLine -> aZ
    geogebra.common.kernel.algos.Algos AlgoLinePointVector -> ba
    geogebra.common.kernel.algos.Algos AlgoLocus -> bb
    geogebra.common.kernel.algos.Algos AlgoLocusEquation -> bc
    geogebra.common.kernel.algos.Algos AlgoLocusSlider -> bd
    geogebra.common.kernel.algos.Algos AlgoMidpoint -> be
    geogebra.common.kernel.algos.Algos AlgoMidpointSegment -> bf
    geogebra.common.kernel.algos.Algos AlgoMirror -> bg
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointLine -> bh
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointVector -> bi
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorLine -> bj
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorVector -> bk
    geogebra.common.kernel.algos.Algos AlgoParabolaParameter -> bl
    geogebra.common.kernel.algos.Algos AlgoParabolaPointLine -> bm
    geogebra.common.kernel.algos.Algos AlgoPointOnPath -> bn
    geogebra.common.kernel.algos.Algos AlgoPointVector -> bo
    geogebra.common.kernel.algos.Algos AlgoPolarLine -> bp
    geogebra.common.kernel.algos.Algos AlgoPolygon -> bq
    geogebra.common.kernel.algos.Algos AlgoPolygonRegular -> br
    geogebra.common.kernel.algos.Algos AlgoPolygonUnion -> bs
    geogebra.common.kernel.algos.Algos AlgoPolygonIntersection -> bt
    geogebra.common.kernel.algos.Algos AlgoPolynomialFromFunction -> bu
    geogebra.common.kernel.algos.Algos AlgoPolynomialFromCoordinates -> bv
    geogebra.common.kernel.algos.Algos AlgoRadius -> bw
    geogebra.common.kernel.algos.Algos AlgoRayPointVector -> bx
    geogebra.common.kernel.algos.Algos AlgoRootInterval -> by
    geogebra.common.kernel.algos.Algos AlgoRootNewton -> bz
    geogebra.common.kernel.algos.Algos AlgoRootsPolynomial -> bA
    geogebra.common.kernel.algos.Algos AlgoRoots -> bB
    geogebra.common.kernel.algos.Algos AlgoRotate -> bC
    geogebra.common.kernel.algos.Algos AlgoRotatePoint -> bD
    geogebra.common.kernel.algos.Algos AlgoSemicircle -> bE
    geogebra.common.kernel.algos.Algos AlgoSequence -> bF
    geogebra.common.kernel.algos.Algos AlgoSlope -> bG
    geogebra.common.kernel.algos.Algos AlgoSumLower -> bH
    geogebra.common.kernel.algos.Algos AlgoSumUpper -> bI
    geogebra.common.kernel.algos.Algos AlgoSumLeft -> bJ
    geogebra.common.kernel.algos.Algos AlgoSumRectangle -> bK
    geogebra.common.kernel.algos.Algos AlgoTangentFunctionNumber -> bL
    geogebra.common.kernel.algos.Algos AlgoTangentFunctionPoint -> bM
    geogebra.common.kernel.algos.Algos AlgoTangentImplicitpoly -> bN
    geogebra.common.kernel.algos.Algos AlgoTangentLine -> bO
    geogebra.common.kernel.algos.Algos AlgoTangentPoint -> bP
    geogebra.common.kernel.algos.Algos AlgoCommonTangents -> bQ
    geogebra.common.kernel.algos.Algos AlgoTaylorSeries -> bR
    geogebra.common.kernel.algos.Algos AlgoTranslate -> bS
    geogebra.common.kernel.algos.Algos AlgoTranslateVector -> bT
    geogebra.common.kernel.algos.Algos AlgoTurningPointPolynomial -> bU
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorLine -> bV
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorVector -> bW
    geogebra.common.kernel.algos.Algos AlgoUnitVectorLine -> bX
    geogebra.common.kernel.algos.Algos AlgoUnitVectorVector -> bY
    geogebra.common.kernel.algos.Algos AlgoVector -> bZ
    geogebra.common.kernel.algos.Algos AlgoVectorPoint -> ca
    geogebra.common.kernel.algos.Algos AlgoVertex -> cb
    geogebra.common.kernel.algos.Algos Expression -> cc
    geogebra.common.kernel.algos.Algos AlgoAffineRatio -> cd
    geogebra.common.kernel.algos.Algos AlgoCrossRatio -> ce
    geogebra.common.kernel.algos.Algos AlgoCurvatureVector -> cf
    geogebra.common.kernel.algos.Algos AlgoCurvatureVectorCurve -> cg
    geogebra.common.kernel.algos.Algos AlgoCurvature -> ch
    geogebra.common.kernel.algos.Algos AlgoCurvatureCurve -> ci
    geogebra.common.kernel.algos.Algos AlgoOsculatingCircle -> cj
    geogebra.common.kernel.algos.Algos AlgoOsculatingCircleCurve -> ck
    geogebra.common.kernel.algos.Algos AlgoTangentCurve -> cl
    geogebra.common.kernel.algos.Algos AlgoLengthFunction -> cm
    geogebra.common.kernel.algos.Algos AlgoLengthFunction2Points -> cn
    geogebra.common.kernel.algos.Algos AlgoLengthCurve -> co
    geogebra.common.kernel.algos.Algos AlgoLengthCurve2Points -> cp
    geogebra.common.kernel.algos.Algos AlgoCircumferenceConic -> cq
    geogebra.common.kernel.algos.Algos AlgoPerimeterPoly -> cr
    geogebra.common.kernel.algos.Algos AlgoPerimeterLocus -> cs
    geogebra.common.kernel.algos.Algos AlgoMod -> ct
    geogebra.common.kernel.algos.Algos AlgoDiv -> cu
    geogebra.common.kernel.algos.Algos AlgoMax -> cv
    geogebra.common.kernel.algos.Algos AlgoFunctionMax -> cw
    geogebra.common.kernel.algos.Algos AlgoMin -> cx
    geogebra.common.kernel.algos.Algos AlgoFunctionMin -> cy
    geogebra.common.kernel.algos.Algos AlgoLCM -> cz
    geogebra.common.kernel.algos.Algos AlgoListLCM -> cA
    geogebra.common.kernel.algos.Algos AlgoGCD -> cB
    geogebra.common.kernel.algos.Algos AlgoListGCD -> cC
    geogebra.common.kernel.algos.Algos AlgoSort -> cD
    geogebra.common.kernel.algos.Algos AlgoFirst -> cE
    geogebra.common.kernel.algos.Algos AlgoLast -> cF
    geogebra.common.kernel.algos.Algos AlgoTake -> cG
    geogebra.common.kernel.algos.Algos AlgoRemoveUndefined -> cH
    geogebra.common.kernel.algos.Algos AlgoDefined -> cI
    geogebra.common.kernel.algos.Algos AlgoReverse -> cJ
    geogebra.common.kernel.algos.Algos AlgoSum -> cK
    geogebra.common.kernel.algos.Algos AlgoMean -> cL
    geogebra.common.kernel.algos.Algos AlgoMeanGrouped -> cM
    geogebra.common.kernel.algos.Algos AlgoVariance -> cN
    geogebra.common.kernel.algos.Algos AlgoSigmaXX -> cO
    geogebra.common.kernel.algos.Algos AlgoStandardDeviation -> cP
    geogebra.common.kernel.algos.Algos AlgoMedian -> cQ
    geogebra.common.kernel.algos.Algos AlgoQ1 -> cR
    geogebra.common.kernel.algos.Algos AlgoQ3 -> cS
    geogebra.common.kernel.algos.Algos AlgoMode -> cT
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaXY -> cU
    geogebra.common.kernel.algos.Algos AlgoDoubleListPMCC -> cV
    geogebra.common.kernel.algos.Algos AlgoDoubleListCovariance -> cW
    geogebra.common.kernel.algos.Algos AlgoDoubleListMeanX -> cX
    geogebra.common.kernel.algos.Algos AlgoDoubleListMeanY -> cY
    geogebra.common.kernel.algos.Algos AlgoDoubleListSXY -> cZ
    geogebra.common.kernel.algos.Algos AlgoListSigmaXY -> da
    geogebra.common.kernel.algos.Algos AlgoListSigmaXX -> db
    geogebra.common.kernel.algos.Algos AlgoListSigmaYY -> dc
    geogebra.common.kernel.algos.Algos AlgoListPMCC -> dd
    geogebra.common.kernel.algos.Algos AlgoListCovariance -> de
    geogebra.common.kernel.algos.Algos AlgoListMeanX -> df
    geogebra.common.kernel.algos.Algos AlgoListMeanY -> dg
    geogebra.common.kernel.algos.Algos AlgoListSampleSDX -> dh
    geogebra.common.kernel.algos.Algos AlgoListSampleSDY -> di
    geogebra.common.kernel.algos.Algos AlgoSXX -> dj
    geogebra.common.kernel.algos.Algos AlgoListSXX -> dk
    geogebra.common.kernel.algos.Algos AlgoListSYY -> dl
    geogebra.common.kernel.algos.Algos AlgoListSXY -> dm
    geogebra.common.kernel.algos.Algos AlgoFitLineY -> dn
    geogebra.common.kernel.algos.Algos AlgoFitLineX -> do
    geogebra.common.kernel.algos.Algos AlgoFitPoly -> dp
    geogebra.common.kernel.algos.Algos AlgoFitExp -> dq
    geogebra.common.kernel.algos.Algos AlgoFitLog -> dr
    geogebra.common.kernel.algos.Algos AlgoFitPow -> ds
    geogebra.common.kernel.algos.Algos AlgoRandomNormal -> dt
    geogebra.common.kernel.algos.Algos AlgoInverseNormal -> du
    geogebra.common.kernel.algos.Algos AlgoNormal -> dv
    geogebra.common.kernel.algos.Algos AlgoNormalDF -> dw
    geogebra.common.kernel.algos.Algos AlgoLogsticDF -> dx
    geogebra.common.kernel.algos.Algos AlgoLogstic -> dy
    geogebra.common.kernel.algos.Algos AlgoInverseLogstic -> dz
    geogebra.common.kernel.algos.Algos AlgoCauchyDF -> dA
    geogebra.common.kernel.algos.Algos AlgoFDistributionDF -> dB
    geogebra.common.kernel.algos.Algos AlgoErlang -> dC
    geogebra.common.kernel.algos.Algos AlgoErlangDF -> dD
    geogebra.common.kernel.algos.Algos AlgoTriangular -> dE
    geogebra.common.kernel.algos.Algos AlgoTriangularDF -> dF
    geogebra.common.kernel.algos.Algos AlgoUniformDF -> dG
    geogebra.common.kernel.algos.Algos AlgoUniform -> dH
    geogebra.common.kernel.algos.Algos AlgoWeibullDF -> dI
    geogebra.common.kernel.algos.Algos AlgoLogNormalDF -> dJ
    geogebra.common.kernel.algos.Algos AlgoLogNormal -> dK
    geogebra.common.kernel.algos.Algos AlgoInverseLogNormal -> dL
    geogebra.common.kernel.algos.Algos AlgoGammaDF -> dM
    geogebra.common.kernel.algos.Algos AlgoChiSquaredDF -> dN
    geogebra.common.kernel.algos.Algos AlgoExponentialDF -> dO
    geogebra.common.kernel.algos.Algos AlgoTDistributionDF -> dP
    geogebra.common.kernel.algos.Algos AlgoBinomial -> dQ
    geogebra.common.kernel.algos.Algos AlgoExpand -> dR
    geogebra.common.kernel.algos.Algos AlgoFactor -> dS
    geogebra.common.kernel.algos.Algos AlgoFactors -> dT
    geogebra.common.kernel.algos.Algos AlgoConstructionStep -> dU
    geogebra.common.kernel.algos.Algos AlgoStepObject -> dV
    geogebra.common.kernel.algos.Algos AlgoName -> dW
    geogebra.common.kernel.algos.Algos AlgoListMax -> dX
    geogebra.common.kernel.algos.Algos AlgoListMin -> dY
    geogebra.common.kernel.algos.Algos AlgoListElement -> dZ
    geogebra.common.kernel.algos.Algos AlgoListLength -> ea
    geogebra.common.kernel.algos.Algos AlgoIteration -> eb
    geogebra.common.kernel.algos.Algos AlgoIterationList -> ec
    geogebra.common.kernel.algos.Algos AlgoProduct -> ed
    geogebra.common.kernel.algos.Algos AlgoRow -> ee
    geogebra.common.kernel.algos.Algos AlgoColumn -> ef
    geogebra.common.kernel.algos.Algos AlgoLaTeX -> eg
    geogebra.common.kernel.algos.Algos AlgoUnicodeToLetter -> eh
    geogebra.common.kernel.algos.Algos AlgoUnicodeToText -> ei
    geogebra.common.kernel.algos.Algos AlgoTextToUnicode -> ej
    geogebra.common.kernel.algos.Algos AlgoLetterToUnicode -> ek
    geogebra.common.kernel.algos.Algos AlgoBarChart -> el
    geogebra.common.kernel.algos.Algos AlgoBoxPlot -> em
    geogebra.common.kernel.algos.Algos AlgoStickGraph -> en
    geogebra.common.kernel.algos.Algos AlgoStepGraph -> eo
    geogebra.common.kernel.algos.Algos AlgoHistogram -> ep
    geogebra.common.kernel.algos.Algos AlgoHistogramRight -> eq
    geogebra.common.kernel.algos.Algos AlgoDotPlot -> er
    geogebra.common.kernel.algos.Algos AlgoResidualPlot -> es
    geogebra.common.kernel.algos.Algos AlgoNormalQuantilePlot -> et
    geogebra.common.kernel.algos.Algos AlgoSumTrapezoidal -> eu
    geogebra.common.kernel.algos.Algos AlgoTableText -> ev
    geogebra.common.kernel.algos.Algos AlgoObject -> ew
    geogebra.common.kernel.algos.Algos AlgoColumnName -> ex
    geogebra.common.kernel.algos.Algos AlgoAppend -> ey
    geogebra.common.kernel.algos.Algos AlgoJoin -> ez
    geogebra.common.kernel.algos.Algos AlgoFlatten -> eA
    geogebra.common.kernel.algos.Algos AlgoUnion -> eB
    geogebra.common.kernel.algos.Algos AlgoInsert -> eC
    geogebra.common.kernel.algos.Algos AlgoIntersection -> eD
    geogebra.common.kernel.algos.Algos AlgoSumFunctions -> eE
    geogebra.common.kernel.algos.Algos AlgoIsInteger -> eF
    geogebra.common.kernel.algos.Algos AlgoRandom -> eG
    geogebra.common.kernel.algos.Algos AlgoRandomFixed -> eH
    geogebra.common.kernel.algos.Algos AlgoRandomUniform -> eI
    geogebra.common.kernel.algos.Algos AlgoRandomBinomial -> eJ
    geogebra.common.kernel.algos.Algos AlgoRandomPoisson -> eK
    geogebra.common.kernel.algos.Algos AlgoFractionText -> eL
    geogebra.common.kernel.algos.Algos AlgoKeepIf -> eM
    geogebra.common.kernel.algos.Algos AlgoKeepIf3 -> eN
    geogebra.common.kernel.algos.Algos AlgoCountIf -> eO
    geogebra.common.kernel.algos.Algos AlgoCountIf3 -> eP
    geogebra.common.kernel.algos.Algos AlgoAxisStepX -> eQ
    geogebra.common.kernel.algos.Algos AlgoAxisStepY -> eR
    geogebra.common.kernel.algos.Algos AlgoInvert -> eS
    geogebra.common.kernel.algos.Algos AlgoTranspose -> eT
    geogebra.common.kernel.algos.Algos AlgoDeterminant -> eU
    geogebra.common.kernel.algos.Algos AlgoSumText -> eV
    geogebra.common.kernel.algos.Algos AlgoSimplify -> eW
    geogebra.common.kernel.algos.Algos AlgoText -> eX
    geogebra.common.kernel.algos.Algos AlgoFitSin -> eY
    geogebra.common.kernel.algos.Algos AlgoFitLogistic -> eZ
    geogebra.common.kernel.algos.Algos AlgoSumPoints -> fa
    geogebra.common.kernel.algos.Algos AlgoSurdText -> fb
    geogebra.common.kernel.algos.Algos AlgoScientificText -> fc
    geogebra.common.kernel.algos.Algos AlgoSurdTextPoint -> fd
    geogebra.common.kernel.algos.Algos AlgoTTest -> fe
    geogebra.common.kernel.algos.Algos AlgoZProportionTest -> ff
    geogebra.common.kernel.algos.Algos AlgoZMeanTest -> fg
    geogebra.common.kernel.algos.Algos AlgoZMean2Test -> fh
    geogebra.common.kernel.algos.Algos AlgoZProportion2Test -> fi
    geogebra.common.kernel.algos.Algos AlgoZProportionEstimate -> fj
    geogebra.common.kernel.algos.Algos AlgoZProportion2Estimate -> fk
    geogebra.common.kernel.algos.Algos AlgoZMeanEstimate -> fl
    geogebra.common.kernel.algos.Algos AlgoZMean2Estimate -> fm
    geogebra.common.kernel.algos.Algos AlgoTTestPaired -> fn
    geogebra.common.kernel.algos.Algos AlgoTTest2 -> fo
    geogebra.common.kernel.algos.Algos AlgoTMeanEstimate -> fp
    geogebra.common.kernel.algos.Algos AlgoTMean2Estimate -> fq
    geogebra.common.kernel.algos.Algos AlgoChiSquareTest -> fr
    geogebra.common.kernel.algos.Algos AlgoANOVA -> fs
    geogebra.common.kernel.algos.Algos AlgoPercentile -> ft
    geogebra.common.kernel.algos.Algos AlgoGeometricMean -> fu
    geogebra.common.kernel.algos.Algos AlgoHarmonicMean -> fv
    geogebra.common.kernel.algos.Algos AlgoDynamicCoordinates -> fw
    geogebra.common.kernel.algos.Algos AlgoTDistribution -> fx
    geogebra.common.kernel.algos.Algos AlgoInverseTDistribution -> fy
    geogebra.common.kernel.algos.Algos AlgoFDistribution -> fz
    geogebra.common.kernel.algos.Algos AlgoInverseFDistribution -> fA
    geogebra.common.kernel.algos.Algos AlgoGamma -> fB
    geogebra.common.kernel.algos.Algos AlgoInverseGamma -> fC
    geogebra.common.kernel.algos.Algos AlgoCauchy -> fD
    geogebra.common.kernel.algos.Algos AlgoInverseCauchy -> fE
    geogebra.common.kernel.algos.Algos AlgoChiSquared -> fF
    geogebra.common.kernel.algos.Algos AlgoInverseChiSquared -> fG
    geogebra.common.kernel.algos.Algos AlgoExponential -> fH
    geogebra.common.kernel.algos.Algos AlgoInverseExponential -> fI
    geogebra.common.kernel.algos.Algos AlgoHyperGeometric -> fJ
    geogebra.common.kernel.algos.Algos AlgoHyperGeometricBarChart -> fK
    geogebra.common.kernel.algos.Algos AlgoInverseHyperGeometric -> fL
    geogebra.common.kernel.algos.Algos AlgoPascal -> fM
    geogebra.common.kernel.algos.Algos AlgoPascalBarChart -> fN
    geogebra.common.kernel.algos.Algos AlgoInversePascal -> fO
    geogebra.common.kernel.algos.Algos AlgoPoisson -> fP
    geogebra.common.kernel.algos.Algos AlgoPoissonBarChart -> fQ
    geogebra.common.kernel.algos.Algos AlgoInversePoisson -> fR
    geogebra.common.kernel.algos.Algos AlgoBinomialDist -> fS
    geogebra.common.kernel.algos.Algos AlgoBinomialDistBarChart -> fT
    geogebra.common.kernel.algos.Algos AlgoInverseBinomial -> fU
    geogebra.common.kernel.algos.Algos AlgoWeibull -> fV
    geogebra.common.kernel.algos.Algos AlgoInverseWeibull -> fW
    geogebra.common.kernel.algos.Algos AlgoZipf -> fX
    geogebra.common.kernel.algos.Algos AlgoInverseZipf -> fY
    geogebra.common.kernel.algos.Algos AlgoCell -> fZ
    geogebra.common.kernel.algos.Algos AlgoTextLength -> ga
    geogebra.common.kernel.algos.Algos AlgoTextElement -> gb
    geogebra.common.kernel.algos.Algos AlgoPolynomialDiv -> gc
    geogebra.common.kernel.algos.Algos AlgoPolynomialMod -> gd
    geogebra.common.kernel.algos.Algos AlgoDegree -> ge
    geogebra.common.kernel.algos.Algos AlgoCoefficients -> gf
    geogebra.common.kernel.algos.Algos AlgoConicCoefficients -> gg
    geogebra.common.kernel.algos.Algos AlgoConicFromCoeffList -> gh
    geogebra.common.kernel.algos.Algos AlgoLimit -> gi
    geogebra.common.kernel.algos.Algos AlgoLimitBelow -> gj
    geogebra.common.kernel.algos.Algos AlgoLimitAbove -> gk
    geogebra.common.kernel.algos.Algos AlgoAsymptoteFunction -> gl
    geogebra.common.kernel.algos.Algos AlgoAsymptoteImplicitPoly -> gm
    geogebra.common.kernel.algos.Algos AlgoPartialFractions -> gn
    geogebra.common.kernel.algos.Algos AlgoNumerator -> go
    geogebra.common.kernel.algos.Algos AlgoFunctionInvert -> gp
    geogebra.common.kernel.algos.Algos AlgoDenominator -> gq
    geogebra.common.kernel.algos.Algos AlgoSumSquaredErrors -> gr
    geogebra.common.kernel.algos.Algos AlgoRSquare -> gs
    geogebra.common.kernel.algos.Algos AlgoFit -> gt
    geogebra.common.kernel.algos.Algos AlgoFitNL -> gu
    geogebra.common.kernel.algos.Algos AlgoFitGrowth -> gv
    geogebra.common.kernel.algos.Algos AlgoPointsFromList -> gw
    geogebra.common.kernel.algos.Algos AlgoPointList -> gx
    geogebra.common.kernel.algos.Algos AlgoRootList -> gy
    geogebra.common.kernel.algos.Algos AlgoIntersectLineCubic -> gz
    geogebra.common.kernel.algos.Algos AlgoSampleStandardDeviation -> gA
    geogebra.common.kernel.algos.Algos AlgoSampleVariance -> gB
    geogebra.common.kernel.algos.Algos AlgoSpearman -> gC
    geogebra.common.kernel.algos.Algos AlgoFrequencyPolygon -> gD
    geogebra.common.kernel.algos.Algos AlgoFrequencyTable -> gE
    geogebra.common.kernel.algos.Algos AlgoContingencyTable -> gF
    geogebra.common.kernel.algos.Algos AlgoReducedRowEchelonForm -> gG
    geogebra.common.kernel.algos.Algos AlgoTiedRank -> gH
    geogebra.common.kernel.algos.Algos AlgoOrdinalRank -> gI
    geogebra.common.kernel.algos.Algos AlgoShuffle -> gJ
    geogebra.common.kernel.algos.Algos AlgoRotateVector -> gK
    geogebra.common.kernel.algos.Algos AlgoRandomElement -> gL
    geogebra.common.kernel.algos.Algos AlgoApplyMatrix -> gM
    geogebra.common.kernel.algos.Algos AlgoShear -> gN
    geogebra.common.kernel.algos.Algos AlgoStretch -> gO
    geogebra.common.kernel.algos.Algos AlgoComplexRoot -> gP
    geogebra.common.kernel.algos.Algos AlgoSimplifyText -> gQ
    geogebra.common.kernel.algos.Algos AlgoSolveODE -> gR
    geogebra.common.kernel.algos.Algos AlgoIntegralODE -> gS
    geogebra.common.kernel.algos.Algos AlgoSlopeField -> gT
    geogebra.common.kernel.algos.Algos AlgoSolveODE2 -> gU
    geogebra.common.kernel.algos.Algos AlgoSolveODECas -> gV
    geogebra.common.kernel.algos.Algos AlgoPolyLine -> gW
    geogebra.common.kernel.algos.Algos AlgoPolyLine3D -> gX
    geogebra.common.kernel.algos.Algos AlgoFirstString -> gY
    geogebra.common.kernel.algos.Algos AlgoLastString -> gZ
    geogebra.common.kernel.algos.Algos AlgoTakeString -> ha
    geogebra.common.kernel.algos.Algos AlgoRotateText -> hb
    geogebra.common.kernel.algos.Algos AlgoVerticalText -> hc
    geogebra.common.kernel.algos.Algos AlgoSample -> hd
    geogebra.common.kernel.algos.Algos AlgoVoronoi -> he
    geogebra.common.kernel.algos.Algos AlgoHull -> hf
    geogebra.common.kernel.algos.Algos AlgoConvexHull -> hg
    geogebra.common.kernel.algos.Algos AlgoMinimumSpanningTree -> hh
    geogebra.common.kernel.algos.Algos AlgoDelauneyTriangulation -> hi
    geogebra.common.kernel.algos.Algos AlgoTravelingSalesman -> hj
    geogebra.common.kernel.algos.Algos AlgoShortestDistance -> hk
    geogebra.common.kernel.algos.Algos AlgoSelectedElement -> hl
    geogebra.common.kernel.algos.Algos AlgoSelectedIndex -> hm
    geogebra.common.kernel.algos.Algos AlgoStemPlot -> hn
    geogebra.common.kernel.algos.Algos AlgoFrequency -> ho
    geogebra.common.kernel.algos.Algos AlgoUnique -> hp
    geogebra.common.kernel.algos.Algos AlgoClasses -> hq
    geogebra.common.kernel.algos.Algos AlgoIndexOf -> hr
    geogebra.common.kernel.algos.Algos AlgoZip -> hs
    geogebra.common.kernel.algos.Algos AlgoFirstLocus -> ht
    geogebra.common.kernel.algos.Algos AlgoLengthLocus -> hu
    geogebra.common.kernel.algos.Algos AlgoPrimeFactors -> hv
    geogebra.common.kernel.algos.Algos AlgoIsInRegion -> hw
    geogebra.common.kernel.algos.Algos AlgoPathParameter -> hx
    geogebra.common.kernel.algos.Algos AlgoClosestPoint -> hy
    geogebra.common.kernel.algos.Algos AlgoClosestPoint3D -> hz
    geogebra.common.kernel.algos.Algos AlgoClosestPointLines3D -> hA
    geogebra.common.kernel.algos.Algos AlgoClosestPointToRegion3D -> hB
    geogebra.common.kernel.algos.Algos AlgoComplexPolynomial -> hC
    geogebra.common.kernel.algos.Algos AlgoOrdinal -> hD
    geogebra.common.kernel.algos.Algos AlgoIntervalMidpoint -> hE
    geogebra.common.kernel.algos.Algos AlgoIntervalMin -> hF
    geogebra.common.kernel.algos.Algos AlgoIntervalMax -> hG
    geogebra.common.kernel.algos.Algos AlgoMaximize -> hH
    geogebra.common.kernel.algos.Algos AlgoMinimize -> hI
    geogebra.common.kernel.algos.Algos AlgoTextfield -> hJ
    geogebra.common.kernel.algos.Algos AlgoListSDX -> hK
    geogebra.common.kernel.algos.Algos AlgoListSDY -> hL
    geogebra.common.kernel.algos.Algos AlgoRootMeanSquare -> hM
    geogebra.common.kernel.algos.Algos AlgoCompleteSquare -> hN
    geogebra.common.kernel.algos.Algos AlgoBernoulliBarChart -> hO
    geogebra.common.kernel.algos.Algos AlgoZipfBarChart -> hP
    geogebra.common.kernel.algos.Algos AlgoKimberling -> hQ
    geogebra.common.kernel.algos.Algos AlgoFunctionFreehand -> hR
    geogebra.common.kernel.algos.Algos AlgoTriangleCurve -> hS
    geogebra.common.kernel.algos.Algos AlgoPolygon3D -> hT
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DSegment -> hU
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DLine -> hV
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DRay -> hW
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePoint -> hX
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointPlane -> hY
    geogebra.common.kernel.algos.Algos AlgoOrthoLineLineLine -> hZ
    geogebra.common.kernel.algos.Algos AlgoOrthoLineLinePointPlane -> ia
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorPlane -> ib
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorPlane -> ic
    geogebra.common.kernel.algos.Algos AlgoCircle3DThreePoints -> id
    geogebra.common.kernel.algos.Algos AlgoCircleAxisPoint -> ie
    geogebra.common.kernel.algos.Algos AlgoCirclePointRadiusDirection -> if
    geogebra.common.kernel.algos.Algos AlgoCirclePointPointDirection -> ig
    geogebra.common.kernel.algos.Algos AlgoPlane -> ih
    geogebra.common.kernel.algos.Algos AlgoPlaneThroughPoint -> ii
    geogebra.common.kernel.algos.Algos AlgoOrthoPlanePoint -> ij
    geogebra.common.kernel.algos.Algos AlgoPlaneBisector -> ik
    geogebra.common.kernel.algos.Algos AlgoPoint3DOnPath -> il
    geogebra.common.kernel.algos.Algos AlgoIntersectCoordSys -> im
    geogebra.common.kernel.algos.Algos AlgoPointInRegion -> in
    geogebra.common.kernel.algos.Algos AlgoPoint3DInRegion -> io
    geogebra.common.kernel.algos.Algos AlgoSphere -> ip
    geogebra.common.kernel.algos.Algos AlgoPrism -> iq
    geogebra.common.kernel.algos.Algos AlgoPyramid -> ir
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanes -> is
    geogebra.common.kernel.algos.Algos AlgoIntersectPlaneQuadric -> it
    geogebra.common.kernel.algos.Algos AlgoSpherePointRadius -> iu
    geogebra.common.kernel.algos.Algos AlgoSphereTwoPoints -> iv
    geogebra.common.kernel.algos.Algos AlgoCone -> iw
    geogebra.common.kernel.algos.Algos AlgoLimitedCone -> ix
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointVectorNumber -> iy
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointPointNumber -> iz
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointLineAngle -> iA
    geogebra.common.kernel.algos.Algos AlgoCylinder -> iB
    geogebra.common.kernel.algos.Algos AlgoLimitedCylinder -> iC
    geogebra.common.kernel.algos.Algos AlgoCylinderInfinitePointPointNumber -> iD
    geogebra.common.kernel.algos.Algos AlgoCylinderInfinitePointVectorNumber -> iE
    geogebra.common.kernel.algos.Algos AlgoCylinderInfiniteAxisRadius -> iF
    geogebra.common.kernel.algos.Algos AlgoTetrahedron -> iG
    geogebra.common.kernel.algos.Algos AlgoCube -> iH
    geogebra.common.kernel.algos.Algos AlgoOctahedron -> iI
    geogebra.common.kernel.algos.Algos AlgoDodecahedron -> iJ
    geogebra.common.kernel.algos.Algos AlgoIcosahedron -> iK
    geogebra.common.kernel.algos.Algos AlgoQuadricSide -> iL
    geogebra.common.kernel.algos.Algos AlgoQuadricEnds -> iM
    geogebra.common.kernel.algos.Algos AlgoQuadricEndBottom -> iN
    geogebra.common.kernel.algos.Algos AlgoQuadricEndTop -> iO
    geogebra.common.kernel.algos.Algos AlgoSurfaceCartesian -> iP
    geogebra.common.kernel.algos.Algos AlgoDependentPlane -> iQ
    geogebra.common.kernel.algos.Algos AlgoDependentPoint3D -> iR
    geogebra.common.kernel.algos.Algos AlgoDependentPoint -> iS
    geogebra.common.kernel.algos.Algos AlgoDependentList -> iT
    geogebra.common.kernel.algos.Algos AlgoDependentImplicitPoly -> iU
    geogebra.common.kernel.algos.Algos AlgoDependentCasCell -> iV
    geogebra.common.kernel.algos.Algos AlgoDependentVector -> iW
    geogebra.common.kernel.algos.Algos AlgoDependentText -> iX
    geogebra.common.kernel.algos.Algos AlgoDependentNumber -> iY
    geogebra.common.kernel.algos.Algos AlgoDependentListExpression -> iZ
    geogebra.common.kernel.algos.Algos AlgoDependentBoolean -> ja
    geogebra.common.kernel.algos.Algos AlgoDependentConic -> jb
    geogebra.common.kernel.algos.Algos AlgoDependentFunction -> jc
    geogebra.common.kernel.algos.Algos AlgoDependentFunctionNVar -> jd
    geogebra.common.kernel.algos.Algos AlgoDependentInterval -> je
    geogebra.common.kernel.algos.Algos AlgoDependentLine -> jf
    geogebra.common.kernel.algos.Algos AlgoCellRangeExpression -> jg
    geogebra.common.kernel.algos.Algos AlgoDependentGeoCopy -> jh
    geogebra.common.kernel.algos.Algos AlgoMacro -> ji
    geogebra.common.kernel.algos.Algos AlgoTo2D -> jj
    geogebra.common.kernel.algos.Algos AlgoDependentVector3D -> jk
    geogebra.common.kernel.algos.Algos AlgoParametricDerivative -> jl
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaXX -> jm
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaYY -> jn
    geogebra.common.kernel.algos.Algos AlgoDoubleListSXX -> jo
    geogebra.common.kernel.algos.Algos AlgoDoubleListSYY -> jp
    geogebra.common.kernel.algos.Algos AlgoExtremumNumerical -> jq
    geogebra.common.kernel.algos.Algos AlgoSimpleRootsPoly -> jr
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyTangentCurve -> js
    geogebra.common.kernel.algos.Algos AlgoToBase -> jt
    geogebra.common.kernel.algos.Algos AlgoFromBase -> ju
    geogebra.common.kernel.algos.Algos AlgoContinuedFraction -> jv
    geogebra.common.kernel.algos.Algos AlgoAttachCopyToView -> jw
    geogebra.common.kernel.algos.Algos AlgoDivisorsSum -> jx
    geogebra.common.kernel.algos.Algos AlgoDivisors -> jy
    geogebra.common.kernel.algos.Algos AlgoDimension -> jz
    geogebra.common.kernel.algos.Algos AlgoDivisorsList -> jA
    geogebra.common.kernel.algos.Algos AlgoPolynomialDivision -> jB
    geogebra.common.kernel.algos.Algos AlgoDivision -> jC
    geogebra.common.kernel.algos.Algos AlgoNpR -> jD
    geogebra.common.kernel.algos.Algos AlgoIsPrime -> jE
    geogebra.common.kernel.algos.Algos AlgoNextPrime -> jF
    geogebra.common.kernel.algos.Algos AlgoPreviousPrime -> jG
    geogebra.common.kernel.algos.Algos AlgoMatrixRank -> jH
    geogebra.common.kernel.algos.Algos AlgoRandomPolynomial -> jI
    geogebra.common.kernel.algos.Algos AlgoLeftSide -> jJ
    geogebra.common.kernel.algos.Algos AlgoRightSide -> jK
    geogebra.common.kernel.algos.Algos AlgoImplicitDerivative -> jL
    geogebra.common.kernel.algos.Algos AlgoToPolar -> jM
    geogebra.common.kernel.algos.Algos AlgoToComplex -> jN
    geogebra.common.kernel.algos.Algos AlgoTrigSimplify -> jO
    geogebra.common.kernel.algos.Algos AlgoTrigCombine -> jP
    geogebra.common.kernel.algos.Algos AlgoTrigExpand -> jQ
    geogebra.common.kernel.algos.Algos AlgoCommonDenominator -> jR
    geogebra.common.kernel.algos.Algos AlgoPolynomialCD -> jS
    geogebra.common.kernel.algos.Algos AlgoToPoint -> jT
    geogebra.common.kernel.algos.Algos AlgoNIntegral -> jU
    geogebra.common.kernel.algos.Algos AlgoIdentity -> jV
    java.lang.String command -> a
    geogebra.common.kernel.algos.Algos[] ENUM$VALUES -> a
    java.lang.String getCommand() -> a
    geogebra.common.kernel.algos.Algos[] values() -> values
    geogebra.common.kernel.algos.Algos valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.algos.AngleAlgo -> geogebra.common.i.c.dN:
geogebra.common.kernel.algos.CmdUnitOrthogonalVector -> geogebra.common.i.c.dO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.algos.CmdUnitVector -> geogebra.common.i.c.dP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.algos.ConstructionElement -> geogebra.common.i.c.dQ:
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    int constIndex -> a
    long ceIDcounter -> a
    long ceID -> b
    void setConstruction(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.Construction getConstruction() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int getMinConstructionIndex() -> h
    int getMaxConstructionIndex() -> i
    int getConstructionIndex() -> b
    void setConstructionIndex(int) -> d
    boolean isInConstructionList() -> i_
    boolean isConsProtocolBreakpoint() -> j
    boolean isAvailableAtConstructionStep(int) -> a
    boolean isIndependent() -> k
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void getXML(java.lang.StringBuilder) -> a
    void remove() -> c
    void update() -> i
    void notifyRemove() -> m
    void notifyAdd() -> l
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> e
    boolean isGeoElement() -> i
    boolean isAlgoElement() -> h
    java.lang.String getNameDescription() -> b
    int getRelatedModeID() -> a
    int compareTo(geogebra.common.kernel.algos.ConstructionElement) -> a
    boolean equals(java.lang.Object) -> equals
    long getID() -> a
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.algos.DependentAlgo -> geogebra.common.i.c.dR:
geogebra.common.kernel.algos.DrawInformationAlgo -> geogebra.common.i.c.dS:
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.algos.EquationElementInterface -> geogebra.common.i.c.dT:
geogebra.common.kernel.algos.EquationScopeInterface -> geogebra.common.i.c.dU:
geogebra.common.kernel.algos.GetPointsAlgo -> geogebra.common.i.c.dV:
    geogebra.common.kernel.geos.GeoElement[] getPoints() -> b
geogebra.common.kernel.algos.TangentAlgo -> geogebra.common.i.c.dW:
geogebra.common.kernel.arithmetic.AssignmentType -> geogebra.common.i.d.a:
    geogebra.common.kernel.arithmetic.AssignmentType NONE -> a
    geogebra.common.kernel.arithmetic.AssignmentType DEFAULT -> b
    geogebra.common.kernel.arithmetic.AssignmentType DELAYED -> c
    geogebra.common.kernel.arithmetic.AssignmentType[] ENUM$VALUES -> a
    geogebra.common.kernel.arithmetic.AssignmentType[] values() -> values
    geogebra.common.kernel.arithmetic.AssignmentType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.arithmetic.BooleanValue -> geogebra.common.i.d.b:
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    boolean getBoolean() -> a
    double getDouble() -> a
geogebra.common.kernel.arithmetic.Command -> geogebra.common.i.d.c:
    java.util.ArrayList args -> a
    java.lang.String name -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    geogebra.common.kernel.geos.GeoElement[] evalGeos -> a
    geogebra.common.kernel.Macro macro -> a
    boolean allowEvaluationForTypeCheck -> a
    java.lang.StringBuilder sbToString -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void addArgument(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String getVariableName(int) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode[] getArguments() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getArgument(int) -> a
    void setArgument(int,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    int getArgumentNumber() -> a
    java.lang.String getName() -> a_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement[] evaluateMultiple() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables(boolean) -> a
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    java.util.HashSet getVariables() -> a
    boolean isExpressionNode() -> g_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isListValue() -> h_
    geogebra.common.kernel.Macro getMacro() -> a
    void setMacro(geogebra.common.kernel.Macro) -> a
    boolean isVector3DValue() -> b_
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getItem(int) -> a
    boolean hasCoords() -> m
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.Equation -> geogebra.common.i.d.d:
    geogebra.common.kernel.arithmetic.ExpressionNode lhs -> a
    geogebra.common.kernel.arithmetic.ExpressionNode rhs -> b
    geogebra.common.kernel.arithmetic.Polynomial leftPoly -> a
    geogebra.common.kernel.arithmetic.Polynomial rightPoly -> b
    geogebra.common.kernel.arithmetic.Polynomial normalForm -> c
    boolean isFunctionDependent -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean forcePlane -> b
    boolean forceLine -> c
    boolean forceConic -> d
    boolean forceImplicitPoly -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getRHS() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getLHS() -> b
    void setLHS(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void setForceLine() -> a
    boolean isForcedLine() -> n
    void setForcePlane() -> b
    boolean isForcedConic() -> o
    void setForceConic() -> c
    boolean isForcedImplicitPoly() -> p
    void setForceImplicitPoly() -> d
    void initEquation() -> e
    void setFunctionDependent(boolean) -> b
    boolean isFunctionDependent() -> q
    geogebra.common.kernel.arithmetic.Polynomial getNormalForm() -> a
    int degree() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    boolean isExplicit(java.lang.String) -> a
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    boolean isBooleanValue() -> e
    boolean isConstant() -> a_
    boolean isExpressionNode() -> g_
    boolean isLeaf() -> x_
    boolean isListValue() -> h_
    boolean isNumberValue() -> c
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isVectorValue() -> d
    void resolveVariables(boolean) -> a
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String getAssignmentOperator() -> a
    java.lang.String getAssignmentOperatorLaTeX() -> b
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.Evaluatable -> geogebra.common.i.d.e:
    double evaluate(double) -> a
geogebra.common.kernel.arithmetic.ExpressionNode -> geogebra.common.i.d.f:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue left -> a
    geogebra.common.kernel.arithmetic.ExpressionValue right -> b
    geogebra.common.plugin.Operation operation -> a
    boolean forceVector -> c
    boolean forcePoint -> d
    boolean forceFunction -> e
    boolean holdsLaTeXtext -> a
    boolean leaf -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> b
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.plugin.Operation getOperation() -> a
    void setOperation(geogebra.common.plugin.Operation) -> a
    void setHoldsLaTeXtext(boolean) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue getLeft() -> a
    void setLeft(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getLeftTree() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getRight() -> b
    void setRight(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode getRightTree() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue copy(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.Kernel) -> a
    void simplifyLeafs() -> a
    void simplifyAndEvalCommands() -> f
    void simplifyConstantIntegers() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables(boolean) -> a
    void doResolveVariables(boolean) -> e
    boolean includesPolynomial() -> n
    java.util.TreeSet getPolynomialVars() -> a
    void getPolynomialVars(java.util.Set) -> a
    boolean shouldEvaluateToGeoVector() -> o
    boolean includesDivisionBy(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    int replaceVariables(java.lang.String,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    int replaceXYZnodes(geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.FunctionVariable,java.util.ArrayList) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean containsFunctionVariable() -> p
    boolean containsCasEvaluableFunction() -> q
    boolean containsGeoFunctionNVar() -> r
    void makePolynomialTree(geogebra.common.kernel.arithmetic.Equation) -> a
    boolean polynomialOperation(geogebra.common.plugin.Operation) -> a
    boolean isConstant() -> a_
    boolean isVectorValue() -> d
    void setForceVector() -> c
    boolean isForcedVector() -> s
    void setForcePoint() -> d
    boolean isForcedPoint() -> t
    void setForceFunction() -> e
    boolean isForcedFunction() -> u
    boolean hasOperations() -> v
    java.util.HashSet getVariables() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    boolean isLeaf() -> x_
    boolean isSingleVariable() -> w
    boolean isImaginaryUnit() -> x
    java.lang.String getCASstring(geogebra.common.kernel.StringTemplate,boolean) -> a
    boolean containsMyStringBuffer() -> y
    java.lang.String printCASstring(boolean,geogebra.common.kernel.StringTemplate) -> b
    boolean expandForOGP(geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String checkMathML(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String operationToString(java.lang.String,java.lang.String,boolean,geogebra.common.kernel.StringTemplate) -> a
    void appendPerpSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    void appendParallelSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> b
    void appendGeqSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> c
    void appendLeqSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> d
    void appendGreaterSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> e
    void appendLessSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> f
    void appendStrictSubsetSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> g
    void appendSubsetSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> h
    void appendNotEqualSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> i
    void appendEqualSign(java.lang.StringBuilder,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> j
    java.lang.String degFix(java.lang.String) -> a
    void appendOp(java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String) -> a
    void trig(java.lang.String,java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,boolean,boolean) -> a
    void appendReduceFunction(java.lang.StringBuilder,java.lang.String) -> a
    boolean isMultiplyOrDivide(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void mathml(java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String) -> b
    void mathml(java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    int opID(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> e
    boolean isListValue() -> h_
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isVector3DValue() -> b_
    boolean isEqual(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isEqualString(geogebra.common.kernel.arithmetic.ExpressionValue,double,boolean) -> a
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String leftBracket(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    java.lang.String rightBracket(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> b
    java.lang.String multiplicationSign(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> c
    java.lang.String multiplicationSpace(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> d
    java.lang.Double getCoefficient(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    void append(java.lang.StringBuilder,java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    boolean chainedBooleanOp(geogebra.common.plugin.Operation) -> b
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    boolean isConstantDouble(geogebra.common.kernel.arithmetic.ExpressionValue,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode plus(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode lessThan(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode lessThan(double) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode lessThanEqual(double) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode erf() -> c
    geogebra.common.kernel.arithmetic.ExpressionNode abs() -> d
    geogebra.common.kernel.arithmetic.ExpressionNode sec() -> e
    geogebra.common.kernel.arithmetic.ExpressionNode tan() -> f
    geogebra.common.kernel.arithmetic.ExpressionNode cosech() -> g
    geogebra.common.kernel.arithmetic.ExpressionNode coth() -> h
    geogebra.common.kernel.arithmetic.ExpressionNode cosec() -> i
    geogebra.common.kernel.arithmetic.ExpressionNode cot() -> j
    geogebra.common.kernel.arithmetic.ExpressionNode factorial() -> k
    geogebra.common.kernel.arithmetic.ExpressionNode ln() -> l
    geogebra.common.kernel.arithmetic.ExpressionNode gamma() -> m
    geogebra.common.kernel.arithmetic.ExpressionNode gammaIncompleteReverseArgs(geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionNode gammaIncomplete(geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    geogebra.common.kernel.arithmetic.ExpressionNode beta(geogebra.common.kernel.arithmetic.ExpressionValue) -> e
    geogebra.common.kernel.arithmetic.ExpressionNode exp() -> n
    geogebra.common.kernel.arithmetic.ExpressionNode polygamma(double) -> c
    geogebra.common.kernel.arithmetic.ExpressionNode sin() -> o
    geogebra.common.kernel.arithmetic.ExpressionNode sinh() -> p
    geogebra.common.kernel.arithmetic.ExpressionNode cosh() -> q
    geogebra.common.kernel.arithmetic.ExpressionNode cos() -> r
    geogebra.common.kernel.arithmetic.ExpressionNode reciprocate() -> s
    geogebra.common.kernel.arithmetic.ExpressionNode sqrt() -> t
    geogebra.common.kernel.arithmetic.ExpressionNode cbrt() -> u
    geogebra.common.kernel.arithmetic.ExpressionNode sgn() -> v
    geogebra.common.kernel.arithmetic.ExpressionNode atan() -> w
    geogebra.common.kernel.arithmetic.ExpressionNode reverseSign() -> x
    geogebra.common.kernel.arithmetic.ExpressionNode betaRegularized(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode square() -> y
    geogebra.common.kernel.arithmetic.ExpressionNode subtract(geogebra.common.kernel.arithmetic.ExpressionValue) -> f
    geogebra.common.kernel.arithmetic.ExpressionNode plus(double) -> d
    geogebra.common.kernel.arithmetic.ExpressionNode multiply(double) -> e
    geogebra.common.kernel.arithmetic.ExpressionNode multiplyR(double) -> f
    geogebra.common.kernel.arithmetic.ExpressionNode power(double) -> g
    geogebra.common.kernel.arithmetic.ExpressionNode subtract(double) -> h
    geogebra.common.kernel.arithmetic.ExpressionNode subtractR(double) -> i
    geogebra.common.kernel.arithmetic.ExpressionNode multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> g
    geogebra.common.kernel.arithmetic.ExpressionNode multiplyR(geogebra.common.kernel.arithmetic.ExpressionValue) -> h
    geogebra.common.kernel.arithmetic.ExpressionNode power(geogebra.common.kernel.arithmetic.ExpressionValue) -> i
    geogebra.common.kernel.arithmetic.ExpressionNode powerR(double) -> j
    geogebra.common.kernel.arithmetic.ExpressionNode divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> j
    geogebra.common.kernel.arithmetic.ExpressionNode divide(double) -> k
    geogebra.common.kernel.arithmetic.ExpressionNode and(geogebra.common.kernel.arithmetic.ExpressionValue) -> k
    geogebra.common.kernel.arithmetic.ExpressionNode negation() -> z
    boolean replacePowersRoots(boolean,int) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue replace(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.geos.GeoFunction buildFunction(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode nroot(geogebra.common.kernel.arithmetic.ExpressionValue) -> l
    geogebra.common.kernel.arithmetic.ExpressionNode linearIntegral(int,geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    double getLinearCoefficient(geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    double getLinearCoefficientDiv(geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode wrap(double) -> l
    geogebra.common.kernel.arithmetic.ExpressionNode wrap(geogebra.common.kernel.arithmetic.ExpressionValue) -> m
    geogebra.common.kernel.arithmetic.ExpressionValue unwrap() -> c
    geogebra.common.kernel.arithmetic.ExpressionNode wrap() -> A
    boolean hasCoords() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> b
geogebra.common.kernel.arithmetic.ExpressionNodeConstants -> geogebra.common.i.d.g:
geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType -> geogebra.common.i.d.g$a:
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType GEOGEBRA_XML -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType GEOGEBRA -> b
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MAXIMA -> c
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MATH_PIPER -> d
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType LATEX -> e
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType LIBRE_OFFICE -> f
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType PSTRICKS -> g
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType PGF -> h
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType JASYMCA -> i
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MPREDUCE -> j
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MATHML -> k
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType OGP -> l
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType[] ENUM$VALUES -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType[] values() -> values
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator -> geogebra.common.i.d.h:
    geogebra.common.kernel.StringTemplate errorTemplate -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleSpecial(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyBoolean evalEquals(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleDefault(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.StringTemplate,boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleXcoord(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.StringTemplate,boolean) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue handleYcoord(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.StringTemplate,boolean) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue handleMult(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handlePlus(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue handleCos(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleSin(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue handleDivide(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleMinus(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue handlePower(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleExp(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handleFunction(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.ExpressionValue -> geogebra.common.i.d.i:
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isVector3DValue() -> b_
    boolean isListValue() -> h_
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isGeoElement() -> i
    boolean isVariable() -> z
    void setInTree(boolean) -> c
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables(boolean) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    geogebra.common.kernel.Kernel getKernel() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue unwrap() -> c
    geogebra.common.kernel.arithmetic.ExpressionNode wrap() -> A
    boolean hasCoords() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.Function -> geogebra.common.i.d.j:
    geogebra.common.kernel.arithmetic.ExpressionNode factorParentExp -> b
    java.util.LinkedList symbolicPolyFactorList -> a
    java.util.LinkedList numericPolyFactorList -> b
    boolean symbolicPolyFactorListDefined -> c
    geogebra.common.kernel.arithmetic.ExpressionNode zeroExpr -> c
    geogebra.common.kernel.geos.GeoFunction geoDeriv -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void setExpression(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.arithmetic.FunctionVariable getFunctionVariable() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    void initFunction() -> a
    void initFunctionVars() -> b
    double evaluate(double) -> a
    boolean evaluateBoolean(double) -> a
    void translate(double,double) -> a
    void translateX(geogebra.common.kernel.arithmetic.ExpressionNode,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode shiftXnode(double) -> a
    void translateY(double) -> a
    void addNumber(double) -> b
    java.util.LinkedList getPolynomialFactors(boolean) -> a
    java.util.LinkedList getPolynomialFactors(boolean,boolean) -> a
    java.util.LinkedList getSymbolicPolynomialDerivativeFactors(int,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction getNumericPolynomialDerivative(int,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction getNumericPolynomialIntegral() -> a
    java.util.LinkedList getSymbolicPolynomialFactors(boolean,boolean) -> b
    java.util.LinkedList getNumericPolynomialFactors(boolean,boolean) -> c
    boolean addPolynomialFactors(geogebra.common.kernel.arithmetic.ExpressionValue,java.util.List,boolean,boolean,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction expandToPolyFunction(geogebra.common.kernel.arithmetic.ExpressionValue,boolean,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction expandToPolyFunctionNoCas(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode evaluateToExpressionNode(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    geogebra.common.kernel.arithmetic.Function getDerivative(int) -> a
    geogebra.common.kernel.arithmetic.Function getDerivativeNoFractions(int) -> b
    geogebra.common.kernel.arithmetic.Function getDerivative(int,boolean) -> a
    geogebra.common.kernel.arithmetic.Function getDerivativeQuotient(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function) -> a
    void difference(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function) -> a
    void difference(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.roots.RealRootDerivFunction getRealRootDerivFunction() -> a
    boolean includesDivisionByVariable() -> n
    boolean isVector3DValue() -> b_
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.arithmetic.Function getDerivativeNoCAS(int) -> c
    geogebra.common.kernel.arithmetic.Function getIntegralNoCAS() -> b
    geogebra.common.kernel.arithmetic.Function getDerivativeQuotientNoCAS(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function) -> b
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.Function$DerivFunction -> geogebra.common.i.d.j$a:
    geogebra.common.kernel.arithmetic.Function fun -> b
    geogebra.common.kernel.arithmetic.Function derivative -> c
    double[] ret -> a
    geogebra.common.kernel.arithmetic.Function this$0 -> a
    double evaluate(double) -> a
    double evaluateDerivative(double) -> b
geogebra.common.kernel.arithmetic.FunctionNVar -> geogebra.common.i.d.k:
    geogebra.common.kernel.arithmetic.ExpressionNode expression -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] fVars -> a
    geogebra.common.kernel.arithmetic.IneqTree ineqs -> a
    boolean isBooleanFunction -> a
    boolean isConstantFunction -> b
    geogebra.common.kernel.Kernel kernel -> a
    java.util.ArrayList undecided -> a
    geogebra.common.kernel.arithmetic.ExpressionNode casEvalExpression -> b
    java.lang.String casEvalStringSymbolic -> a
    geogebra.common.util.MaxSizeHashMap casEvalMap -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    boolean isFunctionVariable(java.lang.String) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpression() -> a
    void resolveVariables(boolean) -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    void setExpression(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void setExpression(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionVariable[]) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    java.lang.String getVarString(int,geogebra.common.kernel.StringTemplate) -> a
    int getVarNumber() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.StringBuilder appendVarString(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    void initFunction() -> a
    void fixStructure() -> b
    void initType(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isBooleanFunction() -> o
    boolean isConstantFunction() -> p
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    double evaluate(double[]) -> a
    boolean evaluateBoolean(double[]) -> a
    java.util.HashSet getVariables() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar evalCasCommand(java.lang.String,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    geogebra.common.util.MaxSizeHashMap getCasEvalMap() -> a
    geogebra.common.kernel.arithmetic.FunctionNVar lookupCasEvalMap(java.lang.String) -> a
    void clearCasEvalMap(java.lang.String) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isListValue() -> h_
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    java.lang.String getLabelForAssignment() -> c
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    boolean initIneqs(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionalNVar) -> a
    boolean initIneqs(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.IneqTree,boolean) -> a
    geogebra.common.plugin.Operation adjustOp(geogebra.common.plugin.Operation,boolean) -> a
    boolean updateIneqs() -> q
    double evaluate(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean evaluateBoolean(geogebra.common.kernel.geos.GeoPoint) -> a
    void translate(double,double) -> a
    void translateX(geogebra.common.kernel.arithmetic.ExpressionNode,double,int) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode shiftXnode(double,int) -> a
    void matrixTransform(double,double,double,double) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> b
    boolean isDefined() -> r
    geogebra.common.kernel.arithmetic.FunctionNVar getDerivativeNoCAS(geogebra.common.kernel.arithmetic.FunctionVariable,int) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.FunctionVariable -> geogebra.common.i.d.l:
    java.lang.String varStr -> a
    boolean isConstant() -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void setVarString(java.lang.String) -> a
    java.lang.String getSetVarString() -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.Functional -> geogebra.common.i.d.m:
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
geogebra.common.kernel.arithmetic.FunctionalNVar -> geogebra.common.i.d.n:
    double evaluate(double[]) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> b
    boolean isDefined() -> r
geogebra.common.kernel.arithmetic.GetItem -> geogebra.common.i.d.o:
    geogebra.common.kernel.arithmetic.ExpressionValue getItem(int) -> a
geogebra.common.kernel.arithmetic.IneqTree -> geogebra.common.i.d.p:
    geogebra.common.kernel.arithmetic.IneqTree left -> a
    geogebra.common.kernel.arithmetic.IneqTree right -> b
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.plugin.Operation operation -> a
    int size -> a
    void setRight(geogebra.common.kernel.arithmetic.IneqTree) -> a
    geogebra.common.kernel.arithmetic.IneqTree getRight() -> a
    void setLeft(geogebra.common.kernel.arithmetic.IneqTree) -> b
    geogebra.common.kernel.arithmetic.IneqTree getLeft() -> b
    void setOperation(geogebra.common.plugin.Operation) -> a
    geogebra.common.plugin.Operation getOperation() -> a
    void setIneq(geogebra.common.kernel.arithmetic.Inequality) -> a
    geogebra.common.kernel.arithmetic.Inequality getIneq() -> a
    boolean updateCoef() -> a
    int getSize() -> a
    geogebra.common.kernel.arithmetic.Inequality get(int) -> a
    void recomputeSize() -> a
    void getZeros(java.util.Set) -> a
geogebra.common.kernel.arithmetic.Inequality -> geogebra.common.i.d.q:
    geogebra.common.plugin.Operation op -> a
    geogebra.common.kernel.arithmetic.Inequality$IneqType type -> a
    geogebra.common.kernel.geos.GeoConic conicBorder -> a
    geogebra.common.kernel.geos.GeoLine lineBorder -> a
    geogebra.common.kernel.geos.GeoFunction funBorder -> a
    geogebra.common.kernel.geos.GeoElement border -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean isAboveBorder -> a
    geogebra.common.kernel.arithmetic.ExpressionNode normal -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] fv -> a
    geogebra.common.kernel.arithmetic.MyDouble coef -> a
    geogebra.common.kernel.geos.GeoPoint[] zeros -> a
    geogebra.common.kernel.arithmetic.MyDouble zeroDummy0 -> b
    geogebra.common.kernel.arithmetic.MyDouble zeroDummy1 -> c
    void update() -> b
    void setAboveBorderFromConic() -> c
    void init1varFunction(int) -> a
    geogebra.common.kernel.geos.GeoPoint[] RootMultiple(geogebra.common.kernel.geos.GeoFunction) -> a
    void updateCoef() -> a
    java.lang.String toString() -> toString
    boolean isStrict() -> a
    geogebra.common.kernel.geos.GeoFunction getFunBorder() -> a
    boolean isAboveBorder() -> b
    geogebra.common.kernel.geos.GeoElement getBorder() -> a
    geogebra.common.kernel.arithmetic.Inequality$IneqType getType() -> a
    geogebra.common.kernel.geos.GeoConic getConicBorder() -> a
    geogebra.common.kernel.geos.GeoLine getLineBorder() -> a
    geogebra.common.kernel.geos.GeoPoint[] getZeros() -> a
geogebra.common.kernel.arithmetic.Inequality$IneqType -> geogebra.common.i.d.q$a:
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_INVALID -> a
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_PARAMETRIC_X -> b
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_PARAMETRIC_Y -> c
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_LINEAR -> d
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_CONIC -> e
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_IMPLICIT -> f
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_1VAR_X -> g
    geogebra.common.kernel.arithmetic.Inequality$IneqType INEQUALITY_1VAR_Y -> h
    geogebra.common.kernel.arithmetic.Inequality$IneqType[] ENUM$VALUES -> a
    geogebra.common.kernel.arithmetic.Inequality$IneqType[] values() -> values
    geogebra.common.kernel.arithmetic.Inequality$IneqType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.arithmetic.ListValue -> geogebra.common.i.d.r:
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    double[] toDouble() -> a
    int size() -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue getListElement(int) -> b
geogebra.common.kernel.arithmetic.MyArbitraryConstant -> geogebra.common.i.d.s:
    java.util.ArrayList consts -> a
    java.util.ArrayList ints -> b
    java.util.ArrayList complexNumbers -> c
    geogebra.common.kernel.algos.ConstructionElement ce -> a
    int position -> a
    geogebra.common.kernel.arithmetic.ExpressionValue nextConst(geogebra.common.kernel.arithmetic.MyDouble) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue nextInt(geogebra.common.kernel.arithmetic.MyDouble) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue nextComplex(geogebra.common.kernel.arithmetic.MyDouble) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue nextConst(java.util.ArrayList,java.util.Map,java.lang.String,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void reset() -> a
    geogebra.common.kernel.geos.GeoNumeric getConst(int) -> a
    int getTotalNumberOfConsts() -> a
    boolean isCAS() -> a
geogebra.common.kernel.arithmetic.MyArbitraryConstant$AlgoDependentArbconst -> geogebra.common.i.d.s$a:
    geogebra.common.kernel.geos.GeoElement constant -> a
    geogebra.common.kernel.algos.ConstructionElement outCE -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant this$0 -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.arithmetic.MyBoolean -> geogebra.common.i.d.t:
    boolean value -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setValue(boolean) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    void resolveVariables(boolean) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    boolean getBoolean() -> a
    boolean isVector3DValue() -> b_
    double getDouble() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    boolean isAngle() -> v_
    boolean isDefined() -> r
geogebra.common.kernel.arithmetic.MyDouble -> geogebra.common.i.d.u:
    double val -> b
    boolean isAngle -> a
    geogebra.common.kernel.Kernel kernel -> a
    double LARGEST_INTEGER -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void set(double) -> a
    void resolveVariables(boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void setAngle() -> a
    boolean isAngle() -> v_
    void add(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void sub(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.MyDouble) -> b
    void mult(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.MyDouble) -> c
    void mult(geogebra.common.kernel.arithmetic.MyDouble,double,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void div(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void pow(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> b
    void powDoubleSgnChange(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> c
    geogebra.common.kernel.arithmetic.MyDouble cos() -> b
    geogebra.common.kernel.arithmetic.MyDouble sin() -> c
    void checkZero() -> b
    geogebra.common.kernel.arithmetic.MyDouble tan() -> d
    geogebra.common.kernel.arithmetic.MyDouble acos() -> e
    geogebra.common.kernel.arithmetic.MyDouble asin() -> f
    geogebra.common.kernel.arithmetic.MyDouble atan() -> g
    geogebra.common.kernel.arithmetic.MyDouble atan2(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.MyDouble log() -> h
    geogebra.common.kernel.arithmetic.MyDouble log(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.arithmetic.MyDouble erf() -> i
    geogebra.common.kernel.arithmetic.MyDouble polygamma(geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.arithmetic.MyDouble psi() -> j
    geogebra.common.kernel.arithmetic.MyDouble log10() -> k
    geogebra.common.kernel.arithmetic.MyDouble log2() -> l
    geogebra.common.kernel.arithmetic.MyDouble exp() -> m
    geogebra.common.kernel.arithmetic.MyDouble sqrt() -> n
    geogebra.common.kernel.arithmetic.MyDouble cbrt() -> o
    geogebra.common.kernel.arithmetic.MyDouble abs() -> p
    geogebra.common.kernel.arithmetic.MyDouble floor() -> q
    geogebra.common.kernel.arithmetic.MyDouble ceil() -> r
    geogebra.common.kernel.arithmetic.MyDouble round() -> s
    double round(double) -> a
    geogebra.common.kernel.arithmetic.MyDouble sgn() -> t
    geogebra.common.kernel.arithmetic.MyDouble cosh() -> u
    geogebra.common.kernel.arithmetic.MyDouble sinh() -> v
    geogebra.common.kernel.arithmetic.MyDouble tanh() -> w
    geogebra.common.kernel.arithmetic.MyDouble acosh() -> x
    geogebra.common.kernel.arithmetic.MyDouble asinh() -> y
    geogebra.common.kernel.arithmetic.MyDouble csc() -> z
    geogebra.common.kernel.arithmetic.MyDouble sec() -> A
    geogebra.common.kernel.arithmetic.MyDouble cot() -> B
    geogebra.common.kernel.arithmetic.MyDouble csch() -> C
    geogebra.common.kernel.arithmetic.MyDouble sech() -> D
    geogebra.common.kernel.arithmetic.MyDouble coth() -> E
    geogebra.common.kernel.arithmetic.MyDouble atanh() -> F
    geogebra.common.kernel.arithmetic.MyDouble cosineIntegral() -> G
    geogebra.common.kernel.arithmetic.MyDouble sineIntegral() -> H
    geogebra.common.kernel.arithmetic.MyDouble expIntegral() -> I
    geogebra.common.kernel.arithmetic.MyDouble factorial() -> J
    geogebra.common.kernel.arithmetic.MyDouble gamma() -> K
    geogebra.common.kernel.arithmetic.MyDouble apply(geogebra.common.kernel.arithmetic.Evaluatable) -> a
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    boolean isConstant() -> a_
    java.util.HashSet getVariables() -> a
    boolean isLeaf() -> x_
    double getDouble() -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    double parsePercentage(geogebra.common.main.App,java.lang.String) -> a
    double parseDouble(geogebra.common.main.App,java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue gammaIncompleteRegularized(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue gammaIncomplete(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue beta(geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue betaIncomplete(geogebra.common.kernel.arithmetic.VectorValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue betaIncompleteRegularized(geogebra.common.kernel.arithmetic.VectorValue) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    int compareTo(java.lang.Object) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isDefined() -> r
    geogebra.common.kernel.arithmetic.ExpressionValue fractionalPart() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue zeta() -> b
    int parseInt(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.MyList -> geogebra.common.i.d.v:
    geogebra.common.kernel.Kernel kernel -> a
    int matrixRows -> a
    int matrixCols -> b
    java.util.ArrayList listElements -> a
    boolean isDefined -> a
    void addListElement(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    double[] toDouble() -> a
    int replaceVariables(java.lang.String,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    void applyRight(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    void applyLeft(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> b
    void matrixMultiply(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList) -> a
    void apply(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,boolean,geogebra.common.kernel.StringTemplate) -> a
    void setIdentityMatrix() -> b
    int getMatrixRows() -> b
    int getMatrixCols() -> c
    geogebra.common.kernel.arithmetic.MyList invert() -> b
    boolean isMatrix() -> n
    void clear() -> a
    boolean isEquation(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    boolean isMatrix(geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCell(geogebra.common.kernel.arithmetic.MyList,int,int) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    int size() -> a_
    void resolveVariables(boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getListElement(int) -> b
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    boolean isVector3DValue() -> b_
    boolean isElementOf(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.MyList) -> a
    boolean listContains(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.StringTemplate) -> a
    boolean listContainsStrict(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyList setDifference(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList) -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void vectorProduct(geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean isDefined() -> o
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.arithmetic.MyList getCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getItem(int) -> a
geogebra.common.kernel.arithmetic.MyNumberPair -> geogebra.common.i.d.w:
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
geogebra.common.kernel.arithmetic.MySpecialDouble -> geogebra.common.i.d.x:
    java.lang.String strToString -> a
    java.lang.String originalString -> b
    boolean keepOriginalString -> a
    boolean isLetterConstant -> b
    boolean scientificNotation -> c
    boolean setFromOutside -> d
    geogebra.common.kernel.arithmetic.MySpecialDouble eulerConstant -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.MySpecialDouble getEulerConstant(geogebra.common.kernel.Kernel) -> a
    boolean isEulerConstant() -> o
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void set(double) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.MyStringBuffer -> geogebra.common.i.d.y:
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.Kernel kernel -> a
    void append(java.lang.String) -> a
    void insert(int,java.lang.String) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void resolveVariables(boolean) -> a
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.MyVecNode -> geogebra.common.i.d.z:
    geogebra.common.kernel.arithmetic.ExpressionValue x -> a
    geogebra.common.kernel.arithmetic.ExpressionValue y -> b
    int mode -> a
    geogebra.common.kernel.Kernel kernel -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables(boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getX() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getY() -> b
    void setPolarCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean hasPolarCoords() -> n
    void setCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    double[] getCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    java.util.HashSet getVariables() -> a
    void setMode(int) -> a
    boolean isVectorValue() -> d
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isListValue() -> h_
    boolean isExpressionNode() -> g_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    boolean hasCoords() -> m
    boolean containsFunctionVariable() -> o
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.NumberValue -> geogebra.common.i.d.A:
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    boolean isAngle() -> v_
    double getDouble() -> a
    boolean isDefined() -> r
geogebra.common.kernel.arithmetic.Parametric -> geogebra.common.i.d.B:
    geogebra.common.kernel.arithmetic.ExpressionNode P -> a
    geogebra.common.kernel.arithmetic.ExpressionNode v -> b
    java.lang.String parameter -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getP() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getv() -> b
    java.lang.String getParameter() -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    boolean isBooleanValue() -> e
    boolean isConstant() -> a_
    boolean isExpressionNode() -> g_
    boolean isLeaf() -> x_
    boolean isListValue() -> h_
    boolean isNumberValue() -> c
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isVectorValue() -> d
    void resolveVariables(boolean) -> a
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.PolyFunction -> geogebra.common.i.d.C:
    double[] coeffs -> a
    int degree -> a
    geogebra.common.kernel.arithmetic.PolyFunction derivative -> a
    geogebra.common.kernel.arithmetic.PolyFunction integral -> b
    double[] getCoeffs() -> a
    double[] getCoeffsCopy() -> b
    boolean updateCoeffValues() -> a
    int getDegree() -> a
    geogebra.common.kernel.arithmetic.PolyFunction getDerivative() -> a
    geogebra.common.kernel.arithmetic.PolyFunction getIntegral() -> b
    geogebra.common.kernel.arithmetic.PolyFunction buildDerivative() -> c
    geogebra.common.kernel.arithmetic.PolyFunction buildIntegral() -> d
    double[] evaluateDerivFunc(double) -> a
    double evaluateDerivative(double) -> b
    double evaluate(double) -> a
    geogebra.common.kernel.arithmetic.Function getFunction(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.Polynomial -> geogebra.common.i.d.D:
    java.util.ArrayList terms -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.Term getTerm(int) -> a
    int length() -> a
    void append(geogebra.common.kernel.arithmetic.Term) -> a
    void add(geogebra.common.kernel.arithmetic.Polynomial) -> a
    void sub(geogebra.common.kernel.arithmetic.Polynomial) -> b
    void multiply(geogebra.common.kernel.arithmetic.Polynomial) -> c
    void multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    void divide(geogebra.common.kernel.arithmetic.Polynomial) -> d
    void multiply(double) -> a
    void power(int) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getConstantCoefficient() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCoefficient(java.lang.String) -> a
    double getCoeffValue(java.lang.String) -> a
    double getConstantCoeffValue() -> a
    void simplify() -> a
    boolean contains(java.lang.String) -> a
    int degree() -> b
    boolean isFreeOf(char) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[][] getCoeff() -> a
    java.util.HashSet getVariables() -> a
    void resolveVariables(boolean) -> a
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> e
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.ReplaceChildrenByValues -> geogebra.common.i.d.E:
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.arithmetic.SymbolicPolyFunction -> geogebra.common.i.d.F:
    geogebra.common.kernel.arithmetic.ExpressionNode[] symbCoeffs -> a
    geogebra.common.kernel.arithmetic.ExpressionNode[] getSymbolicCoeffs() -> a
    boolean updateCoeffValues() -> a
geogebra.common.kernel.arithmetic.Term -> geogebra.common.i.d.G:
    geogebra.common.kernel.arithmetic.ExpressionValue coefficient -> a
    java.lang.StringBuilder variables -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    boolean $assertionsDisabled -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCoefficient() -> a
    java.lang.String getVars() -> a
    int degree() -> a
    int degree(char) -> a
    void addToCoefficient(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue add(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue sub(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    void multiply(geogebra.common.kernel.arithmetic.Term) -> a
    void multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue multiply(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    void divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue divide(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    void sort(java.lang.StringBuilder) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean contains(java.lang.String) -> a
    int compareTo(java.lang.Object) -> compareTo
    java.lang.String toString() -> toString
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String coeffString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String variableString() -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.TextValue -> geogebra.common.i.d.H:
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
geogebra.common.kernel.arithmetic.Traversing -> geogebra.common.i.d.I:
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer -> geogebra.common.i.d.I$a:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer getReplacer(geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
geogebra.common.kernel.arithmetic.Traversing$CommandCollector -> geogebra.common.i.d.I$b:
    java.util.Set commands -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandCollector collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandCollector getCollector(java.util.Set) -> a
geogebra.common.kernel.arithmetic.Traversing$CommandReplacer -> geogebra.common.i.d.I$c:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandReplacer getReplacer(geogebra.common.main.App) -> a
geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector -> geogebra.common.i.d.I$d:
    java.util.List derivativeFunctions -> a
    java.util.List derivativeDegrees -> b
    java.util.Set signatures -> a
    geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector getCollector() -> a
    java.util.List getFunctions() -> a
    java.util.List getDegrees() -> b
geogebra.common.kernel.arithmetic.Traversing$FVarCollector -> geogebra.common.i.d.I$e:
    java.util.Set commands -> a
    geogebra.common.kernel.arithmetic.Traversing$FVarCollector collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$FVarCollector getCollector(java.util.Set) -> a
geogebra.common.kernel.arithmetic.Traversing$FunctionExpander -> geogebra.common.i.d.I$f:
    geogebra.common.kernel.arithmetic.Traversing$FunctionExpander collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue expand(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$FunctionExpander getCollector() -> a
geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer -> geogebra.common.i.d.I$g:
    java.lang.String var -> a
    geogebra.common.kernel.arithmetic.ExpressionValue newObj -> a
    boolean didReplacement -> a
    geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer getReplacer(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean didReplacement() -> a
geogebra.common.kernel.arithmetic.Traversing$PolyReplacer -> geogebra.common.i.d.I$h:
    geogebra.common.kernel.arithmetic.Traversing$PolyReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$PolyReplacer getReplacer() -> a
geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer -> geogebra.common.i.d.I$i:
    boolean toRoot -> a
    int MAX_ROOT -> a
    geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer getReplacer(boolean) -> a
geogebra.common.kernel.arithmetic.Traversing$Replacer -> geogebra.common.i.d.I$j:
    geogebra.common.kernel.arithmetic.ExpressionValue oldObj -> a
    geogebra.common.kernel.arithmetic.ExpressionValue newObj -> b
    geogebra.common.kernel.arithmetic.Traversing$Replacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$Replacer getReplacer(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.arithmetic.Traversing$VariablePolyReplacer -> geogebra.common.i.d.I$k:
    geogebra.common.kernel.arithmetic.FunctionVariable fv -> a
    int replacements -> a
    geogebra.common.kernel.arithmetic.Traversing$VariablePolyReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    int getReplacements() -> a
    geogebra.common.kernel.arithmetic.Traversing$VariablePolyReplacer getReplacer(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.arithmetic.Traversing$VariableReplacer -> geogebra.common.i.d.I$l:
    java.lang.String var -> a
    geogebra.common.kernel.arithmetic.ExpressionValue newObj -> a
    int replacements -> a
    geogebra.common.kernel.arithmetic.Traversing$VariableReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$VariableReplacer getReplacer(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.arithmetic.ValidExpression -> geogebra.common.i.d.J:
    java.util.Vector labels -> a
    boolean inTree -> a
    boolean keepInputUsed -> b
    geogebra.common.kernel.arithmetic.AssignmentType assignmentType -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$AssignmentType -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    void setAssignmentType(geogebra.common.kernel.arithmetic.AssignmentType) -> a
    geogebra.common.kernel.arithmetic.AssignmentType getAssignmentType() -> a
    void addLabel(java.lang.String) -> b
    void initLabels() -> a
    void addLabel(java.util.Vector) -> a
    int labelCount() -> d
    java.lang.String getLabel(int) -> b
    java.lang.String[] getLabels() -> a
    java.lang.String getLabel() -> e
    void setLabel(java.lang.String) -> c
    void setLabels(java.lang.String[]) -> a
    boolean isVariable() -> z
    boolean isInTree() -> A
    void setInTree(boolean) -> c
    boolean isGeoElement() -> i
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String getLabelForAssignment() -> c
    java.lang.String toAssignmentString(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String toAssignmentLaTeXString(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getAssignmentOperator() -> a
    java.lang.String getDelayedAssignmentOperator() -> f
    java.lang.String getAssignmentOperatorLaTeX() -> b
    java.lang.String getDelayedAssignmentOperatorLaTeX() -> g
    boolean isKeepInputUsed() -> B
    void setKeepInputUsed(boolean) -> d
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    java.lang.String toString() -> toString
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    java.lang.String debugString(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue unwrap() -> c
    geogebra.common.kernel.arithmetic.ExpressionNode wrap() -> A
    boolean hasCoords() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$AssignmentType() -> c
geogebra.common.kernel.arithmetic.Variable -> geogebra.common.i.d.K:
    java.lang.String name -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.lang.String getName(geogebra.common.kernel.StringTemplate) -> g
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    geogebra.common.kernel.geos.GeoElement resolve(boolean) -> a
    geogebra.common.kernel.geos.GeoElement resolve(boolean,boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue resolveAsExpressionValue(boolean) -> a
    java.util.HashSet getVariables() -> a
    void resolveVariables(boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isVariable() -> z
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean hasCoords() -> m
geogebra.common.kernel.arithmetic.VectorValue -> geogebra.common.i.d.L:
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    void setMode(int) -> a
geogebra.common.kernel.arithmetic3D.MyVec3DNode -> geogebra.common.i.e.a:
    geogebra.common.kernel.arithmetic.ExpressionValue x -> a
    geogebra.common.kernel.arithmetic.ExpressionValue y -> b
    geogebra.common.kernel.arithmetic.ExpressionValue z -> c
    geogebra.common.kernel.Kernel kernel -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables(boolean) -> a
    void setCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    double[] getCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    double[] getPointAsDouble() -> b
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    java.util.HashSet getVariables() -> a
    boolean isVectorValue() -> d
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isListValue() -> h_
    boolean isExpressionNode() -> g_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic3D.Vector3DValue -> geogebra.common.i.e.b:
    double[] getPointAsDouble() -> b
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
geogebra.common.kernel.barycentric.AlgoBarycenter -> geogebra.common.i.f.a:
    geogebra.common.kernel.geos.GeoList poly -> a
    geogebra.common.kernel.geos.GeoList list -> b
    geogebra.common.kernel.geos.GeoPoint point -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoCubic -> geogebra.common.i.f.b:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly poly -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoKimberling -> geogebra.common.i.f.c:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.geos.GeoPoint M -> d
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getResult() -> a
    double p(double,double) -> a
    double u(double) -> a
    void compute() -> b
    double weight(int,double,double,double) -> a
    double weight0to1000(int,double,double,double) -> b
    double weight1000to1499(int,double,double,double) -> c
    double weight1500to1999(int,double,double,double) -> d
    double weight2000to2500(int,double,double,double) -> e
    double weight2500to2799(int,double,double,double) -> f
    double weight2800plus(int,double,double,double) -> g
    boolean isLocusEquable() -> e
geogebra.common.kernel.barycentric.AlgoTriangleCurve -> geogebra.common.i.f.d:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoPoint C -> c
    geogebra.common.kernel.implicit.GeoImplicitPoly n -> a
    geogebra.common.kernel.geos.GeoElement poly -> a
    geogebra.common.kernel.arithmetic.Equation eq -> a
    geogebra.common.kernel.geos.GeoNumeric[] xcoef -> a
    geogebra.common.kernel.geos.GeoNumeric[] ycoef -> b
    geogebra.common.kernel.geos.GeoNumeric[] constant -> c
    geogebra.common.kernel.implicit.AlgoDependentImplicitPoly dd -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoTrilinear -> geogebra.common.i.f.e:
    geogebra.common.kernel.geos.GeoPoint P1 -> a
    geogebra.common.kernel.geos.GeoPoint P2 -> b
    geogebra.common.kernel.geos.GeoPoint P3 -> c
    geogebra.common.kernel.arithmetic.NumberValue v1 -> a
    geogebra.common.kernel.arithmetic.NumberValue v2 -> b
    geogebra.common.kernel.arithmetic.NumberValue v3 -> c
    geogebra.common.kernel.geos.GeoPoint point -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.CmdBarycenter -> geogebra.common.i.f.f:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.barycentric.CmdCubic -> geogebra.common.i.f.g:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.barycentric.CmdKimberling -> geogebra.common.i.f.h:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.barycentric.CmdTriangleCurve -> geogebra.common.i.f.i:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement resArg(geogebra.common.kernel.arithmetic.Command,int) -> a
geogebra.common.kernel.barycentric.CmdTrilinear -> geogebra.common.i.f.j:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.AlgoCoefficients -> geogebra.common.i.g.a:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoConicCoefficients -> geogebra.common.i.g.b:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoList g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoDegree -> geogebra.common.i.g.c:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoDependentCasCell -> geogebra.common.i.g.d:
    geogebra.common.kernel.geos.GeoCasCell casCell -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void initInput() -> e
    void remove() -> c
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoCasCell getCasCell() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getExpXML(geogebra.common.kernel.StringTemplate) -> f
geogebra.common.kernel.cas.AlgoDerivative -> geogebra.common.i.g.e:
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.NumberValue order -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoExpand -> geogebra.common.i.g.f:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoFactor -> geogebra.common.i.g.g:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoFactors -> geogebra.common.i.g.h:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoImplicitDerivative -> geogebra.common.i.g.i:
    geogebra.common.kernel.geos.GeoFunctionNVar result -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar functional -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoFunctionNVar getResult() -> a
geogebra.common.kernel.cas.AlgoIntegral -> geogebra.common.i.g.j:
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoIntegralDefinite -> geogebra.common.i.g.k:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoBoolean evaluate -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoNumeric n -> a
    boolean numeric -> c
    geogebra.common.kernel.geos.GeoFunction symbIntegral -> b
    org.apache.commons.math.analysis.integration.LegendreGaussIntegrator firstGauss -> a
    org.apache.commons.math.analysis.integration.LegendreGaussIntegrator secondGauss -> b
    int adaptiveGaussQuadCounter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getIntegral() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> a
    geogebra.common.kernel.arithmetic.NumberValue getB() -> b
    void compute() -> b
    double freehandIntegration(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double numericIntegration(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
    double doAdaptiveGaussQuad(geogebra.common.kernel.roots.RealRootFunction,double,double) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
    boolean evaluateOnly() -> f
geogebra.common.kernel.cas.AlgoIntegralDefiniteInterface -> geogebra.common.i.g.l:
    boolean evaluateOnly() -> f
geogebra.common.kernel.cas.AlgoLengthCurve -> geogebra.common.i.g.m:
    geogebra.common.kernel.geos.GeoNumeric t0 -> a
    geogebra.common.kernel.geos.GeoNumeric t1 -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> c
    geogebra.common.kernel.roots.RealRootFunction lengthCurve -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthCurve$LengthCurve -> geogebra.common.i.g.m$a:
    geogebra.common.kernel.cas.AlgoLengthCurve this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthCurve2Points -> geogebra.common.i.g.n:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c -> b
    geogebra.common.kernel.geos.GeoCurveCartesian derivative -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.roots.RealRootFunction lengthCurve -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthCurve2Points$LengthCurve -> geogebra.common.i.g.n$a:
    double[] f1eval -> a
    geogebra.common.kernel.cas.AlgoLengthCurve2Points this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthFunction -> geogebra.common.i.g.o:
    geogebra.common.kernel.geos.GeoNumeric A -> a
    geogebra.common.kernel.geos.GeoNumeric B -> b
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> c
    geogebra.common.kernel.roots.RealRootFunction lengthFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthFunction$LengthFunction -> geogebra.common.i.g.o$a:
    geogebra.common.kernel.cas.AlgoLengthFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthFunction2Points -> geogebra.common.i.g.p:
    geogebra.common.kernel.geos.GeoPoint A -> a
    geogebra.common.kernel.geos.GeoPoint B -> b
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.roots.RealRootFunction lengthFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthFunction2Points$LengthFunction -> geogebra.common.i.g.p$a:
    geogebra.common.kernel.cas.AlgoLengthFunction2Points this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLimit -> geogebra.common.i.g.q:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoNumeric outNum -> a
    java.lang.StringBuilder sb -> b
    java.lang.String limitString -> a
    void init(java.lang.String) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String getCasInput() -> a
    int getDirection() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void handleCASoutput(java.lang.String,int) -> a
    void handleException(java.lang.Throwable,int) -> a
    boolean useCacheing() -> a
geogebra.common.kernel.cas.AlgoLimitAbove -> geogebra.common.i.g.r:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getDirection() -> c
geogebra.common.kernel.cas.AlgoLimitBelow -> geogebra.common.i.g.s:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getDirection() -> c
geogebra.common.kernel.cas.AlgoNextPreviousPrime -> geogebra.common.i.g.t:
    geogebra.common.kernel.arithmetic.NumberValue init -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    boolean next -> c
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.cas.AlgoParametricDerivative -> geogebra.common.i.g.u:
    geogebra.common.kernel.geos.GeoCurveCartesian curve -> a
    geogebra.common.kernel.geos.GeoCurveCartesian paramDeriv -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoCurveCartesian getParametricDerivative() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPartialFractions -> geogebra.common.i.g.v:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialCD -> geogebra.common.i.g.w:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialDiv -> geogebra.common.i.g.x:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialDivision -> geogebra.common.i.g.y:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    geogebra.common.kernel.geos.GeoFunction h -> d
    geogebra.common.kernel.geos.GeoList result -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialMod -> geogebra.common.i.g.z:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPrimeFactorization -> geogebra.common.i.g.A:
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    double LARGEST_INTEGER -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double,double) -> a
geogebra.common.kernel.cas.AlgoSimplify -> geogebra.common.i.g.B:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoSimplifyText -> geogebra.common.i.g.C:
    geogebra.common.kernel.geos.GeoText textIn -> a
    geogebra.common.kernel.geos.GeoText text -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoSolveODE -> geogebra.common.i.g.D:
    geogebra.common.kernel.arithmetic.FunctionalNVar f0 -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar f1 -> b
    geogebra.common.kernel.geos.GeoNumeric x -> a
    geogebra.common.kernel.geos.GeoNumeric y -> b
    geogebra.common.kernel.geos.GeoNumeric end -> c
    geogebra.common.kernel.geos.GeoNumeric step -> d
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    geogebra.common.kernel.algos.AlgoNumerator numAlgo -> a
    geogebra.common.kernel.algos.AlgoDenominator denAlgo -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar num -> c
    geogebra.common.kernel.arithmetic.FunctionalNVar den -> d
    boolean quotient -> c
    org.apache.commons.math.ode.sampling.StepHandler stepHandler -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void remove() -> c
geogebra.common.kernel.cas.AlgoSolveODE$1 -> geogebra.common.i.g.E:
    geogebra.common.kernel.cas.AlgoSolveODE this$0 -> a
    void reset() -> a
    boolean requiresDenseOutput() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
geogebra.common.kernel.cas.AlgoSolveODE$ODE -> geogebra.common.i.g.D$a:
    geogebra.common.kernel.arithmetic.FunctionalNVar f -> a
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.cas.AlgoSolveODE$ODE2 -> geogebra.common.i.g.D$b:
    geogebra.common.kernel.arithmetic.FunctionalNVar y0 -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar y1 -> b
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.cas.AlgoSolveODE2 -> geogebra.common.i.g.F:
    geogebra.common.kernel.geos.GeoFunction b -> a
    geogebra.common.kernel.geos.GeoFunction c -> b
    geogebra.common.kernel.geos.GeoFunction f -> c
    geogebra.common.kernel.geos.GeoNumeric x -> a
    geogebra.common.kernel.geos.GeoNumeric y -> b
    geogebra.common.kernel.geos.GeoNumeric yDot -> c
    geogebra.common.kernel.geos.GeoNumeric end -> d
    geogebra.common.kernel.geos.GeoNumeric step -> e
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    org.apache.commons.math.ode.sampling.StepHandler stepHandler -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoSolveODE2$1 -> geogebra.common.i.g.G:
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.cas.AlgoSolveODE2 this$0 -> a
    void reset() -> a
    boolean requiresDenseOutput() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
geogebra.common.kernel.cas.AlgoSolveODE2$ODE2 -> geogebra.common.i.g.F$a:
    geogebra.common.kernel.geos.GeoFunction b -> a
    geogebra.common.kernel.geos.GeoFunction c -> b
    geogebra.common.kernel.geos.GeoFunction f -> c
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.cas.AlgoSolveODECas -> geogebra.common.i.g.H:
    geogebra.common.kernel.geos.CasEvaluableFunction f -> a
    geogebra.common.kernel.geos.GeoElement g -> a
    geogebra.common.kernel.kernelND.GeoPointND pt -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    java.lang.String oldCASstring -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    void findPathThroughPoint() -> e
    void updateG(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.cas.AlgoSurdText -> geogebra.common.i.g.I:
    int fullScale -> a
    int lessScale -> b
    geogebra.common.kernel.geos.GeoNumberValue num -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder sb -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    void Fractionappend(java.lang.StringBuilder,int,int,geogebra.common.kernel.StringTemplate) -> a
    void PSLQappendGeneral(java.lang.StringBuilder,double,geogebra.common.kernel.StringTemplate) -> a
    boolean fitLinearComb(double,java.lang.String[],double[],int,java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ValidExpression sbToCAS(java.lang.StringBuilder) -> a
    double evaluateCombination(int,double[],int[],int,int) -> a
    void appendCombination(java.lang.StringBuilder,int,java.lang.String[],int[],int,int,geogebra.common.kernel.StringTemplate) -> a
    void appendUndefined(java.lang.StringBuilder,double) -> a
    void PSLQappendQuadratic(java.lang.StringBuilder,double,geogebra.common.kernel.StringTemplate) -> b
    int[][] mPSLQ(int,double[],double,int) -> a
    int[] PSLQ(double[],double,int) -> a
    int[] PSLQ(int,double[],double,int,int[][],double[],int[]) -> a
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFit -> geogebra.common.i.g.I$a:
    double num1 -> a
    int numOfConsts -> a
    int numOfRadicals -> b
    double[] constValues -> a
    java.lang.String[] constStrings -> a
    int coeffBound -> c
    double err -> b
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType aft -> a
    geogebra.common.kernel.StringTemplate tpl -> a
    double[] numList -> b
    int[][] coeffs -> a
    int s -> d
    int numOfPenalties -> e
    int[][] penalties -> b
    int numOfConstsUsed -> f
    int maxCoeff -> g
    int sumCoeffs -> h
    boolean isOneUsed -> a
    int bestIndex -> i
    int[] bestRelation -> a
    java.lang.StringBuilder formalSolution -> a
    geogebra.common.kernel.cas.AlgoSurdText this$0 -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$cas$AlgoSurdText$AlgebraicFittingType -> b
    void compute(double) -> a
    void computeQuadratic(double) -> c
    void computeRationalNumber(double) -> d
    void computeConstant(double) -> b
    int leastPenaltyIndex() -> a
    void setCoeffBound(int) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$cas$AlgoSurdText$AlgebraicFittingType() -> a
geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType -> geogebra.common.i.g.I$b:
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType RATIONAL_NUMBER -> a
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType LINEAR_COMBINATION -> b
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType RATIONAL_COMBINATION -> c
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType POWER_PRODUCT -> d
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType QUADRATIC_RADICAL -> e
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType FUNCTION_OF_RATIONAL_NUMBER -> f
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType FUNCTION_OF_LINEAR_COMBINATION -> g
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType FUNCTION_OF_POWER_PRODUCT -> h
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType FUNCTION_OF_QUADRATIC_RADICAL -> i
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType[] ENUM$VALUES -> a
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType[] values() -> values
    geogebra.common.kernel.cas.AlgoSurdText$AlgebraicFittingType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.cas.AlgoSurdText$IntRelationFinder -> geogebra.common.i.g.I$c:
    geogebra.common.util.MyMathExact$MyDecimal ZERO -> b
    geogebra.common.util.MyMathExact$MyDecimal ZERO_LESS -> a
    geogebra.common.util.MyMathExact$MyDecimal ONE_LESS -> c
    double tau -> b
    double rho -> c
    double gamma -> d
    double err -> a
    double M -> e
    int n -> a
    double[] x -> a
    geogebra.common.util.MyMathExact$MyDecimal[] x_full -> a
    geogebra.common.util.MyMathExact$MyDecimal[] x_double -> b
    int fullScale1 -> b
    int lessScale1 -> c
    geogebra.common.util.MyMathExact$MyDecimal xNorm -> d
    geogebra.common.util.MyMathExact$MyDecimalMatrix H_full -> b
    geogebra.common.util.MyMathExact$MyDecimalMatrix H -> c
    geogebra.common.util.MyMathExact$MyDecimalMatrix I -> a
    geogebra.common.util.MyMathExact$MyDecimalMatrix A -> d
    geogebra.common.util.MyMathExact$MyDecimalMatrix B -> e
    geogebra.common.util.MyMathExact$MyDecimalMatrix D -> f
    geogebra.common.util.MyMathExact$MyDecimalMatrix xB -> g
    geogebra.common.util.MyMathExact$MyDecimal b -> e
    geogebra.common.util.MyMathExact$MyDecimal l -> f
    geogebra.common.util.MyMathExact$MyDecimal d -> g
    int r -> d
    java.util.ArrayList result -> a
    geogebra.common.kernel.cas.AlgoSurdText this$0 -> a
    void initialize_full() -> a
    void hermiteReduction() -> b
geogebra.common.kernel.cas.AlgoSurdText$IntRelationFinder$IntRelation -> geogebra.common.i.g.I$c$a:
    int size -> a
    double sig -> a
    int nilDim -> b
    geogebra.common.util.MyMathExact$MyDecimalMatrix B1 -> b
    geogebra.common.util.MyMathExact$MyDecimalMatrix B_sol -> c
    geogebra.common.util.MyMathExact$MyDecimalMatrix B_rest -> d
    geogebra.common.util.MyMathExact$MyDecimalMatrix xB1 -> a
    int[] orthoIndices -> a
    geogebra.common.kernel.cas.AlgoSurdText$IntRelationFinder this$1 -> a
    geogebra.common.util.MyMathExact$MyDecimalMatrix getBMatrix() -> a
    geogebra.common.util.MyMathExact$MyDecimalMatrix getBSolMatrix() -> b
    geogebra.common.util.MyMathExact$MyDecimalMatrix getBRestMatrix() -> c
    int compareTo(geogebra.common.kernel.cas.AlgoSurdText$IntRelationFinder$IntRelation) -> a
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.cas.AlgoSurdTextPoint -> geogebra.common.i.g.J:
    geogebra.common.kernel.geos.GeoPoint p -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder sbp -> b
    geogebra.common.kernel.StringTemplate tpl -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.cas.AlgoTangentCurve -> geogebra.common.i.g.K:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoCurveCartesian df -> b
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoPoint T -> b
    boolean pointOnCurve -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoTangentFunctionNumber -> geogebra.common.i.g.L:
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.geos.GeoElement ngeo -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoPoint T -> a
    geogebra.common.kernel.geos.GeoFunction deriv -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTangentFunctionPoint -> geogebra.common.i.g.M:
    geogebra.common.kernel.geos.GeoPoint P -> a
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint T -> b
    boolean pointOnFunction -> c
    geogebra.common.kernel.geos.GeoFunction deriv -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTrigCombine -> geogebra.common.i.g.N:
    geogebra.common.kernel.geos.GeoFunction target -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTrigExpand -> geogebra.common.i.g.O:
    geogebra.common.kernel.geos.GeoFunction target -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTrigSimplify -> geogebra.common.i.g.P:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoUsingTempCASalgo -> geogebra.common.i.g.Q:
    geogebra.common.kernel.algos.AlgoElement algoCAS -> a
    void remove() -> c
geogebra.common.kernel.cas.CmdCoefficients -> geogebra.common.i.g.R:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdDegree -> geogebra.common.i.g.S:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdExpand -> geogebra.common.i.g.T:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdFactor -> geogebra.common.i.g.U:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdImplicitDerivative -> geogebra.common.i.g.V:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdIntegral -> geogebra.common.i.g.W:
    java.lang.String internalCommandName -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement Integral(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.cas.CmdLimit -> geogebra.common.i.g.X:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdLimitAbove -> geogebra.common.i.g.Y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdLimitBelow -> geogebra.common.i.g.Z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdNextPreviousPrime -> geogebra.common.i.g.aa:
    boolean next -> a
    geogebra.common.kernel.geos.GeoElement getResult(geogebra.common.kernel.arithmetic.NumberValue,java.lang.String) -> a
geogebra.common.kernel.cas.CmdParametricDerivative -> geogebra.common.i.g.ab:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdPartialFractions -> geogebra.common.i.g.ac:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdSimplify -> geogebra.common.i.g.ad:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdSolveODE -> geogebra.common.i.g.ae:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoLocus SolveODE(java.lang.String,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.cas.CmdSurdText -> geogebra.common.i.g.af:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdTrigCombine -> geogebra.common.i.g.ag:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdTrigExpand -> geogebra.common.i.g.ah:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.CmdTrigSimplify -> geogebra.common.i.g.ai:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.cas.UsesCAS -> geogebra.common.i.g.aj:
geogebra.common.kernel.commands.AlgebraProcessor -> geogebra.common.i.h.a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.main.App app -> a
    geogebra.common.kernel.parser.ParserInterface parser -> a
    geogebra.common.kernel.commands.CommandDispatcher cmdDispatcher -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    java.util.Set getPublicCommandSet() -> a
    java.lang.String getSubCommandSetName(int) -> a
    boolean isCommandAvailable(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processCommand(geogebra.common.kernel.arithmetic.Command,boolean) -> a
    void processCasCell(geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    boolean isNotFunctionAble(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    boolean isNotFunctionAbleEV(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.geos.GeoElement changeGeoElement(geogebra.common.kernel.geos.GeoElement,java.lang.String,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement changeGeoElementNoExceptionHandling(geogebra.common.kernel.geos.GeoElement,java.lang.String,boolean,boolean) -> b
    geogebra.common.kernel.geos.GeoElement changeGeoElementNoExceptionHandling(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.ValidExpression,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommand(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommandNoExceptions(java.lang.String,boolean) -> b
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommandNoExceptionHandling(java.lang.String,boolean,boolean,boolean) -> a
    double evaluateToDouble(java.lang.String) -> a
    double evaluateToDouble(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoBoolean evaluateToBoolean(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoList evaluateToList(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoFunction evaluateToFunction(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar evaluateToFunctionNVar(java.lang.String,boolean) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateToNumeric(java.lang.String,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND evaluateToPoint(java.lang.String,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoText evaluateToText(java.lang.String,boolean,boolean) -> a
    java.lang.String parseLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processValidExpression(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    geogebra.common.kernel.geos.GeoElement[] processValidExpression(geogebra.common.kernel.arithmetic.ValidExpression,boolean) -> a
    boolean compatibleTypes(geogebra.common.plugin.GeoClass,geogebra.common.plugin.GeoClass) -> a
    geogebra.common.kernel.geos.GeoElement[] doProcessValidExpression(geogebra.common.kernel.arithmetic.ValidExpression) -> b
    geogebra.common.kernel.geos.GeoElement[] processFunction(geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoFunction DependentInterval(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoElement DependentGeoCopy(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] processFunctionNVar(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar DependentFunctionNVar(java.lang.String,geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.geos.GeoElement[] processEquation(geogebra.common.kernel.arithmetic.Equation) -> a
    void checkNoTermsInZ(geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoElement[] processLine(geogebra.common.kernel.arithmetic.Equation) -> b
    geogebra.common.kernel.geos.GeoLine DependentLine(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoElement[] processConic(geogebra.common.kernel.arithmetic.Equation) -> c
    geogebra.common.kernel.geos.GeoConic DependentConic(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoElement[] processImplicitPoly(geogebra.common.kernel.arithmetic.Equation) -> d
    geogebra.common.kernel.geos.GeoElement[] processParametric(geogebra.common.kernel.arithmetic.Parametric) -> a
    geogebra.common.kernel.geos.GeoElement[] processExpressionNode(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] processNumber(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.geos.GeoNumeric DependentNumber(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] processList(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.geos.GeoList ListExpression(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] processText(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.geos.GeoText DependentText(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processBoolean(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    geogebra.common.kernel.geos.GeoElement[] processPointVector(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> e
    geogebra.common.kernel.geos.GeoPoint DependentPoint(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,boolean) -> a
    geogebra.common.kernel.geos.GeoVector DependentVector(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] processPointVector3D(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.geos.GeoElement[] processGeoCopy(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement DependentGeoCopy(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void enableCAS() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.commands.CAScmdProcessor -> geogebra.common.i.h.b:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAngle -> geogebra.common.i.h.c:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAngularBisector -> geogebra.common.i.h.d:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAppend -> geogebra.common.i.h.e:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdArc -> geogebra.common.i.h.f:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdArea -> geogebra.common.i.h.g:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBarChart -> geogebra.common.i.h.h:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdBinomial -> geogebra.common.i.h.i:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdCAStoOperation -> geogebra.common.i.h.j:
    geogebra.common.plugin.Operation op -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.commands.CmdCenter -> geogebra.common.i.h.k:
geogebra.common.kernel.commands.CmdCircle -> geogebra.common.i.h.l:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircleArc -> geogebra.common.i.h.m:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircleSector -> geogebra.common.i.h.n:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumcircleArc -> geogebra.common.i.h.o:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumcircleSector -> geogebra.common.i.h.p:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumference -> geogebra.common.i.h.q:
geogebra.common.kernel.commands.CmdConic -> geogebra.common.i.h.r:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] Conic(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdCopyFreeObject -> geogebra.common.i.h.s:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCorner -> geogebra.common.i.h.t:
geogebra.common.kernel.commands.CmdCountIf -> geogebra.common.i.h.u:
    geogebra.common.kernel.geos.GeoElement[] getResult2(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoElement[] getResult3(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoList[]) -> a
geogebra.common.kernel.commands.CmdCurveCartesian -> geogebra.common.i.h.v:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDefined -> geogebra.common.i.h.w:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDerivative -> geogebra.common.i.h.x:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    java.lang.String getDerivLabel(geogebra.common.kernel.geos.GeoElement,int) -> a
    geogebra.common.kernel.geos.GeoElement Derivative(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdDiameter -> geogebra.common.i.h.y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDilate -> geogebra.common.i.h.z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] Dilate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdDistance -> geogebra.common.i.h.A:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDiv -> geogebra.common.i.h.B:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdElement -> geogebra.common.i.h.C:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdEllipse -> geogebra.common.i.h.D:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExecute -> geogebra.common.i.h.E:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExtremum -> geogebra.common.i.h.F:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPoint[] Extremum(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> a
geogebra.common.kernel.commands.CmdFirst -> geogebra.common.i.h.G:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText First(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList First(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.commands.CmdFocus -> geogebra.common.i.h.H:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFractionText -> geogebra.common.i.h.I:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFunction -> geogebra.common.i.h.J:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoFunction Function(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdGCD -> geogebra.common.i.h.K:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdGetTime -> geogebra.common.i.h.L:
    int[] month_days -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    void buildLocalizedDate(java.lang.StringBuilder,java.lang.String,geogebra.common.main.App) -> a
    void decode(char,java.lang.StringBuilder,geogebra.common.main.App) -> a
geogebra.common.kernel.commands.CmdHyperbola -> geogebra.common.i.h.M:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIf -> geogebra.common.i.h.N:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoFunction resolveFunction(geogebra.common.kernel.arithmetic.Command,int,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.geos.GeoFunction If(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
geogebra.common.kernel.commands.CmdIntersect -> geogebra.common.i.h.O:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyLineSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyConicSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolysSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectImplicitpolyPolynomialSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialLineSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint IntersectPolynomialsSingle(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoNumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint[] IntersectFunctions(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdIsInteger -> geogebra.common.i.h.P:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdJoin -> geogebra.common.i.h.Q:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoList Join(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdKeepIf -> geogebra.common.i.h.R:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] getResult2(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoElement[] getResult3(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoList[]) -> a
geogebra.common.kernel.commands.CmdLCM -> geogebra.common.i.h.S:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLaTeX -> geogebra.common.i.h.T:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText LaTeX(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoBoolean) -> a
geogebra.common.kernel.commands.CmdLast -> geogebra.common.i.h.U:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText Last(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Last(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.commands.CmdLeftSum -> geogebra.common.i.h.V:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLength -> geogebra.common.i.h.W:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLetterToUnicode -> geogebra.common.i.h.X:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLine -> geogebra.common.i.h.Y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLineBisector -> geogebra.common.i.h.Z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLocus -> geogebra.common.i.h.aa:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLowerSum -> geogebra.common.i.h.ab:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMax -> geogebra.common.i.h.ac:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMidpoint -> geogebra.common.i.h.ad:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMin -> geogebra.common.i.h.ae:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMirror -> geogebra.common.i.h.af:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMod -> geogebra.common.i.h.ag:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdName -> geogebra.common.i.h.ah:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdObject -> geogebra.common.i.h.ai:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOneListFunction -> geogebra.common.i.h.aj:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
geogebra.common.kernel.commands.CmdOneNumber -> geogebra.common.i.h.ak:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement getResult(geogebra.common.kernel.arithmetic.NumberValue,java.lang.String) -> a
geogebra.common.kernel.commands.CmdOneOrTwoListsFunction -> geogebra.common.i.h.al:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdOrthogonalLine -> geogebra.common.i.h.am:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOrthogonalVector -> geogebra.common.i.h.an:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdParabola -> geogebra.common.i.h.ao:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPerimeter -> geogebra.common.i.h.ap:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPoint -> geogebra.common.i.h.aq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPointIn -> geogebra.common.i.h.ar:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPointList -> geogebra.common.i.h.as:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdPolyLine -> geogebra.common.i.h.at:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLine(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdPolygon -> geogebra.common.i.h.au:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPolynomial -> geogebra.common.i.h.av:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoFunction PolynomialFunction(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdProduct -> geogebra.common.i.h.aw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRadius -> geogebra.common.i.h.ax:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRandom -> geogebra.common.i.h.ay:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRay -> geogebra.common.i.h.az:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRectangleSum -> geogebra.common.i.h.aA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRemoveUndefined -> geogebra.common.i.h.aB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdReverse -> geogebra.common.i.h.aC:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRoot -> geogebra.common.i.h.aD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPoint[] Root(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> a
geogebra.common.kernel.commands.CmdRotate -> geogebra.common.i.h.aE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] Rotate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdScripting -> geogebra.common.i.h.aF:
    geogebra.common.kernel.geos.GeoElement[] arg -> a
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
    void performAndClean(geogebra.common.kernel.arithmetic.Command) -> b
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSector -> geogebra.common.i.h.aG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSegment -> geogebra.common.i.h.aH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSemicircle -> geogebra.common.i.h.aI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSequence -> geogebra.common.i.h.aJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShear -> geogebra.common.i.h.aK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] Shear(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.commands.CmdSlope -> geogebra.common.i.h.aL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSort -> geogebra.common.i.h.aM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoList Sort(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdStretch -> geogebra.common.i.h.aN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] Stretch(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.commands.CmdSum -> geogebra.common.i.h.aO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement Sum(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement SumFunctions(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoElement SumFunctions(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement SumPoints(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoElement SumPoints(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoElement SumText(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoElement SumText(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> c
geogebra.common.kernel.commands.CmdTableText -> geogebra.common.i.h.aP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText TableText(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoText) -> a
geogebra.common.kernel.commands.CmdTake -> geogebra.common.i.h.aQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText Take(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Take(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.commands.CmdTangent -> geogebra.common.i.h.aR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdText -> geogebra.common.i.h.aS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTextToUnicode -> geogebra.common.i.h.aT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTranslate -> geogebra.common.i.h.aU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTrapezoidalSum -> geogebra.common.i.h.aV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTurningPoint -> geogebra.common.i.h.aW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTwoNumFunction -> geogebra.common.i.h.aX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdUnicodeToLetter -> geogebra.common.i.h.aY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnicodeToText -> geogebra.common.i.h.aZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUpperSum -> geogebra.common.i.h.ba:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVector -> geogebra.common.i.h.bb:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVertex -> geogebra.common.i.h.bc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPoint CornerOfDrawingPad(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CommandDispatcher -> geogebra.common.i.h.bd:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.main.App app -> a
    boolean isCasActive -> a
    java.util.HashMap cmdTable -> a
    java.util.HashMap casTable -> b
    java.util.HashMap internalCmdTable -> c
    geogebra.common.kernel.commands.MacroProcessor macroProc -> a
    geogebra.common.kernel.commands.CommandDispatcherStats statsDispatcher -> a
    geogebra.common.kernel.commands.CommandDispatcherDiscrete discreteDispatcher -> a
    geogebra.common.kernel.commands.CommandDispatcherCAS casDispatcher -> a
    geogebra.common.kernel.commands.CommandDispatcherScripting scriptingDispatcher -> a
    geogebra.common.kernel.commands.CommandDispatcherAdvanced advancedDispatcher -> a
    geogebra.common.kernel.commands.CommandDispatcherBasic basicDispatcher -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    java.lang.String getSubCommandSetName(int) -> a
    java.util.Set getPublicCommandSet() -> a
    boolean isCommandAvailable(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processCommand(geogebra.common.kernel.arithmetic.Command,boolean) -> a
    void initCmdTable() -> a
    void initCASCommands() -> b
    void fillInternalCmdTable() -> c
    geogebra.common.kernel.commands.CommandProcessor commandTableSwitch(java.lang.String) -> a
    geogebra.common.kernel.commands.CommandDispatcherStats getStatsDispatcher() -> a
    geogebra.common.kernel.commands.CommandDispatcherInterface getDiscreteDispatcher() -> a
    geogebra.common.kernel.commands.CommandDispatcherCAS getCASDispatcher() -> a
    geogebra.common.kernel.commands.CommandDispatcherInterface getScriptingDispatcher() -> b
    geogebra.common.kernel.commands.CommandDispatcherInterface getAdvancedDispatcher() -> c
    geogebra.common.kernel.commands.CommandDispatcherBasic getBasicDispatcher() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherAdvanced -> geogebra.common.i.h.be:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherBasic -> geogebra.common.i.h.bf:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherCAS -> geogebra.common.i.h.bg:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherDiscrete -> geogebra.common.i.h.bh:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherInterface -> geogebra.common.i.h.bi:
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
geogebra.common.kernel.commands.CommandDispatcherScripting -> geogebra.common.i.h.bj:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandDispatcherStats -> geogebra.common.i.h.bk:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor dispatch(geogebra.common.kernel.commands.Commands,geogebra.common.kernel.Kernel) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandProcessor -> geogebra.common.i.h.bl:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernelA -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] resArgs(geogebra.common.kernel.arithmetic.Command) -> b
    geogebra.common.kernel.geos.GeoElement[] resArg(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] resArgsLocalNumVar(geogebra.common.kernel.arithmetic.Command,int,int) -> a
    geogebra.common.kernel.geos.GeoElement resArgsForZip(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoList[]) -> a
    geogebra.common.main.MyError argErr(geogebra.common.main.App,java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.main.MyError argNumErr(geogebra.common.main.App,java.lang.String,int) -> a
    void getCommandSyntax(java.lang.StringBuilder,geogebra.common.main.App,java.lang.String,int) -> a
    geogebra.common.kernel.geos.GeoElement getBadArg(boolean[],geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoList wrapInList(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoElement[],int,geogebra.common.plugin.GeoClass) -> a
    geogebra.common.kernel.geos.GeoList wrapFreehandFunctionArgInList(geogebra.common.kernel.Kernel,geogebra.common.kernel.algos.AlgoFunctionFreehand) -> a
    void checkDependency(geogebra.common.kernel.geos.GeoElement[],java.lang.String,int,int) -> a
    geogebra.common.kernel.algos.AlgoDispatcher getAlgoDispatcher() -> a
geogebra.common.kernel.commands.Commands -> geogebra.common.i.h.bm:
    geogebra.common.kernel.commands.Commands Mod -> a
    geogebra.common.kernel.commands.Commands Div -> b
    geogebra.common.kernel.commands.Commands Min -> c
    geogebra.common.kernel.commands.Commands Max -> d
    geogebra.common.kernel.commands.Commands LCM -> e
    geogebra.common.kernel.commands.Commands GCD -> f
    geogebra.common.kernel.commands.Commands Expand -> g
    geogebra.common.kernel.commands.Commands Factor -> h
    geogebra.common.kernel.commands.Commands Simplify -> i
    geogebra.common.kernel.commands.Commands PrimeFactors -> j
    geogebra.common.kernel.commands.Commands CompleteSquare -> k
    geogebra.common.kernel.commands.Commands ToBase -> l
    geogebra.common.kernel.commands.Commands FromBase -> m
    geogebra.common.kernel.commands.Commands Division -> n
    geogebra.common.kernel.commands.Commands Divisors -> o
    geogebra.common.kernel.commands.Commands DivisorsList -> p
    geogebra.common.kernel.commands.Commands DivisorsSum -> q
    geogebra.common.kernel.commands.Commands IsPrime -> r
    geogebra.common.kernel.commands.Commands LeftSide -> s
    geogebra.common.kernel.commands.Commands NextPrime -> t
    geogebra.common.kernel.commands.Commands RightSide -> u
    geogebra.common.kernel.commands.Commands PreviousPrime -> v
    geogebra.common.kernel.commands.Commands Line -> w
    geogebra.common.kernel.commands.Commands Ray -> x
    geogebra.common.kernel.commands.Commands AngularBisector -> y
    geogebra.common.kernel.commands.Commands OrthogonalLine -> z
    geogebra.common.kernel.commands.Commands Tangent -> A
    geogebra.common.kernel.commands.Commands Segment -> B
    geogebra.common.kernel.commands.Commands Slope -> C
    geogebra.common.kernel.commands.Commands Angle -> D
    geogebra.common.kernel.commands.Commands Direction -> E
    geogebra.common.kernel.commands.Commands Point -> F
    geogebra.common.kernel.commands.Commands Midpoint -> G
    geogebra.common.kernel.commands.Commands LineBisector -> H
    geogebra.common.kernel.commands.Commands Intersect -> I
    geogebra.common.kernel.commands.Commands IntersectRegion -> J
    geogebra.common.kernel.commands.Commands Distance -> K
    geogebra.common.kernel.commands.Commands Length -> L
    geogebra.common.kernel.commands.Commands Radius -> M
    geogebra.common.kernel.commands.Commands CircleArc -> N
    geogebra.common.kernel.commands.Commands Arc -> O
    geogebra.common.kernel.commands.Commands Sector -> P
    geogebra.common.kernel.commands.Commands CircleSector -> Q
    geogebra.common.kernel.commands.Commands CircumcircleSector -> R
    geogebra.common.kernel.commands.Commands CircumcircleArc -> S
    geogebra.common.kernel.commands.Commands Polygon -> T
    geogebra.common.kernel.commands.Commands RigidPolygon -> U
    geogebra.common.kernel.commands.Commands Area -> V
    geogebra.common.kernel.commands.Commands Circumference -> W
    geogebra.common.kernel.commands.Commands Perimeter -> X
    geogebra.common.kernel.commands.Commands Locus -> Y
    geogebra.common.kernel.commands.Commands Centroid -> Z
    geogebra.common.kernel.commands.Commands TriangleCenter -> aa
    geogebra.common.kernel.commands.Commands Barycenter -> ab
    geogebra.common.kernel.commands.Commands Trilinear -> ac
    geogebra.common.kernel.commands.Commands Cubic -> ad
    geogebra.common.kernel.commands.Commands TriangleCurve -> ae
    geogebra.common.kernel.commands.Commands Vertex -> af
    geogebra.common.kernel.commands.Commands PolyLine -> ag
    geogebra.common.kernel.commands.Commands PointIn -> ah
    geogebra.common.kernel.commands.Commands AffineRatio -> ai
    geogebra.common.kernel.commands.Commands CrossRatio -> aj
    geogebra.common.kernel.commands.Commands ClosestPoint -> ak
    geogebra.common.kernel.commands.Commands LocusEquation -> al
    geogebra.common.kernel.commands.Commands Text -> am
    geogebra.common.kernel.commands.Commands LaTeX -> an
    geogebra.common.kernel.commands.Commands LetterToUnicode -> ao
    geogebra.common.kernel.commands.Commands TextToUnicode -> ap
    geogebra.common.kernel.commands.Commands UnicodeToText -> aq
    geogebra.common.kernel.commands.Commands UnicodeToLetter -> ar
    geogebra.common.kernel.commands.Commands FractionText -> as
    geogebra.common.kernel.commands.Commands SurdText -> at
    geogebra.common.kernel.commands.Commands ScientificText -> au
    geogebra.common.kernel.commands.Commands TableText -> av
    geogebra.common.kernel.commands.Commands VerticalText -> aw
    geogebra.common.kernel.commands.Commands RotateText -> ax
    geogebra.common.kernel.commands.Commands Ordinal -> ay
    geogebra.common.kernel.commands.Commands ContinuedFraction -> az
    geogebra.common.kernel.commands.Commands If -> aA
    geogebra.common.kernel.commands.Commands CountIf -> aB
    geogebra.common.kernel.commands.Commands IsInteger -> aC
    geogebra.common.kernel.commands.Commands KeepIf -> aD
    geogebra.common.kernel.commands.Commands Relation -> aE
    geogebra.common.kernel.commands.Commands Defined -> aF
    geogebra.common.kernel.commands.Commands IsInRegion -> aG
    geogebra.common.kernel.commands.Commands Root -> aH
    geogebra.common.kernel.commands.Commands Roots -> aI
    geogebra.common.kernel.commands.Commands TurningPoint -> aJ
    geogebra.common.kernel.commands.Commands Polynomial -> aK
    geogebra.common.kernel.commands.Commands Function -> aL
    geogebra.common.kernel.commands.Commands Extremum -> aM
    geogebra.common.kernel.commands.Commands CurveCartesian -> aN
    geogebra.common.kernel.commands.Commands ParametricDerivative -> aO
    geogebra.common.kernel.commands.Commands Derivative -> aP
    geogebra.common.kernel.commands.Commands Integral -> aQ
    geogebra.common.kernel.commands.Commands IntegralBetween -> aR
    geogebra.common.kernel.commands.Commands LowerSum -> aS
    geogebra.common.kernel.commands.Commands LeftSum -> aT
    geogebra.common.kernel.commands.Commands RectangleSum -> aU
    geogebra.common.kernel.commands.Commands TaylorSeries -> aV
    geogebra.common.kernel.commands.Commands UpperSum -> aW
    geogebra.common.kernel.commands.Commands TrapezoidalSum -> aX
    geogebra.common.kernel.commands.Commands Limit -> aY
    geogebra.common.kernel.commands.Commands LimitBelow -> aZ
    geogebra.common.kernel.commands.Commands LimitAbove -> ba
    geogebra.common.kernel.commands.Commands Factors -> bb
    geogebra.common.kernel.commands.Commands Degree -> bc
    geogebra.common.kernel.commands.Commands Coefficients -> bd
    geogebra.common.kernel.commands.Commands PartialFractions -> be
    geogebra.common.kernel.commands.Commands Numerator -> bf
    geogebra.common.kernel.commands.Commands Denominator -> bg
    geogebra.common.kernel.commands.Commands ComplexRoot -> bh
    geogebra.common.kernel.commands.Commands SolveODE -> bi
    geogebra.common.kernel.commands.Commands SlopeField -> bj
    geogebra.common.kernel.commands.Commands Iteration -> bk
    geogebra.common.kernel.commands.Commands PathParameter -> bl
    geogebra.common.kernel.commands.Commands Asymptote -> bm
    geogebra.common.kernel.commands.Commands CurvatureVector -> bn
    geogebra.common.kernel.commands.Commands Curvature -> bo
    geogebra.common.kernel.commands.Commands OsculatingCircle -> bp
    geogebra.common.kernel.commands.Commands IterationList -> bq
    geogebra.common.kernel.commands.Commands RootList -> br
    geogebra.common.kernel.commands.Commands ImplicitCurve -> bs
    geogebra.common.kernel.commands.Commands ImplicitDerivative -> bt
    geogebra.common.kernel.commands.Commands Ellipse -> bu
    geogebra.common.kernel.commands.Commands Hyperbola -> bv
    geogebra.common.kernel.commands.Commands SecondAxisLength -> bw
    geogebra.common.kernel.commands.Commands SecondAxis -> bx
    geogebra.common.kernel.commands.Commands Directrix -> by
    geogebra.common.kernel.commands.Commands Diameter -> bz
    geogebra.common.kernel.commands.Commands Conic -> bA
    geogebra.common.kernel.commands.Commands FirstAxis -> bB
    geogebra.common.kernel.commands.Commands Circle -> bC
    geogebra.common.kernel.commands.Commands Incircle -> bD
    geogebra.common.kernel.commands.Commands Semicircle -> bE
    geogebra.common.kernel.commands.Commands FirstAxisLength -> bF
    geogebra.common.kernel.commands.Commands Parabola -> bG
    geogebra.common.kernel.commands.Commands Focus -> bH
    geogebra.common.kernel.commands.Commands Parameter -> bI
    geogebra.common.kernel.commands.Commands Center -> bJ
    geogebra.common.kernel.commands.Commands Polar -> bK
    geogebra.common.kernel.commands.Commands Excentricity -> bL
    geogebra.common.kernel.commands.Commands Eccentricity -> bM
    geogebra.common.kernel.commands.Commands Axes -> bN
    geogebra.common.kernel.commands.Commands Sort -> bO
    geogebra.common.kernel.commands.Commands First -> bP
    geogebra.common.kernel.commands.Commands Last -> bQ
    geogebra.common.kernel.commands.Commands Take -> bR
    geogebra.common.kernel.commands.Commands RemoveUndefined -> bS
    geogebra.common.kernel.commands.Commands Reverse -> bT
    geogebra.common.kernel.commands.Commands Element -> bU
    geogebra.common.kernel.commands.Commands IndexOf -> bV
    geogebra.common.kernel.commands.Commands Append -> bW
    geogebra.common.kernel.commands.Commands Join -> bX
    geogebra.common.kernel.commands.Commands Flatten -> bY
    geogebra.common.kernel.commands.Commands Insert -> bZ
    geogebra.common.kernel.commands.Commands Sequence -> ca
    geogebra.common.kernel.commands.Commands SelectedElement -> cb
    geogebra.common.kernel.commands.Commands SelectedIndex -> cc
    geogebra.common.kernel.commands.Commands RandomElement -> cd
    geogebra.common.kernel.commands.Commands Product -> ce
    geogebra.common.kernel.commands.Commands Frequency -> cf
    geogebra.common.kernel.commands.Commands Unique -> cg
    geogebra.common.kernel.commands.Commands Classes -> ch
    geogebra.common.kernel.commands.Commands Zip -> ci
    geogebra.common.kernel.commands.Commands Intersection -> cj
    geogebra.common.kernel.commands.Commands PointList -> ck
    geogebra.common.kernel.commands.Commands OrdinalRank -> cl
    geogebra.common.kernel.commands.Commands TiedRank -> cm
    geogebra.common.kernel.commands.Commands Union -> cn
    geogebra.common.kernel.commands.Commands BarChart -> co
    geogebra.common.kernel.commands.Commands BoxPlot -> cp
    geogebra.common.kernel.commands.Commands Histogram -> cq
    geogebra.common.kernel.commands.Commands HistogramRight -> cr
    geogebra.common.kernel.commands.Commands DotPlot -> cs
    geogebra.common.kernel.commands.Commands StemPlot -> ct
    geogebra.common.kernel.commands.Commands ResidualPlot -> cu
    geogebra.common.kernel.commands.Commands FrequencyPolygon -> cv
    geogebra.common.kernel.commands.Commands NormalQuantilePlot -> cw
    geogebra.common.kernel.commands.Commands FrequencyTable -> cx
    geogebra.common.kernel.commands.Commands StickGraph -> cy
    geogebra.common.kernel.commands.Commands StepGraph -> cz
    geogebra.common.kernel.commands.Commands ContingencyTable -> cA
    geogebra.common.kernel.commands.Commands Sum -> cB
    geogebra.common.kernel.commands.Commands Mean -> cC
    geogebra.common.kernel.commands.Commands Variance -> cD
    geogebra.common.kernel.commands.Commands SD -> cE
    geogebra.common.kernel.commands.Commands SampleVariance -> cF
    geogebra.common.kernel.commands.Commands SampleSD -> cG
    geogebra.common.kernel.commands.Commands Median -> cH
    geogebra.common.kernel.commands.Commands Q1 -> cI
    geogebra.common.kernel.commands.Commands Q3 -> cJ
    geogebra.common.kernel.commands.Commands Mode -> cK
    geogebra.common.kernel.commands.Commands SigmaXX -> cL
    geogebra.common.kernel.commands.Commands SigmaXY -> cM
    geogebra.common.kernel.commands.Commands SigmaYY -> cN
    geogebra.common.kernel.commands.Commands Covariance -> cO
    geogebra.common.kernel.commands.Commands SXY -> cP
    geogebra.common.kernel.commands.Commands SXX -> cQ
    geogebra.common.kernel.commands.Commands SYY -> cR
    geogebra.common.kernel.commands.Commands MeanX -> cS
    geogebra.common.kernel.commands.Commands MeanY -> cT
    geogebra.common.kernel.commands.Commands PMCC -> cU
    geogebra.common.kernel.commands.Commands SampleSDX -> cV
    geogebra.common.kernel.commands.Commands SampleSDY -> cW
    geogebra.common.kernel.commands.Commands SDX -> cX
    geogebra.common.kernel.commands.Commands SDY -> cY
    geogebra.common.kernel.commands.Commands FitLineY -> cZ
    geogebra.common.kernel.commands.Commands FitLineX -> da
    geogebra.common.kernel.commands.Commands FitPoly -> db
    geogebra.common.kernel.commands.Commands FitExp -> dc
    geogebra.common.kernel.commands.Commands FitLog -> dd
    geogebra.common.kernel.commands.Commands FitPow -> de
    geogebra.common.kernel.commands.Commands Fit -> df
    geogebra.common.kernel.commands.Commands FitGrowth -> dg
    geogebra.common.kernel.commands.Commands FitSin -> dh
    geogebra.common.kernel.commands.Commands FitLogistic -> di
    geogebra.common.kernel.commands.Commands SumSquaredErrors -> dj
    geogebra.common.kernel.commands.Commands RSquare -> dk
    geogebra.common.kernel.commands.Commands Sample -> dl
    geogebra.common.kernel.commands.Commands Shuffle -> dm
    geogebra.common.kernel.commands.Commands Spearman -> dn
    geogebra.common.kernel.commands.Commands TTest -> do
    geogebra.common.kernel.commands.Commands ZProportionTest -> dp
    geogebra.common.kernel.commands.Commands ZProportion2Test -> dq
    geogebra.common.kernel.commands.Commands ZProportionEstimate -> dr
    geogebra.common.kernel.commands.Commands ZProportion2Estimate -> ds
    geogebra.common.kernel.commands.Commands ZMeanEstimate -> dt
    geogebra.common.kernel.commands.Commands ZMean2Estimate -> du
    geogebra.common.kernel.commands.Commands ZMeanTest -> dv
    geogebra.common.kernel.commands.Commands ZMean2Test -> dw
    geogebra.common.kernel.commands.Commands TTestPaired -> dx
    geogebra.common.kernel.commands.Commands TTest2 -> dy
    geogebra.common.kernel.commands.Commands TMeanEstimate -> dz
    geogebra.common.kernel.commands.Commands TMean2Estimate -> dA
    geogebra.common.kernel.commands.Commands ChiSquaredTest -> dB
    geogebra.common.kernel.commands.Commands ANOVA -> dC
    geogebra.common.kernel.commands.Commands Percentile -> dD
    geogebra.common.kernel.commands.Commands GeometricMean -> dE
    geogebra.common.kernel.commands.Commands HarmonicMean -> dF
    geogebra.common.kernel.commands.Commands RootMeanSquare -> dG
    geogebra.common.kernel.commands.Commands Random -> dH
    geogebra.common.kernel.commands.Commands RandomNormal -> dI
    geogebra.common.kernel.commands.Commands RandomUniform -> dJ
    geogebra.common.kernel.commands.Commands RandomBinomial -> dK
    geogebra.common.kernel.commands.Commands RandomPoisson -> dL
    geogebra.common.kernel.commands.Commands Normal -> dM
    geogebra.common.kernel.commands.Commands LogNormal -> dN
    geogebra.common.kernel.commands.Commands Logistic -> dO
    geogebra.common.kernel.commands.Commands InverseLogistic -> dP
    geogebra.common.kernel.commands.Commands InverseNormal -> dQ
    geogebra.common.kernel.commands.Commands Binomial -> dR
    geogebra.common.kernel.commands.Commands BinomialDist -> dS
    geogebra.common.kernel.commands.Commands Bernoulli -> dT
    geogebra.common.kernel.commands.Commands InverseBinomial -> dU
    geogebra.common.kernel.commands.Commands TDistribution -> dV
    geogebra.common.kernel.commands.Commands InverseTDistribution -> dW
    geogebra.common.kernel.commands.Commands FDistribution -> dX
    geogebra.common.kernel.commands.Commands InverseFDistribution -> dY
    geogebra.common.kernel.commands.Commands Gamma -> dZ
    geogebra.common.kernel.commands.Commands InverseGamma -> ea
    geogebra.common.kernel.commands.Commands Cauchy -> eb
    geogebra.common.kernel.commands.Commands InverseCauchy -> ec
    geogebra.common.kernel.commands.Commands ChiSquared -> ed
    geogebra.common.kernel.commands.Commands InverseChiSquared -> ee
    geogebra.common.kernel.commands.Commands Exponential -> ef
    geogebra.common.kernel.commands.Commands InverseExponential -> eg
    geogebra.common.kernel.commands.Commands HyperGeometric -> eh
    geogebra.common.kernel.commands.Commands InverseHyperGeometric -> ei
    geogebra.common.kernel.commands.Commands Pascal -> ej
    geogebra.common.kernel.commands.Commands InversePascal -> ek
    geogebra.common.kernel.commands.Commands Poisson -> el
    geogebra.common.kernel.commands.Commands InversePoisson -> em
    geogebra.common.kernel.commands.Commands Weibull -> en
    geogebra.common.kernel.commands.Commands InverseWeibull -> eo
    geogebra.common.kernel.commands.Commands Zipf -> ep
    geogebra.common.kernel.commands.Commands InverseZipf -> eq
    geogebra.common.kernel.commands.Commands Triangular -> er
    geogebra.common.kernel.commands.Commands Uniform -> es
    geogebra.common.kernel.commands.Commands Erlang -> et
    geogebra.common.kernel.commands.Commands InverseLogNormal -> eu
    geogebra.common.kernel.commands.Commands RandomPolynomial -> ev
    geogebra.common.kernel.commands.Commands nPr -> ew
    geogebra.common.kernel.commands.Commands ApplyMatrix -> ex
    geogebra.common.kernel.commands.Commands UnitVector -> ey
    geogebra.common.kernel.commands.Commands Vector -> ez
    geogebra.common.kernel.commands.Commands UnitOrthogonalVector -> eA
    geogebra.common.kernel.commands.Commands OrthogonalVector -> eB
    geogebra.common.kernel.commands.Commands Invert -> eC
    geogebra.common.kernel.commands.Commands Transpose -> eD
    geogebra.common.kernel.commands.Commands ReducedRowEchelonForm -> eE
    geogebra.common.kernel.commands.Commands Determinant -> eF
    geogebra.common.kernel.commands.Commands Identity -> eG
    geogebra.common.kernel.commands.Commands Dimension -> eH
    geogebra.common.kernel.commands.Commands MatrixRank -> eI
    geogebra.common.kernel.commands.Commands Mirror -> eJ
    geogebra.common.kernel.commands.Commands Dilate -> eK
    geogebra.common.kernel.commands.Commands Rotate -> eL
    geogebra.common.kernel.commands.Commands Translate -> eM
    geogebra.common.kernel.commands.Commands Shear -> eN
    geogebra.common.kernel.commands.Commands Stretch -> eO
    geogebra.common.kernel.commands.Commands CellRange -> eP
    geogebra.common.kernel.commands.Commands Row -> eQ
    geogebra.common.kernel.commands.Commands Column -> eR
    geogebra.common.kernel.commands.Commands ColumnName -> eS
    geogebra.common.kernel.commands.Commands FillRow -> eT
    geogebra.common.kernel.commands.Commands FillColumn -> eU
    geogebra.common.kernel.commands.Commands FillCells -> eV
    geogebra.common.kernel.commands.Commands Cell -> eW
    geogebra.common.kernel.commands.Commands CopyFreeObject -> eX
    geogebra.common.kernel.commands.Commands SetColor -> eY
    geogebra.common.kernel.commands.Commands SetBackgroundColor -> eZ
    geogebra.common.kernel.commands.Commands SetDynamicColor -> fa
    geogebra.common.kernel.commands.Commands SetConditionToShowObject -> fb
    geogebra.common.kernel.commands.Commands SetFilling -> fc
    geogebra.common.kernel.commands.Commands SetLineThickness -> fd
    geogebra.common.kernel.commands.Commands SetLineStyle -> fe
    geogebra.common.kernel.commands.Commands SetPointStyle -> ff
    geogebra.common.kernel.commands.Commands SetPointSize -> fg
    geogebra.common.kernel.commands.Commands SetFixed -> fh
    geogebra.common.kernel.commands.Commands SetTrace -> fi
    geogebra.common.kernel.commands.Commands Rename -> fj
    geogebra.common.kernel.commands.Commands HideLayer -> fk
    geogebra.common.kernel.commands.Commands ShowLayer -> fl
    geogebra.common.kernel.commands.Commands SetCoords -> fm
    geogebra.common.kernel.commands.Commands Pan -> fn
    geogebra.common.kernel.commands.Commands CenterView -> fo
    geogebra.common.kernel.commands.Commands ZoomIn -> fp
    geogebra.common.kernel.commands.Commands SetSeed -> fq
    geogebra.common.kernel.commands.Commands ZoomOut -> fr
    geogebra.common.kernel.commands.Commands SetActiveView -> fs
    geogebra.common.kernel.commands.Commands SelectObjects -> ft
    geogebra.common.kernel.commands.Commands SetLayer -> fu
    geogebra.common.kernel.commands.Commands SetCaption -> fv
    geogebra.common.kernel.commands.Commands SetLabelMode -> fw
    geogebra.common.kernel.commands.Commands SetTooltipMode -> fx
    geogebra.common.kernel.commands.Commands UpdateConstruction -> fy
    geogebra.common.kernel.commands.Commands SetValue -> fz
    geogebra.common.kernel.commands.Commands PlaySound -> fA
    geogebra.common.kernel.commands.Commands ParseToNumber -> fB
    geogebra.common.kernel.commands.Commands ParseToFunction -> fC
    geogebra.common.kernel.commands.Commands StartAnimation -> fD
    geogebra.common.kernel.commands.Commands Delete -> fE
    geogebra.common.kernel.commands.Commands Slider -> fF
    geogebra.common.kernel.commands.Commands Checkbox -> fG
    geogebra.common.kernel.commands.Commands Textfield -> fH
    geogebra.common.kernel.commands.Commands Button -> fI
    geogebra.common.kernel.commands.Commands Execute -> fJ
    geogebra.common.kernel.commands.Commands GetTime -> fK
    geogebra.common.kernel.commands.Commands ShowLabel -> fL
    geogebra.common.kernel.commands.Commands SetAxesRatio -> fM
    geogebra.common.kernel.commands.Commands SetVisibleInView -> fN
    geogebra.common.kernel.commands.Commands ShowAxes -> fO
    geogebra.common.kernel.commands.Commands ShowGrid -> fP
    geogebra.common.kernel.commands.Commands AttachCopyToView -> fQ
    geogebra.common.kernel.commands.Commands Voronoi -> fR
    geogebra.common.kernel.commands.Commands Hull -> fS
    geogebra.common.kernel.commands.Commands ConvexHull -> fT
    geogebra.common.kernel.commands.Commands MinimumSpanningTree -> fU
    geogebra.common.kernel.commands.Commands DelauneyTriangulation -> fV
    geogebra.common.kernel.commands.Commands TravelingSalesman -> fW
    geogebra.common.kernel.commands.Commands ShortestDistance -> fX
    geogebra.common.kernel.commands.Commands Corner -> fY
    geogebra.common.kernel.commands.Commands AxisStepX -> fZ
    geogebra.common.kernel.commands.Commands AxisStepY -> ga
    geogebra.common.kernel.commands.Commands ConstructionStep -> gb
    geogebra.common.kernel.commands.Commands Object -> gc
    geogebra.common.kernel.commands.Commands Name -> gd
    geogebra.common.kernel.commands.Commands SlowPlot -> ge
    geogebra.common.kernel.commands.Commands ToolImage -> gf
    geogebra.common.kernel.commands.Commands DynamicCoordinates -> gg
    geogebra.common.kernel.commands.Commands Maximize -> gh
    geogebra.common.kernel.commands.Commands Minimize -> gi
    geogebra.common.kernel.commands.Commands Curve -> gj
    geogebra.common.kernel.commands.Commands FormulaText -> gk
    geogebra.common.kernel.commands.Commands IsDefined -> gl
    geogebra.common.kernel.commands.Commands ConjugateDiameter -> gm
    geogebra.common.kernel.commands.Commands LinearEccentricity -> gn
    geogebra.common.kernel.commands.Commands MajorAxis -> go
    geogebra.common.kernel.commands.Commands SemiMajorAxisLength -> gp
    geogebra.common.kernel.commands.Commands PerpendicularBisector -> gq
    geogebra.common.kernel.commands.Commands PerpendicularLine -> gr
    geogebra.common.kernel.commands.Commands PerpendicularVector -> gs
    geogebra.common.kernel.commands.Commands MinorAxis -> gt
    geogebra.common.kernel.commands.Commands SemiMinorAxisLength -> gu
    geogebra.common.kernel.commands.Commands UnitPerpendicularVector -> gv
    geogebra.common.kernel.commands.Commands CorrelationCoefficient -> gw
    geogebra.common.kernel.commands.Commands FitLine -> gx
    geogebra.common.kernel.commands.Commands BinomialCoefficient -> gy
    geogebra.common.kernel.commands.Commands RandomBetween -> gz
    geogebra.common.kernel.commands.Commands TaylorPolynomial -> gA
    geogebra.common.kernel.commands.Commands AngleBisector -> gB
    geogebra.common.kernel.commands.Commands CircularArc -> gC
    geogebra.common.kernel.commands.Commands CircularSector -> gD
    geogebra.common.kernel.commands.Commands CircumcircularArc -> gE
    geogebra.common.kernel.commands.Commands CircumcircularSector -> gF
    geogebra.common.kernel.commands.Commands InflectionPoint -> gG
    geogebra.common.kernel.commands.Commands DelaunayTriangulation -> gH
    geogebra.common.kernel.commands.Commands Bottom -> gI
    geogebra.common.kernel.commands.Commands Cone -> gJ
    geogebra.common.kernel.commands.Commands Cube -> gK
    geogebra.common.kernel.commands.Commands Cylinder -> gL
    geogebra.common.kernel.commands.Commands Dodecahedron -> gM
    geogebra.common.kernel.commands.Commands Ends -> gN
    geogebra.common.kernel.commands.Commands Icosahedron -> gO
    geogebra.common.kernel.commands.Commands InfiniteCone -> gP
    geogebra.common.kernel.commands.Commands InfiniteCylinder -> gQ
    geogebra.common.kernel.commands.Commands Octahedron -> gR
    geogebra.common.kernel.commands.Commands Plane -> gS
    geogebra.common.kernel.commands.Commands QuadricSide -> gT
    geogebra.common.kernel.commands.Commands SurfaceCartesian -> gU
    geogebra.common.kernel.commands.Commands Tetrahedron -> gV
    geogebra.common.kernel.commands.Commands Top -> gW
    geogebra.common.kernel.commands.Commands CylinderInfinite -> gX
    geogebra.common.kernel.commands.Commands Sphere -> gY
    geogebra.common.kernel.commands.Commands OrthogonalPlane -> gZ
    geogebra.common.kernel.commands.Commands PerpendicularPlane -> ha
    geogebra.common.kernel.commands.Commands Prism -> hb
    geogebra.common.kernel.commands.Commands Pyramid -> hc
    geogebra.common.kernel.commands.Commands PlaneBisector -> hd
    geogebra.common.kernel.commands.Commands IntersectionPaths -> he
    geogebra.common.kernel.commands.Commands ConeInfinite -> hf
    geogebra.common.kernel.commands.Commands Reflect -> hg
    geogebra.common.kernel.commands.Commands CFactor -> hh
    geogebra.common.kernel.commands.Commands CommonDenominator -> hi
    geogebra.common.kernel.commands.Commands Cross -> hj
    geogebra.common.kernel.commands.Commands CSolutions -> hk
    geogebra.common.kernel.commands.Commands CSolve -> hl
    geogebra.common.kernel.commands.Commands Dot -> hm
    geogebra.common.kernel.commands.Commands Groebner -> hn
    geogebra.common.kernel.commands.Commands NIntegral -> ho
    geogebra.common.kernel.commands.Commands NSolve -> hp
    geogebra.common.kernel.commands.Commands NSolutions -> hq
    geogebra.common.kernel.commands.Commands Numeric -> hr
    geogebra.common.kernel.commands.Commands MixedNumber -> hs
    geogebra.common.kernel.commands.Commands Rationalize -> ht
    geogebra.common.kernel.commands.Commands Solutions -> hu
    geogebra.common.kernel.commands.Commands Solve -> hv
    geogebra.common.kernel.commands.Commands Substitute -> hw
    geogebra.common.kernel.commands.Commands ToComplex -> hx
    geogebra.common.kernel.commands.Commands ToExponential -> hy
    geogebra.common.kernel.commands.Commands ToPolar -> hz
    geogebra.common.kernel.commands.Commands ToPoint -> hA
    geogebra.common.kernel.commands.Commands TrigExpand -> hB
    geogebra.common.kernel.commands.Commands TrigSimplify -> hC
    geogebra.common.kernel.commands.Commands TrigCombine -> hD
    int table -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.Commands[] ENUM$VALUES -> a
    int getTable() -> a
    geogebra.common.kernel.commands.Commands englishToInternal(geogebra.common.kernel.commands.Commands) -> a
    geogebra.common.kernel.commands.Commands[] values() -> values
    geogebra.common.kernel.commands.Commands valueOf(java.lang.String) -> valueOf
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.MacroProcessor -> geogebra.common.i.h.bn:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.MyException -> geogebra.common.i.h.bo:
    int errorType -> a
    int getErrorType() -> a
geogebra.common.kernel.discrete.AlgoConvexHull -> geogebra.common.i.i.a:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    java.util.ArrayList vl -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    boolean contains(java.util.ArrayList,double,double) -> a
geogebra.common.kernel.discrete.AlgoDelauneyTriangulation -> geogebra.common.i.i.b:
    java.util.Comparator lineComparator -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.util.Comparator getComparator() -> a
geogebra.common.kernel.discrete.AlgoDelauneyTriangulation$1 -> geogebra.common.i.i.c:
    int compare(geogebra.common.kernel.discrete.MyLine,geogebra.common.kernel.discrete.MyLine) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.AlgoHull -> geogebra.common.i.i.d:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric percentage -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    java.util.ArrayList vl -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric access$0(geogebra.common.kernel.discrete.AlgoHull) -> a
geogebra.common.kernel.discrete.AlgoHull$1 -> geogebra.common.i.i.e:
    geogebra.common.kernel.discrete.AlgoHull this$0 -> a
    int calculateCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation) -> a
geogebra.common.kernel.discrete.AlgoHull$TestRepresentationWrapper -> geogebra.common.i.i.d$a:
    java.util.ArrayList circleevents -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface innerrepresentation -> a
    geogebra.common.kernel.discrete.AlgoHull this$0 -> a
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
geogebra.common.kernel.discrete.AlgoMinimumSpanningTree -> geogebra.common.i.i.f:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoShortestDistance -> geogebra.common.i.i.g:
    geogebra.common.kernel.kernelND.GeoPointND start -> a
    geogebra.common.kernel.kernelND.GeoPointND end -> b
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoBoolean weighted -> a
    java.util.ArrayList al -> a
    int edgeCount -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoShortestDistance$1 -> geogebra.common.i.i.h:
    geogebra.common.kernel.discrete.AlgoShortestDistance this$0 -> a
    java.lang.Double transform(geogebra.common.kernel.discrete.AlgoShortestDistance$MyLink) -> a
    java.lang.Object transform(java.lang.Object) -> a
geogebra.common.kernel.discrete.AlgoShortestDistance$MyLink -> geogebra.common.i.i.g$a:
    geogebra.common.kernel.discrete.MyNode n1 -> a
    geogebra.common.kernel.discrete.MyNode n2 -> b
    double capacity -> a
    double weight -> b
    int id -> a
    geogebra.common.kernel.discrete.AlgoShortestDistance this$0 -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.AlgoTravelingSalesman -> geogebra.common.i.i.i:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoVoronoi -> geogebra.common.i.i.j:
    java.util.Comparator pointComparator -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.util.Comparator getPointComparator() -> a
geogebra.common.kernel.discrete.AlgoVoronoi$1 -> geogebra.common.i.i.k:
    int compare(geogebra.common.awt.GPoint2D,geogebra.common.awt.GPoint2D) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.CmdConvexHull -> geogebra.common.i.i.l:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.discrete.CmdDelauneyTriangulation -> geogebra.common.i.i.m:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.discrete.CmdHull -> geogebra.common.i.i.n:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.discrete.CmdMinimumSpanningTree -> geogebra.common.i.i.o:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.discrete.CmdShortestDistance -> geogebra.common.i.i.p:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.discrete.CmdTravelingSalesman -> geogebra.common.i.i.q:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.discrete.CmdVoronoi -> geogebra.common.i.i.r:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.discrete.JarvisMarch2D -> geogebra.common.i.i.s:
    java.util.ArrayList convexHull(java.util.Collection) -> a
    geogebra.common.awt.GPoint2D$Double findNextPoint(geogebra.common.awt.GPoint2D$Double,double,java.util.Collection) -> a
    double horizontalAngle(geogebra.common.awt.GPoint2D$Double,geogebra.common.awt.GPoint2D$Double) -> a
    double formatAngle(double) -> a
geogebra.common.kernel.discrete.MyLine -> geogebra.common.i.i.t:
    geogebra.common.awt.GPoint2D p1 -> a
    geogebra.common.awt.GPoint2D p2 -> b
    double lengthSquared() -> a
geogebra.common.kernel.discrete.MyNode -> geogebra.common.i.i.u:
    geogebra.common.kernel.kernelND.GeoPointND id -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.alds.SortableObject -> geogebra.common.i.i.a.a:
    java.lang.Object object -> a
    int value -> a
    java.lang.Object getObject() -> a
    int getValue() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.alds.al.graphs.PrimMinimumSpanningTree -> geogebra.common.i.i.a.a.a.a:
    java.util.Map keyMap -> a
    java.util.Map predecessorMap -> b
    geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph graph -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex root -> a
    geogebra.common.kernel.discrete.alds.al.graphs.PrimMinimumSpanningTree compute() -> a
    geogebra.common.kernel.discrete.alds.ds.heaps.Heap createMinPriorityQueue(geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph,java.util.Set) -> a
    void initialize(geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    java.util.Map getPredecessorMap() -> a
geogebra.common.kernel.discrete.alds.ds.graphs.Graph -> geogebra.common.i.i.a.b.a.a:
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[][] adjacencyList -> a
    int[][] adjacencyMatrix -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type type -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph addVertex(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    boolean containsVertex(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph addEdge(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    boolean containsEdge(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[] addVertexToAdjacentVerticies(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[],geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[] increaseSize(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[]) -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[][] increaseVertices() -> a
    int numberOfVertices() -> a
    void buildAdjacencyMatrix() -> a
    int[][] getAdjacencyMatrix() -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[] getAllAdjacentVertices(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    int getVertexIndex(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    java.lang.String toString() -> toString
    java.util.Set getVertices() -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type getType() -> a
geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type -> geogebra.common.i.i.a.b.a.a$a:
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type DIRECTED -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type UNDIRECTED -> b
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type[] ENUM$VALUES -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type[] values() -> values
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph$Type valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.discrete.alds.ds.graphs.Vertex -> geogebra.common.i.i.a.b.a.b:
    java.lang.String name -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    java.lang.String getName() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph -> geogebra.common.i.i.a.b.a.c:
    geogebra.common.kernel.discrete.alds.ds.graphs.Graph graph -> a
    java.util.Map edgeWeights -> a
    java.util.Comparator vertexComparator -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph addEdge(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,int) -> a
    int getEdgeWeight(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    void addEdgeWeight(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,int) -> a
    int numberOfVertices() -> a
    geogebra.common.kernel.discrete.alds.ds.graphs.Vertex[] getAllAdjacentVertices(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    java.lang.String toString() -> toString
    java.util.Set getVertices() -> a
geogebra.common.kernel.discrete.alds.ds.graphs.WeightedGraph$1 -> geogebra.common.i.i.a.b.a.d:
    int compare(geogebra.common.kernel.discrete.alds.ds.graphs.Vertex,geogebra.common.kernel.discrete.alds.ds.graphs.Vertex) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.alds.ds.heaps.AbstractHeap -> geogebra.common.i.i.a.b.b.a:
    java.util.List list -> a
    geogebra.common.kernel.discrete.alds.SortableObject extract() -> a
    void heapdown(int) -> a
    void insert(geogebra.common.kernel.discrete.alds.SortableObject) -> a
    void heapup(int) -> b
    int size() -> a
    void swap(int,int) -> a
    int parent(int) -> a
    int left(int) -> b
    int right(int) -> c
geogebra.common.kernel.discrete.alds.ds.heaps.Heap -> geogebra.common.i.i.a.b.b.b:
    void insert(geogebra.common.kernel.discrete.alds.SortableObject) -> a
    geogebra.common.kernel.discrete.alds.SortableObject extract() -> a
    int size() -> a
geogebra.common.kernel.discrete.alds.ds.heaps.HeapFactory -> geogebra.common.i.i.a.b.b.c:
    geogebra.common.kernel.discrete.alds.ds.heaps.Heap minHeap() -> a
geogebra.common.kernel.discrete.alds.ds.heaps.MinHeapImpl -> geogebra.common.i.i.a.b.b.d:
    void heapdown(int) -> a
    void heapup(int) -> b
geogebra.common.kernel.discrete.delaunay.Circle_dt -> geogebra.common.i.i.b.a:
    geogebra.common.kernel.discrete.delaunay.Point_dt c -> a
    double r -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.discrete.delaunay.Point_dt Center() -> a
    double Radius() -> a
geogebra.common.kernel.discrete.delaunay.Compare -> geogebra.common.i.i.b.b:
    int _flag -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
    boolean equals(java.lang.Object) -> equals
geogebra.common.kernel.discrete.delaunay.Delaunay_Triangulation -> geogebra.common.i.i.b.c:
    geogebra.common.kernel.discrete.delaunay.Point_dt firstP -> a
    geogebra.common.kernel.discrete.delaunay.Point_dt lastP -> b
    boolean allCollinear -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt firstT -> b
    geogebra.common.kernel.discrete.delaunay.Triangle_dt lastT -> c
    geogebra.common.kernel.discrete.delaunay.Triangle_dt currT -> d
    geogebra.common.kernel.discrete.delaunay.Triangle_dt startTriangle -> e
    geogebra.common.kernel.discrete.delaunay.Triangle_dt startTriangleHull -> a
    int nPoints -> a
    java.util.Set _vertices -> a
    java.util.Vector _triangles -> a
    java.util.Vector deletedTriangles -> b
    java.util.Vector addedTriangles -> c
    int _modCount -> b
    int _modCount2 -> c
    geogebra.common.kernel.discrete.delaunay.Point_dt _bb_min -> c
    geogebra.common.kernel.discrete.delaunay.Point_dt _bb_max -> d
    int size() -> a
    void insertPoint(geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Point_dt[] calcVoronoiCell(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt insertPointSimple(geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    void insertCollinear(geogebra.common.kernel.discrete.delaunay.Point_dt,int) -> a
    void startTriangulation(geogebra.common.kernel.discrete.delaunay.Point_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt extendInside(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt treatDegeneracyInside(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> b
    geogebra.common.kernel.discrete.delaunay.Triangle_dt extendOutside(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> c
    geogebra.common.kernel.discrete.delaunay.Triangle_dt extendcounterclock(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> d
    geogebra.common.kernel.discrete.delaunay.Triangle_dt extendclock(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> e
    void flip(geogebra.common.kernel.discrete.delaunay.Triangle_dt,int) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt find(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> f
    geogebra.common.kernel.discrete.delaunay.Triangle_dt findnext1(geogebra.common.kernel.discrete.delaunay.Point_dt,geogebra.common.kernel.discrete.delaunay.Triangle_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt findnext2(geogebra.common.kernel.discrete.delaunay.Point_dt,geogebra.common.kernel.discrete.delaunay.Triangle_dt) -> b
    java.util.Vector findTriangleNeighborhood(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    void updateBoundingBox(geogebra.common.kernel.discrete.delaunay.Point_dt) -> b
    java.util.Iterator trianglesIterator() -> a
    void initTriangles() -> a
geogebra.common.kernel.discrete.delaunay.Point_dt -> geogebra.common.i.i.b.d:
    double x -> a
    double y -> b
    double z -> c
    double x() -> a
    double y() -> b
    double z() -> c
    double distance2(geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    boolean isLess(geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    boolean isGreater(geogebra.common.kernel.discrete.delaunay.Point_dt) -> b
    boolean equals(geogebra.common.kernel.discrete.delaunay.Point_dt) -> c
    java.lang.String toString() -> toString
    int pointLineTest(geogebra.common.kernel.discrete.delaunay.Point_dt,geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    java.util.Comparator getComparator() -> a
geogebra.common.kernel.discrete.delaunay.Triangle_dt -> geogebra.common.i.i.b.e:
    geogebra.common.kernel.discrete.delaunay.Point_dt a -> a
    geogebra.common.kernel.discrete.delaunay.Point_dt b -> b
    geogebra.common.kernel.discrete.delaunay.Point_dt c -> c
    geogebra.common.kernel.discrete.delaunay.Triangle_dt abnext -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt bcnext -> b
    geogebra.common.kernel.discrete.delaunay.Triangle_dt canext -> c
    geogebra.common.kernel.discrete.delaunay.Circle_dt circum -> a
    int _mc -> a
    boolean halfplane -> a
    boolean _mark -> b
    int _counter -> b
    int _c2 -> c
    boolean isHalfplane() -> a
    geogebra.common.kernel.discrete.delaunay.Point_dt p1() -> a
    geogebra.common.kernel.discrete.delaunay.Point_dt p2() -> b
    geogebra.common.kernel.discrete.delaunay.Point_dt p3() -> c
    geogebra.common.kernel.discrete.delaunay.Triangle_dt next_12() -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt next_23() -> b
    geogebra.common.kernel.discrete.delaunay.Triangle_dt next_31() -> c
    void switchneighbors(geogebra.common.kernel.discrete.delaunay.Triangle_dt,geogebra.common.kernel.discrete.delaunay.Triangle_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Triangle_dt nextNeighbor(geogebra.common.kernel.discrete.delaunay.Point_dt,geogebra.common.kernel.discrete.delaunay.Triangle_dt) -> a
    geogebra.common.kernel.discrete.delaunay.Circle_dt circumcircle() -> a
    boolean circumcircle_contains(geogebra.common.kernel.discrete.delaunay.Point_dt) -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.discrete.delaunay.Point_dt getCorner(int) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint -> geogebra.common.i.i.c.a.a:
    double x -> a
    double y -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.VoronoiAlgorithm -> geogebra.common.i.i.c.a.b:
    void generateVoronoi(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface,java.util.Collection) -> a
    void generateVoronoi(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface,java.util.Collection,java.lang.Object,geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint,int) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.VoronoiShared -> geogebra.common.i.i.c.a.c:
    double[] solveQuadratic(double,double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent calculateCenter(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue -> geogebra.common.i.i.c.a.a.a:
    java.util.Comparator PRIORITY_COMPARATOR -> a
    java.util.TreeMap queue -> a
    void addEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    boolean removeEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent getFirstEvent() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent getAndRemoveFirstEvent() -> b
    boolean isEventQueueEmpty() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue$1 -> geogebra.common.i.i.c.a.a.b:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent -> geogebra.common.i.i.c.a.a.c:
    int x -> c
    int y -> d
    int center_y -> e
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode leafnode -> a
    double getX() -> a
    void setX(int) -> a
    double getY() -> b
    void setY(int) -> b
    int getCenterY() -> a
    void setCenterY(int) -> c
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent -> geogebra.common.i.i.c.a.a.d:
    int uniqueid -> a
    int id -> b
    double getX() -> a
    double getY() -> b
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String getID() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent -> geogebra.common.i.i.c.a.a.e:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint point -> a
    double a -> a
    double b -> b
    double c -> c
    void calcParabolaConstants(double) -> a
    double getX() -> a
    double getY() -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint getPoint() -> a
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.AbstractRepresentation -> geogebra.common.i.i.c.a.b.a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint createPoint(double,double) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationFactory -> geogebra.common.i.i.c.a.b.b:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.AbstractRepresentation createTriangulationRepresentation() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface -> geogebra.common.i.i.c.a.b.c:
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval -> geogebra.common.i.i.c.a.b.a.a:
    java.util.Comparator EDGELENGTH_COMPARATOR -> a
    void removeEdgesInOrderFromOuterBoundary(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,int) -> a
    void removeSingleOuterEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$OrderedEdgeList) -> a
    java.util.Comparator access$0() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$1 -> geogebra.common.i.i.c.a.b.a.b:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$OrderedEdgeList -> geogebra.common.i.i.c.a.b.a.a$a:
    void addOuterEdges(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    void addEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree -> geogebra.common.i.i.c.a.b.a.c:
    java.util.Comparator VERTEX_COMPARATOR -> a
    java.util.Comparator PATH_COMPARATOR -> b
    int determineMSTUsingPrimsAlgorithm(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    int determineMSTUsingPrimsAlgorithm(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex,double,java.util.ArrayList) -> a
    int determineClusterCutOffByGradient(java.util.TreeMap,int) -> a
    java.util.Comparator access$0() -> a
    java.util.Comparator access$1() -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$1 -> geogebra.common.i.i.c.a.b.a.d:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$2 -> geogebra.common.i.i.c.a.b.a.e:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$FuturePathList -> geogebra.common.i.i.c.a.b.a.c$a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge popBestNextPath() -> a
    void addPath(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$VertexList -> geogebra.common.i.i.c.a.b.a.c$b:
    boolean hasVertexBeenConsidered(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    void addVertex(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation -> geogebra.common.i.i.c.a.b.a.f:
    boolean SHOW_INTERNAL_TRIANGLES -> a
    boolean SHOW_EDGE_LENGTHS -> b
    boolean SHOW_DEBUG_INFO -> c
    int MAX_EDGES_TO_REMOVE -> a
    int MODE_REDUCE_OUTER_BOUNDARIES -> b
    int MODE_GETSTATS_EXCLUDINGMSTSTATS -> c
    int MODE_DETERMINE_MINSPANNINGTREE -> d
    int MODE_DETERMINE_CLUSTERS -> e
    int mode -> f
    int vertexnumber -> g
    java.util.Collection vertexpoints -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff calccutoff -> a
    int length_cutoff -> h
    double gradient_diff_before_cluster_cutoff -> a
    java.util.ArrayList clusters -> a
    boolean update_statistics -> d
    int max_length -> i
    int min_length -> j
    int max_length_of_smallesttriangleedge -> k
    int max_length_from_minimumspanningtree -> l
    void setReduceOuterBoundariesMode() -> a
    int calculateLengthCutoff() -> a
    void setCalcCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff) -> a
    int getMaxLength() -> b
    int getMinLength() -> c
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint createPoint(double,double) -> a
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge createOuterEdge() -> b
    java.util.ArrayList getPointsFormingOutterBoundary() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge findOuterEdge() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff -> geogebra.common.i.i.c.a.b.a.f$a:
    int calculateCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VCluster -> geogebra.common.i.i.c.a.b.a.g:
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge -> geogebra.common.i.i.c.a.b.a.h:
    int vertexnumber -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge next -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex vertex -> a
    int length -> b
    boolean shownonminimumspanningtree -> a
    boolean isOuterEdge() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex getConnectedVertex() -> a
    int getLength() -> a
    double getX() -> a
    double getY() -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex -> geogebra.common.i.i.c.a.b.a.i:
    int uniqueid -> a
    int id -> b
    java.util.ArrayList edges -> a
    boolean hasEdges() -> a
    void clearEdges() -> a
    void addEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    java.util.ArrayList getEdges() -> a
    boolean removeEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    double distanceTo(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge getEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge getEdge(int) -> a
    boolean isConnectedTo(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    java.lang.String toString() -> toString
    java.lang.String getConnectedVertexString() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.AbstractStatusStructure -> geogebra.common.i.i.c.a.c.a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.AbstractStatusStructure createDefaultStatusStructure() -> a
    boolean isStatusStructureEmpty() -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode insertNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void removeNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getHeadNode() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode -> geogebra.common.i.i.c.a.c.b:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent siteevent -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode prev -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode next -> b
    java.util.ArrayList circleevents -> a
    void removeCircleEvents(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue) -> a
    void addCircleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue) -> b
    void addCircleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getPrev() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNext() -> b
    void setNext(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    boolean isLeafNode() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.BSTStatusStructure -> geogebra.common.i.i.c.a.c.a.a:
    int uniqueid -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode rootnode -> a
    boolean isStatusStructureEmpty() -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode insertNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void removeNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getSuccessor(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getPredecessor(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getHeadNode() -> a
    java.lang.String toString() -> toString
    java.lang.String strDoublyLinkedList(int) -> a
    java.lang.String strTreeStructure(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode,int) -> a
    java.lang.String printGap(int) -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode -> geogebra.common.i.i.c.a.c.a.b:
    int id -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode parent -> a
    int depth -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode left -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode right -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent v1 -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent v2 -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getParent() -> a
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode getLeft() -> a
    void setLeft(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode getRight() -> b
    void setRight(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> b
    void setDepthForRootNode() -> a
    void correctDepthValues(int,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    void setSiteEvents(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VLeafNode -> geogebra.common.i.i.c.a.c.a.c:
    int id -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode parent -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getParent() -> a
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VLeafNode cloneLeafNode() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode -> geogebra.common.i.i.c.a.c.a.d:
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound -> geogebra.common.i.i.d.a.a.a:
    int limit -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.TspImprovement opt -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Circuit branch(java.lang.Object,double[][],double[],boolean[][],boolean[][],boolean[][],double,int,double) -> a
    int[] compressTableToArray(boolean[][]) -> a
    void copy(boolean[][],boolean[][]) -> a
    double[][] createTable(geogebra.common.kernel.discrete.tsp.model.Node[]) -> a
    double getCost(int[],double[][]) -> a
    double getLowerCost(double[][],double[],boolean[][]) -> a
    void getOneTree(boolean[][],double[][],double[],boolean[][],boolean[][]) -> a
    boolean hasCircuitPossibility(boolean[][],boolean[][]) -> a
    int[] method(geogebra.common.kernel.discrete.tsp.model.Node[]) -> a
    java.lang.String toString() -> toString
    void updateConstraint(boolean[][],boolean[][]) -> b
    boolean updateMulipliers(double,boolean[][],double[]) -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Circuit -> geogebra.common.i.i.d.a.a.a$a:
    double cost -> a
    int[] route -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound this$0 -> a
    double getCost() -> a
    int[] getRoute() -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Entry -> geogebra.common.i.i.d.a.a.a$b:
    double cost -> a
    int s -> a
    int t -> b
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound this$0 -> a
    int compareTo(geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Entry) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.discrete.tsp.method.tsp.Opt3 -> geogebra.common.i.i.d.a.a.b:
    boolean method(int[],double[][]) -> a
    void reverse(int[],int,int) -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.tsp.method.tsp.TspImprovement -> geogebra.common.i.i.d.a.a.c:
    boolean method(int[],double[][]) -> a
geogebra.common.kernel.discrete.tsp.model.Node -> geogebra.common.i.i.d.b.a:
    double x -> a
    double y -> b
    boolean equals(java.lang.Object) -> equals
    double getDistance(geogebra.common.kernel.discrete.tsp.model.Node) -> a
    double getX() -> a
    double getY() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.tsp.util.Heap -> geogebra.common.i.i.d.c.a:
    java.lang.Object[] entries -> a
    int size -> a
    java.util.Map table -> a
    java.util.Comparator comparator -> a
    boolean add(java.lang.Object) -> a
    void swap(int,int) -> a
    java.lang.Object poll() -> a
    void clear() -> a
    void fixDown(int) -> a
    void fixUp(int) -> b
    void grow(int) -> c
    java.lang.String toString() -> toString
    int size() -> a
geogebra.common.kernel.discrete.tsp.util.IntegerSet -> geogebra.common.i.i.d.c.b:
    int[] bitset -> a
    int[] list -> b
    int size -> a
    int[] index -> c
    int size() -> a
    boolean add(int) -> a
    int get(int) -> a
    boolean remove(int) -> b
    void swap(int,int) -> a
geogebra.common.kernel.geos.AbsoluteScreenLocateable -> geogebra.common.i.j.a:
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
geogebra.common.kernel.geos.Animatable -> geogebra.common.i.j.b:
    boolean doAnimationStep(double) -> a
    boolean isAnimating() -> p
geogebra.common.kernel.geos.CasEvaluableFunction -> geogebra.common.i.j.c:
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    void clearCasEvalMap(java.lang.String) -> a
geogebra.common.kernel.geos.ChangeableCoordParent -> geogebra.common.i.j.d:
    geogebra.common.kernel.geos.GeoNumeric changeableCoordNumber -> a
    geogebra.common.kernel.geos.GeoElement changeableCoordDirector -> a
    double startValue -> a
    geogebra.common.kernel.Matrix.Coords direction -> a
    geogebra.common.kernel.geos.GeoElement child -> b
    geogebra.common.kernel.geos.GeoNumeric getNumber() -> a
    double getValue() -> a
    geogebra.common.kernel.geos.GeoElement getDirector() -> a
    void record() -> a
    double getStartValue() -> b
    boolean move(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
geogebra.common.kernel.geos.ConicMirrorable -> geogebra.common.i.j.e:
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
geogebra.common.kernel.geos.Dilateable -> geogebra.common.i.j.f:
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
geogebra.common.kernel.geos.FromMeta -> geogebra.common.i.j.g:
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
geogebra.common.kernel.geos.Furniture -> geogebra.common.i.j.h:
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setAbsoluteScreenLoc(int,int) -> a
    boolean isFurniture() -> l_
geogebra.common.kernel.geos.GeoAngle -> geogebra.common.i.j.i:
    int arcSize -> l
    boolean emphasizeRightAngle -> i
    double rawValue -> f
    int angleStyle -> m
    java.lang.String[] INTERVAL_MIN -> a
    java.lang.String[] INTERVAL_MAX -> b
    int[] INTERVAL_TO_STYLE -> a
    int[] STYLE_TO_INTERVAL -> b
    java.lang.Integer[] getDecoTypes() -> a
    void setAngleInterval(int) -> a
    int getAngleInterval() -> e
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isGeoAngle() -> q
    boolean isAngle() -> v_
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setValue(double,boolean) -> a
    double calcAngleValue(double) -> a
    void setIntervalMax(double) -> a
    void setIntervalMin(double) -> b
    void setEuclidianVisible(boolean) -> d
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setAllowReflexAngle(boolean) -> e
    void setForceReflexAngle(boolean) -> f
    void setAngleStyle(int) -> b
    int getAngleStyle() -> f
    boolean hasOrientation() -> s
    double getRawAngle() -> b
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    int getArcSize() -> g
    void setArcSize(int) -> c
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    void getXMLAllowReflexAngleTag(java.lang.StringBuilder) -> n
    void getXMLEmphasizeRightAngleTag(java.lang.StringBuilder) -> o
    void setDecorationType(int) -> e
    boolean isEmphasizeRightAngle() -> t
    void setEmphasizeRightAngle(boolean) -> g
    void setZero() -> f_
    boolean isDrawable() -> u
    boolean hasDrawable3D() -> v
    boolean canHaveClickScript() -> w
geogebra.common.kernel.geos.GeoAxis -> geogebra.common.i.j.j:
    geogebra.common.kernel.geos.GeoPoint origin -> c
    int type -> l
    java.lang.String axisLabel -> c
    int ticksize -> m
    int getType() -> c
    boolean isAvailableAtConstructionStep(int) -> a
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setAxisLabel(java.lang.String) -> a
    boolean isLabelSet() -> d_
    boolean isAxis() -> f_
geogebra.common.kernel.geos.GeoBoolean -> geogebra.common.i.j.k:
    boolean value -> g
    boolean isDefined -> h
    boolean checkboxFixed -> i
    java.util.ArrayList condListenersShowObject -> b
    int lastLocY -> l
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    int getRelatedModeID() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setValue(boolean) -> e
    boolean getBoolean() -> a
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void registerConditionListener(geogebra.common.kernel.geos.GeoElement) -> c
    void unregisterConditionListener(geogebra.common.kernel.geos.GeoElement) -> d
    void update() -> i
    void doRemove() -> b
    void resolveVariables(boolean) -> a
    boolean showInEuclidianView() -> e_
    void initLocation() -> d
    boolean showInAlgebraView() -> x
    boolean isFixable() -> y
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> e
    boolean isDefined() -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isBooleanValue() -> e
    boolean isGeoBoolean() -> A
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    void setRealWorldLoc(double,double) -> a
    boolean isCheckboxFixed() -> B
    void setCheckboxFixed(boolean) -> f
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> b_
    boolean isNumberValue() -> c
    double getDouble() -> a
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    boolean isLabelValueShowable() -> C
    boolean canHaveClickScript() -> w
    boolean isCasEvaluableObject() -> D
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoButton -> geogebra.common.i.j.l:
    double fontSizeD -> a
    int fontStyle -> l
    boolean serifFont -> g
    int getRelatedModeID() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isGeoButton() -> j_
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    boolean isFixable() -> y
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> e
    boolean isDefined() -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    void setRealWorldLoc(double,double) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> b_
    boolean isLabelValueShowable() -> C
    double getFontSizeMultiplier() -> a
    void setFontSizeMultiplier(double) -> a
    int getFontStyle() -> e
    void setFontStyle(int) -> a
    int getPrintDecimals() -> f
    int getPrintFigures() -> g
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean isSerifFont() -> E
    void setSerifFont(boolean) -> e
    boolean useSignificantFigures() -> t_
    boolean justFontSize() -> k_
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean hasBackgroundColor() -> H
    boolean isFillable() -> I
    int getFillType() -> j
    boolean isFurniture() -> l_
    boolean isPinnable() -> J
geogebra.common.kernel.geos.GeoCasCell -> geogebra.common.i.j.m:
    geogebra.common.kernel.arithmetic.ValidExpression inputVE -> a
    geogebra.common.kernel.arithmetic.ValidExpression evalVE -> b
    geogebra.common.kernel.arithmetic.ValidExpression outputVE -> c
    java.lang.String input -> c
    java.lang.String prefix -> d
    java.lang.String postfix -> e
    java.lang.String error -> f
    java.lang.String latex -> g
    java.lang.String localizedInput -> h
    java.lang.String currentLanguage -> i
    boolean suppressOutput -> g
    java.util.TreeSet invars -> a
    java.util.TreeSet functionvars -> b
    java.util.TreeSet inGeos -> c
    boolean isCircularDefinition -> h
    geogebra.common.kernel.geos.GeoElement twinGeo -> a
    geogebra.common.kernel.geos.GeoElement lastOutputEvaluationGeo -> b
    boolean firstComputeOutput -> i
    boolean ignoreTwinGeoUpdate -> j
    java.util.HashSet commands -> a
    java.lang.String assignmentVar -> j
    boolean includesRowReferences -> k
    boolean includesNumericCommand -> l
    boolean useGeoGebraFallback -> m
    java.lang.String evalCmd -> k
    java.lang.String evalComment -> l
    int row -> l
    boolean useAsText -> n
    geogebra.common.kernel.geos.GeoText commentText -> a
    boolean nativeOutput -> o
    boolean ignoreSetAssignment -> p
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    boolean pointList -> q
    java.lang.String tooltip -> m
    int SCREEN_WIDTH -> m
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$AssignmentType -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getInput(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getOutput(geogebra.common.kernel.StringTemplate) -> g
    java.lang.String getOutputRHS(geogebra.common.kernel.StringTemplate) -> h
    java.lang.String getPrefix() -> c
    java.lang.String getEvalText() -> d
    geogebra.common.kernel.arithmetic.ValidExpression getEvalVE() -> a
    geogebra.common.kernel.arithmetic.ValidExpression getInputVE() -> b
    java.lang.String getPostfix() -> e
    java.lang.String getLaTeXOutput() -> f
    boolean isUseAsText() -> E
    void setUseAsText(boolean) -> b
    void setFontStyle(int) -> a
    geogebra.common.awt.GColor getFontColor() -> a
    void setFontColor(geogebra.common.awt.GColor) -> a
    int getFontStyle() -> c
    void setFontSizeMultiplier(double) -> a
    double getFontSizeMultiplier() -> a
    void setGeoText(geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    boolean isEmpty() -> F
    boolean isInputEmpty() -> G
    boolean isOutputEmpty() -> K
    boolean showOutput() -> n_
    boolean suppressOutput() -> bA
    boolean isSendingUpdatesToCAS() -> M
    boolean hasTwinGeo() -> N
    void setInputFromTwinGeo(boolean) -> e
    boolean setInput(java.lang.String) -> a
    void updateLocalizedInput(geogebra.common.kernel.StringTemplate) -> a
    void setRowNumber(int) -> b
    int getRowNumber() -> d
    void updateInputStringWithRowReferences() -> d
    void setProcessingInformation(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean isStructurallyEqualToLocalizedInput(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> a
    void updateInputVariables(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    java.lang.String getFunctionVariable(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    void internalizeInput() -> I
    java.lang.String localizeInput(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    void setAssignmentVar(java.lang.String) -> l
    void unbindVariableInCAS() -> f
    void changeAssignmentVar(java.lang.String,java.lang.String) -> a
    java.util.TreeSet getInVars() -> f
    java.util.TreeSet getFunctionVars() -> g
    void clearInVars() -> J
    java.lang.String getInVar(int) -> a
    java.util.TreeSet getGeoElementVariables() -> b
    java.util.TreeSet updateInputGeoElements(java.util.TreeSet) -> a
    geogebra.common.kernel.arithmetic.ValidExpression resolveInputReferences(geogebra.common.kernel.arithmetic.ValidExpression,java.util.TreeSet) -> a
    void resolveFunctionVariableReferences(geogebra.common.kernel.arithmetic.ValidExpression) -> b
    void resolveGeoElementReferences(geogebra.common.kernel.arithmetic.ValidExpression) -> c
    boolean includesOnlyDefinedVariables() -> O
    boolean includesOnlyDefinedVariables(boolean) -> a
    boolean isInputVariable(java.lang.String) -> c
    boolean isFunctionVariable(java.lang.String) -> d
    java.lang.String getFunctionVariable() -> g
    boolean includesNumericCommand() -> P
    java.lang.String getAssignmentVariable() -> h
    boolean isAssignmentVariableDefined() -> Q
    java.lang.String getEvalCommand() -> i
    void setEvalCommand(java.lang.String) -> a
    void setKeepInputUsed(boolean) -> f
    void setEvalComment(java.lang.String) -> b
    java.lang.String getEvalComment() -> j
    void setOutput(java.lang.String,boolean) -> a
    void updateTwinGeo() -> g
    void createTwinGeo() -> K
    boolean setLabelOfTwinGeo() -> R
    void simpleUpdateTwinGeo() -> L
    void updateCascade() -> h
    geogebra.common.kernel.geos.GeoElement silentEvalInGeoGebra(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    boolean computeOutput() -> S
    boolean computeOutput(boolean) -> b
    geogebra.common.kernel.arithmetic.ValidExpression wrapPointList(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    void finalizeComputation(boolean,java.lang.String,geogebra.common.kernel.CASException,boolean) -> a
    void setError(java.lang.String) -> c
    boolean isError() -> T
    boolean isCircularDefinition() -> U
    void getElementOpenTagXML(java.lang.StringBuilder) -> c
    void getElementCloseTagXML(java.lang.StringBuilder) -> d
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isDefined() -> r
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isGeoCasCell() -> V
    void doRemove() -> b
    void setTwinGeo(geogebra.common.kernel.geos.GeoElement) -> c
    boolean dependsOnDummy(geogebra.common.kernel.geos.GeoElement) -> f
    geogebra.common.kernel.geos.GeoElement getTwinGeo() -> c
    void addToUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> b
    geogebra.common.kernel.arithmetic.ValidExpression getOutputValidExpression() -> c
    boolean isLaTeXDrawableGeo() -> W
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyList getFunctionVariableList() -> a
    void setInputVE(geogebra.common.kernel.arithmetic.ValidExpression) -> d
    geogebra.common.awt.GColor getAlgebraColor() -> b
    void setNative(boolean) -> g
    boolean isNative() -> X
    void toggleTwinGeoEuclidianVisible() -> j
    boolean plot() -> Y
    void clearStrings() -> M
    void setPointList(boolean) -> h
    boolean hasCoords() -> m
    java.lang.String getTooltipText(boolean,boolean) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$AssignmentType() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> b
geogebra.common.kernel.geos.GeoConic -> geogebra.common.i.j.n:
    geogebra.common.kernel.Matrix.CoordSys coordSys -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    void setCircle(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void mirror(double) -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    boolean hasDrawable3D() -> v
    boolean isCasEvaluableObject() -> D
    char getLabelDelimiter() -> a
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    void setCoeffs(geogebra.common.kernel.arithmetic.ExpressionValue[][]) -> a
    double evalCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][],int,int) -> a
    void fromLine(geogebra.common.kernel.geos.GeoLine) -> b
geogebra.common.kernel.geos.GeoConicPart -> geogebra.common.i.j.o:
    double paramStart -> h
    double paramEnd -> i
    double paramExtent -> j
    boolean posOrientation -> j
    int conic_part_type -> m
    double value -> k
    double area -> l
    double arcLength -> m
    boolean value_defined -> k
    geogebra.common.kernel.integration.EllipticArcLength ellipticArcLength -> a
    boolean allowOutlyingIntersections -> l
    boolean keepTypeOnGeometricTransform -> m
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.PathParameter tempPP -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> a
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    int getConicPartType() -> c
    double getParameterStart() -> c
    double getParameterEnd() -> d
    double getParameterExtent() -> e
    boolean positiveOrientation() -> K
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setParameters(double,double,boolean) -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    double getValue() -> f
    double getArcLength() -> g
    double getArea() -> h
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean allowOutlyingIntersections() -> L
    void setAllowOutlyingIntersections(boolean) -> e
    void setKeepTypeOnGeometricTransform(boolean) -> f
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint,double) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    geogebra.common.kernel.PathParameter getTempPathParameter() -> a
    boolean isClosedPath() -> w_
    void pointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    void setEllipseParameter(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> c
    void clipEllipseParameter(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> d
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    double getDouble() -> a
    boolean isNumberValue() -> c
    boolean isGeoConicPart() -> r_
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isInRegion(double,double) -> a
    double computeArg(double,double) -> b
    void moveBackToRegion(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.RegionParameters) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean hasDrawable3D() -> v
    boolean isAllEndpointsLabelsSet() -> P
    geogebra.common.kernel.geos.GeoPoint getPointParam(double) -> a
geogebra.common.kernel.geos.GeoCurveCartesian -> geogebra.common.i.j.p:
    geogebra.common.kernel.arithmetic.Function funX -> a
    geogebra.common.kernel.arithmetic.Function funY -> b
    boolean isClosedPath -> h
    boolean trace -> i
    double CURVATURE_COLOR -> a
    geogebra.common.kernel.ParametricCurveDistanceFunction distFun -> a
    boolean hideRangeInFormula -> j
    geogebra.common.kernel.geos.GeoCurveCartesian derivGeoFun -> a
    java.lang.String translatedTypeString() -> b_
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setFunctionX(geogebra.common.kernel.arithmetic.Function) -> a
    void setFunctionY(geogebra.common.kernel.arithmetic.Function) -> b
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setInterval(double,double) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    geogebra.common.kernel.geos.GeoCurveCartesian getGeoDerivative(int) -> a
    void setDerivative(geogebra.common.kernel.geos.GeoCurveCartesian,int) -> a
    void setParametricDerivative(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    java.lang.String getFunX(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getFunY(geogebra.common.kernel.StringTemplate) -> g
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    boolean isMatrixTransformable() -> s_
    void translate(double,double) -> b
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void matrixTransform(double,double,double,double) -> a
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    double getClosestParameter(geogebra.common.kernel.geos.GeoPoint,double) -> a
    double adjustRange(double) -> b
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isClosedPath() -> w_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isTraceable() -> m_
    boolean getTrace() -> F
    void setTrace(boolean) -> a_
    void evaluateCurve(double,double[]) -> a
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    double evaluateCurvature(double) -> a
    boolean isCasEvaluableObject() -> D
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isFunctionInX() -> P
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    boolean isVector3DValue() -> b_
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void setFromPolyLine(geogebra.common.kernel.kernelND.GeoPointND[],boolean) -> a
    void setHideRangeInFormula(boolean) -> e
    boolean isLaTeXDrawableGeo() -> W
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    geogebra.common.kernel.arithmetic.Function getFunX() -> a
    geogebra.common.kernel.arithmetic.Function getFunY() -> b
    void clearCasEvalMap(java.lang.String) -> a
geogebra.common.kernel.geos.GeoCurveCartesian3DInterface -> geogebra.common.i.j.q:
geogebra.common.kernel.geos.GeoDummyVariable -> geogebra.common.i.j.r:
    java.lang.String varName -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getVarName() -> d
    geogebra.common.kernel.geos.GeoElement getElementWithSameName() -> c
    boolean hasCoords() -> m
geogebra.common.kernel.geos.GeoElement -> geogebra.common.i.j.s:
    java.util.ArrayList spreadsheetColumnHeadings -> a
    char[] pointLabels -> a
    char[] functionLabels -> b
    char[] lineLabels -> c
    char[] vectorLabels -> d
    char[] conicLabels -> e
    char[] lowerCaseLabels -> f
    char[] integerLabels -> g
    char[] greekLowerCase -> h
    char[] arabic -> i
    char[] yiddish -> j
    char[] greekUpperCase -> k
    int tooltipMode -> l
    java.lang.String label -> a
    java.lang.String realLabel -> c
    java.lang.String oldLabel -> d
    java.lang.String caption -> e
    boolean labelWanted -> a
    boolean labelSet -> b
    boolean localVarLabelSet -> g
    boolean euclidianVisible -> h
    boolean forceEuclidianVisible -> i
    boolean algebraVisible -> j
    boolean labelVisible -> k
    boolean isConsProtBreakpoint -> l
    boolean isAlgoMacroOutput -> m
    boolean fixed -> c
    int labelMode -> a
    int toStringMode -> b
    geogebra.common.awt.GColor objColor -> a
    geogebra.common.awt.GColor bgColor -> b
    geogebra.common.awt.GColor selColor -> c
    geogebra.common.awt.GColor labelColor -> d
    geogebra.common.awt.GColor fillColor -> e
    int layer -> m
    geogebra.common.kernel.arithmetic.NumberValue animationIncrement -> a
    geogebra.common.kernel.arithmetic.NumberValue animationSpeedObj -> b
    geogebra.common.kernel.geos.GeoCasCell correspondingCasCell -> a
    boolean animating -> n
    int animationType -> n
    int animationDirection -> o
    float alphaValue -> a
    int hatchingAngle -> c
    int hatchingDistance -> d
    boolean inverseFill -> o
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter graphicsadapter -> a
    int fillType -> e
    int colorSpace -> p
    java.util.List viewFlags -> a
    int defaultGeoType -> q
    int labelOffsetX -> f
    int labelOffsetY -> g
    boolean auxiliaryObject -> p
    boolean selectionAllowed -> q
    geogebra.common.awt.GPoint spreadsheetCoords -> a
    geogebra.common.awt.GPoint oldSpreadsheetCoords -> b
    int cellRangeUsers -> r
    int casAlgoUsers -> s
    geogebra.common.kernel.geos.GeoBoolean condShowObject -> a
    geogebra.common.kernel.geos.GeoList colFunction -> a
    boolean useVisualDefaults -> r
    boolean isColorSet -> d
    boolean highlighted -> e
    boolean selected -> s
    java.lang.String strAlgebraDescription -> f
    java.lang.String strAlgebraDescTextOrHTML -> g
    java.lang.String strAlgebraDescriptionHTML -> h
    java.lang.String strLabelTextOrHTML -> i
    java.lang.String strLaTeX -> b
    boolean strAlgebraDescriptionNeedsUpdate -> t
    boolean strAlgebraDescTextOrHTMLneedsUpdate -> u
    boolean strAlgebraDescriptionHTMLneedsUpdate -> v
    boolean strLabelTextOrHTMLUpdate -> w
    boolean strLaTeXneedsUpdate -> f
    int lineThickness -> h
    int lineType -> i
    int lineTypeHidden -> j
    int decorationType -> k
    geogebra.common.kernel.algos.AlgoElement algoParent -> a
    geogebra.common.kernel.algos.AlgoElement algoDraw -> b
    java.util.ArrayList algorithmList -> b
    geogebra.common.kernel.algos.AlgorithmSet algoUpdateSet -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim viewForValueString -> a
    geogebra.common.util.LaTeXCache latexCache -> a
    geogebra.common.kernel.geos.GeoElement[] myGeoElements -> a
    java.lang.String subBegin -> j
    java.lang.String subEnd -> k
    java.lang.String strHasIndexLabel -> l
    boolean hasIndexLabel -> x
    geogebra.common.kernel.geos.GeoElement$ScriptType updateScriptType -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType clickScriptType -> b
    java.util.ArrayList moveObjectsUpdateList -> c
    java.util.TreeSet tempSet -> a
    java.util.Comparator algoComparator -> a
    java.util.ArrayList tempMoveObjectList -> d
    boolean spreadsheetTrace -> y
    geogebra.common.util.SpreadsheetTraceSettings traceSettings -> a
    boolean inTree -> z
    java.lang.String clickScript -> m
    java.lang.String updateScript -> n
    boolean showTrimmedIntersectionLines -> A
    boolean isRandomGeo -> B
    geogebra.common.kernel.Matrix.Coords mainDirection -> a
    boolean isPickable -> C
    boolean needsReplacingInExpressionNode -> D
    boolean cloneInUse -> E
    geogebra.common.kernel.arithmetic.MyStringBuffer xBracket -> a
    geogebra.common.kernel.arithmetic.MyStringBuffer yBracket -> b
    geogebra.common.kernel.arithmetic.MyStringBuffer zBracket -> c
    geogebra.common.kernel.arithmetic.MyStringBuffer closeBracket -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType -> b
    boolean isVector3DValue() -> b_
    geogebra.common.kernel.geos.GeoElement$ScriptType getUpdateScriptType() -> a
    void setUpdateScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType getClickScriptType() -> b
    void setClickScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> b
    int getColorSpace() -> k
    void setColorSpace(int) -> f
    int getDefaultGeoType() -> l
    void setDefaultGeoType(int) -> g
    java.lang.String getLabelSimple() -> k
    void setLabelSimple(java.lang.String) -> d
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    void copyLabel(geogebra.common.kernel.geos.GeoElement) -> f
    void setLabelMode(int) -> h
    int getLabelMode() -> m
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement deepCopyGeo() -> d
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPoint[] copyPoints(geogebra.common.kernel.Construction,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables(boolean) -> a
    boolean isInfinite() -> Z
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void setViewForValueString(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim getViewForValueString() -> a
    boolean hasValueStringChangeableRegardingView() -> aa
    java.lang.String getRedefineString(boolean,boolean) -> b
    char getLabelDelimiter() -> a
    java.lang.String getDefinitionForInputBar() -> l
    java.lang.String getValueForInputBar() -> m
    void setZero() -> f_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void setConstructionDefaults() -> k
    void setObjColor(geogebra.common.awt.GColor) -> b
    boolean isColorSet() -> ab
    geogebra.common.awt.GColor getRGBFromList(float) -> a
    geogebra.common.awt.GColor getRGBFromList(int) -> a
    geogebra.common.awt.GColor getSelColor() -> c
    geogebra.common.awt.GColor getFillColor() -> d
    geogebra.common.awt.GColor getAlgebraColor() -> b
    geogebra.common.awt.GColor getLabelColor() -> e
    void setLabelColor(geogebra.common.awt.GColor) -> c
    geogebra.common.awt.GColor getBackgroundColor() -> f
    void setBackgroundColor(geogebra.common.awt.GColor) -> d
    geogebra.common.awt.GColor getObjectColor() -> g
    void setLayer(int) -> i
    int getLayer() -> n
    long getDrawingPriority() -> b
    void setAlphaValue(float) -> a
    float getAlphaValue() -> a
    boolean isLimitedPath() -> o_
    boolean isPath() -> ac
    boolean isRegion() -> ad
    boolean isGeoList() -> ae
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setVisualStyleForTransformations(geogebra.common.kernel.geos.GeoElement) -> g
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setAdvancedVisualStyle(geogebra.common.kernel.geos.GeoElement) -> h
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter getGraphicsAdapter() -> a
    void setLabelOffset(int,int) -> b
    boolean isVisible() -> af
    boolean isEuclidianVisible() -> ag
    void setEuclidianVisible(boolean) -> d
    void forceEuclidianVisible(boolean) -> i
    boolean isSetEuclidianVisible() -> ah
    boolean isConsProtocolBreakpoint() -> j
    void setConsProtocolBreakpoint(boolean) -> j
    boolean isDrawable() -> u
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    boolean isTraceable() -> m_
    boolean isFixed() -> ai
    void setFixed(boolean) -> k
    boolean isFixable() -> y
    void removeOrSetUndefinedIfHasFixedDescendent() -> n
    boolean isAuxiliaryObject() -> aj
    boolean isAuxiliaryObjectByDefault() -> ak
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    void setAuxiliaryObject(boolean) -> l
    void setLabelVisible(boolean) -> m
    boolean isLabelVisible() -> al
    boolean isLabelShowable() -> am
    boolean isLabelValueShowable() -> C
    boolean isAlgebraVisible() -> an
    boolean showToolTipText() -> ao
    java.lang.String getTooltipText(boolean,boolean) -> a
    int getTooltipMode() -> o
    void setTooltipMode(int) -> j
    void setAlgebraVisible(boolean) -> n
    boolean isSetAlgebraVisible() -> ap
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    boolean isAlgebraViewEditable() -> aq
    boolean isEuclidianShowable() -> ar
    boolean isAlgebraShowable() -> as
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    geogebra.common.kernel.algos.AlgoElement getParentAlgorithm() -> a
    void setDrawAlgorithm(geogebra.common.kernel.algos.DrawInformationAlgo) -> a
    geogebra.common.kernel.algos.AlgoElement getDrawAlgorithm() -> b
    java.util.ArrayList getAlgorithmList() -> a
    boolean isIndependent() -> k
    boolean isChangeable() -> at
    boolean isPointOnPath() -> au
    boolean isRedefineable() -> av
    boolean isMoveable() -> aw
    boolean isMoveable(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean hasOnlyFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> c
    boolean containsOnlyMoveableGeos(java.util.ArrayList) -> a
    boolean isTranslateable() -> q_
    boolean isRotateMoveable() -> ax
    boolean hasProperties() -> ay
    void setAnimationStep(double) -> c
    void setAnimationStep(geogebra.common.kernel.arithmetic.NumberValue) -> b
    double getAnimationStep() -> i
    geogebra.common.kernel.geos.GeoElement getAnimationStepObject() -> e
    geogebra.common.kernel.geos.GeoElement getAnimationSpeedObject() -> f
    double getAnimationSpeed() -> j
    void setAnimationSpeedObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setAnimationSpeed(double) -> d
    void initAnimationSpeedObject() -> d
    int getAnimationType() -> p
    void setAnimationType(int) -> k
    int getAnimationDirection() -> q
    void changeAnimationDirection() -> o
    void setAnimating(boolean) -> o
    boolean isAnimating() -> p
    boolean isAnimatable() -> az
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toCasAssignment(geogebra.common.kernel.StringTemplate) -> i
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> j
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    void addCellRangeUser() -> p
    void removeCellRangeUser() -> q
    boolean isRenameable() -> aA
    void addCasAlgoUser() -> r
    void removeCasAlgoUser() -> s
    void unbindVariableInCAS() -> f
    boolean isSendingUpdatesToCAS() -> M
    boolean rename(java.lang.String) -> e
    boolean isLabelSet() -> d_
    void setLabel(java.lang.String) -> e
    void setLoadedLabel(java.lang.String) -> f
    boolean setCaption(java.lang.String) -> f
    java.lang.String getCaption(geogebra.common.kernel.StringTemplate) -> k
    java.lang.String getRawCaption() -> n
    java.lang.String getCaptionDescription(geogebra.common.kernel.StringTemplate) -> l
    void setLocalVariableLabel(java.lang.String) -> g
    void undoLocalVariableLabel() -> t
    boolean isLocalVariable() -> aB
    void doSetLabel(java.lang.String) -> a
    void updateSpreadsheetCoordinates() -> g
    java.lang.String getSpreadsheetLabelWithDollars(boolean,boolean) -> c
    int compareLabels(java.lang.String,java.lang.String) -> a
    void doRenameLabel(java.lang.String) -> b
    java.lang.String getOldLabel() -> o
    void setLabels(java.lang.String,geogebra.common.kernel.geos.GeoElement[]) -> a
    void setLabels(java.lang.String[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void setLabels(java.lang.String[],geogebra.common.kernel.geos.GeoElement[],boolean) -> a
    java.lang.String getFreeLabel(java.lang.String) -> a
    java.lang.String getDefaultLabel(boolean) -> a
    java.lang.String getDefaultLabel() -> p
    java.lang.String getDefaultLabel(char[],boolean) -> a
    java.lang.String defaultNumberedLabel(java.lang.String) -> g
    java.lang.String getIndexLabel(java.lang.String) -> b
    boolean isGeoTextField() -> aC
    void remove() -> c
    void doRemove() -> b
    geogebra.common.util.LaTeXCache getLaTeXCache() -> a
    void notifyAdd() -> l
    void notifyRemove() -> m
    void notifyUpdate() -> u
    void notifyUpdateAuxiliaryObject() -> v
    void addAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> d
    void addToAlgorithmListOnly(geogebra.common.kernel.algos.AlgoElement) -> e
    void addToUpdateSetOnly(geogebra.common.kernel.algos.AlgoElement) -> f
    void removeAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> g
    geogebra.common.kernel.algos.AlgorithmSet getAlgoUpdateSet() -> a
    void addToUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> b
    void update() -> i
    void updateGeo() -> w
    boolean sendValueToCAS() -> aD
    void algebraStringsNeedUpdate() -> j
    void updateCascade() -> h
    void updateDependentObjects() -> I
    void updateAlgoUpdateSetWith(geogebra.common.kernel.geos.GeoElement) -> i
    boolean hasAlgoUpdateSet() -> aE
    void updateCascade(java.util.ArrayList,java.util.TreeSet,boolean) -> a
    void updateCascadeLocation(java.util.ArrayList,geogebra.common.kernel.Construction) -> a
    void updateRepaint() -> x
    void updateVisualStyle() -> y
    void updateVisualStyleRepaint() -> z
    java.lang.String toString() -> toString
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    java.util.TreeSet getAllPredecessors() -> c
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void addPredecessorsToSet(java.util.TreeSet,boolean) -> a
    boolean isParentOf(geogebra.common.kernel.geos.GeoElement) -> b
    boolean hasChildren() -> aF
    boolean isChildOf(geogebra.common.kernel.geos.GeoElement) -> c
    boolean isChildOrEqual(geogebra.common.kernel.geos.GeoElement) -> d
    java.util.TreeSet getAllChildren() -> d
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> e
    boolean isAlgoElement() -> h
    boolean isGeoElement() -> i
    int getConstructionIndex() -> b
    int getMinConstructionIndex() -> h
    int getMaxConstructionIndex() -> i
    java.lang.String getDefinitionDescription(geogebra.common.kernel.StringTemplate) -> m
    java.lang.String getDefinitionDescriptionHTML(boolean) -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> n
    java.lang.String getCommandDescriptionHTML(boolean) -> c
    int getRelatedModeID() -> a
    java.lang.String convertIndicesToHTML(java.lang.String) -> c
    java.lang.String addLabelTextOrHTML(java.lang.String) -> d
    java.lang.String getCaptionDescriptionHTML(boolean,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getXMLtypeString() -> q
    java.lang.String getTypeString() -> a
    java.lang.String getTypeStringForAlgebraView() -> r
    java.lang.String translatedTypeString() -> b_
    java.lang.String translatedTypeStringForAlgebraView() -> s
    java.lang.String getLongDescription() -> t
    java.lang.String getLongDescriptionHTML(boolean,boolean) -> d
    java.lang.String getToolTipDescriptionHTML(java.util.ArrayList,boolean,boolean,boolean) -> a
    java.lang.String getLabelDescription() -> u
    java.lang.String toDefinedValueString(geogebra.common.kernel.StringTemplate) -> o
    java.lang.String getAlgebraDescriptionTextOrHTMLDefault() -> v
    java.lang.String getAlgebraDescriptionHTMLDefault() -> w
    java.lang.String getLabelTextOrHTML() -> x
    java.lang.String getLabelTextOrHTML(boolean) -> d
    java.lang.String getAlgebraDescription(geogebra.common.kernel.StringTemplate) -> p
    java.lang.String getAlgebraDescriptionDefault() -> y
    java.lang.String getAlgebraDescriptionRegrOut(geogebra.common.kernel.StringTemplate) -> q
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String getLaTeXdescription() -> z
    java.lang.String getLaTeXAlgebraDescription(boolean,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String getLaTeXAlgebraDescription(geogebra.common.kernel.geos.GeoElement,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String indicesToHTML(java.lang.String,boolean) -> a
    java.lang.String getNameDescription() -> b
    java.lang.String getNameDescriptionTextOrHTML() -> A
    boolean hasIndexLabel() -> aG
    java.lang.String getNameDescriptionHTML(boolean,boolean) -> e
    boolean isAxis() -> f_
    java.lang.String getXML() -> B
    void getXML(java.lang.StringBuilder) -> a
    void getElementOpenTagXML(java.lang.StringBuilder) -> c
    void getElementCloseTagXML(java.lang.StringBuilder) -> d
    void getScriptTags(java.lang.StringBuilder) -> e
    boolean clickGGBScript() -> aH
    boolean updateGGBScript() -> aI
    boolean clickJavaScript() -> aJ
    boolean updateJavaScript() -> aK
    void getCaptionXML(java.lang.StringBuilder) -> f
    void getAuxiliaryXML(java.lang.StringBuilder) -> g
    void getXMLvisualTags(java.lang.StringBuilder) -> h
    void getXMLvisualTags(java.lang.StringBuilder,boolean) -> a
    void getXMLanimationTags(java.lang.StringBuilder) -> i
    void getXMLfixedTag(java.lang.StringBuilder) -> j
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String regrFormat(double) -> a
    void getLineStyleXML(java.lang.StringBuilder) -> k
    void getBreakpointXML(java.lang.StringBuilder) -> l
    java.lang.String getShowObjectConditionXML() -> d
    int getLineThickness() -> r
    int getMinimumLineThickness() -> s
    int getLineType() -> t
    int getLineTypeHidden() -> u
    void setLineThickness(int) -> l
    void setLineType(int) -> m
    void setLineTypeHidden(int) -> n
    void setDecorationType(int) -> e
    boolean isGeoElement3D() -> aL
    boolean hasDrawable3D() -> v
    boolean hasLevelOfDetail() -> aM
    boolean isGeoAngle() -> q
    boolean isGeoBoolean() -> A
    boolean isGeoPolyLine() -> aN
    boolean isGeoImplicitPoly() -> aO
    boolean isGeoConic() -> aP
    boolean isGeoConicPart() -> r_
    boolean isGeoFunction() -> aQ
    boolean isGeoFunctionNVar() -> aR
    boolean isGeoFunctionBoolean() -> aS
    boolean isGeoFunctionConditional() -> aT
    boolean isGeoFunctionable() -> aU
    boolean isGeoImage() -> aV
    boolean isGeoLine() -> aW
    boolean isGeoPlane() -> aX
    boolean isGeoLocus() -> aY
    boolean isGeoNumeric() -> aZ
    boolean isGeoPoint() -> ba
    boolean isGeoCasCell() -> V
    boolean isGeoPolygon() -> bb
    boolean isGeoRay() -> bc
    boolean isGeoSegment() -> bd
    boolean isGeoText() -> be
    boolean isGeoVector() -> bf
    boolean isGeoCurveCartesian() -> bg
    boolean isCasEvaluableObject() -> D
    boolean isExpressionNode() -> g_
    boolean isVariable() -> z
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void setSelected(boolean) -> p
    void setHighlighted(boolean) -> q
    boolean doHighlighting() -> bh
    boolean isSelected() -> bi
    boolean isNumberValue() -> c
    boolean isAngle() -> v_
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isListValue() -> h_
    boolean isGeoButton() -> j_
    void setUseVisualDefaults(boolean) -> r
    boolean isAbsoluteScreenLocateable() -> o
    geogebra.common.kernel.geos.GeoBoolean getShowObjectCondition() -> a
    void setShowObjectCondition(geogebra.common.kernel.geos.GeoBoolean) -> a
    void removeCondition(geogebra.common.kernel.geos.GeoBoolean) -> b
    geogebra.common.kernel.geos.GeoList getColorFunction() -> a
    void setColorFunction(geogebra.common.kernel.geos.GeoList) -> a
    void removeColorFunction() -> A
    boolean moveObjects(java.util.ArrayList,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    java.util.TreeSet getTempSet() -> e
    boolean movePoint(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean moveObject(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList) -> a
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    boolean hasChangeableCoordParentNumbers() -> bj
    void recordChangeableCoordParentNumbers() -> B
    void addChangeableCoordParentNumberToUpdateList(geogebra.common.kernel.geos.GeoElement,java.util.ArrayList,java.util.ArrayList) -> a
    geogebra.common.awt.GPoint getSpreadsheetCoords() -> a
    geogebra.common.awt.GPoint getOldSpreadsheetCoords() -> b
    boolean isAlgoMacroOutput() -> bk
    void setAlgoMacroOutput(boolean) -> s
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDifferenceZeroInCAS(geogebra.common.kernel.geos.GeoElement) -> e
    java.lang.String getFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> b
    java.lang.String getRealFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> c
    boolean getSpreadsheetTrace() -> bl
    void setSpreadsheetTrace(boolean) -> t
    void resetTraceColumns() -> C
    boolean isSpreadsheetTraceable() -> bm
    boolean hasSpreadsheetTraceModeTraceable() -> bn
    geogebra.common.util.SpreadsheetTraceSettings getTraceSettings() -> a
    void setTraceSettings(geogebra.common.util.SpreadsheetTraceSettings) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElementForPropertiesDialog() -> g
    boolean isTextCommand() -> bo
    void setInTree(boolean) -> c
    java.lang.String[] splitScriptByCommands(java.lang.String) -> a
    boolean bracketAt(java.lang.String,int) -> a
    java.lang.String script2LocalizedScript(java.lang.String) -> e
    boolean isFunction(java.lang.String[],int,geogebra.common.main.App) -> a
    java.lang.String localizedScript2Script(java.lang.String) -> f
    void setClickScript(java.lang.String,boolean) -> b
    void setUpdateScript(java.lang.String,boolean) -> c
    boolean canHaveUpdateScript() -> bp
    java.lang.String getUpdateScript() -> C
    java.lang.String getClickScript() -> D
    void getXMLUpdateScript(java.lang.StringBuilder) -> m
    void getXMLClickScript(java.lang.StringBuilder) -> n
    void runGgbScript(java.lang.String,boolean) -> a
    void runJavaScript(java.lang.String,boolean) -> d
    void runClickScripts(java.lang.String) -> h
    void runUpdateScripts() -> D
    void setShowTrimmedIntersectionLines(boolean) -> u
    boolean getShowTrimmedIntersectionLines() -> bq
    boolean isPointInRegion() -> br
    void setRandomGeo(boolean) -> v
    boolean isRandomGeo() -> bs
    void updateRandomGeo() -> E
    boolean isMatrixTransformable() -> s_
    void setVisibility(int,boolean) -> c
    boolean isVisibleInView(int) -> b
    void addView(int) -> o
    void removeView(int) -> p
    void setViewFlags(java.util.List) -> a
    java.util.List getViewSet() -> a
    void setSelectionAllowed(boolean) -> w
    boolean isSelectionAllowed() -> bt
    void setRealLabel(java.lang.String) -> i
    java.lang.String getRealLabel(geogebra.common.kernel.StringTemplate) -> t
    boolean isHatchingEnabled() -> bu
    void setHatchingAngle(int) -> q
    double getHatchingAngle() -> k
    void setHatchingDistance(int) -> r
    int getHatchingDistance() -> v
    geogebra.common.awt.GBufferedImage getFillImage() -> a
    void setFillImage(java.lang.String) -> j
    int getFillType() -> j
    void setFillType(int) -> s
    void setImageFileName(java.lang.String) -> k
    java.lang.String getImageFileName() -> E
    void setInverseFill(boolean) -> x
    boolean isInverseFill() -> bv
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean canHaveClickScript() -> w
    boolean needsReplacingInExpressionNode() -> bw
    boolean isGeoInterval() -> bx
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    geogebra.common.kernel.geos.GeoCasCell getCorrespondingCasCell() -> a
    void setCorrespondingCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    boolean isLaTeXDrawableGeo() -> W
    boolean hasBackgroundColor() -> H
    boolean algoUpdateSetContains(geogebra.common.kernel.algos.AlgoElement) -> a
    void resetSpreadsheetColumnHeadings() -> F
    java.util.ArrayList getColumnHeadings() -> b
    void updateColumnHeadingsForTraceValues() -> G
    java.lang.String getTraceDialogAsValues() -> F
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes() -> a
    void updateColumnHeadingsForTraceGeoCopy() -> H
    geogebra.common.kernel.geos.GeoText getNameGeo() -> b
    geogebra.common.kernel.geos.GeoText getColumnHeadingText(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.arithmetic.MyStringBuffer getXBracket() -> b
    geogebra.common.kernel.arithmetic.MyStringBuffer getYBracket() -> c
    geogebra.common.kernel.arithmetic.MyStringBuffer getCloseBracket() -> d
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    boolean isFromMeta() -> by
    geogebra.common.kernel.geos.GeoElement unwrap() -> h
    geogebra.common.kernel.arithmetic.ExpressionNode wrap() -> A
    boolean isPinnable() -> J
    boolean isPinned() -> bz
    boolean hasCoords() -> m
    void setScripting(geogebra.common.kernel.geos.GeoElement) -> j
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue unwrap() -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType() -> d
geogebra.common.kernel.geos.GeoElement$1 -> geogebra.common.i.j.t:
    int compare(geogebra.common.kernel.algos.AlgoElement,geogebra.common.kernel.algos.AlgoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoElement$ScriptType -> geogebra.common.i.j.s$a:
    geogebra.common.kernel.geos.GeoElement$ScriptType GGBSCRIPT -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType JAVASCRIPT -> b
    geogebra.common.kernel.geos.GeoElement$ScriptType[] ENUM$VALUES -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType[] values() -> values
    geogebra.common.kernel.geos.GeoElement$ScriptType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.GeoElement$TraceModesEnum -> geogebra.common.i.j.s$b:
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum ONLY_COPY -> a
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum ONE_VALUE_OR_COPY -> b
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum ONE_VALUE_ONLY -> c
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum SEVERAL_VALUES_OR_COPY -> d
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum SEVERAL_VALUES_ONLY -> e
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum NOT_TRACEABLE -> f
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum[] ENUM$VALUES -> a
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum[] values() -> values
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.GeoElementGraphicsAdapter -> geogebra.common.i.j.u:
    java.lang.String imageFileName -> a
    geogebra.common.awt.GBufferedImage image -> a
    geogebra.common.awt.GBufferedImage getImageOnly() -> a
    void setImageOnly(geogebra.common.awt.GBufferedImage) -> a
    void setImageFileNameOnly(java.lang.String) -> a
    java.lang.String getImageFileName() -> a
    geogebra.common.awt.GBufferedImage getFillImage() -> b
    void setImageFileName(java.lang.String) -> b
    void setFillImage(java.lang.String) -> c
geogebra.common.kernel.geos.GeoElementSpreadsheet -> geogebra.common.i.j.v:
    com.google.gwt.regexp.shared.RegExp spreadsheetPattern -> a
    com.google.gwt.regexp.shared.RegExp spreadsheetPatternPart -> b
    java.lang.StringBuilder sb -> a
    java.lang.String getSpreadsheetColumnName(int) -> a
    java.lang.String getSpreadsheetColumnName(java.lang.String) -> a
    java.lang.String getSpreadsheetCellName(int,int) -> a
    geogebra.common.awt.GPoint spreadsheetIndices(java.lang.String) -> a
    boolean hasSpreadsheetLabel(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSpreadsheetLabel(java.lang.String) -> a
    int getSpreadsheetColumn(com.google.gwt.regexp.shared.MatchResult) -> a
    int getSpreadsheetRow(com.google.gwt.regexp.shared.MatchResult) -> b
    geogebra.common.awt.GPoint getSpreadsheetCoordsForLabel(java.lang.String) -> b
    void setSpreadsheetCell(geogebra.common.main.App,int,int,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement autoCreate(java.lang.String,geogebra.common.kernel.Construction) -> a
geogebra.common.kernel.geos.GeoFunction -> geogebra.common.i.j.w:
    geogebra.common.kernel.arithmetic.Function fun -> a
    boolean isDefined -> g
    boolean trace -> i
    boolean includesDivisionByVar -> j
    boolean interval -> h
    double intervalMin -> a
    double intervalMax -> b
    boolean evalSwapped -> k
    java.lang.Boolean isInequality -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly iPoly -> a
    geogebra.common.kernel.geos.GeoFunction[] substituteFunctions -> a
    int FUNCTION_DIRECT -> l
    int FUNCTION_COMPOSITE_IPOLY_FUNCS -> m
    int geoFunctionType -> n
    geogebra.common.kernel.geos.GeoFunction derivGeoFun -> a
    geogebra.common.kernel.arithmetic.Function includesDivisionByVarFun -> b
    java.lang.StringBuilder sbToString -> a
    boolean showOnAxis -> l
    java.lang.StringBuilder sb -> b
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setFunction(geogebra.common.kernel.arithmetic.Function) -> a
    void initFunction() -> d
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    boolean setInterval(double,double) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> b
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.arithmetic.Function getFunction(double) -> a
    void setDerivative(geogebra.common.kernel.geos.CasEvaluableFunction,int) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    double evaluate(double) -> a
    double evaluate(double[]) -> a
    double getIntervalMin() -> c
    double getIntervalMax() -> d
    boolean hasInterval() -> Q
    boolean evaluateBoolean(double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void translate(double,double) -> a
    boolean isPolynomialFunction(boolean,boolean,boolean) -> a
    boolean isPolynomialFunction(boolean,boolean) -> a
    boolean isPolynomialFunction(boolean) -> a
    boolean includesDivisionByVar() -> R
    boolean isDefined() -> r
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    void setDefined(boolean) -> e
    void setUndefined() -> e
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void getXML(java.lang.StringBuilder) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pointChangedBoolean(boolean,geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isPath() -> ac
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isClosedPath() -> w_
    boolean isCasEvaluableObject() -> D
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isTraceable() -> m_
    boolean getTrace() -> F
    void setTrace(boolean) -> a_
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunction() -> aQ
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> j
    boolean isGeoFunctionable() -> aU
    boolean isBooleanFunction() -> S
    void swapEval() -> g
    void evaluateCurve(double,double[]) -> a
    double evaluateCurvature(double) -> b
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isFunctionInX() -> P
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoFunction add(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar operationSymb(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.FunctionalNVar) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar fromExpr(geogebra.common.kernel.arithmetic.ExpressionNode,java.util.HashMap,java.util.TreeSet) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode toExpr(geogebra.common.kernel.arithmetic.FunctionalNVar,java.util.HashMap,geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar applyNumberSymb(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    geogebra.common.kernel.geos.GeoFunction subtract(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoFunction mult(geogebra.common.kernel.geos.GeoFunction,double,geogebra.common.kernel.geos.GeoFunction) -> a
    boolean isVector3DValue() -> b_
    boolean evaluateCondition(double) -> b
    java.lang.String getLimit(double,int) -> a
    void getVerticalAsymptotes(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getHorizontalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void getHorizontalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> b
    void getDiagonalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> c
    void getDiagonalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> d
    void getDiagonalAsymptoteStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getHorizontalAsymptoteStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> b
    char getLabelDelimiter() -> a
    void getVerticalAsymptotesStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> c
    boolean CASError(java.lang.String,boolean) -> a
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    java.lang.String[] getTempVarCASString(boolean) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoFunction threadSafeCopy() -> b
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isInRegion(double,double) -> a
    boolean isFunctionOfY() -> T
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    boolean isRegion() -> ad
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void resetIneqs() -> j
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    boolean showOnAxis() -> U
    void setShowOnAxis(boolean) -> f
    void update() -> i
    boolean isGeoFunctionBoolean() -> aS
    boolean isLaTeXDrawableGeo() -> W
    java.lang.String getFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> b
    java.lang.String getRealFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> c
    int getMinimumLineThickness() -> s
    boolean isInequality() -> X
    boolean isFreehandFunction() -> Y
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    void clearCasEvalMap(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
geogebra.common.kernel.geos.GeoFunction$1 -> geogebra.common.i.j.x:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$2 -> geogebra.common.i.j.y:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$3 -> geogebra.common.i.j.z:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$4 -> geogebra.common.i.j.A:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$5 -> geogebra.common.i.j.B:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunctionConditional -> geogebra.common.i.j.C:
    geogebra.common.kernel.geos.GeoFunction condFun -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> b
    geogebra.common.kernel.geos.GeoFunction elseFun -> c
    geogebra.common.kernel.arithmetic.Function uncondFun -> b
    geogebra.common.kernel.geos.GeoFunctionConditional derivGeoFun -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void adjustCons(geogebra.common.kernel.geos.GeoFunction) -> d
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isDefined() -> r
    geogebra.common.kernel.geos.GeoFunction getIfFunction() -> c
    geogebra.common.kernel.geos.GeoFunction getCondFunction() -> d
    geogebra.common.kernel.geos.GeoFunction getElseFunction() -> e
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setDerivative(geogebra.common.kernel.geos.CasEvaluableFunction,int) -> a
    double evaluate(double) -> a
    void translate(double,double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.arithmetic.Function getFunction(double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    boolean isPolynomialFunction(boolean,boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate,boolean) -> d
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isGeoFunction() -> aQ
    boolean isGeoFunctionConditional() -> aT
    boolean isBooleanFunction() -> S
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean evaluateCondition(double) -> b
    java.lang.String getLimit(double,int) -> a
    void getVerticalAsymptotes(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getDiagonalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> c
    void getDiagonalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> d
    void getHorizontalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void getHorizontalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> b
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String conditionalLaTeX(boolean,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String conditionalMathML(boolean,geogebra.common.kernel.StringTemplate) -> e
    boolean collectCases(java.util.ArrayList,java.util.ArrayList,geogebra.common.kernel.geos.GeoFunctionConditional$Bounds) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.geos.GeoFunction threadSafeCopy() -> b
    void setElseFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    void setConditionalFunction(geogebra.common.kernel.geos.GeoFunction) -> b
    void setIfFunction(geogebra.common.kernel.geos.GeoFunction) -> c
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
geogebra.common.kernel.geos.GeoFunctionConditional$Bounds -> geogebra.common.i.j.C$a:
    boolean lowerSharp -> a
    boolean upperSharp -> b
    java.lang.Double lower -> a
    java.lang.Double upper -> b
    geogebra.common.kernel.arithmetic.ExpressionNode condition -> a
    geogebra.common.kernel.geos.GeoFunctionConditional this$0 -> a
    geogebra.common.kernel.geos.GeoFunctionConditional$Bounds addRestriction(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String toLaTeXString(boolean,java.lang.String,geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.geos.GeoFunctionNVar -> geogebra.common.i.j.D:
    geogebra.common.kernel.arithmetic.FunctionNVar fun -> a
    boolean isInequality -> g
    boolean isDefined -> h
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.kernelND.LevelOfDetail levelOfDetail -> a
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> b
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    double evaluate(double[]) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    boolean isDefined() -> r
    void setDefined(boolean) -> b
    void setUndefined() -> e
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    java.lang.String toXMLString(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> j
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    char getLabelDelimiter() -> a
    void getXML(java.lang.StringBuilder) -> a
    boolean isCasEvaluableObject() -> D
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isBooleanFunction() -> F
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> b_
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    int getVarNumber() -> c
    boolean hasDrawable3D() -> v
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    void update() -> i
    boolean isRegion() -> ad
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void tryLocateInEV(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean isInequality() -> P
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void matrixTransform(double,double,double,double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void mirror(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isGeoFunctionNVar() -> aR
    boolean isLaTeXDrawableGeo() -> W
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.LevelOfDetail getLevelOfDetail() -> a
    boolean hasLevelOfDetail() -> aM
    boolean needsLevelOfDetail() -> Q
    int getMinimumLineThickness() -> s
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    geogebra.common.kernel.arithmetic.MyList getFunctionVariableList() -> a
    java.lang.String getFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> b
    void clearCasEvalMap(java.lang.String) -> a
geogebra.common.kernel.geos.GeoFunctionable -> geogebra.common.i.j.E:
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.geos.GeoImage -> geogebra.common.i.j.F:
    geogebra.common.kernel.geos.GeoPoint[] corners -> a
    int pixelWidth -> l
    int pixelHeight -> m
    boolean inBackground -> g
    boolean defined -> h
    boolean hasAbsoluteLocation -> i
    boolean interpolate -> j
    int screenX -> n
    int screenY -> o
    boolean hasAbsoluteScreenLocation -> k
    geogebra.common.kernel.geos.GeoPoint[] tempPoints -> b
    java.util.Vector instances -> a
    double[] tempCoords -> a
    java.util.ArrayList al -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    int getRelatedModeID() -> a
    void initTempPoints() -> j
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void updateInstances() -> d
    boolean showToolTipText() -> ao
    boolean isInBackground() -> F
    void setInBackground(boolean) -> e
    void setImageFileName(java.lang.String) -> k
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void setCorner(geogebra.common.kernel.geos.GeoPoint,int) -> a
    void updateHasAbsoluteLocation() -> I
    void doRemove() -> b
    geogebra.common.kernel.geos.GeoPoint getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint[] getStartPoints() -> a
    geogebra.common.kernel.geos.GeoPoint getCorner(int) -> a
    boolean hasAbsoluteLocation() -> P
    boolean isInterpolate() -> Q
    void setInterpolate(boolean) -> f
    void setWaitForStartPoint() -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isMoveable() -> aw
    boolean isRotateMoveable() -> ax
    boolean isFillable() -> I
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isGeoImage() -> aV
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getXMLabsScreenLoc() -> d
    java.lang.String getCornerPointXML(int) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
    void calculateCornerPoint(geogebra.common.kernel.geos.GeoPoint,int) -> b
    void getInternalCornerPointCoords(double[],int) -> a
    boolean initTransformPoints() -> R
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void matrixTransform(double,double,double,double) -> a
    boolean isMatrixTransformable() -> s_
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isAlwaysFixed() -> a
    boolean isVector3DValue() -> b_
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean isAuxiliaryObjectByDefault() -> ak
    boolean isAlgebraViewEditable() -> aq
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void clearFillImage() -> g
    boolean isPinnable() -> J
    void updateLocation() -> e_
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
geogebra.common.kernel.geos.GeoInterval -> geogebra.common.i.j.G:
    java.lang.StringBuilder sbToString2 -> b
    double rightBound -> c
    double leftBound -> d
    java.lang.String rightStr -> c
    java.lang.String leftStr -> d
    char rightInequality -> a
    char leftInequality -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(boolean,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void updateBoundaries() -> I
    void setLeftBound(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void setRightBound(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    double getMin() -> e
    double getMax() -> f
    double getMidPoint() -> g
    boolean isGeoInterval() -> bx
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    int getMinimumLineThickness() -> s
geogebra.common.kernel.geos.GeoLine -> geogebra.common.i.j.H:
    boolean showUndefinedInAlgebraView -> h
    java.lang.String parameter -> c
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoPoint endPoint -> b
    boolean KEEP_LEADING_SIGN -> i
    java.lang.String[] vars -> a
    geogebra.common.kernel.PathParameter tempPP -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.lang.StringBuilder sbToStringLHS -> c
    java.util.ArrayList pointsOnLine -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setCoords(double,double,double) -> a
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint,double) -> a
    boolean isOnFullLine(geogebra.common.kernel.geos.GeoPoint,double) -> b
    boolean isOnFullLine(geogebra.common.kernel.Matrix.Coords,double) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    double getPossibleParameter(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.PathParameter getTempPathParameter() -> a
    boolean isParallel(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isSameDirection(geogebra.common.kernel.geos.GeoLine) -> b
    boolean isPerpendicular(geogebra.common.kernel.geos.GeoLine) -> c
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    double distanceHom(geogebra.common.kernel.Matrix.Coords) -> b
    double distance(geogebra.common.kernel.geos.GeoLine) -> a
    void getDirection(geogebra.common.kernel.geos.GeoVec3D) -> b
    void getDirection(double[]) -> a
    void getInhomPointOnLine(double[]) -> b
    void getPointOnLine(geogebra.common.kernel.geos.GeoPoint) -> b
    void setStandardStartPoint() -> d
    void setStartPoint(geogebra.common.kernel.geos.GeoPoint) -> c
    void setEndPoint(geogebra.common.kernel.geos.GeoPoint) -> d
    geogebra.common.kernel.geos.GeoPoint getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint getEndPoint() -> b
    boolean isDefined() -> r
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefinedTangent(geogebra.common.kernel.geos.GeoConic) -> a
    boolean isDefinedAsymptote(geogebra.common.kernel.geos.GeoConic) -> b
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void setToParametric(java.lang.String) -> b
    void setToExplicit() -> g
    void setToImplicit() -> j
    void setMode(int) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.StringBuilder getSbToString() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.StringBuilder getSbBuildValueString() -> b
    void toStringLHS(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isClosedPath() -> w_
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void doPointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> e
    void doPointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    boolean isPath() -> ac
    boolean isGeoLine() -> aW
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void setZero() -> f_
    boolean isVector3DValue() -> b_
    void matrixTransform(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunctionable() -> aU
    boolean isMatrixTransformable() -> s_
    void toGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    double evaluate(double) -> a
    boolean hasDrawable3D() -> v
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    geogebra.common.kernel.Matrix.Coords getStartCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getDirectionInD(int) -> b
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> a
    geogebra.common.kernel.Matrix.Coords getCartesianEquationVector(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getStartInhomCoords() -> b
    geogebra.common.kernel.Matrix.Coords getEndInhomCoords() -> c
    boolean isCasEvaluableObject() -> D
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    java.util.ArrayList getPointsOnLine() -> c
    void addPointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void doRemove() -> b
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND getEndPoint() -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> c
geogebra.common.kernel.geos.GeoLine$PathMoverLine -> geogebra.common.i.j.H$a:
    geogebra.common.kernel.geos.GeoLine this$0 -> a
geogebra.common.kernel.geos.GeoList -> geogebra.common.i.j.I:
    geogebra.common.plugin.GeoClass ELEMENT_TYPE_MIXED -> a
    boolean trace -> i
    java.lang.String STR_OPEN -> c
    java.lang.String STR_CLOSE -> d
    java.util.ArrayList geoList -> b
    java.util.ArrayList cacheList -> c
    boolean isDefined -> j
    boolean isDrawable -> k
    boolean drawAsComboBox -> l
    geogebra.common.plugin.GeoClass elementType -> b
    boolean showAllProperties -> m
    java.util.ArrayList colorFunctionListener -> d
    java.lang.StringBuilder sbBuildValueString -> a
    java.lang.String typeStringForXML -> e
    int pointSize -> l
    int pointStyle -> m
    boolean serifFont -> n
    int fontStyle -> n
    double fontSizeD -> a
    int printDecimals -> o
    int printFigures -> p
    boolean useSignificantFigures -> o
    int selectedIndex -> q
    int closestPointIndex -> r
    geogebra.common.javax.swing.AbstractJComboBox comboBox -> a
    geogebra.common.javax.swing.AbstractJComboBox comboBox2 -> b
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum traceModes -> a
    boolean showOnAxis -> p
    boolean[] directionInfoArray -> a
    int[] directionInfoOrdering -> a
    boolean shouldUseAlgoLocusList -> g
    boolean locusCalledAlgoLocusList -> h
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$TraceModesEnum -> b
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.plugin.GeoClass getElementType() -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement deepCopyGeo() -> d
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setShowAllProperties(boolean) -> g
    void copyListElements(geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoElement getCopyForList(geogebra.common.kernel.geos.GeoElement) -> a
    void applyVisualStyle(geogebra.common.kernel.geos.GeoElement) -> m
    void removeColorFunction() -> A
    void setColorFunction(geogebra.common.kernel.geos.GeoList) -> a
    void setColorSpace(int) -> f
    void setShowObjectCondition(geogebra.common.kernel.geos.GeoBoolean) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setObjColor(geogebra.common.awt.GColor) -> b
    void setBackgroundColor(geogebra.common.awt.GColor) -> d
    void setEuclidianVisible(boolean) -> d
    void setElementEuclidianVisible(geogebra.common.kernel.geos.GeoElement,boolean) -> b
    void setVisibility(int,boolean) -> c
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    boolean isDefined() -> r
    void setDefined(boolean) -> h
    void setUndefined() -> e
    boolean showInEuclidianView() -> e_
    boolean isDrawable() -> u
    boolean showInAlgebraView() -> x
    void clear() -> d
    void clearCache() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void remove(int) -> b
    geogebra.common.kernel.geos.GeoElement get(int) -> a
    geogebra.common.kernel.geos.GeoElement get(int,int) -> a
    double[] toDouble() -> a
    void ensureCapacity(int) -> c
    int size() -> a_
    int getCacheSize() -> w
    geogebra.common.kernel.geos.GeoElement getCached(int) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    boolean isGeoList() -> ae
    boolean isListValue() -> h_
    void getXML(java.lang.StringBuilder) -> a
    java.lang.String getTypeStringForXML() -> d
    void setTypeStringForXML(java.lang.String) -> a
    void registerColorFunctionListener(geogebra.common.kernel.geos.GeoElement) -> k
    void unregisterColorFunctionListener(geogebra.common.kernel.geos.GeoElement) -> l
    void update() -> i
    void doRemove() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setZero() -> f_
    void setLineThickness(int) -> l
    int getMinimumLineThickness() -> s
    void setLineType(int) -> m
    void setPointSize(int) -> t
    int getPointSize() -> x
    void setPointStyle(int) -> u
    float getAlphaValue() -> a
    void setAlphaValue(float) -> a
    int getPointStyle() -> y
    boolean isFillable() -> I
    geogebra.common.kernel.geos.GeoElement getGeoElementForPropertiesDialog() -> g
    boolean isMatrix() -> P
    double getFontSizeMultiplier() -> a
    void setFontSizeMultiplier(double) -> a
    int getFontStyle() -> e
    void setFontStyle(int) -> a
    int getPrintDecimals() -> f
    int getPrintFigures() -> g
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean useSignificantFigures() -> t_
    boolean isSerifFont() -> E
    void setSerifFont(boolean) -> e
    void setHatchingAngle(int) -> q
    void setHatchingDistance(int) -> r
    void setFillType(int) -> s
    void setFillImage(java.lang.String) -> j
    void setImageFileName(java.lang.String) -> k
    boolean showLineProperties() -> Q
    boolean showPointProperties() -> R
    boolean isVector3DValue() -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    int getSelectedIndex() -> z
    void setSelectedIndex(int,boolean) -> d
    boolean hasDrawable3D() -> v
    geogebra.common.kernel.geos.GeoElement getSelectedElement() -> c
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    boolean isTraceable() -> m_
    boolean isLimitedPath() -> o_
    boolean isPath() -> ac
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void getNearestPoint(geogebra.common.kernel.kernelND.GeoPointND) -> c
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> w_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean justFontSize() -> k_
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean isCasEvaluableObject() -> D
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    boolean listContains(geogebra.common.kernel.geos.GeoElement) -> f
    boolean isLaTeXDrawableGeo() -> W
    void updateColumnHeadingsForTraceValues() -> G
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes(java.util.ArrayList) -> a
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes() -> a
    boolean hasSpreadsheetTraceModeTraceable() -> bn
    java.lang.String getTraceDialogAsValues() -> F
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    int performScriptActions() -> A
    int find(geogebra.common.kernel.geos.GeoElement) -> a
    boolean drawAsComboBox() -> S
    void setDrawAsComboBox(boolean) -> y
    geogebra.common.javax.swing.AbstractJComboBox getComboBox(int) -> a
    geogebra.common.javax.swing.AbstractJComboBox buildComboBox(geogebra.common.javax.swing.AbstractJComboBox) -> a
    geogebra.common.javax.swing.AbstractJComboBox buildComboBox() -> a
    void rebuildComboxBoxIfNecessary(geogebra.common.javax.swing.AbstractJComboBox) -> a
    void rebuildComboBoxes() -> j
    boolean isAbsoluteScreenLocateable() -> o
    boolean isMoveable() -> aw
    boolean isAbsoluteScreenLocActive() -> l
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    boolean isFurniture() -> l_
    geogebra.common.kernel.arithmetic.ExpressionValue getListElement(int) -> b
    double mean() -> e
    boolean shouldUseAlgoLocusList(boolean) -> a
    boolean showOnAxis() -> U
    void setShowOnAxis(boolean) -> f
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$TraceModesEnum() -> a
geogebra.common.kernel.geos.GeoLocus -> geogebra.common.i.j.J:
    boolean defined -> g
    java.util.ArrayList myPointList -> b
    java.lang.StringBuilder sbToString -> a
    double closestPointDist -> a
    int closestPointIndex -> l
    double closestPointParameter -> b
    boolean trace -> h
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    int getPointLength() -> c
    void clearPoints() -> d
    void insertPoint(double,double,boolean) -> a
    java.util.ArrayList getPoints() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> x
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isDefined() -> r
    void setDefined(boolean) -> e
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInEuclidianView() -> e_
    boolean isGeoLocus() -> aY
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> w_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    geogebra.common.kernel.MyPoint getClosestPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.geos.GeoLine getClosestLine(geogebra.common.kernel.geos.GeoPoint) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isPath() -> ac
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> b_
    boolean isLabelValueShowable() -> C
    void setPoints(java.util.ArrayList) -> b
    boolean isAuxiliaryObjectByDefault() -> ak
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    boolean isTraceable() -> m_
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
geogebra.common.kernel.geos.GeoNumberValue -> geogebra.common.i.j.K:
geogebra.common.kernel.geos.GeoNumeric -> geogebra.common.i.j.L:
    int DEFAULT_SLIDER_WIDTH_RW -> l
    int DEFAULT_SLIDER_WIDTH_PIXEL -> m
    int DEFAULT_SLIDER_WIDTH_PIXEL_ANGLE -> n
    double DEFAULT_SLIDER_MIN -> a
    double DEFAULT_SLIDER_MAX -> b
    double DEFAULT_SLIDER_INCREMENT -> c
    double DEFAULT_SLIDER_SPEED -> d
    double value -> e
    boolean isDrawable -> g
    int slopeTriangleSize -> o
    boolean intervalMinActive -> i
    boolean intervalMaxActive -> j
    geogebra.common.kernel.arithmetic.NumberValue intervalMin -> a
    geogebra.common.kernel.arithmetic.NumberValue intervalMax -> b
    double sliderWidth -> f
    double sliderX -> g
    double sliderY -> h
    boolean sliderFixed -> k
    boolean sliderHorizontal -> l
    double animationValue -> i
    boolean hasAbsoluteScreenLocation -> h
    java.lang.StringBuilder sbToString -> a
    java.util.ArrayList minMaxListeners -> b
    boolean randomSlider -> m
    java.util.Comparator comparator -> a
    java.util.ArrayList evListeners -> c
    int getRelatedModeID() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setZero() -> f_
    boolean isDrawable() -> u
    boolean isFillable() -> I
    void setDrawable(boolean) -> h
    void setEuclidianVisible(boolean) -> d
    int countSliders() -> e
    boolean isSlider() -> F
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> e
    boolean isDefined() -> r
    boolean isInfinite() -> Z
    java.lang.String getLaTeXdescription() -> z
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    double getAnimationStep() -> i
    double getAnimationSpeed() -> j
    void setValue(double) -> e
    void setValue(double,boolean) -> a
    double getValue() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    double getDouble() -> a
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isSliderable() -> P
    boolean isFixable() -> y
    void getXMLsliderTag(java.lang.StringBuilder) -> m
    boolean isNumberValue() -> c
    boolean isGeoNumeric() -> aZ
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    int getSlopeTriangleSize() -> w
    void setSlopeTriangleSize(int) -> t
    boolean isTextValue() -> g
    void setIntervalMax(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void setIntervalMin(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void setSliderWidth(double) -> f
    void setSliderLocation(double,double,boolean) -> a
    double getIntervalMax() -> f
    double getIntervalMin() -> g
    double getSliderWidth() -> h
    double getSliderX() -> l
    double getSliderY() -> m
    boolean isIntervalMaxActive() -> Q
    boolean isIntervalMinActive() -> R
    boolean isSliderFixed() -> S
    void setSliderFixed(boolean) -> y
    boolean isSliderHorizontal() -> T
    void setSliderHorizontal(boolean) -> z
    void setAbsoluteScreenLoc(int,int,boolean) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    void setAbsoluteScreenLocActive(boolean) -> b
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunctionable() -> aU
    void doRemove() -> b
    void registerMinMaxListener(geogebra.common.kernel.geos.GeoNumeric) -> a
    void unregisterMinMaxListener(geogebra.common.kernel.geos.GeoNumeric) -> b
    java.util.List getMinMaxListeners() -> b
    void setRandom(boolean) -> A
    boolean isRandom() -> U
    void updateRandom() -> d
    double getRandom() -> b
    void update() -> i
    void resolveMinMax() -> g
    boolean isAnimatable() -> az
    void setAnimating(boolean) -> o
    boolean doAnimationStep(double) -> a
    java.util.Comparator getComparator() -> a
    void updateRandomGeo() -> E
    boolean isVector3DValue() -> b_
    int getMinimumLineThickness() -> s
    void setIntervalMin(double) -> b
    void setIntervalMax(double) -> a
    geogebra.common.kernel.geos.GeoElement getIntervalMinObject() -> i
    geogebra.common.kernel.geos.GeoElement getIntervalMaxObject() -> j
    boolean canHaveClickScript() -> w
    boolean isCasEvaluableObject() -> D
    void addEVSizeListener(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    void removeEVSizeListener(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> c
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    boolean isLaTeXDrawableGeo() -> W
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    void setIntervalMinActive(boolean) -> e
    void setIntervalMaxActive(boolean) -> f
    boolean isPinnable() -> J
    geogebra.common.kernel.arithmetic.ExpressionValue derivative(geogebra.common.kernel.arithmetic.FunctionVariable) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue integral(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.geos.GeoNumeric$1 -> geogebra.common.i.j.M:
    int compare(geogebra.common.kernel.geos.GeoNumberValue,geogebra.common.kernel.geos.GeoNumberValue) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoPenStroke -> geogebra.common.i.j.N:
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    boolean isPinnable() -> J
geogebra.common.kernel.geos.GeoPoint -> geogebra.common.i.j.O:
    int pointSize -> l
    int pointStyle -> m
    double animationValue -> f
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.PathParameter pathParameter -> a
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.RegionParameters regionParameters -> a
    double x2D -> g
    double y2D -> h
    double inhomX -> a
    double inhomY -> b
    boolean isInfinite -> h
    boolean isDefined -> i
    boolean showUndefinedInAlgebraView -> j
    geogebra.common.kernel.LocateableList locateableList -> a
    java.util.ArrayList changeableCoordNumbers -> b
    boolean hasPolarParentNumbers -> k
    geogebra.common.kernel.PathParameter tempPathParameter -> b
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.util.Comparator comparatorX -> a
    java.util.ArrayList incidenceList -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    void setZero() -> f_
    geogebra.common.kernel.PathParameter getPathParameter() -> a
    geogebra.common.kernel.RegionParameters getRegionParameters() -> a
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void set(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoPoint copy() -> a
    void setPointSize(int) -> t
    int getPointSize() -> x
    int getPointStyle() -> y
    void setPointStyle(int) -> u
    boolean isChangeable() -> at
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    boolean hasChangeableCoordParentNumbers() -> bj
    java.util.ArrayList getCoordParentNumbers() -> c
    boolean hasPolarParentNumbers() -> P
    geogebra.common.kernel.geos.GeoNumeric getCoordNumber(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    boolean isPointOnPath() -> au
    boolean isAnimatable() -> az
    boolean hasPath() -> Q
    geogebra.common.kernel.Path getPath() -> a
    void setPath(geogebra.common.kernel.Path) -> a
    void addToPathParameter(double) -> a
    boolean isInfinite() -> Z
    boolean isFinite() -> R
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    boolean isDefined() -> r
    void setUndefined() -> e
    boolean isFixable() -> y
    void setCoords2D(double,double,double) -> b
    void setCoords(double,double,double) -> a
    void setCoords(geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra.common.kernel.PathParameter getTempPathparameter() -> b
    void updateCoords() -> d
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    void setCoords(geogebra.common.kernel.geos.GeoVec2D) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void getInhomCoords(double[]) -> a_
    double getInhomX() -> c
    double getInhomY() -> d
    double[] vectorTo(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean samePosition(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    double distanceSqr(geogebra.common.kernel.geos.GeoPoint) -> b
    boolean collinear(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    double det(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    double affineRatio(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void buildValueString(geogebra.common.kernel.Kernel,geogebra.common.kernel.StringTemplate,int,double,double,java.lang.StringBuilder) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getStartPointXML() -> d
    boolean isAbsoluteStartPoint() -> S
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    void update() -> i
    geogebra.common.kernel.LocateableList getLocateableList() -> a
    void doRemove() -> b
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isGeoPoint() -> ba
    void showUndefinedInAlgebraView(boolean) -> e
    java.util.Comparator getComparatorX() -> a
    boolean isPointInRegion() -> br
    boolean hasRegion() -> T
    boolean isVector3DValue() -> b_
    void updateCoords2D() -> g
    double getX2D() -> e
    double getY2D() -> f
    void updateCoordsFrom2D(boolean,geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> b
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD2(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> b
    boolean isMatrixTransformable() -> s_
    void matrixTransform(double,double,double,double) -> a
    boolean hasDrawable3D() -> v
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> w_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean doAnimationStep(double) -> a
    boolean isCasEvaluableObject() -> D
    boolean isFixed() -> ai
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void removePath() -> j
    void setCoords(double,double,double,double) -> b
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    java.util.ArrayList getIncidenceList() -> d
    void setIncidenceList(java.util.ArrayList) -> b
    void createIncidenceList() -> I
    void addIncidence(geogebra.common.kernel.geos.GeoElement) -> c
    void removeIncidence(geogebra.common.kernel.geos.GeoElement) -> d
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    boolean movePoint(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void setX(double) -> b
    void setY(double) -> e
    void setZ(double) -> f
    void updateColumnHeadingsForTraceValues() -> G
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes() -> a
    java.lang.String getTraceDialogAsValues() -> F
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    int getDimension() -> c
    geogebra.common.kernel.kernelND.GeoPointND copy() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoPoint$1 -> geogebra.common.i.j.P:
    int compare(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoPoly -> geogebra.common.i.j.Q:
    boolean isAllVertexLabelsSet() -> n
    boolean isVertexCountFixed() -> u_
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.geos.GeoPoint getPoint(int) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.Path getBoundary() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
geogebra.common.kernel.geos.GeoPolyLine -> geogebra.common.i.j.R:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    double length -> a
    boolean defined -> g
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.geos.GeoSegment seg -> a
    boolean trace -> h
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    int getNumPoints() -> c
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFillable() -> I
    boolean isDefined() -> r
    void setDefined() -> d
    void setUndefined() -> e
    boolean showInAlgebraView() -> x
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    double getLength() -> c
    double getDouble() -> a
    boolean showInEuclidianView() -> e_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isGeoPolygon() -> bb
    boolean isGeoPolyLine() -> aN
    boolean isPath() -> ac
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> w_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void setSegmentPoints(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
    void calcLength() -> g
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void matrixTransform(double,double,double,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isAllVertexLabelsSet() -> n
    boolean isVertexCountFixed() -> u_
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint getPoint(int) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.Path getBoundary() -> a
geogebra.common.kernel.geos.GeoPolygon -> geogebra.common.i.j.S:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.kernelND.GeoSegmentND[] segments -> a
    geogebra.common.kernel.geos.GeoPoint p0 -> a
    geogebra.common.kernel.geos.GeoPoint p1 -> b
    geogebra.common.kernel.geos.GeoPoint p2 -> c
    int numCS -> l
    double area -> a
    boolean defined -> g
    boolean initLabelsCalled -> h
    boolean createSegments -> i
    java.lang.StringBuilder sbToString -> a
    boolean asBoundary -> j
    boolean trace -> k
    geogebra.common.kernel.geos.ChangeableCoordParent changeableCoordParent -> a
    geogebra.common.kernel.Matrix.Coords interiorPoint -> a
    void setCoordSys(geogebra.common.kernel.Matrix.CoordSys) -> a
    java.lang.String getTypeString() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[],geogebra.common.kernel.Matrix.CoordSys,boolean) -> a
    int getPointsLength() -> c
    double getPointX(int) -> a
    double getPointY(int) -> b
    void initLabels(java.lang.String[]) -> a
    boolean wasInitLabelsCalled() -> P
    void defaultSegmentLabels() -> I
    void setLabel(geogebra.common.kernel.kernelND.GeoSegmentND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void updateSegments() -> J
    void removeSegment(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoSegmentND,boolean) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPolygon newGeoPolygon(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] copyPoints(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint() -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoPoint getPoint(int) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
    geogebra.common.kernel.kernelND.GeoSegmentND[] getSegments() -> a
    void setSegments(geogebra.common.kernel.kernelND.GeoSegmentND[]) -> a
    boolean isFillable() -> I
    boolean isInverseFillable() -> p_
    void calcArea() -> d
    double getArea() -> c
    geogebra.common.kernel.Path getBoundary() -> a
    double calcArea(geogebra.common.kernel.geos.GeoPoint[]) -> a
    double calcAreaWithSign(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void calcCentroid(geogebra.common.kernel.geos.GeoPoint) -> b
    double pointsClosedX(int) -> c
    double pointsClosedY(int) -> d
    double getAreaWithSign() -> d
    boolean isDefined() -> r
    void setDefined() -> g
    void setUndefined() -> e
    boolean showInAlgebraView() -> x
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setEuclidianVisible(boolean) -> d
    void setEuclidianVisible(boolean,boolean) -> a
    void setObjColor(geogebra.common.awt.GColor) -> b
    void setLineType(int) -> m
    void setLineType(int,boolean) -> a
    void setLineTypeHidden(int) -> n
    void setLineTypeHidden(int,boolean) -> b
    void setLineThickness(int) -> l
    void setLineThickness(int,boolean) -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    double getDouble() -> a
    boolean showInEuclidianView() -> e_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isGeoPolygon() -> bb
    boolean isPath() -> ac
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> w_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isRegion() -> ad
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void setRegionChanged(geogebra.common.kernel.kernelND.GeoPointND,double,double) -> a
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void updateRegionCS(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void updateRegionCS() -> j
    int intersectOx(double,double,double,double) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isVector3DValue() -> b_
    int getMinimumLineThickness() -> s
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    boolean hasDrawable3D() -> v
    void setChangeableCoordParent(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoElement) -> a
    boolean hasChangeableCoordParentNumbers() -> bj
    void recordChangeableCoordParentNumbers() -> B
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void matrixTransform(double,double,double,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isAllVertexLabelsSet() -> n
    boolean isVertexCountFixed() -> u_
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    java.lang.String getDefaultLabel(char[],boolean) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
geogebra.common.kernel.geos.GeoRay -> geogebra.common.i.j.T:
    boolean allowOutlyingIntersections -> h
    boolean keepTypeOnGeometricTransform -> i
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean allowOutlyingIntersections() -> L
    void setAllowOutlyingIntersections(boolean) -> e
    void setKeepTypeOnGeometricTransform(boolean) -> f
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isGeoRay() -> bc
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    boolean isAllEndpointsLabelsSet() -> P
geogebra.common.kernel.geos.GeoScriptAction -> geogebra.common.i.j.U:
    geogebra.common.kernel.commands.CmdScripting action -> a
    geogebra.common.kernel.arithmetic.Command command -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void perform() -> d
geogebra.common.kernel.geos.GeoSegment -> geogebra.common.i.j.V:
    double length -> a
    boolean defined -> h
    boolean allowOutlyingIntersections -> i
    boolean keepTypeOnGeometricTransform -> j
    java.lang.StringBuilder sbToString -> a
    boolean forceSimpleTransform -> k
    geogebra.common.kernel.geos.GeoElement meta -> a
    java.lang.Integer[] getDecoTypes() -> a
    void setDecorationType(int) -> e
    void setPoints(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void calcLength() -> I
    double getLength() -> c
    boolean isDefined() -> r
    void setUndefined() -> e
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> a
    double getDouble() -> a
    boolean isConstant() -> a_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean allowOutlyingIntersections() -> L
    void setAllowOutlyingIntersections(boolean) -> e
    void setKeepTypeOnGeometricTransform(boolean) -> f
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint,double) -> a
    geogebra.common.kernel.geos.GeoElement getStartPointAsGeoElement() -> c
    geogebra.common.kernel.geos.GeoElement getEndPointAsGeoElement() -> i
    double getPointX(double) -> b
    double getPointY(double) -> c
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isGeoSegment() -> bd
    void setZero() -> f_
    boolean hasDrawable3D() -> v
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    double getParameter(double,double) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    boolean checkOnPath(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,boolean,double) -> a
    boolean isAllEndpointsLabelsSet() -> P
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isFromMeta() -> by
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
    void setFromMeta(geogebra.common.kernel.geos.GeoElement) -> c
geogebra.common.kernel.geos.GeoSurfaceFinite -> geogebra.common.i.j.W:
geogebra.common.kernel.geos.GeoText -> geogebra.common.i.j.X:
    java.lang.String str -> c
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    boolean isLaTeXorMathML -> i
    boolean isMathML -> j
    geogebra.common.awt.GRectangle2D boundingBox -> a
    boolean needsUpdatedBoundingBox -> k
    boolean serifFont -> l
    int fontStyle -> l
    double fontSizeD -> a
    int printDecimals -> m
    int printFigures -> n
    boolean useSignificantFigures -> m
    boolean hasAbsoluteScreenLocation -> n
    java.lang.StringBuilder sbToString -> a
    boolean isTextCommand -> g
    boolean alwaysFixed -> h
    geogebra.common.kernel.StringTemplate tpl -> a
    geogebra.common.kernel.geos.GeoText linkedText -> a
    java.util.Comparator comparator -> a
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase spreadsheetTraceableCase -> a
    geogebra.common.kernel.arithmetic.ExpressionValue spreadsheetTraceableValue -> a
    geogebra.common.kernel.arithmetic.ExpressionNode spreadsheetTraceableLeftTree -> a
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum traceModes -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoText$SpreadsheetTraceableCase -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setTextString(java.lang.String) -> a
    java.lang.String getTextString() -> d
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void doRemove() -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    boolean hasAbsoluteLocation() -> P
    void setWaitForStartPoint() -> a
    void update() -> i
    boolean isDefined() -> r
    void setUndefined() -> e
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    int getRelatedModeID() -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isMoveable() -> aw
    void setIsTextCommand(boolean) -> f
    boolean isTextCommand() -> bo
    boolean isLaTeXTextCommand() -> Q
    void setAlgoMacroOutput(boolean) -> s
    void addTextDescendant(geogebra.common.kernel.geos.GeoText) -> a
    void setAlwaysFixed(boolean) -> g
    boolean isFixable() -> y
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isGeoText() -> be
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
    void getXML(java.lang.StringBuilder) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getXMLlocation() -> e
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setSameLocation(geogebra.common.kernel.geos.GeoText) -> b
    boolean isLaTeX() -> R
    void setLaTeX(boolean,boolean) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> c
    int getAbsoluteScreenLocY() -> d
    double getRealWorldLocX() -> c
    double getRealWorldLocY() -> d
    void setRealWorldLoc(double,double) -> a
    void setAbsoluteScreenLocActive(boolean) -> b
    boolean isAbsoluteScreenLocActive() -> l
    boolean isAbsoluteScreenLocateable() -> o
    double getFontSizeMultiplier() -> a
    double getRelativeFontSize(int) -> a
    int getFontSizeIndex(double) -> a
    void setFontSizeMultiplier(double) -> a
    int getFontStyle() -> e
    void setFontStyle(int) -> a
    int getPrintDecimals() -> f
    int getPrintFigures() -> g
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    void updateTemplateAlgos(geogebra.common.kernel.algos.AlgoElement) -> h
    boolean useSignificantFigures() -> t_
    boolean isSerifFont() -> E
    void setSerifFont(boolean) -> e
    void calculateCornerPoint(geogebra.common.kernel.geos.GeoPoint,int) -> a
    geogebra.common.awt.GRectangle2D getBoundingBox() -> a
    void setBoundingBox(double,double,double,double) -> a
    boolean isNeedsUpdatedBoundingBox() -> S
    void setNeedsUpdatedBoundingBox(boolean) -> h
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setZero() -> f_
    java.util.Comparator getComparator() -> a
    void updateTemplate() -> g
    boolean isAlwaysFixed() -> a
    boolean isAuxiliaryObjectByDefault() -> ak
    boolean justFontSize() -> k_
    boolean isRedefineable() -> av
    boolean isLaTeXDrawableGeo() -> W
    boolean hasDrawable3D() -> v
    boolean hasBackgroundColor() -> H
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
    void setSpreadsheetTraceable(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void initSpreadsheetTraceableCase() -> d
    boolean isSpreadsheetTraceable() -> bm
    void updateColumnHeadingsForTraceValues() -> G
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes() -> a
    void appendFontTag(java.lang.StringBuilder,boolean,double,int,boolean,geogebra.common.main.App) -> a
    boolean isPinnable() -> J
    void updateLocation() -> e_
    void updateVisualStyle() -> y
    void setMathML(boolean) -> y
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoText$SpreadsheetTraceableCase() -> a
geogebra.common.kernel.geos.GeoText$1 -> geogebra.common.i.j.Y:
    int compare(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase -> geogebra.common.i.j.X$a:
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase SPREADSHEET_TRACEABLE_NOT_TESTED -> a
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase SPREADSHEET_TRACEABLE_TRUE -> b
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase SPREADSHEET_TRACEABLE_FALSE -> c
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase[] ENUM$VALUES -> a
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase[] values() -> values
    geogebra.common.kernel.geos.GeoText$SpreadsheetTraceableCase valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.GeoTextField -> geogebra.common.i.j.Z:
    int defaultLength -> l
    int length -> m
    geogebra.common.kernel.geos.GeoElement linkedGeo -> a
    java.lang.String text -> c
    geogebra.common.gui.inputfield.AutoCompleteTextField textField -> a
    geogebra.common.gui.inputfield.AutoCompleteTextField textField2 -> b
    int printDecimals -> n
    int printFigures -> o
    boolean useSignificantFigures -> g
    geogebra.common.kernel.StringTemplate tpl -> a
    boolean isChangeable() -> at
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setLinkedGeo(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoElement getLinkedGeo() -> c
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void setText(java.lang.String) -> a
    java.lang.String getText() -> d
    boolean isGeoTextField() -> aC
    void setLength(int) -> b
    int getLength() -> w
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void updateLinkedGeo(java.lang.String) -> b
    void updateText(geogebra.common.util.TextObject) -> a
    void textObjectUpdated(geogebra.common.util.TextObject) -> b
    void textSubmitted() -> d
    geogebra.common.gui.inputfield.AutoCompleteTextField getTextField(int,geogebra.common.euclidian.draw.DrawTextField) -> a
    void setSelected(boolean) -> p
    void updateTemplate() -> g
    int getPrintDecimals() -> f
    int getPrintFigures() -> g
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean useSignificantFigures() -> t_
    void setBackgroundColor(geogebra.common.awt.GColor) -> d
geogebra.common.kernel.geos.GeoUserInputElement -> geogebra.common.i.j.aa:
    geogebra.common.kernel.arithmetic.ValidExpression userInput -> a
    boolean inputForm -> g
    boolean validInputForm -> h
    void setInputForm() -> d
    void setExtendedForm() -> g
    boolean isInputForm() -> P
    void setUserInput(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String toRawValueString(geogebra.common.kernel.StringTemplate) -> f
    void setValidInputForm(boolean) -> e
    boolean isValidInputForm() -> Q
geogebra.common.kernel.geos.GeoVec2D -> geogebra.common.i.j.ab:
    double x -> a
    double y -> b
    int mode -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.StringBuilder sbToString -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    boolean isImaginaryUnit() -> n
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables(boolean) -> a
    void setX(double) -> a
    void setY(double) -> b
    void setCoords(geogebra.common.kernel.geos.GeoVec2D) -> a
    double getX() -> a
    double getY() -> b
    double[] getCoords() -> a
    double length() -> c
    void makeUnitVector() -> a
    double inner(geogebra.common.kernel.geos.GeoVec2D) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoVec2D) -> a
    void rotate(double) -> c
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(double) -> d
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> a
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.ListValue,geogebra.common.kernel.geos.GeoVec2D) -> a
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.ListValue,geogebra.common.kernel.geos.GeoVec2D,boolean) -> a
    void sub(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> b
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void mult(double) -> e
    void mult(geogebra.common.kernel.geos.GeoVec2D,double,geogebra.common.kernel.geos.GeoVec2D) -> a
    void complexDivide(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexDivide(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexMultiply(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> d
    void complexPower(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexSqrt(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void complexZeta(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexCbrt(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexConjugate(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> d
    double arg(geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexPower(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexExp(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> e
    void complexLog(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> f
    double complexAbs(geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexPower(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> e
    void vectorProduct(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void inner(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.MyDouble) -> b
    void div(geogebra.common.kernel.geos.GeoVec2D,double,geogebra.common.kernel.geos.GeoVec2D) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> a_
    boolean isLeaf() -> x_
    int getMode() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    void setMode(int) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> e
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isExpressionNode() -> g_
    boolean isListValue() -> h_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void multiplyMatrix(geogebra.common.kernel.arithmetic.MyList) -> a
    void matrixTransform(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    void multiplyMatrixAffine(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> b_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean hasCoords() -> m
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoVec3D -> geogebra.common.i.j.ac:
    double x -> c
    double y -> d
    double z -> e
    boolean trace -> h
    boolean hasUpdatePrevilege -> g
    java.lang.StringBuilder sbToString -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setCoords(double,double,double) -> a
    double getX() -> g
    double getY() -> h
    double getZ() -> l
    void getCoords(double[]) -> c
    geogebra.common.kernel.Matrix.Coords getCoords() -> d
    void getInhomCoords(double[]) -> a_
    boolean isPolar() -> U
    int getMode() -> d
    void setMode(int) -> a
    void setPolar() -> J
    void setCartesian() -> K
    void setComplex() -> L
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    boolean linDep(geogebra.common.kernel.geos.GeoVec3D) -> a
    boolean isZero() -> X
    void cross(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.Matrix.Coords cross(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D) -> a
    void lineThroughPoints(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> a
    void lineThroughPointVector(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoLine) -> a
    void cross(geogebra.common.kernel.geos.GeoVec3D,double,double,double,geogebra.common.kernel.geos.GeoVec3D) -> a
    void cross(double,double,double,double,double,double,geogebra.common.kernel.geos.GeoVec3D) -> a
    void changeSign() -> M
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    void setZero() -> f_
    void rotateXY(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void mirrorXY(double) -> g
    boolean hasCoords() -> m
geogebra.common.kernel.geos.GeoVector -> geogebra.common.i.j.ad:
    geogebra.common.kernel.geos.GeoPoint startPoint -> a
    geogebra.common.kernel.geos.GeoSegment pathSegment -> a
    geogebra.common.kernel.geos.GeoPoint pathStartPoint -> b
    geogebra.common.kernel.geos.GeoPoint pathEndPoint -> c
    boolean waitingForStartPoint -> h
    java.util.HashSet waitingPointSet -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.lang.StringBuilder sb -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isCasEvaluableObject() -> D
    void setCoords(double,double,double) -> a
    void setCoords(double[]) -> b
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoVec2D getInhomVec() -> b
    geogebra.common.kernel.geos.GeoPoint getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint[] getStartPoints() -> a
    boolean hasAbsoluteLocation() -> P
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void setWaitForStartPoint() -> a
    void doRemove() -> b
    boolean isFinite() -> Q
    boolean isInfinite() -> Z
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void matrixTransform(double,double,double,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isClosedPath() -> w_
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isPath() -> ac
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void initPathSegment() -> d
    void updatePathSegment() -> g
    boolean isGeoVector() -> bf
    boolean isAlwaysFixed() -> a
    boolean isVector3DValue() -> b_
    boolean isMatrixTransformable() -> s_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> a
    boolean hasDrawable3D() -> v
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isLaTeXDrawableGeo() -> W
    void updateColumnHeadingsForTraceValues() -> G
    geogebra.common.kernel.geos.GeoElement$TraceModesEnum getTraceModes() -> a
    java.lang.String getTraceDialogAsValues() -> F
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    void updateLocation() -> e_
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.InequalityProperties -> geogebra.common.i.j.ae:
    void setShowOnAxis(boolean) -> f
    boolean showOnAxis() -> U
geogebra.common.kernel.geos.LabelManager -> geogebra.common.i.j.af:
    boolean checkName(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    boolean validVar(java.lang.String) -> a
geogebra.common.kernel.geos.LimitedPath -> geogebra.common.i.j.ag:
    boolean allowOutlyingIntersections() -> L
    void setAllowOutlyingIntersections(boolean) -> e
    void setKeepTypeOnGeometricTransform(boolean) -> f
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isAllEndpointsLabelsSet() -> P
geogebra.common.kernel.geos.LineProperties -> geogebra.common.i.j.ah:
geogebra.common.kernel.geos.Mirrorable -> geogebra.common.i.j.ai:
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
geogebra.common.kernel.geos.ParametricCurve -> geogebra.common.i.j.aj:
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    void evaluateCurve(double,double[]) -> a
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    boolean isFunctionInX() -> P
geogebra.common.kernel.geos.PointProperties -> geogebra.common.i.j.ak:
    void setPointSize(int) -> t
    int getPointSize() -> x
    void setPointStyle(int) -> u
    int getPointStyle() -> y
    void updateRepaint() -> x
geogebra.common.kernel.geos.PointRotateable -> geogebra.common.i.j.al:
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
geogebra.common.kernel.geos.Rotateable -> geogebra.common.i.j.am:
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.geos.SpreadsheetTraceable -> geogebra.common.i.j.an:
    void addToSpreadsheetTraceList(java.util.ArrayList) -> a
    java.util.ArrayList getColumnHeadings() -> b
geogebra.common.kernel.geos.Test -> geogebra.common.i.j.ao:
    geogebra.common.kernel.geos.Test GEOANGLE -> a
    geogebra.common.kernel.geos.Test GEODUMMYVARIABLE -> b
    geogebra.common.kernel.geos.Test GEONUMERIC -> c
    geogebra.common.kernel.geos.Test GEOAXIS -> d
    geogebra.common.kernel.geos.Test GEOSEGMENT -> e
    geogebra.common.kernel.geos.Test GEOSEGMENTND -> f
    geogebra.common.kernel.geos.Test GEORAY -> g
    geogebra.common.kernel.geos.Test GEOLINE -> h
    geogebra.common.kernel.geos.Test GEOLINEND -> i
    geogebra.common.kernel.geos.Test GEOVECTOR -> j
    geogebra.common.kernel.geos.Test GEOVECTORND -> k
    geogebra.common.kernel.geos.Test GEOBOOLEAN -> l
    geogebra.common.kernel.geos.Test GEOTEXTFIELD -> m
    geogebra.common.kernel.geos.Test GEOBUTTON -> n
    geogebra.common.kernel.geos.Test GEOCASCELL -> o
    geogebra.common.kernel.geos.Test GEOCONICPART -> p
    geogebra.common.kernel.geos.Test GEOCONIC -> q
    geogebra.common.kernel.geos.Test GEOCONICND -> r
    geogebra.common.kernel.geos.Test GEOQUADRIC3D -> s
    geogebra.common.kernel.geos.Test GEOQUADRICND -> t
    geogebra.common.kernel.geos.Test GEOCURVECARTESIAN -> u
    geogebra.common.kernel.geos.Test GEOCURVECARTESIAN3D -> v
    geogebra.common.kernel.geos.Test GEOCURVECARTESIANND -> w
    geogebra.common.kernel.geos.Test GEOFUNCTIONCONDITIONAL -> x
    geogebra.common.kernel.geos.Test GEOINTERVAL -> y
    geogebra.common.kernel.geos.Test GEOFUNCTION -> z
    geogebra.common.kernel.geos.Test GEOFUNCTIONNVAR -> A
    geogebra.common.kernel.geos.Test GEOIMAGE -> B
    geogebra.common.kernel.geos.Test GEOLIST -> C
    geogebra.common.kernel.geos.Test GEOLOCUS -> D
    geogebra.common.kernel.geos.Test GEOPOINT -> E
    geogebra.common.kernel.geos.Test GEOPOINTND -> F
    geogebra.common.kernel.geos.Test GEOPOLYGON -> G
    geogebra.common.kernel.geos.Test GEOPOLYGON3D -> H
    geogebra.common.kernel.geos.Test GEOPOLYLINE -> I
    geogebra.common.kernel.geos.Test GEOSCRIPTACTION -> J
    geogebra.common.kernel.geos.Test GEOTEXT -> K
    geogebra.common.kernel.geos.Test GEOIMPLICITPOLY -> L
    geogebra.common.kernel.geos.Test GEOUSERINPUTELEMENT -> M
    geogebra.common.kernel.geos.Test GEODIRECTIONND -> N
    geogebra.common.kernel.geos.Test GEOCOORDSYS2D -> O
    geogebra.common.kernel.geos.Test GEOCOORDSYS1D -> P
    geogebra.common.kernel.geos.Test NUMBERVALUE -> Q
    geogebra.common.kernel.geos.Test PATH -> R
    geogebra.common.kernel.geos.Test REGION3D -> S
    geogebra.common.kernel.geos.Test DILATEABLE -> T
    geogebra.common.kernel.geos.Test TRANSLATEABLE -> U
    geogebra.common.kernel.geos.Test MOVEABLE -> V
    geogebra.common.kernel.geos.Test ROTATEMOVEABLE -> W
    geogebra.common.kernel.geos.Test TRANSFORMABLE -> X
    geogebra.common.kernel.geos.Test GEOELEMENT -> Y
    geogebra.common.kernel.geos.Test OBJECT -> Z
    geogebra.common.kernel.geos.Test[] ENUM$VALUES -> a
    boolean check(java.lang.Object) -> a
    geogebra.common.kernel.geos.Test getSpecificTest(java.lang.Object) -> a
    geogebra.common.kernel.geos.Test[] values() -> values
    geogebra.common.kernel.geos.Test valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.Test$1 -> geogebra.common.i.j.ap:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$10 -> geogebra.common.i.j.aq:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$11 -> geogebra.common.i.j.ar:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$12 -> geogebra.common.i.j.as:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$13 -> geogebra.common.i.j.at:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$14 -> geogebra.common.i.j.au:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$15 -> geogebra.common.i.j.av:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$16 -> geogebra.common.i.j.aw:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$17 -> geogebra.common.i.j.ax:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$18 -> geogebra.common.i.j.ay:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$19 -> geogebra.common.i.j.az:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$2 -> geogebra.common.i.j.aA:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$20 -> geogebra.common.i.j.aB:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$21 -> geogebra.common.i.j.aC:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$22 -> geogebra.common.i.j.aD:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$23 -> geogebra.common.i.j.aE:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$24 -> geogebra.common.i.j.aF:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$25 -> geogebra.common.i.j.aG:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$26 -> geogebra.common.i.j.aH:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$27 -> geogebra.common.i.j.aI:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$28 -> geogebra.common.i.j.aJ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$29 -> geogebra.common.i.j.aK:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$3 -> geogebra.common.i.j.aL:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$30 -> geogebra.common.i.j.aM:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$31 -> geogebra.common.i.j.aN:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$32 -> geogebra.common.i.j.aO:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$33 -> geogebra.common.i.j.aP:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$34 -> geogebra.common.i.j.aQ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$35 -> geogebra.common.i.j.aR:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$36 -> geogebra.common.i.j.aS:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$37 -> geogebra.common.i.j.aT:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$38 -> geogebra.common.i.j.aU:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$39 -> geogebra.common.i.j.aV:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$4 -> geogebra.common.i.j.aW:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$40 -> geogebra.common.i.j.aX:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$41 -> geogebra.common.i.j.aY:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$42 -> geogebra.common.i.j.aZ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$43 -> geogebra.common.i.j.ba:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$44 -> geogebra.common.i.j.bb:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$45 -> geogebra.common.i.j.bc:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$46 -> geogebra.common.i.j.bd:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$47 -> geogebra.common.i.j.be:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$48 -> geogebra.common.i.j.bf:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$49 -> geogebra.common.i.j.bg:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$5 -> geogebra.common.i.j.bh:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$50 -> geogebra.common.i.j.bi:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$51 -> geogebra.common.i.j.bj:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$52 -> geogebra.common.i.j.bk:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$6 -> geogebra.common.i.j.bl:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$7 -> geogebra.common.i.j.bm:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$8 -> geogebra.common.i.j.bn:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$9 -> geogebra.common.i.j.bo:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.TextProperties -> geogebra.common.i.j.bp:
    double getFontSizeMultiplier() -> a
    void setFontSizeMultiplier(double) -> a
    int getFontStyle() -> e
    void setFontStyle(int) -> a
    int getPrintDecimals() -> f
    int getPrintFigures() -> g
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean isSerifFont() -> E
    void setSerifFont(boolean) -> e
    boolean useSignificantFigures() -> t_
    boolean justFontSize() -> k_
geogebra.common.kernel.geos.ToGeoElement -> geogebra.common.i.j.bq:
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.geos.Traceable -> geogebra.common.i.j.br:
    boolean getTrace() -> F
    void setTrace(boolean) -> a_
    void updateRepaint() -> x
geogebra.common.kernel.geos.Transformable -> geogebra.common.i.j.bs:
geogebra.common.kernel.geos.Translateable -> geogebra.common.i.j.bt:
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
geogebra.common.kernel.implicit.AlgoAsymptoteImplicitPoly -> geogebra.common.i.k.a:
    geogebra.common.kernel.implicit.GeoImplicitPoly ip -> a
    geogebra.common.kernel.geos.GeoList g -> a
    geogebra.common.kernel.EquationSolverInterface solver -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void makeLines(java.util.ArrayList,double,double) -> a
    void compute() -> b
geogebra.common.kernel.implicit.AlgoDependentImplicitPoly -> geogebra.common.i.k.b:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[][] coeff -> a
    geogebra.common.kernel.geos.GeoElement geoElement -> a
    java.util.Set dependentFromFunctions -> a
    void compute() -> b
    void replaceGeoElement(geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.kernel.arithmetic.Equation getEquation() -> a
    void compute(boolean) -> d
    void setLine() -> e
    void setConic() -> f
    void addAllFunctionalDescendents(geogebra.common.kernel.algos.AlgoElement,java.util.Set,java.util.Set) -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toExpString(geogebra.common.kernel.StringTemplate) -> g
geogebra.common.kernel.implicit.AlgoImplicitPolyFunction -> geogebra.common.i.k.c:
    geogebra.common.kernel.geos.GeoFunctionNVar function -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getImplicitPoly() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.implicit.AlgoImplicitPolyTangentCurve -> geogebra.common.i.k.d:
    geogebra.common.kernel.implicit.GeoImplicitPoly poly -> a
    geogebra.common.kernel.geos.GeoPoint point -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly tangentPoly -> b
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getTangentCurve() -> a
geogebra.common.kernel.implicit.AlgoImplicitPolyThroughPoints -> geogebra.common.i.k.e:
    geogebra.common.kernel.geos.GeoList P -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getImplicitPoly() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric -> geogebra.common.i.k.f:
    org.apache.commons.math.analysis.polynomials.PolynomialFunction tx -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction ty -> b
    geogebra.common.kernel.implicit.GeoImplicitPoly p -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint[] tangentPoints -> a
    double getYValue(double) -> a
    double getXValue(double) -> b
    void compute() -> b
    void mergeWithTangentPoints() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys -> geogebra.common.i.k.g:
    geogebra.common.kernel.implicit.GeoImplicitPoly p1 -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly p2 -> b
    geogebra.common.kernel.geos.GeoConic c1 -> a
    java.util.List valPairs -> a
    int univarType -> a
    java.util.List hints -> b
    double getYValue(double) -> a
    void compute() -> b
    int getNearRoots(double[],geogebra.common.kernel.EquationSolverInterface,double) -> a
    void insert(double[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
geogebra.common.kernel.implicit.AlgoTangentImplicitpoly -> geogebra.common.i.k.h:
    geogebra.common.kernel.implicit.GeoImplicitPoly p -> a
    geogebra.common.kernel.geos.GeoPoint R -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint[] ip -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler tangents -> a
    boolean pointOnPath -> c
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys algoIntersect -> a
    java.lang.String[] labels -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.geos.GeoPoint[] getTangentPoints() -> a
geogebra.common.kernel.implicit.AlgoTangentImplicitpoly$1 -> geogebra.common.i.k.i:
    geogebra.common.kernel.implicit.AlgoTangentImplicitpoly this$0 -> a
    geogebra.common.kernel.geos.GeoLine newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.implicit.GeoImplicitPoly -> geogebra.common.i.k.j:
    double[][] coeff -> a
    double[][] coeffSquarefree -> b
    int degX -> l
    int degY -> m
    boolean defined -> g
    boolean isConstant -> h
    boolean calcPath -> i
    boolean trace -> j
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.List singularitiesCollection -> a
    java.util.List boundaryIntersectCollection -> b
    boolean[][] remember -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly$GridRect[][] grid -> a
    int gridWidth -> n
    int gridHeight -> o
    double scaleX -> a
    double scaleY -> b
    double minGap -> c
    void preventPathCreation() -> j
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isDefined() -> r
    boolean isOnScreen() -> R
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isGeoImplicitPoly() -> aO
    boolean isPath() -> ac
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> e
    void setDefined() -> I
    boolean showInAlgebraView() -> x
    boolean showInEuclidianView() -> e_
    void addPow(java.lang.StringBuilder,int,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRawValueString(geogebra.common.kernel.StringTemplate) -> f
    boolean isVector3DValue() -> b_
    void setCoeff(double[][]) -> a
    void setCoeff(double[][],boolean) -> a
    void setCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][]) -> a
    void setCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][],boolean) -> a
    double[][] getCoeff(boolean) -> a
    double[][] getCoeff() -> a
    double evalPolyAt(double,double) -> a
    double evalPolyAt(double,double,boolean) -> a
    double evalPolyCoeffAt(double,double,double[][]) -> a
    double evalDiffXPolyAt(double,double) -> b
    double evalDiffXPolyAt(double,double,boolean) -> b
    double evalDiffYPolyAt(double,double) -> c
    double evalDiffYPolyAt(double,double,boolean) -> c
    void plugInRatPoly(double[][],double[][],double[][],double[][]) -> a
    void plugInPoly(double[][],double[][]) -> a
    void polyMult(double[][],double[][],int,int,int,int) -> a
    boolean isConstant() -> a_
    int getDegX() -> c
    int getDegY() -> d
    void getFactors() -> K
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    void throughPoints(geogebra.common.kernel.geos.GeoList) -> b
    void throughPoints(java.util.ArrayList) -> b
    void polishPointOnPath(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> w_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a_
    boolean getTrace() -> F
    int getDeg() -> e
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void translate(double,double) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isTranslateable() -> q_
    char getLabelDelimiter() -> a
    boolean euclidianViewUpdate() -> b
    int epsSignum(double) -> a
    void updatePath() -> J
    void updatePath(double,double,double,double,double) -> a
    double scaledNormSquared(double,double) -> d
    void startPath(int,int,double,double,geogebra.common.kernel.geos.GeoLocus) -> a
    double bisec(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    boolean isCasEvaluableObject() -> D
geogebra.common.kernel.implicit.GeoImplicitPoly$GridRect -> geogebra.common.i.k.j$a:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    int[] eval -> a
geogebra.common.kernel.implicit.PolynomialUtils -> geogebra.common.i.k.k:
    double[] polynomialDivision(double[],double[]) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction polynomialDivision(org.apache.commons.math.analysis.polynomials.PolynomialFunction,org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    int getDegree(double[]) -> a
    double getLeadingCoeff(double[]) -> a
    double getLeadingCoeff(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    double eval(double[],double) -> a
    double[][] coeffMinDeg(double[][]) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,double[]) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,double[]) -> a
geogebra.common.kernel.integration.EllipticArcLength -> geogebra.common.i.l.a:
    double[] halfAxes -> a
    geogebra.common.kernel.roots.RealRootFunction arcLengthFunction -> a
    double compute(double,double) -> a
geogebra.common.kernel.integration.EllipticArcLength$EllipticArcLengthFunction -> geogebra.common.i.l.a$a:
    geogebra.common.kernel.integration.EllipticArcLength this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.kernelND.AlgoIntersectND -> geogebra.common.i.m.a:
    int numberOfUsers -> a
    boolean[] didSetIntersectionPoint -> a
    void avoidDoubleTangentPoint() -> a
    void noUndefinedPointsInAlgebraView() -> n
    void addUser() -> o
    void removeUser() -> p
    geogebra.common.kernel.kernelND.GeoPointND[] getIntersectionPoints() -> b
    geogebra.common.kernel.kernelND.GeoPointND[] getLastDefinedIntersectionPoints() -> a
    void setIntersectionPoint(int,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean didSetIntersectionPoint(int) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void remove() -> c
geogebra.common.kernel.kernelND.AlgoMidpointND -> geogebra.common.i.m.b:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.kernelND.GeoPointND M -> c
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    void compute() -> b
    void copyCoords(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void computeMidCoords() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> c
    geogebra.common.kernel.kernelND.GeoPointND getP() -> b
    geogebra.common.kernel.kernelND.GeoPointND getQ() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.kernelND.Geo3DVec -> geogebra.common.i.m.c:
    boolean isEqual(geogebra.common.kernel.kernelND.Geo3DVec) -> a
    void multiplyMatrix(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.kernelND.GeoAxisND -> geogebra.common.i.m.d:
geogebra.common.kernel.kernelND.GeoConicND -> geogebra.common.i.m.e:
    java.lang.String[] vars -> a
    java.lang.String[] varsLateX -> b
    java.lang.String[] varsCAS -> c
    boolean KEEP_LEADING_SIGN -> g
    geogebra.common.kernel.geos.GeoPoint singlePoint -> a
    geogebra.common.kernel.geos.GeoLine[] lines -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    double eigenvecX -> a
    double eigenvecY -> b
    double maxCoeffAbs -> c
    geogebra.common.awt.GAffineTransform transform -> a
    geogebra.common.awt.GAffineTransform oldTransform -> b
    boolean trace -> h
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint[] startPoints -> a
    java.util.ArrayList pointsOnConic -> b
    double detS -> h
    double length -> i
    double temp -> j
    double temp1 -> k
    double temp2 -> l
    double nx -> m
    double ny -> n
    double lambda -> o
    int index -> m
    double[] eigenval -> d
    double[] mu -> a
    geogebra.common.kernel.geos.GeoVec2D c -> b
    double errDetS -> d
    double[] coeffs -> e
    boolean eigenvectorsSetOnLoad -> j
    double area -> p
    boolean isEndOfQuadric -> k
    geogebra.common.kernel.kernelND.GeoConicND$HitType lastHitType -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec(int) -> b
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint,double) -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isPath() -> ac
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    double[] getPerpendicularParams(double,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean compatibleType(int) -> c
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> w_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnFullConic(geogebra.common.kernel.kernelND.GeoPointND,double) -> b
    boolean isOnFullConic(geogebra.common.kernel.Matrix.Coords,double) -> a
    geogebra.common.kernel.PathMover createPathMover() -> a
    void coordsEVtoRW(geogebra.common.kernel.Matrix.Coords) -> b
    void coordsRWtoEV(geogebra.common.kernel.Matrix.Coords) -> d
    boolean isFillable() -> I
    java.util.ArrayList getPointsOnConic() -> c
    void setPointsOnConic(java.util.ArrayList) -> b
    void addPointOnConic(geogebra.common.kernel.kernelND.GeoPointND) -> e
    void removePointOnConic(geogebra.common.kernel.kernelND.GeoPointND) -> f
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> i
    void setToStringMode(int) -> a
    int getToStringMode() -> d
    boolean isCircle() -> Q
    void setToSpecific() -> d
    void setToImplicit() -> g
    void setToExplicit() -> j
    boolean isSpecificPossible() -> R
    boolean isExplicitPossible() -> S
    boolean checkDefined() -> F
    boolean showInEuclidianView() -> e_
    boolean showInAlgebraView() -> x
    boolean isLineConic() -> T
    boolean isDegenerate() -> U
    void setCoeffs(double[]) -> a
    void setCoeffs(double,double,double,double,double,double) -> a
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String getXMLtagsMinimal() -> d
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate,double[]) -> a
    double[] getHalfAxes() -> a
    geogebra.common.kernel.geos.GeoLine[] getLines() -> a
    geogebra.common.kernel.geos.GeoPoint getSinglePoint() -> a
    geogebra.common.awt.GAffineTransform getAffineTransform() -> a
    void setAffineTransform() -> I
    geogebra.common.kernel.geos.GeoVec2D getTranslationVector() -> a
    double getCircleRadius() -> l
    void coordsEVtoRW(geogebra.common.kernel.geos.GeoPoint) -> b
    void coordsRWtoEV(geogebra.common.kernel.geos.GeoPoint) -> a
    double[] getMatrix() -> b
    void setMatrix(double[]) -> b
    void setDegenerateMatrixFromArray(double[]) -> c
    void setMatrix(double[][]) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoSegment) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCircleMatrix(geogebra.common.kernel.geos.GeoPoint,double) -> b
    void setParabola(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> a
    void setEllipseHyperbola(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void translate(double,double) -> a
    void doTranslate(geogebra.common.kernel.Matrix.Coords) -> c
    void doTranslate(double,double) -> b
    void translateMatrix(double[],double,double) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> b
    boolean isMatrixTransformable() -> s_
    void matrixTransform(double,double,double,double) -> a
    void rotate(double) -> a
    void rotateMatrix(double[],double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint) -> a
    void doDilate(double) -> b
    void updateDegenerates() -> J
    void setEigenvectors(double,double,double,double,double,double) -> b
    void setFirstEigenvector(double[]) -> d
    void setEigenvectors() -> K
    void setParabolicEigenvectors() -> P
    void makePathParametersInvalid() -> Q
    void classifyConic() -> R
    void classifyConic(boolean) -> g
    boolean isDetSzero() -> P
    void classifyMidpointConic(boolean) -> b
    void singlePoint() -> L
    void intersectingLines(double[]) -> g
    void ellipse(double[]) -> h
    void hyperbola(double[]) -> i
    void classifyParabolicConic(boolean) -> e
    void doubleLine() -> S
    void enforceDoubleLine() -> M
    void handleSzero() -> T
    void parallelLines(double[]) -> e
    void setStartPointsForLines() -> U
    void parabola() -> V
    boolean hasPositiveEigenvectorOrientation() -> X
    void setPositiveEigenvectorOrientation(boolean) -> h
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint,double) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    double evaluate(double,double) -> a
    void polarLine(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoLine) -> b
    void diameterLine(geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoLine) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getSpecificEquation() -> e
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> f
    boolean isTextValue() -> g
    boolean isGeoConic() -> aP
    void setZero() -> f_
    boolean isVector3DValue() -> b_
    void setMidpoint(double[]) -> f
    boolean isRegion() -> ad
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    double evaluateInSignificantPoint() -> m
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void moveBackToRegion(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.RegionParameters) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void toGeoImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    boolean keepsType() -> Y
    double distance(geogebra.common.kernel.geos.GeoPoint) -> a
    java.lang.String getTypeString() -> a
    double getArea() -> h
    void doRemove() -> b
    void setLastHitType(geogebra.common.kernel.kernelND.GeoConicND$HitType) -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType getLastHitType() -> a
    java.lang.String getTypeStringForAlgebraView() -> r
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.kernelND.GeoConicND$HitType -> geogebra.common.i.m.e$a:
    geogebra.common.kernel.kernelND.GeoConicND$HitType NONE -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType ON_BOUNDARY -> b
    geogebra.common.kernel.kernelND.GeoConicND$HitType ON_FILLING -> c
    geogebra.common.kernel.kernelND.GeoConicND$HitType[] ENUM$VALUES -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType[] values() -> values
    geogebra.common.kernel.kernelND.GeoConicND$HitType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.kernelND.GeoCoordSys1DInterface -> geogebra.common.i.m.f:
geogebra.common.kernel.kernelND.GeoCoordSys2D -> geogebra.common.i.m.g:
geogebra.common.kernel.kernelND.GeoCurveCartesianND -> geogebra.common.i.m.h:
    geogebra.common.kernel.arithmetic.Function[] fun -> a
    double startParam -> b
    double endParam -> c
    boolean isDefined -> g
    boolean isGeoCurveCartesian() -> bg
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setInterval(double,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isPath() -> ac
    boolean isDefined() -> r
    void setDefined(boolean) -> f
    void setUndefined() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.kernelND.GeoDirectionND -> geogebra.common.i.m.i:
geogebra.common.kernel.kernelND.GeoElementND -> geogebra.common.i.m.j:
    void setLabel(java.lang.String) -> e
    void update() -> i
    void setObjColor(geogebra.common.awt.GColor) -> b
    void setEuclidianVisible(boolean) -> d
    boolean isEuclidianVisible() -> ag
    boolean isLabelSet() -> d_
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    boolean isInfinite() -> Z
    void updateVisualStyle() -> y
    void remove() -> c
    boolean getSpreadsheetTrace() -> bl
    boolean isIndependent() -> k
    geogebra.common.kernel.algos.AlgoElement getParentAlgorithm() -> a
    boolean isDefined() -> r
    void setUndefined() -> e
    void setLineType(int) -> m
    void setLineThickness(int) -> l
    boolean isPointOnPath() -> au
    boolean isPointInRegion() -> br
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void updateCascade() -> h
    void updateRepaint() -> x
    int getLineType() -> t
    int getLineThickness() -> r
    boolean isInverseFill() -> bv
    double getAnimationStep() -> i
    int getConstructionIndex() -> b
    geogebra.common.kernel.algos.AlgorithmSet getAlgoUpdateSet() -> a
    boolean hasAlgoUpdateSet() -> aE
    boolean isGeoText() -> be
geogebra.common.kernel.kernelND.GeoLevelOfDetail -> geogebra.common.i.m.k:
    geogebra.common.kernel.kernelND.LevelOfDetail getLevelOfDetail() -> a
geogebra.common.kernel.kernelND.GeoLineND -> geogebra.common.i.m.l:
    boolean getTrace() -> F
    geogebra.common.kernel.Matrix.Coords getCartesianEquationVector(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getStartInhomCoords() -> b
    geogebra.common.kernel.Matrix.Coords getEndInhomCoords() -> c
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    geogebra.common.kernel.kernelND.GeoPointND getEndPoint() -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void addPointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> c
geogebra.common.kernel.kernelND.GeoPlaneND -> geogebra.common.i.m.m:
    void setFading(float) -> a
    float getFading() -> a
geogebra.common.kernel.kernelND.GeoPointND -> geogebra.common.i.m.n:
    boolean hasChangeableCoordParentNumbers() -> bj
    geogebra.common.kernel.RegionParameters getRegionParameters() -> a
    void updateCoords2D() -> g
    double getX2D() -> e
    double getY2D() -> f
    void updateCoordsFrom2D(boolean,geogebra.common.kernel.Matrix.CoordSys) -> a
    int getMode() -> d
    boolean isFinite() -> R
    void set(geogebra.common.kernel.kernelND.GeoPointND) -> c
    java.lang.String getStartPointXML() -> d
    geogebra.common.kernel.LocateableList getLocateableList() -> a
    double[] vectorTo(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> b
    void getInhomCoords(double[]) -> a_
    boolean hasPath() -> Q
    geogebra.common.kernel.PathParameter getPathParameter() -> a
    void setCoords(double,double,double) -> a
    void setCoords(double,double,double,double) -> b
    void setCoords(geogebra.common.kernel.Matrix.Coords,boolean) -> a
    void setCoords2D(double,double,double) -> b
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> b
    geogebra.common.kernel.Matrix.Coords getCoordsInD2(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Path getPath() -> a
    void updateCoords() -> d
    void showUndefinedInAlgebraView(boolean) -> e
    geogebra.common.kernel.kernelND.GeoPointND copy() -> a
    boolean isAbsoluteStartPoint() -> S
    boolean showInEuclidianView() -> e_
    boolean getTrace() -> F
    int getDimension() -> c
geogebra.common.kernel.kernelND.GeoPolygon3DInterface -> geogebra.common.i.m.o:
geogebra.common.kernel.kernelND.GeoQuadric3DInterface -> geogebra.common.i.m.p:
geogebra.common.kernel.kernelND.GeoQuadricND -> geogebra.common.i.m.q:
    int dimension -> m
    int matrixDim -> n
    int type -> l
    double[] matrix -> b
    double[] halfAxes -> c
    double linearEccentricity -> e
    double eccentricity -> f
    double p -> g
    boolean defined -> i
    geogebra.common.kernel.Matrix.Coords midpoint -> a
    geogebra.common.kernel.Matrix.Coords[] eigenvecND -> a
    char[] VAR_STRING -> a
    geogebra.common.kernel.geos.ChangeableCoordParent changeableCoordParent -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void setSphereND(geogebra.common.kernel.Matrix.Coords,double) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setSphereNDMatrix(geogebra.common.kernel.Matrix.Coords,double) -> b
    void empty() -> N
    void setUndefined() -> e
    void setDefined() -> O
    void setMidpoint(double[]) -> f
    geogebra.common.kernel.Matrix.Coords getMidpoint2D() -> b
    geogebra.common.kernel.Matrix.Coords getMidpoint() -> c
    geogebra.common.kernel.Matrix.Coords getMidpoint3D() -> d
    double getHalfAxis(int) -> a
    boolean isDefined() -> r
    int getType() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void buildSphereNDString(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    void setFirstEigenvector(double[]) -> d
    void setEigenvectors() -> K
    void singlePoint() -> L
    void setAffineTransform() -> I
    void setChangeableCoordParent(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoElement) -> a
    boolean hasChangeableCoordParentNumbers() -> bj
    void recordChangeableCoordParentNumbers() -> B
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.kernelND.GeoRayND -> geogebra.common.i.m.r:
geogebra.common.kernel.kernelND.GeoSegmentND -> geogebra.common.i.m.s:
    double getLength() -> c
    geogebra.common.kernel.geos.GeoElement getStartPointAsGeoElement() -> c
    geogebra.common.kernel.geos.GeoElement getEndPointAsGeoElement() -> i
    double getPointX(double) -> b
    double getPointY(double) -> c
geogebra.common.kernel.kernelND.GeoVectorND -> geogebra.common.i.m.t:
    void setLabel(java.lang.String) -> e
    void setUndefined() -> e
    void setCoords(double[]) -> b
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> a
    boolean getTrace() -> F
geogebra.common.kernel.kernelND.LevelOfDetail -> geogebra.common.i.m.u:
    int LEVEL_OF_DETAIL_DEFAULT -> a
    int value -> b
    void setValue(int) -> a
    int getValue() -> a
geogebra.common.kernel.kernelND.Region3D -> geogebra.common.i.m.v:
geogebra.common.kernel.kernelND.ViewCreator -> geogebra.common.i.m.w:
    void createView2D() -> a
geogebra.common.kernel.locusequ.AlgoLocusEquation -> geogebra.common.i.n.a:
    geogebra.common.kernel.geos.GeoPoint movingPoint -> a
    geogebra.common.kernel.geos.GeoPoint locusPoint -> b
    geogebra.common.kernel.implicit.GeoImplicitPoly geoPoly -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    void setInputOutput() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getPoly() -> a
    void compute() -> b
    geogebra.common.kernel.locusequ.EquationSystem getOriginalIdeal() -> a
    void addAlgoIfNotVisited(geogebra.common.kernel.locusequ.EquationList,geogebra.common.kernel.algos.AlgoElement,geogebra.common.kernel.locusequ.EquationScope,java.util.Set) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.locusequ.CmdLocusEquation -> geogebra.common.i.n.b:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly LocusEquation(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
geogebra.common.kernel.locusequ.EquationAuxiliarSymbolicPoint -> geogebra.common.i.n.c:
    java.util.List incidences -> a
    boolean addIncidence(geogebra.common.kernel.locusequ.EquationElement) -> a
    geogebra.common.kernel.locusequ.EquationList getRestrictions() -> a
geogebra.common.kernel.locusequ.EquationDependentPoint -> geogebra.common.i.n.d:
    geogebra.common.kernel.geos.GeoPoint p -> a
geogebra.common.kernel.locusequ.EquationElement -> geogebra.common.i.n.e:
    geogebra.common.kernel.geos.GeoElement result -> a
    geogebra.common.kernel.locusequ.EquationScope scope -> a
    geogebra.common.kernel.locusequ.EquationAuxiliarSymbolicPoint getNewIncidentPoint() -> a
    geogebra.common.kernel.locusequ.EquationScope getScope() -> a
    void setScope(geogebra.common.kernel.locusequ.EquationScope) -> a
    geogebra.common.kernel.locusequ.EquationList forPoint(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.locusequ.EquationScope) -> a
    geogebra.common.kernel.locusequ.EquationList forPoint(geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void setResult(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.locusequ.EquationElementMap -> geogebra.common.i.n.f:
    java.util.Map container -> a
    geogebra.common.kernel.locusequ.EquationScope scope -> a
    geogebra.common.kernel.locusequ.EquationElement get(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.locusequ.EquationElement put(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.locusequ.EquationElement) -> a
    geogebra.common.kernel.locusequ.EquationElement getOrCreate(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.algos.EquationElementInterface createEquationElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.locusequ.EquationFreePoint -> geogebra.common.i.n.g:
    geogebra.common.kernel.locusequ.arith.EquationNumericValue x -> a
    geogebra.common.kernel.locusequ.arith.EquationNumericValue y -> b
    geogebra.common.kernel.locusequ.arith.EquationNumericValue z -> c
    geogebra.common.kernel.geos.GeoPoint p -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
    boolean isIndependent() -> a
geogebra.common.kernel.locusequ.EquationHelpers -> geogebra.common.i.n.h:
    geogebra.common.kernel.geos.GeoPoint[] getDependentPredecessorPointsForElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.locusequ.EquationList -> geogebra.common.i.n.i:
    geogebra.common.kernel.locusequ.EquationList emptyList -> a
    boolean isAlgebraic -> a
    geogebra.common.kernel.locusequ.arith.Equation set(int,geogebra.common.kernel.locusequ.arith.Equation) -> a
    boolean add(geogebra.common.kernel.locusequ.arith.Equation) -> a
    void add(int,geogebra.common.kernel.locusequ.arith.Equation) -> a
    geogebra.common.kernel.locusequ.arith.Equation remove(int) -> a
    boolean remove(java.lang.Object) -> remove
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void updateAlgebraic() -> a
    geogebra.common.kernel.locusequ.EquationList getEmptyList() -> a
    void setAlgebraic(boolean) -> a
    void add(int,java.lang.Object) -> add
    boolean add(java.lang.Object) -> add
    java.lang.Object set(int,java.lang.Object) -> set
    java.lang.Object remove(int) -> remove
geogebra.common.kernel.locusequ.EquationList$EmptyEquationList -> geogebra.common.i.n.i$a:
    geogebra.common.kernel.locusequ.arith.Equation set(int,geogebra.common.kernel.locusequ.arith.Equation) -> a
    boolean add(geogebra.common.kernel.locusequ.arith.Equation) -> a
    void add(int,geogebra.common.kernel.locusequ.arith.Equation) -> a
    geogebra.common.kernel.locusequ.arith.Equation remove(int) -> a
    boolean remove(java.lang.Object) -> remove
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
geogebra.common.kernel.locusequ.EquationMidpoint -> geogebra.common.i.n.j:
    geogebra.common.kernel.locusequ.EquationPoint a -> a
    geogebra.common.kernel.locusequ.EquationPoint b -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
    boolean isIndependent() -> a
geogebra.common.kernel.locusequ.EquationNormalPoint -> geogebra.common.i.n.k:
    geogebra.common.kernel.locusequ.EquationPoint point -> a
    boolean isIndependent() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.EquationPoint -> geogebra.common.i.n.l:
    geogebra.common.kernel.locusequ.arith.EquationExpression xExpr -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression yExpr -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression zExpr -> c
    geogebra.common.kernel.locusequ.EquationPoint ORIGIN -> b
    geogebra.common.kernel.locusequ.EquationPoint fromCoordinates(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.EquationPoint fromCoordinates(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    boolean isIndependent() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getX() -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getY() -> e
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getZ() -> f
geogebra.common.kernel.locusequ.EquationPoint$1 -> geogebra.common.i.n.m:
    boolean isIndependent() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.EquationPoint$2 -> geogebra.common.i.n.n:
    geogebra.common.kernel.locusequ.arith.EquationExpression val$x -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression val$y -> e
    geogebra.common.kernel.locusequ.arith.EquationExpression val$z -> f
    boolean isIndependent() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.EquationPointMap -> geogebra.common.i.n.o:
    geogebra.common.kernel.geos.GeoPoint locusPoint -> a
    geogebra.common.kernel.geos.GeoPoint movingPoint -> b
    int curInd -> a
    java.util.Map container -> a
    java.util.Map identifications -> b
    geogebra.common.kernel.locusequ.EquationScope scope -> a
    geogebra.common.kernel.locusequ.EquationPoint get(geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.locusequ.EquationPoint getOrCreate(geogebra.common.kernel.geos.GeoPoint) -> b
    geogebra.common.kernel.locusequ.EquationPoint constructEquationPoint(geogebra.common.kernel.geos.GeoPoint) -> c
    boolean mustTakeNumericCoordinates(geogebra.common.kernel.geos.GeoPoint) -> a
    boolean isAuxiliarPointOnAPolygon(geogebra.common.kernel.geos.GeoPoint) -> e
    boolean isIntersectionOfAxis(geogebra.common.kernel.geos.GeoPoint) -> b
    boolean isPointOnPath(geogebra.common.kernel.geos.GeoPoint) -> c
    boolean hasMovingPointAsPredecessor(geogebra.common.kernel.geos.GeoPoint) -> d
    geogebra.common.kernel.algos.Algos getParentAlgorithmName(geogebra.common.kernel.geos.GeoPoint) -> a
    void put(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.locusequ.EquationPoint) -> a
geogebra.common.kernel.locusequ.EquationRestriction -> geogebra.common.i.n.p:
    geogebra.common.kernel.algos.AlgoElement algo -> a
    geogebra.common.kernel.locusequ.EquationList equationList -> a
    geogebra.common.kernel.algos.AlgoElement getAlgo() -> a
    void setEquationList(geogebra.common.kernel.locusequ.EquationList) -> a
    geogebra.common.kernel.locusequ.EquationList getEquationList() -> a
    void computeEquationList() -> a
    geogebra.common.kernel.geos.GeoPoint getResult() -> a
    geogebra.common.kernel.locusequ.EquationElement getEmptyRestriction() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.locusequ.EquationRestriction$1 -> geogebra.common.i.n.q:
    boolean isAlgebraic() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    void computeEquationList() -> a
geogebra.common.kernel.locusequ.EquationScope -> geogebra.common.i.n.r:
    geogebra.common.kernel.locusequ.EquationPointMap pointMap -> a
    geogebra.common.kernel.locusequ.EquationElementMap elementsMap -> a
    java.util.Set auxiliarPoints -> a
    int auxPointIndex -> a
    void initAuxiliarPoints() -> a
    geogebra.common.kernel.locusequ.EquationPoint getPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.locusequ.EquationElement getElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.locusequ.EquationList getRestrictionsFromAlgo(geogebra.common.kernel.algos.AlgoElement) -> a
    void addPoint(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.EquationAuxiliarSymbolicPoint getNewAuxiliarPoint() -> a
    void registerAuxiliarPoint(geogebra.common.kernel.locusequ.EquationAuxiliarSymbolicPoint) -> a
    java.util.Set getAuxiliarSymbolicPoints() -> a
geogebra.common.kernel.locusequ.EquationSpecialSymbolicPoint -> geogebra.common.i.n.s:
    geogebra.common.kernel.geos.GeoPoint p -> a
geogebra.common.kernel.locusequ.EquationSymbolicPoint -> geogebra.common.i.n.t:
    java.lang.String DEPENDENT_POINT_ID -> a
    java.lang.String SPECIAL_SYMBOLIC_ID -> b
    java.lang.String AUXILIAR_SYMBOLIC_ID -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression x -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression y -> e
    geogebra.common.kernel.locusequ.arith.EquationExpression z -> f
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.EquationSystem -> geogebra.common.i.n.u:
    geogebra.common.kernel.locusequ.EquationList el -> a
    geogebra.common.kernel.locusequ.EquationScope scope -> a
    geogebra.common.kernel.locusequ.EquationList getEquations() -> a
geogebra.common.kernel.locusequ.EquationTranslator -> geogebra.common.i.n.v:
    java.util.Map container -> a
    geogebra.common.kernel.locusequ.EquationSystem system -> a
    void setSystem(geogebra.common.kernel.locusequ.EquationSystem) -> a
    java.util.Collection translate(geogebra.common.kernel.locusequ.EquationSystem) -> a
    geogebra.common.kernel.locusequ.EquationSystem getSystem() -> a
    java.lang.Object sum(java.lang.Object,java.lang.Object) -> a
    java.lang.Object diff(java.lang.Object,java.lang.Object) -> b
    java.lang.Object product(java.lang.Object,java.lang.Object) -> c
    java.lang.Object div(java.lang.Object,java.lang.Object) -> d
    java.lang.Object exp(java.lang.Object,long) -> a
    java.lang.Object number(double) -> a
    java.lang.Object auxiliarSymbolic(int) -> a
    java.lang.Object specialSymbolic(int) -> b
    java.lang.Object symbolic(int) -> c
    java.lang.Object opposite(java.lang.Object) -> a
    java.lang.Object sqrt(java.lang.Object) -> b
    double[][] eliminateSystem(geogebra.common.kernel.locusequ.EquationSystem) -> a
    double[][] eliminate(java.util.Collection) -> a
geogebra.common.kernel.locusequ.EquationUnitaryPoint -> geogebra.common.i.n.w:
    geogebra.common.kernel.locusequ.EquationPoint point -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression module -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.MPReducePolynomialParser -> geogebra.common.i.n.x:
    double[][] parsePolynomial(java.lang.String,geogebra.common.cas.GeoGebraCAS) -> a
    double[][] mapToArray(java.util.Map) -> a
    void addCoefficients(java.util.Map,int,int,double) -> a
geogebra.common.kernel.locusequ.MPReduceTranslator -> geogebra.common.i.n.y:
    java.util.Set varsToEliminate -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.String getVarsToEliminate() -> a
    java.lang.String getVars() -> b
    java.util.Collection translate(geogebra.common.kernel.locusequ.EquationSystem) -> a
    java.lang.StringBuilder sum(java.lang.StringBuilder,java.lang.StringBuilder) -> a
    java.lang.StringBuilder diff(java.lang.StringBuilder,java.lang.StringBuilder) -> b
    java.lang.StringBuilder product(java.lang.StringBuilder,java.lang.StringBuilder) -> c
    java.lang.StringBuilder div(java.lang.StringBuilder,java.lang.StringBuilder) -> d
    java.lang.StringBuilder exp(java.lang.StringBuilder,long) -> a
    java.lang.StringBuilder number(double) -> a
    java.lang.StringBuilder auxiliarSymbolic(int) -> a
    java.lang.StringBuilder specialSymbolic(int) -> b
    java.lang.StringBuilder symbolic(int) -> c
    java.lang.StringBuilder opposite(java.lang.StringBuilder) -> a
    java.lang.StringBuilder sqrt(java.lang.StringBuilder) -> b
    double[][] eliminate(java.util.Collection) -> a
    double[][] getCoefficientsFromResult(java.lang.String,geogebra.common.cas.GeoGebraCAS) -> a
    double[][] simplifyResult(double[][]) -> a
    double[][] parseResult(java.lang.String,geogebra.common.cas.GeoGebraCAS) -> b
    java.lang.String getResultFromRaw(java.lang.String) -> b
    java.lang.String createMPReduceScript(java.util.Collection) -> a
    java.lang.String constructRestrictions(java.util.Collection) -> b
    java.lang.String convertFloatsToRationals(java.lang.String) -> a
    java.lang.Object auxiliarSymbolic(int) -> a
    java.lang.Object exp(java.lang.Object,long) -> a
    java.lang.Object specialSymbolic(int) -> b
    java.lang.Object symbolic(int) -> c
    java.lang.Object opposite(java.lang.Object) -> a
    java.lang.Object sqrt(java.lang.Object) -> b
    java.lang.Object number(double) -> a
    java.lang.Object diff(java.lang.Object,java.lang.Object) -> b
    java.lang.Object product(java.lang.Object,java.lang.Object) -> c
    java.lang.Object div(java.lang.Object,java.lang.Object) -> d
    java.lang.Object sum(java.lang.Object,java.lang.Object) -> a
geogebra.common.kernel.locusequ.SumVector -> geogebra.common.i.n.z:
    geogebra.common.kernel.locusequ.SymbolicVector vector1 -> a
    geogebra.common.kernel.locusequ.SymbolicVector vector2 -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
geogebra.common.kernel.locusequ.SymbolicVector -> geogebra.common.i.n.A:
    geogebra.common.kernel.locusequ.EquationPoint a -> a
    geogebra.common.kernel.locusequ.EquationPoint b -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression module -> d
    geogebra.common.kernel.locusequ.SymbolicVector normal -> a
    geogebra.common.kernel.locusequ.SymbolicVector unitary -> b
    geogebra.common.kernel.locusequ.SymbolicVector normal() -> a
    geogebra.common.kernel.locusequ.SymbolicVector getNormal() -> b
    boolean isFirstCoordinateZero() -> b
    boolean isSecondCoordinateZero() -> c
    boolean isIndependent() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getXExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getYExpression() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getZExpression() -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getModule() -> g
    geogebra.common.kernel.locusequ.SymbolicVector getUnitary() -> c
    geogebra.common.kernel.locusequ.SymbolicVector getBisector(geogebra.common.kernel.locusequ.SymbolicVector) -> a
    geogebra.common.kernel.locusequ.SymbolicVector sum(geogebra.common.kernel.locusequ.SymbolicVector) -> b
geogebra.common.kernel.locusequ.arith.Equation -> geogebra.common.i.n.a.a:
    geogebra.common.kernel.locusequ.arith.EquationExpression equ -> a
    boolean algebraic -> a
    boolean isAlgebraic() -> a
    geogebra.common.kernel.locusequ.EquationList toList() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getExpression() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.locusequ.arith.EquationArithHelper -> geogebra.common.i.n.a.b:
    geogebra.common.kernel.locusequ.arith.Equation equation(geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression sqr(geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression dbl(geogebra.common.kernel.locusequ.arith.EquationExpression) -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression sqrt(geogebra.common.kernel.locusequ.arith.EquationExpression) -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression pow(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression half(geogebra.common.kernel.locusequ.arith.EquationExpression) -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression mid(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression middle(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression det3(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression det4(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression det5(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression sum(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression sumRaw(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression diff(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression times(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression timesRaw(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> e
    geogebra.common.kernel.locusequ.arith.EquationExpression div(geogebra.common.kernel.locusequ.arith.EquationExpression,geogebra.common.kernel.locusequ.arith.EquationExpression) -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression dist(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression dist2(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint) -> b
geogebra.common.kernel.locusequ.arith.EquationAuxiliarSymbolicValue -> geogebra.common.i.n.a.c:
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.locusequ.arith.EquationBinaryOperator -> geogebra.common.i.n.a.d:
    geogebra.common.kernel.locusequ.arith.EquationExpression getFirstExpression() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getSecondExpression() -> b
    double operation(double,double) -> a
    double computeValueImpl() -> a
geogebra.common.kernel.locusequ.arith.EquationCoordinateValue -> geogebra.common.i.n.a.e:
    geogebra.common.kernel.locusequ.EquationPoint point -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getOriginalExpression() -> a
    geogebra.common.kernel.locusequ.EquationPoint getPoint() -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
    boolean isNumericValue() -> a
    boolean containsSymbolicValuesImpl() -> b
    double computeValueImpl() -> a
geogebra.common.kernel.locusequ.arith.EquationDiffOperator -> geogebra.common.i.n.a.f:
    long toLong() -> a
    java.lang.String toString() -> toString
    double operation(double,double) -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationDivOperator -> geogebra.common.i.n.a.g:
    geogebra.common.kernel.locusequ.arith.EquationExpression getNumerator() -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getDenominator() -> d
    long toLong() -> a
    java.lang.String toString() -> toString
    double operation(double,double) -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationExpOperator -> geogebra.common.i.n.a.h:
    geogebra.common.kernel.locusequ.arith.EquationExpression getBase() -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getExp() -> d
    long toLong() -> a
    java.lang.String toString() -> toString
    double operation(double,double) -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationExpression -> geogebra.common.i.n.a.i:
    geogebra.common.kernel.locusequ.arith.EquationExpression opposite -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression inverse -> b
    java.lang.Boolean containsSymbolicValues -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getOpposite() -> e
    boolean isNumericValue() -> a
    boolean containsSymbolicValues() -> c
    boolean containsSymbolicValuesImpl() -> b
    double computeValue() -> b
    double computeValueImpl() -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    java.lang.Object translate(geogebra.common.kernel.locusequ.EquationTranslator) -> b
    long toLong() -> a
    boolean isSimplifiable() -> d
    java.lang.String toString() -> toString
geogebra.common.kernel.locusequ.arith.EquationFirstCoordinateValue -> geogebra.common.i.n.a.j:
    geogebra.common.kernel.locusequ.arith.EquationExpression getOriginalExpression() -> a
geogebra.common.kernel.locusequ.arith.EquationNumericValue -> geogebra.common.i.n.a.k:
    double value -> a
    geogebra.common.kernel.locusequ.arith.EquationNumericValue ZERO -> a
    geogebra.common.kernel.locusequ.arith.EquationNumericValue ONE -> b
    geogebra.common.kernel.locusequ.arith.EquationNumericValue TWO -> c
    geogebra.common.kernel.locusequ.arith.EquationNumericValue from(double) -> a
    double getValue() -> c
    boolean isNumericValue() -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
    boolean containsSymbolicValuesImpl() -> b
    double computeValueImpl() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getOpposite() -> e
geogebra.common.kernel.locusequ.arith.EquationOperator -> geogebra.common.i.n.a.l:
    geogebra.common.kernel.locusequ.arith.EquationExpression[] exprs -> a
    boolean containsSymbolicValuesImpl() -> b
geogebra.common.kernel.locusequ.arith.EquationOppositeOperator -> geogebra.common.i.n.a.m:
    geogebra.common.kernel.locusequ.arith.EquationExpression getOpposite() -> e
    double operation(double) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationProductOperator -> geogebra.common.i.n.a.n:
    long toLong() -> a
    java.lang.String toString() -> toString
    double operation(double,double) -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationSecondCoordinateValue -> geogebra.common.i.n.a.o:
    geogebra.common.kernel.locusequ.arith.EquationExpression getOriginalExpression() -> a
geogebra.common.kernel.locusequ.arith.EquationSpecialSymbolicValue -> geogebra.common.i.n.a.p:
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.locusequ.arith.EquationSqrtOperator -> geogebra.common.i.n.a.q:
    double operation(double) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationSumOperator -> geogebra.common.i.n.a.r:
    long toLong() -> a
    java.lang.String toString() -> toString
    double operation(double,double) -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
geogebra.common.kernel.locusequ.arith.EquationSymbolicValue -> geogebra.common.i.n.a.s:
    int id -> a
    int getId() -> a
    java.lang.Object translateImpl(geogebra.common.kernel.locusequ.EquationTranslator) -> a
    long toLong() -> a
    java.lang.String toString() -> toString
    boolean containsSymbolicValuesImpl() -> b
    double computeValueImpl() -> a
geogebra.common.kernel.locusequ.arith.EquationThirdCoordinateValue -> geogebra.common.i.n.a.t:
    geogebra.common.kernel.locusequ.arith.EquationExpression getOriginalExpression() -> a
geogebra.common.kernel.locusequ.arith.EquationUnaryOperator -> geogebra.common.i.n.a.u:
    geogebra.common.kernel.locusequ.arith.EquationExpression getOriginalExpression() -> a
    boolean containsSymbolicValuesImpl() -> b
    double operation(double) -> a
    double computeValueImpl() -> a
geogebra.common.kernel.locusequ.arith.EquationValue -> geogebra.common.i.n.a.v:
geogebra.common.kernel.locusequ.elements.EquationAngularBisectorLines -> geogebra.common.i.n.b.a:
geogebra.common.kernel.locusequ.elements.EquationAngularBisectorPoints -> geogebra.common.i.n.b.b:
geogebra.common.kernel.locusequ.elements.EquationCirclePointRadius -> geogebra.common.i.n.b.c:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationCircleThreePoints -> geogebra.common.i.n.b.d:
    geogebra.common.kernel.geos.GeoPoint p -> a
    geogebra.common.kernel.geos.GeoPoint q -> b
    geogebra.common.kernel.geos.GeoPoint r -> c
    geogebra.common.kernel.locusequ.EquationPoint pequ -> a
    geogebra.common.kernel.locusequ.EquationPoint qequ -> b
    geogebra.common.kernel.locusequ.EquationPoint requ -> c
    boolean isAlgebraic() -> a
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationCircleTwoPoints -> geogebra.common.i.n.b.e:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationConicFivePoints -> geogebra.common.i.n.b.f:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationConicPartCircle -> geogebra.common.i.n.b.g:
    void computeMatrix() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
geogebra.common.kernel.locusequ.elements.EquationConicPartCircumcircle -> geogebra.common.i.n.b.h:
    void computeMatrix() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
geogebra.common.kernel.locusequ.elements.EquationDiameterLine -> geogebra.common.i.n.b.i:
geogebra.common.kernel.locusequ.elements.EquationEllipseFociLength -> geogebra.common.i.n.b.j:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationEllipseFociPoint -> geogebra.common.i.n.b.k:
    geogebra.common.kernel.geos.GeoPoint f1 -> a
    geogebra.common.kernel.geos.GeoPoint f2 -> b
    geogebra.common.kernel.geos.GeoPoint ep -> c
    geogebra.common.kernel.locusequ.EquationPoint ef1 -> a
    geogebra.common.kernel.locusequ.EquationPoint ef2 -> b
    geogebra.common.kernel.locusequ.EquationPoint eep -> c
    geogebra.common.kernel.locusequ.EquationPoint center -> d
    geogebra.common.kernel.locusequ.arith.EquationExpression distance -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression a2 -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression b2 -> c
    geogebra.common.kernel.locusequ.SymbolicVector ev1 -> a
    geogebra.common.kernel.locusequ.SymbolicVector ev2 -> b
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationGenericAngularBisector -> geogebra.common.i.n.b.l:
    void setVectors(geogebra.common.kernel.locusequ.SymbolicVector,geogebra.common.kernel.locusequ.SymbolicVector) -> a
geogebra.common.kernel.locusequ.elements.EquationGenericBisector -> geogebra.common.i.n.b.m:
    void setExtremePoints(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void setExtremePoints(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint) -> a
geogebra.common.kernel.locusequ.elements.EquationGenericConic -> geogebra.common.i.n.b.n:
    geogebra.common.kernel.locusequ.arith.EquationExpression[] matrix -> a
    java.util.Map polarLines -> a
    void setMatrix(geogebra.common.kernel.locusequ.arith.EquationExpression[]) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression[] getMatrix() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression[] getPolarLineCoefficientsFor(geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.elements.EquationPolarLine getPolarLine(geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression[] matrixForCircle(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression[] matrixForCircle(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression ssqr(geogebra.common.kernel.locusequ.EquationPoint) -> a
    void setEllipseHyperbola(geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.EquationPoint,geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
geogebra.common.kernel.locusequ.elements.EquationGenericConicPart -> geogebra.common.i.n.b.o:
    boolean isAlgebraic() -> a
    boolean isSector() -> b
    geogebra.common.kernel.locusequ.EquationList orAllExpressions(geogebra.common.kernel.locusequ.EquationList) -> a
geogebra.common.kernel.locusequ.elements.EquationGenericLine -> geogebra.common.i.n.b.p:
    geogebra.common.kernel.locusequ.SymbolicVector vector -> a
    geogebra.common.kernel.locusequ.EquationPoint pequ -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression a -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression b -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression c -> c
    void setPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void setPoint(geogebra.common.kernel.locusequ.EquationPoint) -> a
    geogebra.common.kernel.locusequ.EquationPoint getEquationPoint() -> a
    geogebra.common.kernel.locusequ.SymbolicVector getVector() -> a
    void setVector(geogebra.common.kernel.locusequ.SymbolicVector) -> a
    boolean isHorizonta() -> b
    boolean isVertical() -> c
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
    void setA(geogebra.common.kernel.locusequ.arith.EquationExpression) -> a
    void setB(geogebra.common.kernel.locusequ.arith.EquationExpression) -> b
    void setC(geogebra.common.kernel.locusequ.arith.EquationExpression) -> c
    geogebra.common.kernel.locusequ.arith.EquationExpression getA() -> a
    geogebra.common.kernel.locusequ.arith.EquationExpression getB() -> b
    geogebra.common.kernel.locusequ.arith.EquationExpression getC() -> c
    geogebra.common.kernel.locusequ.SymbolicVector getVectorFromABC() -> b
geogebra.common.kernel.locusequ.elements.EquationGenericMidpointRestriction -> geogebra.common.i.n.b.q:
    geogebra.common.kernel.geos.GeoPoint firstEnd -> a
    geogebra.common.kernel.geos.GeoPoint secondEnd -> b
    geogebra.common.kernel.geos.GeoPoint midpoint -> c
    void setEnds(geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void setMidpoint(geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
    geogebra.common.kernel.geos.GeoPoint getFirstEnd() -> b
    geogebra.common.kernel.geos.GeoPoint getSecondEnd() -> c
    geogebra.common.kernel.geos.GeoPoint getMidpoint() -> d
geogebra.common.kernel.locusequ.elements.EquationGenericPolygon -> geogebra.common.i.n.b.r:
    geogebra.common.kernel.geos.GeoSegment[] segments -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    geogebra.common.kernel.geos.GeoSegment[] getSegments() -> a
    void setSegments(geogebra.common.kernel.kernelND.GeoSegmentND[]) -> a
    boolean isAlgebraic() -> a
geogebra.common.kernel.locusequ.elements.EquationGenericRay -> geogebra.common.i.n.b.s:
    boolean isAlgebraic() -> a
geogebra.common.kernel.locusequ.elements.EquationGenericSegment -> geogebra.common.i.n.b.t:
    boolean isAlgebraic() -> a
geogebra.common.kernel.locusequ.elements.EquationHyperbolaFociLength -> geogebra.common.i.n.b.u:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationHyperbolaFociPoint -> geogebra.common.i.n.b.v:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationIntersectConicsRestriction -> geogebra.common.i.n.b.w:
    geogebra.common.kernel.locusequ.EquationElement firstConic -> a
    geogebra.common.kernel.locusequ.EquationElement secondConic -> b
    geogebra.common.kernel.algos.AlgoIntersectConics getAlgo() -> a
    geogebra.common.kernel.locusequ.EquationElement getFirstConic() -> b
    geogebra.common.kernel.locusequ.EquationElement getSecondConic() -> c
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    geogebra.common.kernel.algos.AlgoIntersect getAlgo() -> a
geogebra.common.kernel.locusequ.elements.EquationIntersectLineConicRestriction -> geogebra.common.i.n.b.x:
    geogebra.common.kernel.locusequ.EquationElement line -> a
    geogebra.common.kernel.locusequ.EquationElement conic -> b
    geogebra.common.kernel.algos.AlgoIntersectLineConic getAlgo() -> a
    geogebra.common.kernel.locusequ.EquationElement getLine() -> b
    geogebra.common.kernel.locusequ.EquationElement getConic() -> c
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    geogebra.common.kernel.algos.AlgoIntersect getAlgo() -> a
geogebra.common.kernel.locusequ.elements.EquationIntersectLinesRestriction -> geogebra.common.i.n.b.y:
    geogebra.common.kernel.algos.AlgoIntersectLines getAlgo() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
    geogebra.common.kernel.algos.AlgoElement getAlgo() -> a
geogebra.common.kernel.locusequ.elements.EquationIntersectRestriction -> geogebra.common.i.n.b.z:
    geogebra.common.kernel.algos.AlgoIntersect getAlgo() -> a
    void computeEquationList() -> a
    boolean isAlgebraic() -> a
    geogebra.common.kernel.algos.AlgoElement getAlgo() -> a
geogebra.common.kernel.locusequ.elements.EquationIntersectSingleRestriction -> geogebra.common.i.n.b.A:
    geogebra.common.kernel.locusequ.EquationRestriction internalRestriction -> a
    void computeEquationList() -> a
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
geogebra.common.kernel.locusequ.elements.EquationJoinPoints -> geogebra.common.i.n.b.B:
    geogebra.common.kernel.geos.GeoPoint q -> a
    geogebra.common.kernel.locusequ.EquationPoint qequ -> a
geogebra.common.kernel.locusequ.elements.EquationJoinPointsRay -> geogebra.common.i.n.b.C:
geogebra.common.kernel.locusequ.elements.EquationJoinPointsSegment -> geogebra.common.i.n.b.D:
    geogebra.common.kernel.geos.GeoPoint q -> a
    geogebra.common.kernel.locusequ.EquationPoint qequ -> a
geogebra.common.kernel.locusequ.elements.EquationLineBisector -> geogebra.common.i.n.b.E:
geogebra.common.kernel.locusequ.elements.EquationLineBisectorSegment -> geogebra.common.i.n.b.F:
    boolean isAlgebraic() -> a
geogebra.common.kernel.locusequ.elements.EquationLinePointLine -> geogebra.common.i.n.b.G:
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.locusequ.elements.EquationGenericLine lequ -> a
geogebra.common.kernel.locusequ.elements.EquationMidpointRestriction -> geogebra.common.i.n.b.H:
geogebra.common.kernel.locusequ.elements.EquationMidpointSegmentRestriction -> geogebra.common.i.n.b.I:
geogebra.common.kernel.locusequ.elements.EquationOrthoLinePointLine -> geogebra.common.i.n.b.J:
    geogebra.common.kernel.geos.GeoLine lParam -> a
    geogebra.common.kernel.locusequ.elements.EquationGenericLine lParamEqu -> a
geogebra.common.kernel.locusequ.elements.EquationParabolaPointLine -> geogebra.common.i.n.b.K:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationPointOnPathRestriction -> geogebra.common.i.n.b.L:
    geogebra.common.kernel.locusequ.EquationList forPointImpl(geogebra.common.kernel.locusequ.EquationPoint) -> b
    boolean isAlgebraic() -> a
geogebra.common.kernel.locusequ.elements.EquationPolarLine -> geogebra.common.i.n.b.M:
    void getCoefficientsFromConic(geogebra.common.kernel.locusequ.elements.EquationGenericConic,geogebra.common.kernel.locusequ.EquationPoint) -> a
geogebra.common.kernel.locusequ.elements.EquationPolygon -> geogebra.common.i.n.b.N:
geogebra.common.kernel.locusequ.elements.EquationPolygonRegular -> geogebra.common.i.n.b.O:
geogebra.common.kernel.locusequ.elements.EquationSemicircle -> geogebra.common.i.n.b.P:
    void computeMatrix() -> a
geogebra.common.kernel.locusequ.elements.EquationTangentPoint -> geogebra.common.i.n.b.Q:
geogebra.common.kernel.optimization.ExtremumFinder -> geogebra.common.i.o.a:
    int MAX_ITERATIONS -> a
    double findMaximum(double,double,geogebra.common.kernel.roots.RealRootFunction,double) -> a
    double findMinimum(double,double,geogebra.common.kernel.roots.RealRootFunction,double) -> b
geogebra.common.kernel.optimization.FitRealFunction -> geogebra.common.i.o.b:
    geogebra.common.kernel.Kernel kernel -> a
    int numberOfParameters -> a
    java.lang.Object[] gliders -> a
    geogebra.common.kernel.arithmetic.Function newf -> a
    double lastvalue -> a
    geogebra.common.kernel.arithmetic.MyDouble[] mydoubles -> a
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
    void setFunction(geogebra.common.kernel.arithmetic.Function) -> a
    double[] getStartValues() -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
geogebra.common.kernel.optimization.NegativeRealRootFunction -> geogebra.common.i.o.c:
    geogebra.common.kernel.roots.RealRootFunction f -> a
    double evaluate(double) -> a
geogebra.common.kernel.optimization.RealRootFunctionVariable -> geogebra.common.i.o.d:
    geogebra.common.kernel.arithmetic.NumberValue geodep -> a
    geogebra.common.kernel.geos.GeoNumeric geoindep -> a
    double evaluate(double) -> a
geogebra.common.kernel.parser.ParseException -> geogebra.common.i.p.a:
    geogebra.common.kernel.parser.Token currentToken -> a
    int[][] expectedTokenSequences -> a
    java.lang.String[] tokenImage -> a
    java.lang.String eol -> a
    java.lang.String initialise(geogebra.common.kernel.parser.Token,int[][],java.lang.String[]) -> a
    java.lang.String add_escapes(java.lang.String) -> a
geogebra.common.kernel.parser.Parser -> geogebra.common.i.p.b:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    boolean GeoGebraCASParsing -> a
    boolean ExternalCASParsing -> b
    boolean MPReduceParsing -> c
    java.util.ArrayList undecided -> a
    geogebra.common.kernel.parser.ParserTokenManager token_source -> a
    geogebra.common.kernel.parser.SimpleCharStream jj_input_stream -> a
    geogebra.common.kernel.parser.Token token -> a
    geogebra.common.kernel.parser.Token jj_nt -> b
    int jj_ntk -> a
    geogebra.common.kernel.parser.Token jj_scanpos -> c
    geogebra.common.kernel.parser.Token jj_lastpos -> d
    int jj_la -> b
    int jj_gen -> c
    int[] jj_la1 -> a
    int[] jj_la1_0 -> b
    int[] jj_la1_1 -> c
    int[] jj_la1_2 -> d
    geogebra.common.kernel.parser.Parser$JJCalls[] jj_2_rtns -> a
    boolean jj_rescan -> d
    int jj_gc -> d
    geogebra.common.kernel.parser.Parser$LookaheadSuccess jj_ls -> a
    java.util.List jj_expentries -> a
    int[] jj_expentry -> e
    int jj_kind -> e
    int[] jj_lasttokens -> f
    int jj_endpos -> f
    void myReInit(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraExpression(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCAS(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseMPReduce(java.lang.String) -> c
    geogebra.common.kernel.arithmetic.Function parseFunction(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar parseFunctionNVar(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode parseCmdExpression(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode parseExpression(java.lang.String) -> b
    java.lang.String parseLabel(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode makePower(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void processUndecided() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode buildOpNode(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode polysToFunctionVariables(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.arithmetic.ValidExpression buildValidExpression() -> a
    geogebra.common.kernel.arithmetic.ValidExpression buildCASExpression() -> b
    geogebra.common.kernel.arithmetic.ValidExpression buildMPReduceExpression() -> d
    geogebra.common.kernel.parser.Token label() -> a
    geogebra.common.kernel.parser.Token casVar() -> b
    geogebra.common.kernel.arithmetic.ValidExpression command() -> c
    java.util.Vector labellist() -> a
    geogebra.common.kernel.arithmetic.Parametric parametric() -> a
    geogebra.common.kernel.arithmetic.Equation equation() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode expression() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode cmdexpression() -> b
    geogebra.common.kernel.arithmetic.Function function() -> a
    geogebra.common.kernel.arithmetic.FunctionNVar functionNVar() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode functionExpressionnode() -> c
    geogebra.common.kernel.arithmetic.FunctionNVar casFunction() -> b
    geogebra.common.kernel.arithmetic.ExpressionNode expressionnode() -> d
    geogebra.common.kernel.arithmetic.ExpressionNode expressionOrEquation() -> e
    geogebra.common.kernel.arithmetic.ExpressionValue ANDterm() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue ORterm() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue COMPAREterm() -> c
    geogebra.common.kernel.arithmetic.ExpressionValue plusminusnode() -> d
    geogebra.common.kernel.arithmetic.ExpressionValue setdifferencenode() -> e
    geogebra.common.kernel.arithmetic.ExpressionValue listopnode() -> f
    geogebra.common.kernel.arithmetic.ExpressionValue multterm() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue divterm() -> h
    geogebra.common.kernel.arithmetic.ExpressionValue powerdivterm() -> i
    geogebra.common.kernel.arithmetic.ExpressionValue enunary() -> j
    geogebra.common.kernel.arithmetic.ExpressionValue enpower() -> k
    geogebra.common.kernel.arithmetic.ExpressionValue enfactorial() -> l
    geogebra.common.kernel.arithmetic.ExpressionValue ensqrt() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue NOTterm() -> n
    geogebra.common.kernel.arithmetic.ExpressionValue enelement() -> o
    geogebra.common.kernel.arithmetic.ExpressionValue list() -> p
    geogebra.common.kernel.arithmetic.ExpressionValue matrixReduce() -> q
    geogebra.common.kernel.arithmetic.ExpressionValue matrixRowReduce() -> r
    geogebra.common.kernel.arithmetic.ExpressionValue numVecVariable() -> s
    geogebra.common.kernel.arithmetic.Command spreadsheetRange() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue myDouble() -> t
    geogebra.common.kernel.arithmetic.ExpressionNode numberFunction() -> f
    geogebra.common.kernel.arithmetic.VectorValue cartesianvector() -> a
    geogebra.common.kernel.arithmetic3D.Vector3DValue cartesianvector3D() -> a
    geogebra.common.kernel.arithmetic.VectorValue polarvector() -> b
    geogebra.common.kernel.arithmetic.ExpressionNode cartesianvector_special() -> g
    geogebra.common.kernel.arithmetic.ExpressionNode polarvector_special() -> h
    boolean jj_2_1(int) -> a
    boolean jj_2_2(int) -> b
    boolean jj_2_3(int) -> c
    boolean jj_2_4(int) -> d
    boolean jj_2_5(int) -> e
    boolean jj_2_6(int) -> f
    boolean jj_2_7(int) -> g
    boolean jj_2_8(int) -> h
    boolean jj_2_9(int) -> i
    boolean jj_2_10(int) -> j
    boolean jj_2_11(int) -> k
    boolean jj_2_12(int) -> l
    boolean jj_2_13(int) -> m
    boolean jj_2_14(int) -> n
    boolean jj_2_15(int) -> o
    boolean jj_2_16(int) -> p
    boolean jj_2_17(int) -> q
    boolean jj_2_18(int) -> r
    boolean jj_2_19(int) -> s
    boolean jj_2_20(int) -> t
    boolean jj_2_21(int) -> u
    boolean jj_2_22(int) -> v
    boolean jj_2_23(int) -> w
    boolean jj_2_24(int) -> x
    boolean jj_2_25(int) -> y
    boolean jj_2_26(int) -> z
    boolean jj_2_27(int) -> A
    boolean jj_2_28(int) -> B
    boolean jj_2_29(int) -> C
    boolean jj_2_30(int) -> D
    boolean jj_3R_91() -> a
    boolean jj_3R_117() -> b
    boolean jj_3R_81() -> c
    boolean jj_3R_51() -> d
    boolean jj_3R_33() -> e
    boolean jj_3R_70() -> f
    boolean jj_3R_111() -> g
    boolean jj_3R_116() -> h
    boolean jj_3R_136() -> i
    boolean jj_3R_44() -> j
    boolean jj_3R_23() -> k
    boolean jj_3R_135() -> l
    boolean jj_3_17() -> m
    boolean jj_3R_134() -> n
    boolean jj_3R_82() -> o
    boolean jj_3R_133() -> p
    boolean jj_3R_72() -> q
    boolean jj_3R_69() -> r
    boolean jj_3R_112() -> s
    boolean jj_3R_107() -> t
    boolean jj_3R_132() -> u
    boolean jj_3R_71() -> v
    boolean jj_3R_73() -> w
    boolean jj_3R_47() -> x
    boolean jj_3R_131() -> y
    boolean jj_3R_83() -> z
    boolean jj_3R_46() -> A
    boolean jj_3R_130() -> B
    boolean jj_3R_27() -> C
    boolean jj_3R_49() -> D
    boolean jj_3R_48() -> E
    boolean jj_3R_129() -> F
    boolean jj_3R_30() -> G
    boolean jj_3R_28() -> H
    boolean jj_3R_138() -> I
    boolean jj_3R_45() -> J
    boolean jj_3R_26() -> K
    boolean jj_3R_137() -> L
    boolean jj_3R_29() -> M
    boolean jj_3R_128() -> N
    boolean jj_3R_127() -> O
    boolean jj_3R_32() -> P
    boolean jj_3R_118() -> Q
    boolean jj_3R_66() -> R
    boolean jj_3R_22() -> S
    boolean jj_3R_65() -> T
    boolean jj_3R_50() -> U
    boolean jj_3R_21() -> V
    boolean jj_3R_38() -> W
    boolean jj_3R_114() -> X
    boolean jj_3_30() -> Y
    boolean jj_3R_64() -> Z
    boolean jj_3R_108() -> aa
    boolean jj_3R_113() -> ab
    boolean jj_3R_37() -> ac
    boolean jj_3R_93() -> ad
    boolean jj_3_29() -> ae
    boolean jj_3R_63() -> af
    boolean jj_3R_40() -> ag
    boolean jj_3R_36() -> ah
    boolean jj_3R_31() -> ai
    boolean jj_3R_88() -> aj
    boolean jj_3R_87() -> ak
    boolean jj_3R_77() -> al
    boolean jj_3R_86() -> am
    boolean jj_3R_60() -> an
    boolean jj_3_28() -> ao
    boolean jj_3R_94() -> ap
    boolean jj_3R_41() -> aq
    boolean jj_3R_89() -> ar
    boolean jj_3R_59() -> as
    boolean jj_3R_58() -> at
    boolean jj_3R_78() -> au
    boolean jj_3R_57() -> av
    boolean jj_3R_34() -> aw
    boolean jj_3R_67() -> ax
    boolean jj_3_15() -> ay
    boolean jj_3R_92() -> az
    boolean jj_3_14() -> aA
    boolean jj_3_13() -> aB
    boolean jj_3_12() -> aC
    boolean jj_3R_80() -> aD
    boolean jj_3R_84() -> aE
    boolean jj_3_11() -> aF
    boolean jj_3R_20() -> aG
    boolean jj_3R_68() -> aH
    boolean jj_3R_79() -> aI
    boolean jj_3R_42() -> aJ
    boolean jj_3R_85() -> aK
    boolean jj_3_10() -> aL
    boolean jj_3R_76() -> aM
    boolean jj_3R_96() -> aN
    boolean jj_3R_90() -> aO
    boolean jj_3_9() -> aP
    boolean jj_3_8() -> aQ
    boolean jj_3_7() -> aR
    boolean jj_3R_62() -> aS
    boolean jj_3R_75() -> aT
    boolean jj_3R_110() -> aU
    boolean jj_3R_95() -> aV
    boolean jj_3R_61() -> aW
    boolean jj_3R_115() -> aX
    boolean jj_3R_35() -> aY
    boolean jj_3_27() -> aZ
    boolean jj_3R_109() -> ba
    boolean jj_3R_126() -> bb
    boolean jj_3R_74() -> bc
    boolean jj_3R_43() -> bd
    boolean jj_3_5() -> be
    boolean jj_3_16() -> bf
    boolean jj_3_6() -> bg
    boolean jj_3R_56() -> bh
    boolean jj_3_26() -> bi
    boolean jj_3_25() -> bj
    boolean jj_3R_25() -> bk
    boolean jj_3R_55() -> bl
    boolean jj_3_24() -> bm
    boolean jj_3_2() -> bn
    boolean jj_3_4() -> bo
    boolean jj_3R_106() -> bp
    boolean jj_3_3() -> bq
    boolean jj_3_23() -> br
    boolean jj_3R_54() -> bs
    boolean jj_3R_105() -> bt
    boolean jj_3_22() -> bu
    boolean jj_3_1() -> bv
    boolean jj_3_21() -> bw
    boolean jj_3R_39() -> bx
    boolean jj_3R_104() -> by
    boolean jj_3_20() -> bz
    boolean jj_3_19() -> bA
    boolean jj_3R_103() -> bB
    boolean jj_3_18() -> bC
    boolean jj_3R_102() -> bD
    boolean jj_3R_24() -> bE
    boolean jj_3R_125() -> bF
    boolean jj_3R_124() -> bG
    boolean jj_3R_101() -> bH
    boolean jj_3R_122() -> bI
    boolean jj_3R_123() -> bJ
    boolean jj_3R_53() -> bK
    boolean jj_3R_100() -> bL
    boolean jj_3R_99() -> bM
    boolean jj_3R_52() -> bN
    boolean jj_3R_98() -> bO
    boolean jj_3R_121() -> bP
    boolean jj_3R_97() -> bQ
    boolean jj_3R_119() -> bR
    boolean jj_3R_120() -> bS
    void jj_la1_init_0() -> b
    void jj_la1_init_1() -> c
    void jj_la1_init_2() -> d
    void ReInit(java.io.Reader) -> a
    geogebra.common.kernel.parser.Token jj_consume_token(int) -> a
    boolean jj_scan_token(int) -> E
    int jj_ntk() -> a
    void jj_add_error_token(int,int) -> a
    geogebra.common.kernel.parser.ParseException generateParseException() -> a
    void jj_rescan_token() -> e
    void jj_save(int,int) -> b
geogebra.common.kernel.parser.Parser$JJCalls -> geogebra.common.i.p.b$a:
    int gen -> a
    geogebra.common.kernel.parser.Token first -> a
    int arg -> b
    geogebra.common.kernel.parser.Parser$JJCalls next -> a
geogebra.common.kernel.parser.Parser$LookaheadSuccess -> geogebra.common.i.p.b$b:
geogebra.common.kernel.parser.ParserConstants -> geogebra.common.i.p.c:
    java.lang.String[] tokenImage -> a
geogebra.common.kernel.parser.ParserInterface -> geogebra.common.i.p.d:
    geogebra.common.kernel.arithmetic.ExpressionNode parseExpression(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraExpression(java.lang.String) -> a
    java.lang.String parseLabel(java.lang.String) -> a
geogebra.common.kernel.parser.ParserTokenManager -> geogebra.common.i.p.e:
    java.io.PrintStream debugStream -> a
    long[] jjbitVec0 -> a
    long[] jjbitVec1 -> b
    long[] jjbitVec2 -> c
    long[] jjbitVec3 -> d
    long[] jjbitVec4 -> e
    long[] jjbitVec5 -> f
    long[] jjbitVec6 -> g
    long[] jjbitVec7 -> h
    long[] jjbitVec8 -> i
    long[] jjbitVec9 -> j
    long[] jjbitVec10 -> k
    long[] jjbitVec11 -> l
    long[] jjbitVec12 -> m
    long[] jjbitVec13 -> n
    long[] jjbitVec14 -> o
    long[] jjbitVec15 -> p
    long[] jjbitVec16 -> q
    long[] jjbitVec17 -> r
    long[] jjbitVec18 -> s
    long[] jjbitVec19 -> t
    long[] jjbitVec20 -> u
    long[] jjbitVec22 -> v
    long[] jjbitVec23 -> w
    long[] jjbitVec24 -> x
    long[] jjbitVec25 -> y
    long[] jjbitVec26 -> z
    long[] jjbitVec27 -> A
    long[] jjbitVec28 -> B
    long[] jjbitVec29 -> C
    long[] jjbitVec30 -> D
    long[] jjbitVec31 -> E
    long[] jjbitVec32 -> F
    long[] jjbitVec33 -> G
    long[] jjbitVec34 -> H
    long[] jjbitVec35 -> I
    long[] jjbitVec36 -> J
    long[] jjbitVec37 -> K
    long[] jjbitVec38 -> L
    long[] jjbitVec39 -> M
    long[] jjbitVec40 -> N
    long[] jjbitVec41 -> O
    long[] jjbitVec42 -> P
    long[] jjbitVec43 -> Q
    long[] jjbitVec44 -> R
    long[] jjbitVec45 -> S
    long[] jjbitVec46 -> T
    long[] jjbitVec47 -> U
    long[] jjbitVec48 -> V
    long[] jjbitVec49 -> W
    long[] jjbitVec50 -> X
    long[] jjbitVec51 -> Y
    long[] jjbitVec52 -> Z
    int[] jjnextStates -> a
    java.lang.String[] jjstrLiteralImages -> b
    java.lang.String[] lexStateNames -> c
    long[] jjtoToken -> aa
    long[] jjtoSkip -> ab
    geogebra.common.kernel.parser.SimpleCharStream input_stream -> a
    int[] jjrounds -> b
    int[] jjstateSet -> c
    char curChar -> a
    int curLexState -> a
    int defaultLexState -> b
    int jjnewStateCnt -> c
    int jjround -> d
    int jjmatchedPos -> e
    int jjmatchedKind -> f
    int jjStopStringLiteralDfa_0(int,long,long) -> a
    int jjStartNfa_0(int,long,long) -> b
    int jjStopAtPos(int,int) -> a
    int jjMoveStringLiteralDfa0_0() -> a
    int jjMoveStringLiteralDfa1_0(long,long) -> a
    int jjMoveStringLiteralDfa2_0(long,long,long,long) -> a
    int jjMoveStringLiteralDfa3_0(long,long,long,long) -> b
    int jjMoveStringLiteralDfa4_0(long,long,long,long) -> c
    int jjMoveStringLiteralDfa5_0(long,long) -> b
    int jjMoveStringLiteralDfa6_0(long,long) -> c
    int jjMoveStringLiteralDfa7_0(long,long) -> d
    int jjMoveStringLiteralDfa8_0(long,long) -> e
    int jjMoveStringLiteralDfa9_0(long,long) -> f
    int jjMoveStringLiteralDfa10_0(long,long) -> g
    int jjMoveStringLiteralDfa11_0(long,long) -> h
    int jjMoveStringLiteralDfa12_0(long,long) -> i
    int jjMoveStringLiteralDfa13_0(long,long) -> j
    int jjStartNfaWithStates_0(int,int,int) -> a
    int jjMoveNfa_0(int,int) -> b
    boolean jjCanMove_0(int,int,int,long,long) -> a
    boolean jjCanMove_1(int,int,int,long,long) -> b
    boolean jjCanMove_2(int,int,int,long,long) -> c
    boolean jjCanMove_3(int,int,int,long,long) -> d
    boolean jjCanMove_4(int,int,int,long,long) -> e
    boolean jjCanMove_5(int,int,int,long,long) -> f
    boolean jjCanMove_6(int,int,int,long,long) -> g
    boolean jjCanMove_7(int,int,int,long,long) -> h
    boolean jjCanMove_8(int,int,int,long,long) -> i
    boolean jjCanMove_9(int,int,int,long,long) -> j
    boolean jjCanMove_10(int,int,int,long,long) -> k
    boolean jjCanMove_11(int,int,int,long,long) -> l
    boolean jjCanMove_12(int,int,int,long,long) -> m
    boolean jjCanMove_13(int,int,int,long,long) -> n
    boolean jjCanMove_14(int,int,int,long,long) -> o
    boolean jjCanMove_15(int,int,int,long,long) -> p
    boolean jjCanMove_16(int,int,int,long,long) -> q
    boolean jjCanMove_17(int,int,int,long,long) -> r
    boolean jjCanMove_18(int,int,int,long,long) -> s
    boolean jjCanMove_19(int,int,int,long,long) -> t
    boolean jjCanMove_20(int,int,int,long,long) -> u
    boolean jjCanMove_21(int,int,int,long,long) -> v
    void ReInit(geogebra.common.kernel.parser.SimpleCharStream) -> a
    void ReInitRounds() -> a
    geogebra.common.kernel.parser.Token jjFillToken() -> a
    geogebra.common.kernel.parser.Token getNextToken() -> b
    void jjCheckNAdd(int) -> a
    void jjAddStates(int,int) -> a
    void jjCheckNAddTwoStates(int,int) -> b
    void jjCheckNAddStates(int,int) -> c
geogebra.common.kernel.parser.SimpleCharStream -> geogebra.common.i.p.f:
    int bufsize -> a
    int available -> b
    int tokenBegin -> c
    int bufpos -> d
    int[] bufline -> a
    int[] bufcolumn -> b
    int column -> e
    int line -> f
    boolean prevCharIsCR -> a
    boolean prevCharIsLF -> b
    java.io.Reader inputStream -> a
    char[] buffer -> a
    int maxNextCharInd -> g
    int inBuf -> h
    int tabSize -> i
    void ExpandBuff(boolean) -> a
    void FillBuff() -> a
    char BeginToken() -> a
    void UpdateLineColumn(char) -> a
    char readChar() -> b
    int getEndColumn() -> a
    int getEndLine() -> b
    int getBeginColumn() -> c
    int getBeginLine() -> d
    void backup(int) -> a
    void ReInit(java.io.Reader,int,int,int) -> a
    void ReInit(java.io.Reader,int,int) -> a
    java.lang.String GetImage() -> a
geogebra.common.kernel.parser.Token -> geogebra.common.i.p.g:
    int kind -> a
    int beginLine -> b
    int beginColumn -> c
    int endLine -> d
    int endColumn -> e
    java.lang.String image -> a
    geogebra.common.kernel.parser.Token next -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.parser.Token newToken(int,java.lang.String) -> a
geogebra.common.kernel.parser.TokenMgrError -> geogebra.common.i.p.h:
    int errorCode -> a
    java.lang.String addEscapes(java.lang.String) -> a
    java.lang.String LexicalError(boolean,int,int,int,java.lang.String,char) -> a
    java.lang.String getMessage() -> getMessage
geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce -> geogebra.common.i.p.a.a:
    int[] $SWITCH_TABLE$geogebra$common$kernel$parser$cashandlers$CommandDispatcherMPReduce$commands -> a
    geogebra.common.kernel.arithmetic.ExpressionNode processCommand(java.lang.String,geogebra.common.kernel.arithmetic.GetItem) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$parser$cashandlers$CommandDispatcherMPReduce$commands() -> a
geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands -> geogebra.common.i.p.a.a$a:
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands igamma -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands factorial -> b
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands myfloor -> c
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands myceil -> d
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ceiling -> e
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbcomplex -> f
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbconst -> g
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbint -> h
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands df -> i
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands addition -> j
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands multiplication -> k
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands applyfunction -> l
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands subtraction -> m
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands logb -> n
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands si -> o
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ci -> p
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ei -> q
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands xscoord -> r
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands yscoord -> s
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands zscoord -> t
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands taylor -> u
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sub -> v
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ggbinterval -> w
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands mydivision -> x
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands mypower -> y
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands myround -> z
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ifelsefun -> A
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands iffun -> B
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sum -> C
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands impart -> D
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands repart -> E
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands myreal -> F
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sequal -> G
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sunequal -> H
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sand -> I
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sor -> J
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands simplies -> K
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands snot -> L
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sgreater -> M
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sgreaterequal -> N
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands sless -> O
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands slessequal -> P
    geogebra.common.plugin.Operation op -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands[] ENUM$VALUES -> a
    geogebra.common.plugin.Operation getOperation() -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands[] values() -> values
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.parser.cashandlers.ParserFunctions -> geogebra.common.i.p.a.b:
    java.util.List stringToOp -> a
    java.util.Set RESERVED_FUNCTION_NAMES -> a
    void reset() -> a
    void updateLocale(geogebra.common.main.App) -> a
    geogebra.common.plugin.Operation get(java.lang.String,int) -> a
    void put(int,java.lang.String,geogebra.common.plugin.Operation) -> a
    boolean isReserved(java.lang.String) -> a
geogebra.common.kernel.roots.RealRootAdapter -> geogebra.common.i.q.a:
    geogebra.common.kernel.roots.RealRootFunction fun -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivAdapter -> geogebra.common.i.q.b:
    geogebra.common.kernel.roots.RealRootDerivFunction derivFun -> a
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivAdapter$1 -> geogebra.common.i.q.c:
    geogebra.common.kernel.roots.RealRootDerivAdapter this$0 -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivFunction -> geogebra.common.i.q.d:
    double evaluateDerivative(double) -> b
geogebra.common.kernel.roots.RealRootFunction -> geogebra.common.i.q.e:
    double evaluate(double) -> a
geogebra.common.kernel.roots.RealRootUtil -> geogebra.common.i.q.f:
    int ITER_MAX -> a
    double[] getDefinedInterval(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
    double getDefinitionBorder(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
geogebra.common.kernel.scripting.CmdButton -> geogebra.common.i.r.a:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdCenterView -> geogebra.common.i.r.b:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdCheckbox -> geogebra.common.i.r.c:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdDelete -> geogebra.common.i.r.d:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdHideLayer -> geogebra.common.i.r.e:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdLineStyle -> geogebra.common.i.r.f:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdPan -> geogebra.common.i.r.g:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdParseToFunction -> geogebra.common.i.r.h:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdParseToNumber -> geogebra.common.i.r.i:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdPlaySound -> geogebra.common.i.r.j:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdRelation -> geogebra.common.i.r.k:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdRename -> geogebra.common.i.r.l:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdRigidPolygon -> geogebra.common.i.r.m:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSelectObjects -> geogebra.common.i.r.n:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetActiveView -> geogebra.common.i.r.o:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetAxesRatio -> geogebra.common.i.r.p:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetBackgroundColor -> geogebra.common.i.r.q:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetCaption -> geogebra.common.i.r.r:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetColor -> geogebra.common.i.r.s:
    boolean background -> a
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetConditionToShowObject -> geogebra.common.i.r.t:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetCoords -> geogebra.common.i.r.u:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetDynamicColor -> geogebra.common.i.r.v:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetFilling -> geogebra.common.i.r.w:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetFixed -> geogebra.common.i.r.x:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetLabelMode -> geogebra.common.i.r.y:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetLayer -> geogebra.common.i.r.z:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetLineThickness -> geogebra.common.i.r.A:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetPointSize -> geogebra.common.i.r.B:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetPointStyle -> geogebra.common.i.r.C:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetSeed -> geogebra.common.i.r.D:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetTooltipMode -> geogebra.common.i.r.E:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetTrace -> geogebra.common.i.r.F:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetValue -> geogebra.common.i.r.G:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSetVisibleInView -> geogebra.common.i.r.H:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdShowAxes -> geogebra.common.i.r.I:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdShowGrid -> geogebra.common.i.r.J:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdShowLabel -> geogebra.common.i.r.K:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdShowLayer -> geogebra.common.i.r.L:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSlider -> geogebra.common.i.r.M:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdSlowPlot -> geogebra.common.i.r.N:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdStartAnimation -> geogebra.common.i.r.O:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdTextfield -> geogebra.common.i.r.P:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdToolImage -> geogebra.common.i.r.Q:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdUpdateConstruction -> geogebra.common.i.r.R:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdZoomIn -> geogebra.common.i.r.S:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.scripting.CmdZoomOut -> geogebra.common.i.r.T:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.AlgoANOVA -> geogebra.common.i.s.a:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoList result -> b
    java.util.ArrayList categoryData -> a
    double p -> a
    double testStat -> b
    org.apache.commons.math.stat.inference.OneWayAnovaImpl anovaImpl -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoBernoulliBarChart -> geogebra.common.i.s.b:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoBinomialDist -> geogebra.common.i.s.c:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoBinomialDistBarChart -> geogebra.common.i.s.d:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoCauchy -> geogebra.common.i.s.e:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoCauchyDF -> geogebra.common.i.s.f:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunction ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoCell -> geogebra.common.i.s.g:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    java.lang.String currentLabel -> a
    geogebra.common.kernel.geos.GeoElement refObject -> b
    geogebra.common.kernel.geos.GeoElement[] inputForUpdateSetPropagation -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void updateReferencedObject() -> e
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a
geogebra.common.kernel.statistics.AlgoCellRange -> geogebra.common.i.s.h:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement startCell -> a
    geogebra.common.kernel.geos.GeoElement endCell -> b
    java.lang.String toStringOutput -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void remove() -> c
    void clearGeoList() -> e
    void setInputOutput() -> a
    java.util.ArrayList initCellRangeList(geogebra.common.awt.GPoint,geogebra.common.awt.GPoint) -> a
    geogebra.common.kernel.geos.GeoList getList() -> a
    void compute() -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.awt.GPoint[] getRectangle() -> a
geogebra.common.kernel.statistics.AlgoChiSquared -> geogebra.common.i.s.i:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoChiSquaredDF -> geogebra.common.i.s.j:
    geogebra.common.kernel.arithmetic.NumberValue k -> a
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoChiSquaredTest -> geogebra.common.i.s.k:
    geogebra.common.kernel.geos.GeoList geoList1 -> a
    geogebra.common.kernel.geos.GeoList geoList2 -> b
    geogebra.common.kernel.geos.GeoList result -> c
    double p -> a
    double testStat -> b
    org.apache.commons.math.distribution.ChiSquaredDistribution chisquared -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution getChiSquaredDistribution(double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoClasses -> geogebra.common.i.s.l:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoNumeric start -> a
    geogebra.common.kernel.geos.GeoNumeric width -> b
    geogebra.common.kernel.geos.GeoNumeric numClasses -> c
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoColumn -> geogebra.common.i.s.m:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoColumnName -> geogebra.common.i.s.n:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoContingencyTable -> geogebra.common.i.s.o:
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoList rowList -> c
    geogebra.common.kernel.geos.GeoList colList -> d
    geogebra.common.kernel.geos.GeoList freqMatrix -> e
    geogebra.common.kernel.geos.GeoText args -> a
    geogebra.common.kernel.geos.GeoText table -> b
    geogebra.common.kernel.statistics.AlgoFrequency freq -> a
    java.lang.StringBuilder sb -> b
    boolean isRawData -> c
    java.lang.String[] rowValues -> a
    java.lang.String[] colValues -> b
    int[][] freqValues -> a
    double[][] expected -> a
    double[][] chiCont -> b
    int[] rowSum -> a
    int[] colSum -> b
    int totalSum -> a
    boolean showRowPercent -> d
    boolean showColPercent -> e
    boolean showTotalPercent -> f
    boolean showChi -> g
    boolean showExpected -> h
    boolean showTest -> i
    int rowCount -> b
    int colCount -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void parseArgs() -> e
    boolean loadRawDataValues() -> f
    boolean loadPreparedDataValues() -> n
    void computeChiTestValues() -> f
    void compute() -> b
    void addTableRow(java.lang.StringBuilder,int,java.lang.String,java.lang.String) -> a
    java.lang.String handleSpecialChar(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoDistribution -> geogebra.common.i.s.p:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue c -> c
    geogebra.common.kernel.arithmetic.NumberValue d -> d
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    org.apache.commons.math.distribution.TDistribution t -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution chisquared -> a
    org.apache.commons.math.distribution.FDistribution f -> a
    org.apache.commons.math.distribution.GammaDistribution gamma -> a
    org.apache.commons.math.distribution.CauchyDistribution cauchy -> a
    org.apache.commons.math.distribution.ExponentialDistribution exponential -> a
    org.apache.commons.math.distribution.HypergeometricDistribution hypergeometric -> a
    org.apache.commons.math.distribution.PascalDistribution pascal -> a
    org.apache.commons.math.distribution.BinomialDistribution binomial -> a
    org.apache.commons.math.distribution.WeibullDistribution weibull -> a
    org.apache.commons.math.distribution.ZipfDistribution zipf -> a
    org.apache.commons.math.distribution.NormalDistribution normal -> a
    org.apache.commons.math.distribution.PoissonDistribution poisson -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    org.apache.commons.math.distribution.TDistribution getTDistribution(double) -> a
    org.apache.commons.math.distribution.FDistribution getFDistribution(double,double) -> a
    org.apache.commons.math.distribution.GammaDistribution getGammaDistribution(double,double) -> a
    org.apache.commons.math.distribution.CauchyDistribution getCauchyDistribution(double,double) -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution getChiSquaredDistribution(double) -> a
    org.apache.commons.math.distribution.ExponentialDistribution getExponentialDistribution(double) -> a
    org.apache.commons.math.distribution.HypergeometricDistribution getHypergeometricDistribution(int,int,int) -> a
    org.apache.commons.math.distribution.PascalDistribution getPascalDistribution(int,double) -> a
    org.apache.commons.math.distribution.PoissonDistribution getPoissonDistribution(double) -> a
    org.apache.commons.math.distribution.BinomialDistribution getBinomialDistribution(int,double) -> a
    org.apache.commons.math.distribution.WeibullDistribution getWeibullDistribution(double,double) -> a
    org.apache.commons.math.distribution.NormalDistribution getNormalDistribution(double,double) -> a
    org.apache.commons.math.distribution.ZipfDistribution getZipfDistribution(int,double) -> a
geogebra.common.kernel.statistics.AlgoDistributionDF -> geogebra.common.i.s.q:
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
geogebra.common.kernel.statistics.AlgoDotPlot -> geogebra.common.i.s.r:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double[] sortedData -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoDoubleListCovariance -> geogebra.common.i.s.s:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListPMCC -> geogebra.common.i.s.t:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSXX -> geogebra.common.i.s.u:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSXY -> geogebra.common.i.s.v:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSigmaXY -> geogebra.common.i.s.w:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoErlang -> geogebra.common.i.s.x:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoErlangDF -> geogebra.common.i.s.y:
    geogebra.common.kernel.arithmetic.NumberValue k -> a
    geogebra.common.kernel.arithmetic.NumberValue l -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoExponential -> geogebra.common.i.s.z:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoExponentialDF -> geogebra.common.i.s.A:
    geogebra.common.kernel.arithmetic.NumberValue lambda -> a
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFDistribution -> geogebra.common.i.s.B:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFDistributionDF -> geogebra.common.i.s.C:
    geogebra.common.kernel.arithmetic.NumberValue d1 -> a
    geogebra.common.kernel.arithmetic.NumberValue d2 -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFit -> geogebra.common.i.s.D:
    geogebra.common.kernel.geos.GeoList pointlist -> a
    geogebra.common.kernel.geos.GeoList functionlist -> b
    geogebra.common.kernel.geos.GeoFunction fitfunction -> a
    int datasize -> a
    int functionsize -> b
    geogebra.common.kernel.geos.GeoFunctionable[] functionarray -> a
    org.apache.commons.math.linear.RealMatrix M -> a
    org.apache.commons.math.linear.RealMatrix Y -> b
    org.apache.commons.math.linear.RealMatrix P -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFit() -> a
    void compute() -> b
    void makeMatrixes() -> e
    geogebra.common.kernel.geos.GeoFunction makeFunction() -> b
geogebra.common.kernel.statistics.AlgoFitExp -> geogebra.common.i.s.E:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitExp() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitGrowth -> geogebra.common.i.s.F:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitGrowth() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLineX -> geogebra.common.i.s.G:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getFitLineX() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLineY -> geogebra.common.i.s.H:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getFitLineY() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLog -> geogebra.common.i.s.I:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitLog() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLogistic -> geogebra.common.i.s.J:
    double a -> a
    double b -> b
    double c -> c
    double[] xd -> a
    double[] yd -> b
    int size -> a
    int iterations -> b
    boolean error -> c
    boolean allplus -> d
    boolean allneg -> e
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    double x1 -> d
    double y1 -> e
    double x2 -> f
    double y2 -> g
    double ymult -> h
    double e1 -> i
    double e2 -> j
    double emult -> k
    double ydiff -> l
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitLogistic() -> a
    void compute() -> b
    void doReg() -> e
    void findParameters() -> f
    void Logistic_Reg() -> n
    double f(double,double,double,double) -> a
    double f(double,double) -> a
    double df_c(double,double,double) -> a
    double df_a(double,double,double,double) -> b
    double df_b(double,double,double,double) -> c
    double beta(double,double,double,double,double) -> a
    double beta(double,double,double) -> b
    double beta2(double[],double[],double,double,double) -> a
    double beta2(double) -> a
    double c(double,double,double,double,double) -> b
    double a(double,double,double,double,double) -> c
    void getPoints() -> o
    void errorMsg(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoFitNL -> geogebra.common.i.s.K:
    geogebra.common.kernel.geos.GeoList pointlist -> a
    geogebra.common.kernel.geos.GeoFunction inputfunction -> a
    geogebra.common.kernel.geos.GeoFunction outputfunction -> b
    int datasize -> a
    double[] xdata -> a
    double[] ydata -> b
    geogebra.common.kernel.optimization.FitRealFunction prfunction -> a
    org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer LMO -> a
    org.apache.commons.math.optimization.fitting.CurveFitter curvefitter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitNL() -> a
    void compute() -> b
    void makeDataArrays() -> e
    void errorMsg(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoFitPoly -> geogebra.common.i.s.L:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.arithmetic.NumberValue degree -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.geos.GeoElement geodegree -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitPoly() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitPow -> geogebra.common.i.s.M:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitPow() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitSin -> geogebra.common.i.s.N:
    double a -> a
    double b -> b
    double c -> c
    double d -> d
    double[] xd -> a
    double[] yd -> b
    int size -> a
    int iterations -> b
    boolean error -> c
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitSin() -> a
    void compute() -> b
    void doReg() -> e
    void findParameters() -> f
    void sinus_Reg() -> n
    double sin(double,double,double) -> a
    double cos(double,double,double) -> b
    double f(double,double,double,double,double) -> a
    double df_a() -> a
    double df_b(double,double,double) -> c
    double df_c(double,double,double,double) -> a
    double df_d(double,double,double,double) -> b
    double beta(double,double,double,double,double,double) -> a
    double beta2(double[],double[],double,double,double,double) -> a
    double beta(double[],double[],double,double,double,double) -> b
    int direction(double,double,double) -> a
    void getPoints() -> o
    boolean nearmaxmin(double,double,int,int,double,double) -> a
    void errorMsg(java.lang.String) -> a
    int findNumberOfHalfPeriods(int,int,int) -> a
geogebra.common.kernel.statistics.AlgoFrequency -> geogebra.common.i.s.O:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoList frequency -> c
    geogebra.common.kernel.geos.GeoList value -> d
    java.lang.String[] contingencyRowValues -> a
    java.lang.String[] contingencyColumnValues -> b
    java.lang.Boolean isContingencyTable -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    geogebra.common.kernel.geos.GeoList getValue() -> b
    java.lang.String[] getContingencyRowValues() -> a
    java.lang.String[] getContingencyColumnValues() -> b
    void compute() -> b
    void computeContingencyTable() -> e
    java.lang.String[] getUniqueValues(geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.AlgoFrequencyPolygon -> geogebra.common.i.s.P:
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoList list3 -> c
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoPolyLine outputPolyLine -> a
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.statistics.AlgoHistogram algoHistogram -> a
    boolean right -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void setOutput() -> e
    geogebra.common.kernel.geos.GeoPolyLine getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFrequencyTable -> geogebra.common.i.s.Q:
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType type -> a
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoNumeric chart -> b
    geogebra.common.kernel.geos.GeoText table -> a
    geogebra.common.kernel.statistics.AlgoFrequency freq -> a
    java.lang.String[] strHeader -> a
    java.lang.String[] strValue -> b
    java.lang.String[] strFrequency -> c
    java.lang.StringBuilder sb -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$statistics$AlgoFrequencyTable$inputType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    java.lang.String[] getValueString() -> a
    java.lang.String[] getFrequencyString() -> b
    java.lang.String[] getHeaderString() -> c
    void compute() -> b
    void createLaTeXTable(boolean) -> d
    int[] $SWITCH_TABLE$geogebra$common$kernel$statistics$AlgoFrequencyTable$inputType() -> a
geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType -> geogebra.common.i.s.Q$a:
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType STANDARD -> a
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType HISTOGRAM -> b
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType BARCHART -> c
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType[] ENUM$VALUES -> a
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType[] values() -> values
    geogebra.common.kernel.statistics.AlgoFrequencyTable$inputType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.statistics.AlgoGamma -> geogebra.common.i.s.R:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoGammaDF -> geogebra.common.i.s.S:
    geogebra.common.kernel.arithmetic.NumberValue mean -> a
    geogebra.common.kernel.arithmetic.NumberValue sd -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoGeometricMean -> geogebra.common.i.s.T:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHarmonicMean -> geogebra.common.i.s.U:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    double sum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHistogram -> geogebra.common.i.s.V:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.statistics.AlgoHistogram copy() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoHyperGeometric -> geogebra.common.i.s.W:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHyperGeometricBarChart -> geogebra.common.i.s.X:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoInverseBinomial -> geogebra.common.i.s.Y:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseCauchy -> geogebra.common.i.s.Z:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseChiSquared -> geogebra.common.i.s.aa:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseExponential -> geogebra.common.i.s.ab:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseFDistribution -> geogebra.common.i.s.ac:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseGamma -> geogebra.common.i.s.ad:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseHyperGeometric -> geogebra.common.i.s.ae:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseLogNormal -> geogebra.common.i.s.af:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseLogistic -> geogebra.common.i.s.ag:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseNormal -> geogebra.common.i.s.ah:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInversePascal -> geogebra.common.i.s.ai:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInversePoisson -> geogebra.common.i.s.aj:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseTDistribution -> geogebra.common.i.s.ak:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseWeibull -> geogebra.common.i.s.al:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseZipf -> geogebra.common.i.s.am:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoListCovariance -> geogebra.common.i.s.an:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListMeanX -> geogebra.common.i.s.ao:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListMeanY -> geogebra.common.i.s.ap:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListPMCC -> geogebra.common.i.s.aq:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSDX -> geogebra.common.i.s.ar:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSDY -> geogebra.common.i.s.as:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSXX -> geogebra.common.i.s.at:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSXY -> geogebra.common.i.s.au:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSYY -> geogebra.common.i.s.av:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSampleSDX -> geogebra.common.i.s.aw:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSampleSDY -> geogebra.common.i.s.ax:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaXX -> geogebra.common.i.s.ay:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaXY -> geogebra.common.i.s.az:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaYY -> geogebra.common.i.s.aA:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoLogNormal -> geogebra.common.i.s.aB:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoLogNormalDF -> geogebra.common.i.s.aC:
    geogebra.common.kernel.arithmetic.NumberValue mean -> a
    geogebra.common.kernel.arithmetic.NumberValue sd -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoLogistic -> geogebra.common.i.s.aD:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoLogisticDF -> geogebra.common.i.s.aE:
    geogebra.common.kernel.arithmetic.NumberValue mean -> a
    geogebra.common.kernel.arithmetic.NumberValue scale -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunction ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoMean -> geogebra.common.i.s.aF:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoMode -> geogebra.common.i.s.aG:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.statistics.AlgoNormal -> geogebra.common.i.s.aH:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoNormalDF -> geogebra.common.i.s.aI:
    geogebra.common.kernel.arithmetic.NumberValue mean -> a
    geogebra.common.kernel.arithmetic.NumberValue sd -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunction ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoNormalQuantilePlot -> geogebra.common.i.s.aJ:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double[] zValues -> a
    double[] sortedData -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void calculateZValues(int) -> a
    geogebra.common.kernel.geos.GeoSegment getQQLineSegment() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoNpR -> geogebra.common.i.s.aK:
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.arithmetic.NumberValue num1 -> a
    geogebra.common.kernel.arithmetic.NumberValue num2 -> b
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    double NpR(double,double) -> a
    double NpRBig(double,double) -> b
    double NpRLog(double,double) -> c
geogebra.common.kernel.statistics.AlgoOrdinalRank -> geogebra.common.i.s.aL:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    java.util.Comparator comparator -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.util.Comparator getComparator() -> a
geogebra.common.kernel.statistics.AlgoOrdinalRank$1 -> geogebra.common.i.s.aM:
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.statistics.AlgoOrdinalRank$OrderedPair -> geogebra.common.i.s.aL$a:
    double x -> a
    int y -> a
    geogebra.common.kernel.statistics.AlgoOrdinalRank this$0 -> a
geogebra.common.kernel.statistics.AlgoPascal -> geogebra.common.i.s.aN:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPascalBarChart -> geogebra.common.i.s.aO:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoPercentile -> geogebra.common.i.s.aP:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric value -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    int size -> a
    org.apache.commons.math.stat.descriptive.rank.Percentile percentile -> a
    double[] inputArray -> a
    double val -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPoisson -> geogebra.common.i.s.aQ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPoissonBarChart -> geogebra.common.i.s.aR:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.AlgoRSquare -> geogebra.common.i.s.aS:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoNumeric r2 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getRSquare() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRandomBinomial -> geogebra.common.i.s.aT:
    double halflog2pi -> a
    double[] logtable -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    void setRandomValue(double) -> a
    int randomBinomial(double,double) -> a
geogebra.common.kernel.statistics.AlgoRandomElement -> geogebra.common.i.s.aU:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement element -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRandomNormal -> geogebra.common.i.s.aV:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    double randomNormal(double,double) -> a
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRandomPoisson -> geogebra.common.i.s.aW:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    double halflog2pi -> a
    double[] logtable -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    int randomPoisson(double) -> a
    int randomPoissonTRS(double) -> b
    double logOfKFactorial(int) -> a
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRandomPolynomial -> geogebra.common.i.s.aX:
    geogebra.common.kernel.arithmetic.NumberValue degree -> a
    geogebra.common.kernel.arithmetic.NumberValue min -> b
    geogebra.common.kernel.arithmetic.NumberValue max -> c
    geogebra.common.kernel.geos.GeoFunction polynomial -> a
    geogebra.common.kernel.arithmetic.Function f -> a
    geogebra.common.kernel.arithmetic.FunctionVariable fv -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.ExpressionNode randomCoef(boolean) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
geogebra.common.kernel.statistics.AlgoRandomUniform -> geogebra.common.i.s.aY:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoResidualPlot -> geogebra.common.i.s.aZ:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double min -> a
    double max -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double[] getResidualBounds() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRootMeanSquare -> geogebra.common.i.s.ba:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    double sum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRow -> geogebra.common.i.s.bb:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoSXX -> geogebra.common.i.s.bc:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSample -> geogebra.common.i.s.bd:
    int SAMPLE_MAXSIZE -> a
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoBoolean replacement -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.statistics.AlgoSampleStandardDeviation -> geogebra.common.i.s.be:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSampleVariance -> geogebra.common.i.s.bf:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoShuffle -> geogebra.common.i.s.bg:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoSigmaXX -> geogebra.common.i.s.bh:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSpearman -> geogebra.common.i.s.bi:
    geogebra.common.kernel.geos.GeoList geoListPts -> a
    geogebra.common.kernel.geos.GeoList geoListX -> b
    geogebra.common.kernel.geos.GeoList geoListY -> c
    geogebra.common.kernel.geos.GeoNumeric result -> a
    org.apache.commons.math.stat.correlation.SpearmansCorrelation sp -> a
    double[] valX -> a
    double[] valY -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoStandardDeviation -> geogebra.common.i.s.bj:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoStats1D -> geogebra.common.i.s.bk:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoList geoList2 -> b
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    int stat -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoStats2D -> geogebra.common.i.s.bl:
    geogebra.common.kernel.geos.GeoList geoListx -> a
    geogebra.common.kernel.geos.GeoList geoListy -> b
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int mode -> a
    int stat -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoStemPlot -> geogebra.common.i.s.bm:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric scaleAdjustment -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder low -> b
    java.lang.StringBuilder high -> c
    java.lang.StringBuilder sb -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    int[] getOutlierIndex(double[]) -> a
    java.util.ArrayList createStemPlotArray(double[],double,int[]) -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> c
geogebra.common.kernel.statistics.AlgoSumSquaredErrors -> geogebra.common.i.s.bn:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoNumeric sse -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getsse() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTDistribution -> geogebra.common.i.s.bo:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTDistributionDF -> geogebra.common.i.s.bp:
    geogebra.common.kernel.arithmetic.NumberValue v -> a
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunction ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTMean2Estimate -> geogebra.common.i.s.bq:
    geogebra.common.kernel.geos.GeoList geoList1 -> a
    geogebra.common.kernel.geos.GeoList geoList2 -> b
    geogebra.common.kernel.geos.GeoNumeric geoLevel -> a
    geogebra.common.kernel.geos.GeoNumeric geoMean1 -> b
    geogebra.common.kernel.geos.GeoNumeric geoSD1 -> c
    geogebra.common.kernel.geos.GeoNumeric geoN1 -> d
    geogebra.common.kernel.geos.GeoNumeric geoMean2 -> e
    geogebra.common.kernel.geos.GeoNumeric geoSD2 -> f
    geogebra.common.kernel.geos.GeoNumeric geoN2 -> g
    geogebra.common.kernel.geos.GeoBoolean geoPooled -> a
    geogebra.common.kernel.geos.GeoList result -> c
    double[] val1 -> a
    double[] val2 -> b
    int size1 -> a
    int size2 -> b
    double level -> a
    double mean1 -> b
    double var1 -> c
    double n1 -> d
    double mean2 -> e
    double var2 -> f
    double n2 -> g
    double me -> h
    boolean pooled -> c
    org.apache.commons.math.stat.descriptive.SummaryStatistics stats -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    double difference -> i
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getDegreeOfFreedom(double,double,double,double,boolean) -> a
    double getMarginOfError(double,double,double,double,double,boolean) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTMeanEstimate -> geogebra.common.i.s.br:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric geoLevel -> a
    geogebra.common.kernel.geos.GeoNumeric geoMean -> b
    geogebra.common.kernel.geos.GeoNumeric geoSD -> c
    geogebra.common.kernel.geos.GeoNumeric geoN -> d
    geogebra.common.kernel.geos.GeoList result -> b
    double[] val -> a
    double level -> a
    double mean -> b
    double sd -> c
    double n -> d
    double me -> e
    org.apache.commons.math.stat.descriptive.SummaryStatistics stats -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getME() -> a
    double getMarginOfError(double,double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTest -> geogebra.common.i.s.bs:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric hypMean -> a
    geogebra.common.kernel.geos.GeoNumeric mean -> b
    geogebra.common.kernel.geos.GeoNumeric sd -> c
    geogebra.common.kernel.geos.GeoNumeric n -> d
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> b
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val -> a
    double p -> a
    double testStat -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTest2 -> geogebra.common.i.s.bt:
    geogebra.common.kernel.geos.GeoList geoList0 -> a
    geogebra.common.kernel.geos.GeoList geoList1 -> b
    geogebra.common.kernel.geos.GeoNumeric mean0 -> a
    geogebra.common.kernel.geos.GeoNumeric mean1 -> b
    geogebra.common.kernel.geos.GeoNumeric sd0 -> c
    geogebra.common.kernel.geos.GeoNumeric sd1 -> d
    geogebra.common.kernel.geos.GeoNumeric n0 -> e
    geogebra.common.kernel.geos.GeoNumeric n1 -> f
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoBoolean pooled -> a
    geogebra.common.kernel.geos.GeoList result -> c
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val0 -> a
    double[] val1 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTestPaired -> geogebra.common.i.s.bu:
    geogebra.common.kernel.geos.GeoList geoList0 -> a
    geogebra.common.kernel.geos.GeoList geoList1 -> b
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> c
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val0 -> a
    double[] val1 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTiedRank -> geogebra.common.i.s.bv:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    org.apache.commons.math.stat.ranking.NaturalRanking rankingAlgorithm -> a
    double[] inputArray -> a
    double[] outputArray -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTriangular -> geogebra.common.i.s.bw:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTriangularDF -> geogebra.common.i.s.bx:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue mode -> c
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoUniform -> geogebra.common.i.s.by:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoUniformDF -> geogebra.common.i.s.bz:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoVariance -> geogebra.common.i.s.bA:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoWeibull -> geogebra.common.i.s.bB:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoWeibullDF -> geogebra.common.i.s.bC:
    geogebra.common.kernel.arithmetic.NumberValue k -> a
    geogebra.common.kernel.arithmetic.NumberValue l -> b
    geogebra.common.kernel.arithmetic.BooleanValue cumulative -> a
    geogebra.common.kernel.geos.GeoFunctionConditional ret -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> a
    geogebra.common.kernel.geos.GeoFunction elseFun -> b
    geogebra.common.kernel.geos.GeoFunction condFun -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZMean2Estimate -> geogebra.common.i.s.bD:
    geogebra.common.kernel.geos.GeoNumeric mean -> a
    geogebra.common.kernel.geos.GeoNumeric sd -> b
    geogebra.common.kernel.geos.GeoNumeric n -> c
    geogebra.common.kernel.geos.GeoNumeric mean_2 -> d
    geogebra.common.kernel.geos.GeoNumeric sd_2 -> e
    geogebra.common.kernel.geos.GeoNumeric n_2 -> f
    geogebra.common.kernel.geos.GeoNumeric level -> g
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoList result -> c
    double me -> a
    double se -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZMean2Test -> geogebra.common.i.s.bE:
    geogebra.common.kernel.geos.GeoNumeric mean -> a
    geogebra.common.kernel.geos.GeoNumeric sd -> b
    geogebra.common.kernel.geos.GeoNumeric n -> c
    geogebra.common.kernel.geos.GeoNumeric mean_2 -> d
    geogebra.common.kernel.geos.GeoNumeric sd_2 -> e
    geogebra.common.kernel.geos.GeoNumeric n_2 -> f
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoList result -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZMeanEstimate -> geogebra.common.i.s.bF:
    geogebra.common.kernel.geos.GeoNumeric mean -> a
    geogebra.common.kernel.geos.GeoNumeric sd -> b
    geogebra.common.kernel.geos.GeoNumeric n -> c
    geogebra.common.kernel.geos.GeoNumeric level -> d
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoList result -> b
    double me -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    double getME() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZMeanTest -> geogebra.common.i.s.bG:
    geogebra.common.kernel.geos.GeoNumeric hypMean -> a
    geogebra.common.kernel.geos.GeoNumeric mean -> b
    geogebra.common.kernel.geos.GeoNumeric sd -> c
    geogebra.common.kernel.geos.GeoNumeric n -> d
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZProportion2Estimate -> geogebra.common.i.s.bH:
    geogebra.common.kernel.geos.GeoNumeric proportion -> a
    geogebra.common.kernel.geos.GeoNumeric n -> b
    geogebra.common.kernel.geos.GeoNumeric proportion2 -> c
    geogebra.common.kernel.geos.GeoNumeric n_2 -> d
    geogebra.common.kernel.geos.GeoNumeric level -> e
    geogebra.common.kernel.geos.GeoList result -> a
    double se -> a
    double me -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getME() -> a
    double getSE() -> b
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZProportion2Test -> geogebra.common.i.s.bI:
    geogebra.common.kernel.geos.GeoNumeric proportion -> a
    geogebra.common.kernel.geos.GeoNumeric n -> b
    geogebra.common.kernel.geos.GeoNumeric proportion2 -> c
    geogebra.common.kernel.geos.GeoNumeric n_2 -> d
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> a
    double se -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getSE() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZProportionEstimate -> geogebra.common.i.s.bJ:
    geogebra.common.kernel.geos.GeoNumeric proportion -> a
    geogebra.common.kernel.geos.GeoNumeric n -> b
    geogebra.common.kernel.geos.GeoNumeric level -> c
    geogebra.common.kernel.geos.GeoList result -> a
    double se -> a
    double me -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getME() -> a
    double getSE() -> b
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZProportionTest -> geogebra.common.i.s.bK:
    geogebra.common.kernel.geos.GeoNumeric hypPropertion -> a
    geogebra.common.kernel.geos.GeoNumeric proportion -> b
    geogebra.common.kernel.geos.GeoNumeric n -> c
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> a
    double se -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getSE() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZipf -> geogebra.common.i.s.bL:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZipfBarChart -> geogebra.common.i.s.bM:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.DrawInformationAlgo copy() -> a
geogebra.common.kernel.statistics.CmdANOVA -> geogebra.common.i.s.bN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoList ANOVATest(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdBernoulli -> geogebra.common.i.s.bO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdBinomialDist -> geogebra.common.i.s.bP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdBoxPlot -> geogebra.common.i.s.bQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdCauchy -> geogebra.common.i.s.bR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdCell -> geogebra.common.i.s.bS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdCellRange -> geogebra.common.i.s.bT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdChiSquared -> geogebra.common.i.s.bU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdChiSquaredTest -> geogebra.common.i.s.bV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdClasses -> geogebra.common.i.s.bW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdColumn -> geogebra.common.i.s.bX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdColumnName -> geogebra.common.i.s.bY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdContingencyTable -> geogebra.common.i.s.bZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdCovariance -> geogebra.common.i.s.ca:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdDotPlot -> geogebra.common.i.s.cb:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdErlang -> geogebra.common.i.s.cc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdExponential -> geogebra.common.i.s.cd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFDistribution -> geogebra.common.i.s.ce:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFillCells -> geogebra.common.i.s.cf:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFillColumn -> geogebra.common.i.s.cg:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFillRow -> geogebra.common.i.s.ch:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFit -> geogebra.common.i.s.ci:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdFitExp -> geogebra.common.i.s.cj:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitGrowth -> geogebra.common.i.s.ck:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitLineX -> geogebra.common.i.s.cl:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitLineY -> geogebra.common.i.s.cm:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitLog -> geogebra.common.i.s.cn:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitLogistic -> geogebra.common.i.s.co:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitPoly -> geogebra.common.i.s.cp:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoFunction FitPoly(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.statistics.CmdFitPow -> geogebra.common.i.s.cq:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFitSin -> geogebra.common.i.s.cr:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdFrequency -> geogebra.common.i.s.cs:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.statistics.CmdFrequencyPolygon -> geogebra.common.i.s.ct:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoPolyLine FrequencyPolygon(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.statistics.CmdFrequencyTable -> geogebra.common.i.s.cu:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.statistics.CmdGamma -> geogebra.common.i.s.cv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdGeometricMean -> geogebra.common.i.s.cw:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdHarmonicMean -> geogebra.common.i.s.cx:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdHistogram -> geogebra.common.i.s.cy:
    boolean right -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
geogebra.common.kernel.statistics.CmdHistogramRight -> geogebra.common.i.s.cz:
geogebra.common.kernel.statistics.CmdHyperGeometric -> geogebra.common.i.s.cA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseBinomial -> geogebra.common.i.s.cB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseCauchy -> geogebra.common.i.s.cC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseChiSquared -> geogebra.common.i.s.cD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseExponential -> geogebra.common.i.s.cE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseFDistribution -> geogebra.common.i.s.cF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseGamma -> geogebra.common.i.s.cG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseHyperGeometric -> geogebra.common.i.s.cH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseLogNormal -> geogebra.common.i.s.cI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseLogistic -> geogebra.common.i.s.cJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseNormal -> geogebra.common.i.s.cK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInversePascal -> geogebra.common.i.s.cL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInversePoisson -> geogebra.common.i.s.cM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseTDistribution -> geogebra.common.i.s.cN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseWeibull -> geogebra.common.i.s.cO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdInverseZipf -> geogebra.common.i.s.cP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdLogNormal -> geogebra.common.i.s.cQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdLogistic -> geogebra.common.i.s.cR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdMean -> geogebra.common.i.s.cS:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdMeanX -> geogebra.common.i.s.cT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdMeanY -> geogebra.common.i.s.cU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdMedian -> geogebra.common.i.s.cV:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdMode -> geogebra.common.i.s.cW:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdNormal -> geogebra.common.i.s.cX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdNormalQuantilePlot -> geogebra.common.i.s.cY:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdNpR -> geogebra.common.i.s.cZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdOrdinalRank -> geogebra.common.i.s.da:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdPMCC -> geogebra.common.i.s.db:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdPascal -> geogebra.common.i.s.dc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdPercentile -> geogebra.common.i.s.dd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdPoisson -> geogebra.common.i.s.de:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdQ1 -> geogebra.common.i.s.df:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdQ3 -> geogebra.common.i.s.dg:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdRSquare -> geogebra.common.i.s.dh:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdRandomBinomial -> geogebra.common.i.s.di:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.statistics.CmdRandomElement -> geogebra.common.i.s.dj:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdRandomNormal -> geogebra.common.i.s.dk:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.statistics.CmdRandomPoisson -> geogebra.common.i.s.dl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdRandomPolynomial -> geogebra.common.i.s.dm:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdRandomUniform -> geogebra.common.i.s.dn:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.statistics.CmdResidualPlot -> geogebra.common.i.s.do:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdRootMeanSquare -> geogebra.common.i.s.dp:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdRow -> geogebra.common.i.s.dq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdSD -> geogebra.common.i.s.dr:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSDX -> geogebra.common.i.s.ds:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSDY -> geogebra.common.i.s.dt:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSXX -> geogebra.common.i.s.du:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSXY -> geogebra.common.i.s.dv:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSYY -> geogebra.common.i.s.dw:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSample -> geogebra.common.i.s.dx:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement Sample(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
geogebra.common.kernel.statistics.CmdSampleSD -> geogebra.common.i.s.dy:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSampleSDX -> geogebra.common.i.s.dz:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSampleSDY -> geogebra.common.i.s.dA:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSampleVariance -> geogebra.common.i.s.dB:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdShuffle -> geogebra.common.i.s.dC:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSigmaXX -> geogebra.common.i.s.dD:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
geogebra.common.kernel.statistics.CmdSigmaXY -> geogebra.common.i.s.dE:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSigmaYY -> geogebra.common.i.s.dF:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdSpearman -> geogebra.common.i.s.dG:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdStemPlot -> geogebra.common.i.s.dH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoText StemPlot(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra.common.kernel.statistics.CmdStepGraph -> geogebra.common.i.s.dI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdStickGraph -> geogebra.common.i.s.dJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdSumSquaredErrors -> geogebra.common.i.s.dK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTDistribution -> geogebra.common.i.s.dL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTMean2Estimate -> geogebra.common.i.s.dM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTMeanEstimate -> geogebra.common.i.s.dN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTTest -> geogebra.common.i.s.dO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTTest2 -> geogebra.common.i.s.dP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTTestPaired -> geogebra.common.i.s.dQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdTiedRank -> geogebra.common.i.s.dR:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdTriangular -> geogebra.common.i.s.dS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdUniform -> geogebra.common.i.s.dT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdVariance -> geogebra.common.i.s.dU:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.statistics.CmdWeibull -> geogebra.common.i.s.dV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZMean2Estimate -> geogebra.common.i.s.dW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZMean2Test -> geogebra.common.i.s.dX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZMeanEstimate -> geogebra.common.i.s.dY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZMeanTest -> geogebra.common.i.s.dZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZProportion2Estimate -> geogebra.common.i.s.ea:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZProportion2Test -> geogebra.common.i.s.eb:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZProportionEstimate -> geogebra.common.i.s.ec:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZProportionTest -> geogebra.common.i.s.ed:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.CmdZipf -> geogebra.common.i.s.ee:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.statistics.FrequencyGgb -> geogebra.common.i.s.ef:
    long getCount(java.lang.Comparable) -> a
    long getCumFreq(java.lang.Comparable) -> b
geogebra.common.kernel.statistics.RegressionMath -> geogebra.common.i.s.eg:
    boolean error -> a
    double p1 -> a
    double p2 -> b
    double p3 -> c
    double p4 -> d
    double p5 -> e
    double sigmax -> f
    double sigmax2 -> g
    double sigmax3 -> h
    double sigmax4 -> i
    double sigmax5 -> j
    double sigmax6 -> k
    double sigmax7 -> l
    double sigmax8 -> m
    double sigmay -> n
    double sigmay2 -> o
    double sigmaxy -> p
    double sigmax2y -> q
    double sigmax3y -> r
    double sigmax4y -> s
    geogebra.common.kernel.geos.GeoList geolist -> a
    double[] xlist -> a
    double[] ylist -> b
    int size -> a
    double[][] marray -> a
    double[][] yarray -> b
    double[] pararray -> c
    double getP1() -> a
    double getP2() -> b
    double getP3() -> c
    double getP4() -> d
    double getP5() -> e
    double[] getPar() -> a
    boolean doPolyN(geogebra.common.kernel.geos.GeoList,int) -> a
    boolean doLinear(geogebra.common.kernel.geos.GeoList) -> a
    boolean doQuad(geogebra.common.kernel.geos.GeoList) -> b
    boolean doCubic(geogebra.common.kernel.geos.GeoList) -> c
    boolean doQuart(geogebra.common.kernel.geos.GeoList) -> d
    boolean doExp(geogebra.common.kernel.geos.GeoList) -> e
    boolean doLog(geogebra.common.kernel.geos.GeoList) -> f
    boolean doPow(geogebra.common.kernel.geos.GeoList) -> g
    double det22(double,double,double,double) -> a
    double det33(double,double,double,double,double,double,double,double,double) -> a
    double det44(double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double) -> a
    double det55(double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double) -> a
    void doSums(int) -> a
    void getPoints() -> a
    void makeMatrixArrays(int) -> b
geogebra.common.main.App -> geogebra.common.j.a:
    geogebra.common.plugin.ScriptManager scriptManager -> a
    boolean hasFullPermissions -> a
    boolean isSaved -> b
    boolean showResetIcon -> x
    boolean runningInFrame -> c
    geogebra.common.kernel.parser.cashandlers.ParserFunctions pf -> a
    geogebra.common.main.SpreadsheetTraceManager traceManager -> a
    int capturingThreshold -> a
    boolean showInputTop -> d
    boolean showAlgebraInput -> e
    boolean showToolBarTop -> f
    boolean showToolBarHelp -> g
    boolean showInputHelpToggle -> h
    boolean showAuxiliaryObjects -> i
    boolean rightClickEnabled -> j
    boolean exporting -> k
    java.lang.String CASVersionString -> a
    geogebra.common.io.MyXMLio myXMLio -> a
    int guiFontSize -> h
    int appFontSize -> i
    int maxLayerUsed -> j
    int booleanSize -> b
    int rightAngleStyle -> c
    boolean useJavaFontsForLaTeX -> l
    java.util.ArrayList selectedGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean isOnTheFlyPointCreationActive -> m
    geogebra.common.main.settings.Settings settings -> a
    boolean antialiasing -> n
    boolean[] showAxes -> a
    boolean showGrid -> o
    boolean initing -> p
    boolean labelDragsEnabled -> y
    java.util.HashMap translateCommandTable -> a
    geogebra.common.util.LowerCaseDictionary commandDict -> a
    geogebra.common.util.LowerCaseDictionary commandDictCAS -> b
    geogebra.common.euclidian.EuclidianView euclidianView -> a
    geogebra.common.euclidian.EuclidianController euclidianController -> a
    geogebra.common.main.GeoElementSelectionListener currentSelectionListener -> a
    boolean showMenuBar -> q
    geogebra.common.util.LowerCaseDictionary[] subCommandDict -> a
    java.lang.String scriptingLanguage -> b
    boolean blockUpdateScripts -> z
    boolean useBrowserForJavaScript -> A
    java.lang.String[] fontSizeStrings -> b
    int[] roundingMenuLookup -> a
    int[] decimalsLookup -> b
    int[] figuresLookup -> c
    java.lang.String[] strDecimalSpacesAC -> a
    java.lang.StringBuilder sbOrdinal -> a
    boolean useLocalizedDigits -> B
    boolean reverseNameDescription -> C
    boolean isAutoCompletePossible -> D
    geogebra.common.main.InfoBar infobar -> a
    geogebra.common.util.GeoGebraLogger logger -> a
    int[] version -> d
    geogebra.common.kernel.Macro macro -> a
    int labelingStyle -> k
    boolean scriptingDisabled -> E
    boolean reverseMouseWheel -> F
    java.util.ArrayList tmpPerspectives -> b
    boolean showToolBar -> r
    geogebra.common.gui.view.properties.PropertiesView propertiesView -> a
    boolean shiftDragZoomEnabled -> s
    boolean useTransparentCursorWhenDragging -> t
    int dataParamWidth -> d
    int dataParamHeight -> e
    boolean useFullGui -> u
    java.lang.StringBuilder sbPlain -> b
    boolean useFullAppGui -> v
    int appCanvasHeight -> f
    int appCanvasWidth -> g
    java.util.Random random -> a
    geogebra.common.kernel.geos.GeoElement geoForCopyStyle -> a
    geogebra.common.gui.menubar.OptionsMenu optionsMenu -> a
    boolean needsSpreadsheetTableModel -> w
    void setCASVersionString(java.lang.String) -> a
    java.lang.String getCASVersionString() -> a
    boolean useJavaFontsForLaTeX() -> a
    geogebra.common.util.LowerCaseDictionary newLowerCaseDictionary() -> a
    void fillCasCommandDict() -> a
    geogebra.common.util.LowerCaseDictionary getCommandDictionaryCAS() -> b
    geogebra.common.util.LowerCaseDictionary[] getSubCommandDictionary() -> a
    void initTranslatedCommands() -> b
    geogebra.common.util.LowerCaseDictionary getCommandDictionary() -> c
    void fillCommandDict() -> c
    boolean tableVisible(int) -> a
    java.lang.String getReverseCommand(java.lang.String) -> a
    void updateCommandDictionary() -> d
    void addMacroCommands() -> e
    void removeMacroCommands() -> f
    java.lang.String getCommand(java.lang.String) -> b
    java.lang.String getPlain(java.lang.String) -> c
    java.lang.String getPlainLabel(java.lang.String) -> d
    java.lang.String getMenu(java.lang.String) -> e
    java.lang.String getError(java.lang.String) -> f
    java.lang.String getSymbol(int) -> a
    java.lang.String getSymbolTooltip(int) -> b
    void setTooltipFlag() -> g
    void setTooltipLanguage(java.lang.String) -> b
    boolean isApplet() -> b
    void storeUndoInfo() -> h
    boolean isUsingFullGui() -> c
    boolean showView(int) -> b
    java.lang.String getLanguage() -> b
    boolean letRename() -> d
    boolean letDelete() -> e
    boolean letRedefine() -> f
    java.lang.String translationFix(java.lang.String) -> g
    boolean isBlockUpdateScripts() -> g
    void setBlockUpdateScripts(boolean) -> a
    java.lang.String getInternalCommand(java.lang.String) -> h
    void showError(java.lang.String) -> c
    void showErrorDialog(java.lang.String) -> d
    void setUseBrowserForJavaScript(boolean) -> b
    boolean useBrowserForJavaScript() -> h
    void initJavaScriptViewWithoutJavascript() -> i
    geogebra.common.plugin.ScriptManager getScriptManager() -> a
    java.lang.String getTraceXML(geogebra.common.kernel.geos.GeoElement) -> a
    void resetTraceColumn(geogebra.common.kernel.geos.GeoElement) -> a
    void updateMaxLayerUsed(int) -> a
    boolean is3D() -> i
    java.lang.String[] getFontSizeStrings() -> a
    geogebra.common.kernel.geos.GeoElement getLastCreatedGeoElement() -> a
    java.lang.String[] getRoundingMenu() -> b
    boolean isZeroPlural(java.lang.String) -> a
    void deleteSelectedObjects() -> j
    void setSelectedGeos(java.util.ArrayList) -> a
    void setSelectedGeos(java.util.ArrayList,boolean) -> a
    geogebra.common.kernel.geos.GeoElement setFirstGeoSelectedForPropertiesView() -> b
    int getSelectedLayer() -> a
    void selectAll(int) -> b
    void invertSelection() -> k
    void selectAllPredecessors() -> l
    void showHideSelection() -> m
    void showHideSelectionLabels() -> n
    boolean showAuxiliaryObjects() -> j
    void selectAllDescendants() -> o
    void getKeyboardXML(java.lang.StringBuilder) -> a
    boolean freeMemoryIsCritical() -> k
    long freeMemory() -> a
    java.lang.String getOrdinalNumber(int) -> c
    java.lang.String getOrdinalNumberEn(int) -> d
    boolean isUsingLocalizedDigits() -> l
    void setUseLocalizedDigits(boolean) -> c
    boolean isReverseNameDescriptionLanguage() -> m
    boolean isAutoCompletePossible() -> n
    boolean isRightToLeftReadingOrder() -> o
    boolean isRightToLeftDigits(geogebra.common.kernel.StringTemplate) -> a
    void updateRightAngleStyle() -> p
    int getMaxLayerUsed() -> b
    double countPixels(double,double) -> a
    geogebra.common.gui.view.algebra.AlgebraView getAlgebraView() -> a
    geogebra.common.euclidian.EuclidianView getEuclidianView1() -> a
    void resetMaxLayerUsed() -> q
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getActiveEuclidianView() -> a
    void getEuclidianViewXML(java.lang.StringBuilder,boolean) -> a
    boolean hasEuclidianView3D() -> p
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getEuclidianView3D() -> b
    boolean hasEuclidianView2EitherShowingOrNot() -> q
    boolean isShowingEuclidianView2() -> r
    geogebra.common.util.AbstractImageManager getImageManager() -> a
    geogebra.common.gui.GuiManager getGuiManager() -> a
    geogebra.common.main.DialogManager getDialogManager() -> a
    void initGuiManager() -> r
    void printStacktrace(java.lang.String) -> e
    void showAnnouncement(java.lang.String) -> f
    void hideAnnouncement() -> s
    void debug(java.lang.Object) -> a
    void debug(java.lang.String) -> g
    void notice(java.lang.String) -> h
    void info(java.lang.String) -> i
    void error(java.lang.String) -> j
    void warn(java.lang.String) -> k
    boolean isMacOS() -> s
    boolean isWindows() -> t
    java.lang.String getScriptingLanguage() -> c
    void setScriptingLanguage(java.lang.String) -> l
    boolean isWhitespace(char) -> a
    void evalJavaScript(geogebra.common.main.App,java.lang.String,java.lang.String) -> a
    void setFileVersion(java.lang.String) -> m
    int[] getSubValues(java.lang.String) -> a
    geogebra.common.euclidian.EuclidianView createEuclidianView() -> b
    int getMode() -> c
    int getCurrentLabelingStyle() -> d
    int getMD5folderLength(java.lang.String) -> a
    geogebra.common.awt.GBufferedImage getExternalImageAdapter(java.lang.String) -> a
    java.lang.String getSyntaxString() -> d
    java.lang.String getCommandSyntax(java.lang.String) -> i
    void clearSelectedGeos() -> t
    void clearSelectedGeos(boolean) -> d
    void clearSelectedGeos(boolean,boolean) -> a
    boolean isLabelDragsEnabled() -> u
    void setLabelDragsEnabled(boolean) -> e
    void setScrollToShow(boolean) -> f
    void setUnsaved() -> u
    void setActiveView(int) -> c
    void refreshViews() -> v
    void openMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro() -> a
    java.lang.String getMacroXML() -> e
    boolean hasEuclidianView2() -> v
    void showError(geogebra.common.main.MyError) -> a
    java.lang.String getXML() -> f
    void showError(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.View getView(int) -> a
    java.lang.String getCompleteUserInterfaceXML(boolean) -> a
    void getScriptingXML(java.lang.StringBuilder,boolean) -> c
    geogebra.common.main.settings.Settings getSettings() -> a
    java.lang.String getUniqueId() -> g
    void setUniqueId(java.lang.String) -> n
    void setShowAuxiliaryObjects(boolean) -> g
    void setLabelingStyle(int) -> d
    int getLabelingStyle() -> e
    boolean isScriptingDisabled() -> w
    void setScriptingDisabled(boolean) -> h
    boolean isMouseWheelReversed() -> x
    void reverseMouseWheel(boolean) -> i
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    int getTooltipTimeout() -> f
    boolean isUsingLocalizedLabels() -> y
    void setUseLocalizedLabels(boolean) -> j
    geogebra.common.euclidian.DrawEquationInterface getDrawEquation() -> a
    void setShowConstructionProtocolNavigation(boolean) -> k
    void setTmpPerspectives(java.util.ArrayList) -> b
    java.util.ArrayList getTmpPerspectives() -> a
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    void setTooltipTimeout(int) -> e
    geogebra.common.euclidian.EuclidianView getEuclidianView2() -> c
    double getWidth() -> a
    double getHeight() -> b
    geogebra.common.awt.GFont getFontCommon(boolean,int,int) -> a
    geogebra.common.awt.GFont getPlainFontCommon() -> a
    boolean isExporting() -> z
    java.util.ArrayList getSelectedGeos() -> b
    void setShowToolBarNoUpdate(boolean) -> l
    void setShowToolBarHelpNoUpdate(boolean) -> m
    boolean showToolBar() -> A
    void setShowMenuBar(boolean) -> n
    void setShowToolBar(boolean,boolean) -> b
    void addSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> b
    void addSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean,boolean) -> a
    void addSelectedGeos(java.util.ArrayList,boolean) -> b
    void initKernel() -> w
    void initEuclidianViews() -> x
    geogebra.common.euclidian.EuclidianView newEuclidianView(boolean[],boolean) -> a
    geogebra.common.euclidian.EuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.UndoManager getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.AnimationManager newAnimationManager(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter newGeoElementGraphicsAdapter() -> a
    void repaintSpreadsheet() -> y
    boolean isOnTheFlyPointCreationActive() -> B
    geogebra.common.main.SpreadsheetTraceManager getTraceManager() -> a
    void setDefaultCursor() -> z
    void setWaitCursor() -> A
    void updateStyleBars() -> B
    void toggleSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> c
    void toggleSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setMoveMode() -> C
    geogebra.common.main.SpreadsheetTableModel getSpreadsheetTableModel() -> a
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void setMode(int) -> f
    void addToEuclidianView(geogebra.common.kernel.geos.GeoElement) -> d
    void removeFromEuclidianView(geogebra.common.kernel.geos.GeoElement) -> e
    void setXML(java.lang.String,boolean) -> a
    geogebra.common.plugin.GgbAPI getGgbApi() -> a
    geogebra.common.sound.SoundManager getSoundManager() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int selectedGeosSize() -> g
    boolean isRightClick(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean isControlDown(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean isMiddleClick(geogebra.common.euclidian.event.AbstractEvent) -> c
    boolean showAlgebraInput() -> C
    geogebra.common.main.GlobalKeyDispatcher getGlobalKeyDispatcher() -> a
    void callAppletJavaScript(java.lang.String,java.lang.Object[]) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> b
    void setPropertiesView(geogebra.common.gui.view.properties.PropertiesView) -> a
    void setSelectionListenerMode(geogebra.common.main.GeoElementSelectionListener) -> a
    void updateSelection() -> D
    void updateSelection(boolean) -> o
    void setPropertiesViewPanel(geogebra.common.main.OptionType) -> a
    boolean containsSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean containsSelectedGeos(java.util.ArrayList) -> a
    void removeSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> f
    void removeSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean,boolean) -> b
    void selectNextGeo() -> E
    void selectLastGeo() -> F
    boolean isIniting() -> D
    boolean isShiftDragZoomEnabled() -> E
    void setShiftDragZoomEnabled(boolean) -> p
    void updateMenubar() -> G
    int getFontSize() -> h
    void setFontSize(int) -> g
    void setFontSize(int,boolean) -> a
    void updateUI() -> H
    void clearTooltipFlag() -> I
    void resetFonts() -> J
    int getGUIFontSize() -> i
    void setGUIFontSize(int) -> h
    geogebra.common.main.FontManager getFontManager() -> a
    geogebra.common.awt.GFont getFontCanDisplay(java.lang.String) -> a
    geogebra.common.awt.GFont getFontCanDisplay(java.lang.String,int) -> a
    geogebra.common.awt.GFont getFontCanDisplay(java.lang.String,boolean,int,int) -> a
    java.lang.String getGuiXML(boolean) -> b
    void getConsProtocolXML(java.lang.StringBuilder) -> b
    void getWindowLayoutXML(java.lang.StringBuilder,boolean) -> b
    void reset() -> K
    java.lang.String getPlainTooltip(java.lang.String) -> j
    java.lang.String getMenuTooltip(java.lang.String) -> k
    geogebra.common.main.GeoElementSelectionListener getCurrentSelectionListener() -> a
    void setCurrentSelectionListener(geogebra.common.main.GeoElementSelectionListener) -> b
    void setShowResetIcon(boolean) -> q
    boolean showResetIcon() -> F
    boolean isUndoActive() -> G
    boolean isHTML5Applet() -> H
    void setOnTheFlyPointCreationActive(boolean) -> r
    void setUseTransparentCursorWhenDragging(boolean) -> s
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getFormulaRenderingType() -> a
    void doAfterRedefine(geogebra.common.kernel.geos.GeoElement) -> g
    java.lang.String getLocaleStr() -> h
    void showURLinBrowser(java.lang.String) -> o
    void uploadToGeoGebraTube() -> L
    int getDataParamWidth() -> j
    int getDataParamHeight() -> k
    boolean getUseFullGui() -> I
    void setUndoActive(boolean) -> t
    java.lang.String getPlain(java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String[]) -> a
    boolean isFullAppGui() -> J
    int getAppCanvasWidth() -> l
    int getAppCanvasHeight() -> m
    boolean showInputTop() -> K
    void setShowInputTop(boolean,boolean) -> c
    boolean showInputHelpToggle() -> L
    void setShowInputHelpToggle(boolean) -> u
    void updateApplicationLayout() -> M
    java.lang.String getToolNameOrHelp(int,boolean) -> a
    java.lang.String getToolName(int) -> e
    java.lang.String getToolHelp(int) -> f
    java.lang.String getFunction(java.lang.String) -> l
    geogebra.common.kernel.parser.cashandlers.ParserFunctions getParserFunctions() -> a
    java.lang.String getCountryFromGeoIP() -> i
    double getRandomNumber() -> c
    int getRandomIntegerBetween(double,double) -> a
    void setRandomSeed(int) -> i
    boolean loadXML(java.lang.String) -> b
    void exportToLMS(boolean) -> v
    void copyGraphicsViewToClipboard() -> N
    void setStandardView() -> O
    void exitAll() -> P
    void addMenuItem(geogebra.common.gui.menubar.MenuInterface,java.lang.String,java.lang.String,boolean,geogebra.common.gui.menubar.MenuInterface) -> a
    java.lang.String getVersionString() -> j
    geogebra.common.util.NormalizerMinimal getNormalizer() -> a
    java.lang.String getEmptyIconFileName() -> k
    void zoom(double,double,double) -> a
    void zoomAxesRatio(double) -> a
    void setViewShowAllObjects() -> Q
    void setRightClickEnabled(boolean) -> w
    boolean isRightClickEnabled() -> M
    boolean letShowPopupMenu() -> N
    boolean letShowPropertiesDialog() -> O
    java.lang.String getPreferencesXML() -> l
    void runScripts(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    void showRelation(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.Object getMainComponent() -> a
    geogebra.common.kernel.geos.GeoElement getGeoForCopyStyle() -> c
    void setGeoForCopyStyle(geogebra.common.kernel.geos.GeoElement) -> h
    geogebra.common.factories.CASFactory getCASFactory() -> a
    geogebra.common.factories.SwingFactory getSwingFactory() -> a
    geogebra.common.factories.Factory getFactory() -> a
    geogebra.common.gui.menubar.OptionsMenu getOptionsMenu() -> a
    boolean hasOptionsMenu() -> P
    geogebra.common.io.MyXMLio getXMLio() -> a
    geogebra.common.io.MyXMLio createXMLio(geogebra.common.kernel.Construction) -> a
    void scheduleUpdateConstruction() -> R
    void setNeedsSpreadsheetTableModel() -> S
    boolean needsSpreadsheetTableModel() -> Q
    void setShowAlgebraInput(boolean,boolean) -> d
    geogebra.common.main.Localization getLocalization() -> a
geogebra.common.main.BracketsError -> geogebra.common.j.b:
geogebra.common.main.CasType -> geogebra.common.j.c:
    geogebra.common.main.CasType NO_CAS -> a
    geogebra.common.main.CasType MATHPIPER -> b
    geogebra.common.main.CasType MAXIMA -> c
    geogebra.common.main.CasType MPREDUCE -> d
    geogebra.common.main.CasType[] ENUM$VALUES -> a
    geogebra.common.main.CasType[] values() -> values
    geogebra.common.main.CasType valueOf(java.lang.String) -> valueOf
geogebra.common.main.DialogManager -> geogebra.common.j.d:
    java.lang.String defaultAngle -> a
    geogebra.common.main.App app -> a
    java.lang.Object oldString -> a
    geogebra.common.gui.dialog.TextInputDialog textInputDialog -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showDataSourceDialog(int,boolean) -> a
    void showRedefineDialog(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void doAngleFixed(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    boolean showSliderCreationDialog(int,int) -> a
    boolean confirm(java.lang.String) -> a
    void showNumberInputDialogRotate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showNumberInputDialogRegularPolygon(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.GPoint,geogebra.common.kernel.geos.GeoBoolean) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.EuclidianView) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    java.lang.String rotateObject(geogebra.common.main.App,java.lang.String,boolean,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    boolean makeRegularPolygon(geogebra.common.main.App,java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    geogebra.common.kernel.arithmetic.NumberValue getNumber(geogebra.common.kernel.Kernel,java.lang.String,java.lang.String) -> a
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoNumeric setSliderFromDefault(geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    void closeAll() -> a
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showPropertiesDialog() -> b
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showPropertiesDialog(geogebra.common.main.OptionType,java.util.ArrayList) -> a
    void showToolbarConfigDialog() -> c
    boolean doDilate(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void doSegmentFixed(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.arithmetic.NumberValue) -> a
    void showTextDialog(geogebra.common.kernel.geos.GeoText) -> a
    void showTextCreationDialog(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void openToolHelp() -> d
    void showTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.gui.dialog.TextInputDialog createTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
geogebra.common.main.FontManager -> geogebra.common.j.e:
    void setFontSize(int) -> a
    geogebra.common.awt.GFont getFontCanDisplay(java.lang.String,boolean,int,int) -> a
geogebra.common.main.GeoElementSelectionListener -> geogebra.common.j.f:
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
geogebra.common.main.GeoGebraColorConstants -> geogebra.common.j.g:
    geogebra.common.awt.GColor TABLE_SELECTED_BACKGROUND_COLOR -> a
    geogebra.common.awt.GColor TABLE_SELECTED_BACKGROUND_COLOR_HEADER -> b
    geogebra.common.awt.GColor TABLE_BACKGROUND_COLOR_HEADER -> c
    geogebra.common.awt.GColor TABLE_GRID_COLOR -> d
    geogebra.common.awt.GColor RED -> e
    geogebra.common.awt.GColor ORANGE -> f
    geogebra.common.awt.GColor YELLOW -> g
    geogebra.common.awt.GColor GREEN -> h
    geogebra.common.awt.GColor CYAN -> i
    geogebra.common.awt.GColor BLUE -> j
    geogebra.common.awt.GColor VIOLET -> k
    geogebra.common.awt.GColor MAGENTA -> l
    geogebra.common.awt.GColor LIME -> m
    geogebra.common.awt.GColor PINK -> n
    geogebra.common.awt.GColor LIGHTORANGE -> o
    geogebra.common.awt.GColor LIGHTYELLOW -> p
    geogebra.common.awt.GColor AQUA -> q
    geogebra.common.awt.GColor LIGHTPURPLE -> r
    geogebra.common.awt.GColor LIGHTVIOLET -> s
    geogebra.common.awt.GColor TURQUOISE -> t
    geogebra.common.awt.GColor LIGHTGREEN -> u
    geogebra.common.awt.GColor MAROON -> v
    geogebra.common.awt.GColor BROWN -> w
    geogebra.common.awt.GColor DARKGREEN -> x
    geogebra.common.awt.GColor LIGHTBLUE -> y
    geogebra.common.awt.GColor GOLD -> z
    geogebra.common.awt.GColor DARKBLUE -> A
    geogebra.common.awt.GColor INDIGO -> B
    geogebra.common.awt.GColor PURPLE -> C
    geogebra.common.awt.GColor CRIMSON -> D
    geogebra.common.awt.GColor WHITE -> E
    geogebra.common.awt.GColor BLACK -> F
    geogebra.common.awt.GColor GRAY7 -> G
    geogebra.common.awt.GColor GRAY6 -> H
    geogebra.common.awt.GColor GRAY5 -> I
    geogebra.common.awt.GColor GRAY4 -> J
    geogebra.common.awt.GColor GRAY3 -> K
    geogebra.common.awt.GColor GRAY2 -> L
    geogebra.common.awt.GColor GRAY1 -> M
    geogebra.common.awt.GColor DARKGRAY -> N
    geogebra.common.awt.GColor LIGHTGRAY -> O
    geogebra.common.awt.GColor SILVER -> P
    java.util.HashMap geogebraColor -> a
    java.util.HashMap geogebraColorReverse -> b
    geogebra.common.awt.GColor[] primaryColors -> b
    geogebra.common.awt.GColor[] lightPrimaryColors -> c
    geogebra.common.awt.GColor[] darkPrimaryColors -> d
    geogebra.common.awt.GColor[] grayColors -> e
    geogebra.common.awt.GColor[] mainColorSwatchColors -> a
    java.util.HashMap colors -> c
    java.util.HashMap getGeoGebraColors() -> a
    java.util.HashMap getGeoGebraColorReverse() -> c
    geogebra.common.awt.GColor getGeogebraColor(geogebra.common.main.App,java.lang.String) -> a
    java.lang.String getGeogebraColorName(geogebra.common.main.App,geogebra.common.awt.GColor) -> a
    geogebra.common.awt.GColor grayN(int) -> a
    geogebra.common.awt.GColor[] getPrimaryColors() -> b
    geogebra.common.awt.GColor[] getLightPrimaryColors() -> c
    geogebra.common.awt.GColor[] getDarkPrimaryColors() -> d
    geogebra.common.awt.GColor[] getGrayColors() -> e
    geogebra.common.awt.GColor[] getPopupArray(int) -> a
    geogebra.common.awt.GColor[] getPrimarySwatchColors() -> a
    java.util.HashMap htmlColorMap() -> b
geogebra.common.main.GeoGebraPreferences -> geogebra.common.j.h:
geogebra.common.main.GlobalKeyDispatcher -> geogebra.common.j.i:
    geogebra.common.main.App app -> a
    java.util.TreeSet tempSet -> a
    geogebra.common.kernel.Matrix.Coords tempVec -> a
    int[] $SWITCH_TABLE$geogebra$common$main$KeyCodes -> a
    void handleFunctionKeyForAlgebraInput(int,geogebra.common.kernel.geos.GeoElement) -> a
    java.util.TreeSet getTempSet() -> a
    boolean handleArrowKeyMovement(java.util.ArrayList,double,double,double) -> a
    boolean handleGeneralKeys(geogebra.common.main.KeyCodes,boolean,boolean,boolean,boolean,boolean) -> a
    void createNewWindow() -> a
    void showPrintPreview(geogebra.common.main.App) -> a
    void handleCtrlV() -> b
    boolean handleCtrlShiftN(boolean) -> a
    void handleCtrlC() -> c
    boolean handleTab(boolean,boolean) -> a
    boolean handleEnter() -> a
    boolean changeFontsAndGeoElements(geogebra.common.main.App,int,boolean) -> a
    int getPointSizeInc(int,int) -> a
    void setGeoProperties(geogebra.common.kernel.geos.GeoElement,int,int,int,boolean) -> a
    boolean handleSelectedGeosKeys(geogebra.common.main.KeyCodes,java.util.ArrayList,boolean,boolean,boolean,boolean) -> a
    void copyDefinitionsToInputBarAsList(java.util.ArrayList) -> a
    int[] $SWITCH_TABLE$geogebra$common$main$KeyCodes() -> a
geogebra.common.main.InfoBar -> geogebra.common.j.j:
    void show(java.lang.String) -> a
    void hide() -> a
geogebra.common.main.KeyCodes -> geogebra.common.j.k:
    geogebra.common.main.KeyCodes A -> a
    geogebra.common.main.KeyCodes B -> b
    geogebra.common.main.KeyCodes C -> c
    geogebra.common.main.KeyCodes D -> d
    geogebra.common.main.KeyCodes E -> e
    geogebra.common.main.KeyCodes F -> f
    geogebra.common.main.KeyCodes G -> g
    geogebra.common.main.KeyCodes H -> h
    geogebra.common.main.KeyCodes I -> i
    geogebra.common.main.KeyCodes J -> j
    geogebra.common.main.KeyCodes K -> k
    geogebra.common.main.KeyCodes L -> l
    geogebra.common.main.KeyCodes M -> m
    geogebra.common.main.KeyCodes N -> n
    geogebra.common.main.KeyCodes O -> o
    geogebra.common.main.KeyCodes P -> p
    geogebra.common.main.KeyCodes Q -> q
    geogebra.common.main.KeyCodes R -> r
    geogebra.common.main.KeyCodes S -> s
    geogebra.common.main.KeyCodes T -> t
    geogebra.common.main.KeyCodes U -> u
    geogebra.common.main.KeyCodes V -> v
    geogebra.common.main.KeyCodes W -> w
    geogebra.common.main.KeyCodes X -> x
    geogebra.common.main.KeyCodes Y -> y
    geogebra.common.main.KeyCodes Z -> z
    geogebra.common.main.KeyCodes F1 -> A
    geogebra.common.main.KeyCodes F2 -> B
    geogebra.common.main.KeyCodes F3 -> C
    geogebra.common.main.KeyCodes F4 -> D
    geogebra.common.main.KeyCodes F5 -> E
    geogebra.common.main.KeyCodes F6 -> F
    geogebra.common.main.KeyCodes F7 -> G
    geogebra.common.main.KeyCodes F8 -> H
    geogebra.common.main.KeyCodes F9 -> I
    geogebra.common.main.KeyCodes F10 -> J
    geogebra.common.main.KeyCodes F11 -> K
    geogebra.common.main.KeyCodes F12 -> L
    geogebra.common.main.KeyCodes K0 -> M
    geogebra.common.main.KeyCodes K1 -> N
    geogebra.common.main.KeyCodes K2 -> O
    geogebra.common.main.KeyCodes K3 -> P
    geogebra.common.main.KeyCodes K4 -> Q
    geogebra.common.main.KeyCodes K5 -> R
    geogebra.common.main.KeyCodes K6 -> S
    geogebra.common.main.KeyCodes K7 -> T
    geogebra.common.main.KeyCodes K8 -> U
    geogebra.common.main.KeyCodes K9 -> V
    geogebra.common.main.KeyCodes NUMPAD0 -> W
    geogebra.common.main.KeyCodes NUMPAD1 -> X
    geogebra.common.main.KeyCodes NUMPAD2 -> Y
    geogebra.common.main.KeyCodes NUMPAD3 -> Z
    geogebra.common.main.KeyCodes NUMPAD4 -> aa
    geogebra.common.main.KeyCodes NUMPAD5 -> ab
    geogebra.common.main.KeyCodes NUMPAD6 -> ac
    geogebra.common.main.KeyCodes NUMPAD7 -> ad
    geogebra.common.main.KeyCodes NUMPAD8 -> ae
    geogebra.common.main.KeyCodes NUMPAD9 -> af
    geogebra.common.main.KeyCodes MINUS -> ag
    geogebra.common.main.KeyCodes SUBTRACT -> ah
    geogebra.common.main.KeyCodes PLUS -> ai
    geogebra.common.main.KeyCodes ADD -> aj
    geogebra.common.main.KeyCodes EQUALS -> ak
    geogebra.common.main.KeyCodes BACK_QUOTE -> al
    geogebra.common.main.KeyCodes LEFT_SQUARE_BRACKET -> am
    geogebra.common.main.KeyCodes RIGHT_SQUARE_BRACKET -> an
    geogebra.common.main.KeyCodes ALT -> ao
    geogebra.common.main.KeyCodes BACKSPACE -> ap
    geogebra.common.main.KeyCodes CTRL -> aq
    geogebra.common.main.KeyCodes DELETE -> ar
    geogebra.common.main.KeyCodes DOWN -> as
    geogebra.common.main.KeyCodes END -> at
    geogebra.common.main.KeyCodes ENTER -> au
    geogebra.common.main.KeyCodes ESCAPE -> av
    geogebra.common.main.KeyCodes HOME -> aw
    geogebra.common.main.KeyCodes LEFT -> ax
    geogebra.common.main.KeyCodes PAGEDOWN -> ay
    geogebra.common.main.KeyCodes PAGEUP -> az
    geogebra.common.main.KeyCodes RIGHT -> aA
    geogebra.common.main.KeyCodes SHIFT -> aB
    geogebra.common.main.KeyCodes INSERT -> aC
    geogebra.common.main.KeyCodes TAB -> aD
    geogebra.common.main.KeyCodes UP -> aE
    geogebra.common.main.KeyCodes SPACE -> aF
    geogebra.common.main.KeyCodes CONTEXT_MENU -> aG
    geogebra.common.main.KeyCodes WINDOWS -> aH
    geogebra.common.main.KeyCodes BACKSLASH -> aI
    geogebra.common.main.KeyCodes SLASH -> aJ
    geogebra.common.main.KeyCodes NUMPADSLASH -> aK
    geogebra.common.main.KeyCodes COMMA -> aL
    geogebra.common.main.KeyCodes SEMICOLON -> aM
    geogebra.common.main.KeyCodes APOSTROPHE -> aN
    geogebra.common.main.KeyCodes HASH -> aO
    geogebra.common.main.KeyCodes NUMPADASTERISK -> aP
    geogebra.common.main.KeyCodes NUMLOCK -> aQ
    geogebra.common.main.KeyCodes META -> aR
    geogebra.common.main.KeyCodes CLEAR -> aS
    geogebra.common.main.KeyCodes PERIOD -> aT
    geogebra.common.main.KeyCodes UNKNOWN -> aU
    int javaKey -> a
    int GWTKey -> b
    geogebra.common.main.KeyCodes[] ENUM$VALUES -> a
    geogebra.common.main.KeyCodes translateJavacode(int) -> a
    geogebra.common.main.KeyCodes[] values() -> values
    geogebra.common.main.KeyCodes valueOf(java.lang.String) -> valueOf
geogebra.common.main.Localization -> geogebra.common.j.l:
    boolean tooltipFlag -> a
    java.lang.String[] fontSizeStrings -> a
    boolean reverseNameDescription -> c
    boolean rightToLeftReadingOrder -> b
    char unicodeDecimalPoint -> a
    char unicodeComma -> b
    char unicodeZero -> c
    java.lang.StringBuilder sbPlain -> a
    java.lang.StringBuilder sbOrdinal -> b
    boolean isAutoCompletePossible -> d
    boolean rightToLeftDigits -> e
    boolean useLocalizedDigits -> f
    boolean useLocalizedLabels -> g
    boolean isRightToLeftReadingOrder() -> a
    java.lang.String translationFixHu(java.lang.String) -> k
    java.lang.String translationFixPronouncedPrevChars(java.lang.String,int,int) -> a
    java.lang.String translationFixHuAffixChange(java.lang.String,int,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getCommand(java.lang.String) -> a
    java.lang.String getPlain(java.lang.String) -> b
    java.lang.String getMenu(java.lang.String) -> c
    java.lang.String getError(java.lang.String) -> d
    java.lang.String getSymbol(int) -> a
    java.lang.String reverseGetColor(java.lang.String) -> e
    java.lang.String getColor(java.lang.String) -> f
    java.lang.String getPlain(java.lang.String,java.lang.String[]) -> a
    java.lang.String getPlainLabel(java.lang.String) -> g
    java.lang.String getPlain(java.lang.String,java.lang.String) -> a
    java.lang.String getLanguage() -> a
    boolean languageIs(java.lang.String) -> a
    java.lang.String translationFix(java.lang.String) -> h
    java.lang.String getOrdinalNumber(int) -> b
    java.lang.String getOrdinalNumberEn(int) -> c
    boolean isAutoCompletePossible() -> b
    boolean isRightToLeftDigits(geogebra.common.kernel.StringTemplate) -> a
    boolean isUsingLocalizedDigits() -> c
    void updateLanguageFlags(java.lang.String) -> a
    boolean rightToLeftReadingOrder(java.lang.String) -> b
    boolean isUsingLocalizedLabels() -> d
    void setUseLocalizedLabels(boolean) -> a
    void setUseLocalizedDigits(boolean,geogebra.common.main.App) -> a
    java.lang.String getSymbolTooltip(int) -> d
    java.lang.String getMenuTooltip(java.lang.String) -> i
    java.lang.String getPlainTooltip(java.lang.String) -> j
    void initCommand() -> a
    void setTooltipFlag() -> b
    void clearTooltipFlag() -> c
    java.lang.String getTooltipLanguageString() -> b
    boolean isCommandChanged() -> e
    void setCommandChanged(boolean) -> b
    boolean isCommandNull() -> f
geogebra.common.main.MyError -> geogebra.common.j.m:
    geogebra.common.main.App app -> a
    java.lang.String[] strs -> a
    java.lang.String commandName -> a
    java.lang.String getcommandName() -> a
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    java.lang.String toString() -> toString
geogebra.common.main.MyParseError -> geogebra.common.j.n:
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
geogebra.common.main.OptionType -> geogebra.common.j.o:
    geogebra.common.main.OptionType OBJECTS -> a
    geogebra.common.main.OptionType EUCLIDIAN -> b
    geogebra.common.main.OptionType EUCLIDIAN2 -> c
    geogebra.common.main.OptionType CAS -> d
    geogebra.common.main.OptionType SPREADSHEET -> e
    geogebra.common.main.OptionType LAYOUT -> f
    geogebra.common.main.OptionType DEFAULTS -> g
    geogebra.common.main.OptionType ADVANCED -> h
    geogebra.common.main.OptionType[] ENUM$VALUES -> a
    geogebra.common.main.OptionType[] values() -> values
    geogebra.common.main.OptionType valueOf(java.lang.String) -> valueOf
geogebra.common.main.SpreadsheetTableModel -> geogebra.common.j.p:
    geogebra.common.main.App app -> a
    int highestUsedColumn -> a
    int highestUsedRow -> b
    boolean isIniting -> a
    int getRowCount() -> b
    int getColumnCount() -> c
    void setRowCount(int) -> a
    void setColumnCount(int) -> b
    java.lang.Object getValueAt(int,int) -> a
    void setValueAt(java.lang.Object,int,int) -> a
    void attachView() -> a
    int getHighestUsedColumn() -> d
    int getHighestUsedRow() -> e
    void updateHighestUsedColAndRow(int,int) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void addWithoutTrace(geogebra.common.kernel.geos.GeoElement) -> h
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void doRemove(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateWithoutTrace(geogebra.common.kernel.geos.GeoElement) -> i
    void updateLocation(geogebra.common.kernel.geos.GeoElement) -> g
    void clearView() -> d
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void repaintView() -> b
    void reset() -> g
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    int getViewID() -> a
geogebra.common.main.SpreadsheetTraceManager -> geogebra.common.j.q:
    geogebra.common.main.App app -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.util.HashMap traceGeoCollection -> a
    java.util.HashSet storedTraces -> a
    boolean collectingTraces -> a
    boolean doShiftCellsUp -> b
    double[] coords -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void addSpreadsheetTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void updateTraceSettings(geogebra.common.kernel.geos.GeoElement) -> b
    void clearGeoTrace(geogebra.common.kernel.geos.GeoElement) -> c
    void removeSpreadsheetTraceGeo(geogebra.common.kernel.geos.GeoElement) -> d
    void loadTraceGeoCollection() -> a
    int getNextTraceColumn() -> a
    int getHighestTraceColumn() -> b
    boolean isTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isTraceColumn(int) -> a
    java.util.ArrayList getTraceGeoList() -> a
    geogebra.common.kernel.geos.GeoElement getTraceGeo(int) -> a
    void clearGeoTraceColumns(geogebra.common.kernel.geos.GeoElement) -> e
    void clearGeoTraceColumns(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void handleColumnDelete(int,int) -> a
    void setNeedsColumnReset(geogebra.common.kernel.geos.GeoElement,boolean) -> b
    java.lang.String getTraceXML(geogebra.common.kernel.geos.GeoElement) -> a
    void traceToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> f
    boolean setGeoTraceRow(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction,java.util.ArrayList,int) -> a
    void setTraceCellAsGeoCopy(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    void setTraceCell(geogebra.common.kernel.Construction,int,int,java.lang.Object,geogebra.common.plugin.GeoClass) -> a
    void createTraceListCell(geogebra.common.kernel.Construction,int,int) -> a
    void updateTraceListCell(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement,int,int,java.util.ArrayList,int) -> a
    void clearTraceListCell(int,int) -> b
    void getCurrentTrace(geogebra.common.kernel.geos.GeoElement,java.util.ArrayList) -> a
    boolean addElementTrace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction,java.util.ArrayList) -> a
    void setHeader(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.main.settings.AbstractSettings -> geogebra.common.j.a.a:
    boolean isBatch -> a
    boolean settingsChanged -> b
    java.util.LinkedList listeners -> a
    void settingChanged() -> a
    void beginBatch() -> b
    void endBatch() -> c
    void addListener(geogebra.common.main.settings.SettingListener) -> a
    void removeListener(geogebra.common.main.settings.SettingListener) -> b
    java.util.LinkedList getListeners() -> a
    void setListeners(java.util.LinkedList) -> a
geogebra.common.main.settings.AlgebraSettings -> geogebra.common.j.a.b:
    int treeMode -> a
    boolean showAuxiliaryObjects -> a
    int[] collapsedNodes -> a
    void setTreeMode(int) -> a
    int getTreeMode() -> a
    void setShowAuxiliaryObjects(boolean) -> a
    boolean getShowAuxiliaryObjects() -> a
    void setCollapsedNodes(int[]) -> a
    int[] getCollapsedNodes() -> a
    void reset() -> d
geogebra.common.main.settings.ApplicationSettings -> geogebra.common.j.a.c:
geogebra.common.main.settings.CASSettings -> geogebra.common.j.a.d:
    long timeoutMillis -> a
    boolean showExpAsRoots -> a
    void init() -> d
    void setTimeoutMilliseconds(long) -> a
    void setShowExpAsRoots(boolean) -> a
    long getTimeoutMilliseconds() -> a
    boolean getShowExpAsRoots() -> a
geogebra.common.main.settings.ConstructionProtocolSettings -> geogebra.common.j.a.e:
    boolean showConstructionProtocol -> a
    double playDelay -> a
    boolean showPlayButton -> b
    boolean showConsProtButton -> c
    boolean[] defaultCpColumnsVisible -> a
    boolean[] cpColumnsVisible -> b
    boolean showPlayButton() -> a
    void setShowPlayButton(boolean) -> a
    double getPlayDelay() -> a
    void setPlayDelay(double) -> a
    boolean showConstructionProtocol() -> b
    void setShowConstructionProtocol(boolean) -> b
    boolean[] getColsVisibility() -> a
    void setColsVisibility(boolean[]) -> a
geogebra.common.main.settings.EuclidianSettings -> geogebra.common.j.a.f:
    geogebra.common.awt.GColor backgroundColor -> a
    geogebra.common.awt.GColor axesColor -> b
    geogebra.common.awt.GColor gridColor -> c
    int axesLineStyle -> a
    int gridLineStyle -> b
    double[] gridDistances -> a
    double[] axisCross -> b
    boolean[] positiveAxes -> e
    boolean[] drawBorderAxes -> f
    geogebra.common.kernel.arithmetic.NumberValue xminObject -> a
    geogebra.common.kernel.arithmetic.NumberValue xmaxObject -> b
    geogebra.common.kernel.arithmetic.NumberValue yminObject -> c
    geogebra.common.kernel.arithmetic.NumberValue ymaxObject -> d
    int tooltipsInThisView -> c
    geogebra.common.main.settings.EuclidianSettings euclidianSettings1 -> a
    boolean[] showAxes -> a
    boolean[] showAxesNumbers -> b
    java.lang.String[] axesLabels -> a
    java.lang.String[] axesUnitLabels -> b
    boolean[] piAxisUnit -> c
    int[] axesTickStyles -> a
    boolean[] automaticAxesNumberingDistances -> d
    double axisNumberingDistanceX -> a
    double axisNumberingDistanceY -> b
    boolean automaticGridDistance -> a
    double xZero -> c
    double yZero -> d
    double xscale -> e
    double yscale -> f
    geogebra.common.awt.GDimension preferredSize -> a
    boolean showGrid -> b
    boolean gridIsBold -> c
    int gridType -> d
    int pointCapturingMode -> e
    boolean allowShowMouseCoords -> d
    java.lang.Double lockedAxesRatio -> a
    void reset() -> d
    void setBackground(geogebra.common.awt.GColor) -> a
    geogebra.common.awt.GColor getBackground() -> a
    void setAxesColor(geogebra.common.awt.GColor) -> b
    geogebra.common.awt.GColor getAxesColor() -> b
    void setGridColor(geogebra.common.awt.GColor) -> c
    geogebra.common.awt.GColor getGridColor() -> c
    void setAxesLineStyle(int) -> a
    int getAxesLineStyle() -> a
    void setGridLineStyle(int) -> b
    int getGridLineStyle() -> b
    void setGridDistances(double[]) -> a
    double[] getGridDistances() -> a
    void setAutomaticGridDistance(boolean,boolean) -> a
    boolean getAutomaticGridDistance() -> a
    boolean getAllowShowMouseCoords() -> b
    void setAllowShowMouseCoords(boolean) -> a
    void setShowAxis(int,boolean) -> a
    boolean getShowAxis(int) -> a
    void setAxisLabel(int,java.lang.String) -> a
    java.lang.String[] getAxesLabels() -> a
    java.lang.String[] getAxesUnitLabels() -> b
    void setAxesUnitLabels(java.lang.String[]) -> a
    void setShowAxisNumbers(int,boolean) -> b
    boolean[] getShowAxisNumbers() -> a
    double getAxisNumberingDistanceX() -> a
    double getAxisNumberingDistanceY() -> b
    void setAxisNumberingDistanceX(double) -> a
    void setAxisNumberingDistanceY(double) -> b
    void setAutomaticAxesNumberingDistance(boolean,int,boolean) -> a
    boolean getAutomaticAxesNumberingDistance(int) -> b
    int[] getAxesTickStyles() -> a
    void setAxisTickStyle(int,int) -> a
    double[] getAxesCross() -> b
    void setAxisCross(int,double) -> a
    boolean[] getPositiveAxes() -> b
    void setPositiveAxis(int,boolean) -> c
    geogebra.common.kernel.geos.GeoNumeric getXminObject() -> a
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric getXmaxObject() -> b
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> b
    geogebra.common.kernel.geos.GeoNumeric getYminObject() -> c
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> c
    geogebra.common.kernel.geos.GeoNumeric getYmaxObject() -> d
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> d
    double getXZero() -> c
    double getYZero() -> d
    double getXscale() -> e
    double getYscale() -> f
    boolean hasDynamicBounds() -> c
    void setCoordSystem(double,double,double,double) -> a
    void setAxesNumberingDistance(double,int) -> a
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    geogebra.common.awt.GDimension getPreferredSize() -> a
    void setShowAxes(boolean,boolean) -> b
    void showGrid(boolean) -> b
    boolean getShowGrid() -> d
    boolean getGridIsBold() -> e
    void setGridIsBold(boolean) -> c
    int getGridType() -> c
    void setGridType(int) -> c
    int getPointCapturingMode() -> d
    boolean setPointCapturing(int) -> c
    void setAllowToolTips(int) -> d
    int getAllowToolTips() -> e
    void setDrawBorderAxes(int,boolean) -> d
    boolean[] getDrawBorderAxes() -> c
    void setLockedAxesRatio(double) -> c
    java.lang.Double getLockedAxesRatio() -> a
    void setBoldAxes(boolean) -> d
geogebra.common.main.settings.KeyboardSettings -> geogebra.common.j.a.g:
    java.util.ArrayList supportedLocales -> a
    float keyboardOpacity -> a
    int keyboardWidth -> a
    int keyboardHeight -> b
    java.lang.String keyboardLocale -> a
    boolean showKeyboardOnStart -> a
    float getKeyboardOpacity() -> a
    int getKeyboardWidth() -> a
    int getKeyboardHeight() -> b
    java.lang.String getKeyboardLocale() -> a
    void setKeyboardWidth(int) -> a
    void setKeyboardHeight(int) -> b
    void setShowKeyboardOnStart(boolean) -> a
    boolean isShowKeyboardOnStart() -> a
    void setKeyboardOpacity(float) -> a
    void keyboardResized(int,int) -> a
    void setKeyboardLocale(java.lang.String) -> a
geogebra.common.main.settings.LayoutSettings -> geogebra.common.j.a.h:
    boolean showTitleBar -> a
    boolean ignoreDocumentLayout -> b
    boolean allowStyleBar -> c
    boolean showTitleBar() -> a
    void setShowTitleBar(boolean) -> a
    boolean isIgnoringDocumentLayout() -> b
    void setIgnoreDocumentLayout(boolean) -> b
    boolean isAllowingStyleBar() -> c
    void setAllowStyleBar(boolean) -> c
geogebra.common.main.settings.ProbabilityCalculatorSettings -> geogebra.common.j.a.i:
    int distCount -> a
    double[] parameters -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST distributionType -> a
    boolean isCumulative -> a
    void setParameters(double[]) -> a
    double[] getParameters() -> a
    void setDistributionType(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST) -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST getDistributionType() -> a
    void setCumulative(boolean) -> a
    boolean isCumulative() -> a
geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST -> geogebra.common.j.a.i$a:
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST NORMAL -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST STUDENT -> b
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST CHISQUARE -> c
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST F -> d
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST CAUCHY -> e
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST EXPONENTIAL -> f
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST GAMMA -> g
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST WEIBULL -> h
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST LOGISTIC -> i
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST LOGNORMAL -> j
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST ERLANG -> k
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST BINOMIAL -> l
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST PASCAL -> m
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST HYPERGEOMETRIC -> n
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST POISSON -> o
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST[] ENUM$VALUES -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST[] values() -> values
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST valueOf(java.lang.String) -> valueOf
geogebra.common.main.settings.SettingListener -> geogebra.common.j.a.j:
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
geogebra.common.main.settings.Settings -> geogebra.common.j.a.k:
    geogebra.common.main.settings.EuclidianSettings[] euclidianSettings -> a
    geogebra.common.main.settings.AlgebraSettings algebraSettings -> a
    geogebra.common.main.settings.SpreadsheetSettings spreadsheetSettings -> a
    geogebra.common.main.settings.ConstructionProtocolSettings consProtSettings -> a
    geogebra.common.main.settings.LayoutSettings layoutSettings -> a
    geogebra.common.main.settings.ApplicationSettings applicationSettings -> a
    geogebra.common.main.settings.KeyboardSettings keyboardSettings -> a
    geogebra.common.main.settings.CASSettings casSettings -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings probCalcSettings -> a
    void resetSettings() -> a
    void beginBatch() -> b
    void endBatch() -> c
    geogebra.common.main.settings.EuclidianSettings getEuclidian(int) -> a
    geogebra.common.main.settings.AlgebraSettings getAlgebra() -> a
    geogebra.common.main.settings.SpreadsheetSettings getSpreadsheet() -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings getProbCalcSettings() -> a
    geogebra.common.main.settings.ConstructionProtocolSettings getConstructionProtocol() -> a
    geogebra.common.main.settings.LayoutSettings getLayout() -> a
    geogebra.common.main.settings.KeyboardSettings getKeyboard() -> a
    geogebra.common.main.settings.CASSettings getCasSettings() -> a
geogebra.common.main.settings.SpreadsheetSettings -> geogebra.common.j.a.l:
    boolean showFormulaBar -> a
    boolean showGrid -> b
    boolean showRowHeader -> c
    boolean showColumnHeader -> d
    boolean showVScrollBar -> e
    boolean showHScrollBar -> f
    boolean showBrowserPanel -> g
    boolean isColumnSelect -> h
    boolean allowSpecialEditor -> i
    boolean allowToolTips -> j
    boolean equalsRequired -> k
    boolean enableAutoComplete -> l
    java.lang.String defaultFile -> a
    java.lang.String initialURL -> b
    java.lang.String initialFilePath -> c
    int initialBrowserMode -> a
    boolean isDefaultBrowser -> m
    java.util.HashMap widthMap -> a
    java.util.HashMap heightMap -> b
    int preferredColumnWidth -> b
    int preferredRowHeight -> c
    java.lang.String cellFormat -> d
    geogebra.common.awt.GPoint scrollPosition -> a
    geogebra.common.awt.GPoint selectedCell -> b
    geogebra.common.awt.GDimension preferredSize -> a
    java.util.HashMap getWidthMap() -> a
    void addWidth(int,int) -> a
    int preferredColumnWidth() -> a
    void setPreferredColumnWidth(int) -> a
    java.util.HashMap getHeightMap() -> b
    void addHeight(int,int) -> b
    int preferredRowHeight() -> b
    void setPreferredRowHeight(int) -> b
    boolean showFormulaBar() -> a
    void setShowFormulaBar(boolean) -> a
    boolean showGrid() -> b
    void setShowGrid(boolean) -> b
    boolean showRowHeader() -> c
    void setShowRowHeader(boolean) -> c
    boolean showColumnHeader() -> d
    void setShowColumnHeader(boolean) -> d
    boolean showVScrollBar() -> e
    void setShowVScrollBar(boolean) -> e
    boolean showHScrollBar() -> f
    void setShowHScrollBar(boolean) -> f
    boolean showBrowserPanel() -> g
    void setShowFileBrowser(boolean) -> g
    boolean allowSpecialEditor() -> h
    void setAllowSpecialEditor(boolean) -> h
    boolean allowToolTips() -> i
    void setAllowToolTips(boolean) -> i
    boolean equalsRequired() -> j
    void setEqualsRequired(boolean) -> j
    boolean isColumnSelect() -> k
    java.lang.String cellFormat() -> a
    void setCellFormat(java.lang.String) -> a
    void setScrollPosition(geogebra.common.awt.GPoint) -> a
    geogebra.common.awt.GDimension preferredSize() -> a
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    java.lang.String defaultFile() -> b
    void setDefaultFile(java.lang.String) -> b
    java.lang.String initialURL() -> c
    void setInitialURL(java.lang.String) -> c
    java.lang.String initialFilePath() -> d
    void setInitialFilePath(java.lang.String) -> d
    int initialBrowserMode() -> c
    void setInitialBrowserMode(int) -> c
    void setDefaultBrowser(boolean) -> k
    void setEnableAutoComplete(boolean) -> l
    boolean isEnableAutoComplete() -> l
geogebra.common.plugin.EuclidianStyleConstants -> geogebra.common.plugin.EuclidianStyleConstants:
    int LINE_TYPE_FULL -> LINE_TYPE_FULL
    int LINE_TYPE_DASHED_SHORT -> LINE_TYPE_DASHED_SHORT
    int LINE_TYPE_DASHED_LONG -> LINE_TYPE_DASHED_LONG
    int LINE_TYPE_DOTTED -> LINE_TYPE_DOTTED
    int LINE_TYPE_DASHED_DOTTED -> LINE_TYPE_DASHED_DOTTED
    int RIGHT_ANGLE_STYLE_NONE -> RIGHT_ANGLE_STYLE_NONE
    int RIGHT_ANGLE_STYLE_SQUARE -> RIGHT_ANGLE_STYLE_SQUARE
    int RIGHT_ANGLE_STYLE_DOT -> RIGHT_ANGLE_STYLE_DOT
    int RIGHT_ANGLE_STYLE_L -> RIGHT_ANGLE_STYLE_L
    int DEFAULT_POINT_SIZE -> DEFAULT_POINT_SIZE
    int DEFAULT_LINE_THICKNESS -> DEFAULT_LINE_THICKNESS
    int DEFAULT_ANGLE_SIZE -> DEFAULT_ANGLE_SIZE
    int DEFAULT_LINE_TYPE -> DEFAULT_LINE_TYPE
    int LINE_TYPE_HIDDEN_NONE -> LINE_TYPE_HIDDEN_NONE
    int LINE_TYPE_HIDDEN_DASHED -> LINE_TYPE_HIDDEN_DASHED
    int LINE_TYPE_HIDDEN_AS_NOT_HIDDEN -> LINE_TYPE_HIDDEN_AS_NOT_HIDDEN
    int DEFAULT_LINE_TYPE_HIDDEN -> DEFAULT_LINE_TYPE_HIDDEN
    float SELECTION_ADD -> SELECTION_ADD
    int AXES_TICK_STYLE_MAJOR_MINOR -> AXES_TICK_STYLE_MAJOR_MINOR
    int AXES_TICK_STYLE_MAJOR -> AXES_TICK_STYLE_MAJOR
    int AXES_TICK_STYLE_NONE -> AXES_TICK_STYLE_NONE
    int AXES_RIGHT_ARROW -> AXES_RIGHT_ARROW
    int AXES_BOLD -> AXES_BOLD
    int AXES_LEFT_ARROW -> AXES_LEFT_ARROW
    int AXES_FILL_ARROWS -> AXES_FILL_ARROWS
    int AXES_LINE_TYPE_FULL -> AXES_LINE_TYPE_FULL
    int AXES_LINE_TYPE_ARROW -> AXES_LINE_TYPE_ARROW
    int AXES_LINE_TYPE_FULL_BOLD -> AXES_LINE_TYPE_FULL_BOLD
    int AXES_LINE_TYPE_ARROW_BOLD -> AXES_LINE_TYPE_ARROW_BOLD
    int AXES_LINE_TYPE_ARROW_FILLED -> AXES_LINE_TYPE_ARROW_FILLED
    int AXES_LINE_TYPE_TWO_ARROWS -> AXES_LINE_TYPE_TWO_ARROWS
    int AXES_LINE_TYPE_TWO_ARROWS_FILLED -> AXES_LINE_TYPE_TWO_ARROWS_FILLED
    int AXES_LINE_TYPE_ARROW_FILLED_BOLD -> AXES_LINE_TYPE_ARROW_FILLED_BOLD
    int AXES_LINE_TYPE_TWO_ARROWS_BOLD -> AXES_LINE_TYPE_TWO_ARROWS_BOLD
    int AXES_LINE_TYPE_TWO_ARROWS_FILLED_BOLD -> AXES_LINE_TYPE_TWO_ARROWS_FILLED_BOLD
    java.lang.Integer[] lineStyleOptions -> lineStyleOptions
    int POINT_STYLE_DOT -> POINT_STYLE_DOT
    int POINT_STYLE_CROSS -> POINT_STYLE_CROSS
    int POINT_STYLE_CIRCLE -> POINT_STYLE_CIRCLE
    int POINT_STYLE_PLUS -> POINT_STYLE_PLUS
    int POINT_STYLE_FILLED_DIAMOND -> POINT_STYLE_FILLED_DIAMOND
    int POINT_STYLE_EMPTY_DIAMOND -> POINT_STYLE_EMPTY_DIAMOND
    int POINT_STYLE_TRIANGLE_NORTH -> POINT_STYLE_TRIANGLE_NORTH
    int POINT_STYLE_TRIANGLE_SOUTH -> POINT_STYLE_TRIANGLE_SOUTH
    int POINT_STYLE_TRIANGLE_EAST -> POINT_STYLE_TRIANGLE_EAST
    int POINT_STYLE_TRIANGLE_WEST -> POINT_STYLE_TRIANGLE_WEST
    int MAX_POINT_STYLE -> MAX_POINT_STYLE
    int MAX_LAYERS -> MAX_LAYERS
    int POINT_CAPTURING_OFF -> POINT_CAPTURING_OFF
    int POINT_CAPTURING_ON -> POINT_CAPTURING_ON
    int POINT_CAPTURING_ON_GRID -> POINT_CAPTURING_ON_GRID
    int POINT_CAPTURING_AUTOMATIC -> POINT_CAPTURING_AUTOMATIC
    int POINT_CAPTURING_STICKY_POINTS -> POINT_CAPTURING_STICKY_POINTS
    int POINT_CAPTURING_DEFAULT -> POINT_CAPTURING_DEFAULT
    int POINT_CAPTURING_XML_MAX -> POINT_CAPTURING_XML_MAX
    int TOOLTIPS_AUTOMATIC -> TOOLTIPS_AUTOMATIC
    int TOOLTIPS_ON -> TOOLTIPS_ON
    int TOOLTIPS_OFF -> TOOLTIPS_OFF
    double DEFAULT_GRID_DIST_FACTOR -> DEFAULT_GRID_DIST_FACTOR
    double automaticGridDistanceFactor -> automaticGridDistanceFactor
geogebra.common.plugin.GeoClass -> geogebra.common.plugin.GeoClass:
    geogebra.common.plugin.GeoClass ANGLE -> ANGLE
    geogebra.common.plugin.GeoClass AXIS -> AXIS
    geogebra.common.plugin.GeoClass BOOLEAN -> BOOLEAN
    geogebra.common.plugin.GeoClass BUTTON -> BUTTON
    geogebra.common.plugin.GeoClass TEXTFIELD -> TEXTFIELD
    geogebra.common.plugin.GeoClass CONIC -> CONIC
    geogebra.common.plugin.GeoClass CONICPART -> CONICPART
    geogebra.common.plugin.GeoClass FUNCTION -> FUNCTION
    geogebra.common.plugin.GeoClass INTERVAL -> INTERVAL
    geogebra.common.plugin.GeoClass FUNCTIONCONDITIONAL -> FUNCTIONCONDITIONAL
    geogebra.common.plugin.GeoClass IMAGE -> IMAGE
    geogebra.common.plugin.GeoClass LINE -> LINE
    geogebra.common.plugin.GeoClass LIST -> LIST
    geogebra.common.plugin.GeoClass LOCUS -> LOCUS
    geogebra.common.plugin.GeoClass NUMERIC -> NUMERIC
    geogebra.common.plugin.GeoClass POINT -> POINT
    geogebra.common.plugin.GeoClass POLYGON -> POLYGON
    geogebra.common.plugin.GeoClass RAY -> RAY
    geogebra.common.plugin.GeoClass SEGMENT -> SEGMENT
    geogebra.common.plugin.GeoClass TEXT -> TEXT
    geogebra.common.plugin.GeoClass VECTOR -> VECTOR
    geogebra.common.plugin.GeoClass CURVE_CARTESIAN -> CURVE_CARTESIAN
    geogebra.common.plugin.GeoClass CURVE_POLAR -> CURVE_POLAR
    geogebra.common.plugin.GeoClass IMPLICIT_POLY -> IMPLICIT_POLY
    geogebra.common.plugin.GeoClass FUNCTION_NVAR -> FUNCTION_NVAR
    geogebra.common.plugin.GeoClass POLYLINE -> POLYLINE
    geogebra.common.plugin.GeoClass PENSTROKE -> PENSTROKE
    geogebra.common.plugin.GeoClass LINEAR_INEQUALITY -> LINEAR_INEQUALITY
    geogebra.common.plugin.GeoClass CAS_CELL -> CAS_CELL
    geogebra.common.plugin.GeoClass ANGLE3D -> ANGLE3D
    geogebra.common.plugin.GeoClass POINT3D -> POINT3D
    geogebra.common.plugin.GeoClass VECTOR3D -> VECTOR3D
    geogebra.common.plugin.GeoClass SEGMENT3D -> SEGMENT3D
    geogebra.common.plugin.GeoClass LINE3D -> LINE3D
    geogebra.common.plugin.GeoClass RAY3D -> RAY3D
    geogebra.common.plugin.GeoClass CONIC3D -> CONIC3D
    geogebra.common.plugin.GeoClass AXIS3D -> AXIS3D
    geogebra.common.plugin.GeoClass CURVECARTESIAN3D -> CURVECARTESIAN3D
    geogebra.common.plugin.GeoClass POLYGON3D -> POLYGON3D
    geogebra.common.plugin.GeoClass PLANE3D -> PLANE3D
    geogebra.common.plugin.GeoClass QUADRIC -> QUADRIC
    geogebra.common.plugin.GeoClass QUADRIC_PART -> QUADRIC_PART
    geogebra.common.plugin.GeoClass QUADRIC_LIMITED -> QUADRIC_LIMITED
    geogebra.common.plugin.GeoClass POLYLINE3D -> POLYLINE3D
    geogebra.common.plugin.GeoClass POLYHEDRON -> POLYHEDRON
    geogebra.common.plugin.GeoClass SURFACECARTESIAN3D -> SURFACECARTESIAN3D
    geogebra.common.plugin.GeoClass CLIPPINGCUBE3D -> CLIPPINGCUBE3D
    geogebra.common.plugin.GeoClass DEFAULT -> DEFAULT
    java.lang.String name -> name
    geogebra.common.plugin.GeoClass[] ENUM$VALUES -> ENUM$VALUES
    geogebra.common.plugin.GeoClass[] values() -> values
    geogebra.common.plugin.GeoClass valueOf(java.lang.String) -> valueOf
geogebra.common.plugin.GgbAPI -> geogebra.common.plugin.GgbAPI:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction construction -> a
    geogebra.common.kernel.commands.AlgebraProcessor algebraprocessor -> a
    geogebra.common.main.App app -> a
    java.lang.String[] objNames -> a
    int lastGeoElementsIteratorSize -> a
    geogebra.common.kernel.Construction getConstruction() -> getConstruction
    geogebra.common.kernel.Kernel getKernel() -> getKernel
    geogebra.common.kernel.commands.AlgebraProcessor getAlgebraProcessor() -> getAlgebraProcessor
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    java.lang.String evalGeoGebraCAS(java.lang.String) -> evalGeoGebraCAS
    java.lang.String evalGeoGebraCAS(java.lang.String,boolean) -> evalGeoGebraCAS
    void debug(java.lang.String) -> debug
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    boolean getVisible(java.lang.String,int) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    java.lang.String[] getObjNames() -> getObjNames
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setColor(java.lang.String,int,int,int) -> setColor
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    java.lang.String getColor(java.lang.String) -> getColor
    int getLineThickness(java.lang.String) -> getLineThickness
    void setLineThickness(java.lang.String,int) -> setLineThickness
    int getPointStyle(java.lang.String) -> getPointStyle
    void setPointStyle(java.lang.String,int) -> setPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    void setPointSize(java.lang.String,int) -> setPointSize
    double getFilling(java.lang.String) -> getFilling
    void setFilling(java.lang.String,double) -> setFilling
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void initCAS() -> initCAS
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    boolean isMoveable(java.lang.String) -> isMoveable
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    void setMode(int) -> setMode
    int getLineStyle(java.lang.String) -> getLineStyle
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void deleteObject(java.lang.String) -> deleteObject
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    boolean exists(java.lang.String) -> exists
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setAxesCornerCoordsVisible(boolean) -> setAxesCornerCoordsVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getSelectedObjectNames() -> getSelectedObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    void setXML(java.lang.String) -> setXML
    java.lang.String getXML() -> getXML
    geogebra.common.main.App getApplication() -> getApplication
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getBase64() -> getBase64
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    void setListValue(java.lang.String,int,double) -> setListValue
    double getListValue(java.lang.String,int) -> getListValue
    void addUserAwarenessListener(geogebra.common.kernel.UserAwarenessListener) -> addUserAwarenessListener
    void removeUserAwarenessListener(geogebra.common.kernel.UserAwarenessListener) -> removeUserAwarenessListener
geogebra.common.plugin.JavaScriptAPI -> geogebra.common.plugin.a:
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getXML() -> getXML
    java.lang.String getBase64(boolean) -> getBase64
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    void debug(java.lang.String) -> debug
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void reset() -> reset
    void refreshViews() -> refreshViews
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
    void openFile(java.lang.String) -> openFile
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    boolean getVisible(java.lang.String,int) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setLineThickness(java.lang.String,int) -> setLineThickness
    int getLineThickness(java.lang.String) -> getLineThickness
    void setLineStyle(java.lang.String,int) -> setLineStyle
    int getLineStyle(java.lang.String) -> getLineStyle
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    double getFilling(java.lang.String) -> getFilling
    int getPointStyle(java.lang.String) -> getPointStyle
    void setPointSize(java.lang.String,int) -> setPointSize
    int getPointSize(java.lang.String) -> getPointSize
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setColor(java.lang.String,int,int,int) -> setColor
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    java.lang.String getColor(java.lang.String) -> getColor
    void deleteObject(java.lang.String) -> deleteObject
    boolean exists(java.lang.String) -> exists
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    boolean isMoveable(java.lang.String) -> isMoveable
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setListValue(java.lang.String,int,double) -> setListValue
    double getListValue(java.lang.String,int) -> getListValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    void setMode(int) -> setMode
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
geogebra.common.plugin.Operation -> geogebra.common.plugin.Operation:
    geogebra.common.plugin.Operation NO_OPERATION -> NO_OPERATION
    geogebra.common.plugin.Operation NOT_EQUAL -> NOT_EQUAL
    geogebra.common.plugin.Operation NOT -> NOT
    geogebra.common.plugin.Operation OR -> OR
    geogebra.common.plugin.Operation AND -> AND
    geogebra.common.plugin.Operation AND_INTERVAL -> AND_INTERVAL
    geogebra.common.plugin.Operation IMPLICATION -> IMPLICATION
    geogebra.common.plugin.Operation EQUAL_BOOLEAN -> EQUAL_BOOLEAN
    geogebra.common.plugin.Operation LESS -> LESS
    geogebra.common.plugin.Operation GREATER -> GREATER
    geogebra.common.plugin.Operation LESS_EQUAL -> LESS_EQUAL
    geogebra.common.plugin.Operation GREATER_EQUAL -> GREATER_EQUAL
    geogebra.common.plugin.Operation PARALLEL -> PARALLEL
    geogebra.common.plugin.Operation PERPENDICULAR -> PERPENDICULAR
    geogebra.common.plugin.Operation IS_ELEMENT_OF -> IS_ELEMENT_OF
    geogebra.common.plugin.Operation IS_SUBSET_OF -> IS_SUBSET_OF
    geogebra.common.plugin.Operation IS_SUBSET_OF_STRICT -> IS_SUBSET_OF_STRICT
    geogebra.common.plugin.Operation SET_DIFFERENCE -> SET_DIFFERENCE
    geogebra.common.plugin.Operation PLUS -> PLUS
    geogebra.common.plugin.Operation MINUS -> MINUS
    geogebra.common.plugin.Operation VECTORPRODUCT -> VECTORPRODUCT
    geogebra.common.plugin.Operation MULTIPLY -> MULTIPLY
    geogebra.common.plugin.Operation MULTIPLY_OR_FUNCTION -> MULTIPLY_OR_FUNCTION
    geogebra.common.plugin.Operation DIVIDE -> DIVIDE
    geogebra.common.plugin.Operation POWER -> POWER
    geogebra.common.plugin.Operation FREEHAND -> FREEHAND
    geogebra.common.plugin.Operation COS -> COS
    geogebra.common.plugin.Operation SIN -> SIN
    geogebra.common.plugin.Operation TAN -> TAN
    geogebra.common.plugin.Operation EXP -> EXP
    geogebra.common.plugin.Operation LOG -> LOG
    geogebra.common.plugin.Operation ARCCOS -> ARCCOS
    geogebra.common.plugin.Operation ARCSIN -> ARCSIN
    geogebra.common.plugin.Operation ARCTAN -> ARCTAN
    geogebra.common.plugin.Operation ARCTAN2 -> ARCTAN2
    geogebra.common.plugin.Operation NROOT -> NROOT
    geogebra.common.plugin.Operation SQRT -> SQRT
    geogebra.common.plugin.Operation SQRT_SHORT -> SQRT_SHORT
    geogebra.common.plugin.Operation ABS -> ABS
    geogebra.common.plugin.Operation SGN -> SGN
    geogebra.common.plugin.Operation XCOORD -> XCOORD
    geogebra.common.plugin.Operation YCOORD -> YCOORD
    geogebra.common.plugin.Operation ZCOORD -> ZCOORD
    geogebra.common.plugin.Operation IMAGINARY -> IMAGINARY
    geogebra.common.plugin.Operation REAL -> REAL
    geogebra.common.plugin.Operation FRACTIONAL_PART -> FRACTIONAL_PART
    geogebra.common.plugin.Operation COSH -> COSH
    geogebra.common.plugin.Operation SINH -> SINH
    geogebra.common.plugin.Operation TANH -> TANH
    geogebra.common.plugin.Operation ACOSH -> ACOSH
    geogebra.common.plugin.Operation ASINH -> ASINH
    geogebra.common.plugin.Operation ATANH -> ATANH
    geogebra.common.plugin.Operation CSC -> CSC
    geogebra.common.plugin.Operation SEC -> SEC
    geogebra.common.plugin.Operation COT -> COT
    geogebra.common.plugin.Operation CSCH -> CSCH
    geogebra.common.plugin.Operation SECH -> SECH
    geogebra.common.plugin.Operation COTH -> COTH
    geogebra.common.plugin.Operation FLOOR -> FLOOR
    geogebra.common.plugin.Operation CEIL -> CEIL
    geogebra.common.plugin.Operation FACTORIAL -> FACTORIAL
    geogebra.common.plugin.Operation ROUND -> ROUND
    geogebra.common.plugin.Operation GAMMA -> GAMMA
    geogebra.common.plugin.Operation GAMMA_INCOMPLETE -> GAMMA_INCOMPLETE
    geogebra.common.plugin.Operation GAMMA_INCOMPLETE_REGULARIZED -> GAMMA_INCOMPLETE_REGULARIZED
    geogebra.common.plugin.Operation BETA -> BETA
    geogebra.common.plugin.Operation BETA_INCOMPLETE -> BETA_INCOMPLETE
    geogebra.common.plugin.Operation BETA_INCOMPLETE_REGULARIZED -> BETA_INCOMPLETE_REGULARIZED
    geogebra.common.plugin.Operation ERF -> ERF
    geogebra.common.plugin.Operation PSI -> PSI
    geogebra.common.plugin.Operation POLYGAMMA -> POLYGAMMA
    geogebra.common.plugin.Operation LOG10 -> LOG10
    geogebra.common.plugin.Operation LOG2 -> LOG2
    geogebra.common.plugin.Operation LOGB -> LOGB
    geogebra.common.plugin.Operation CI -> CI
    geogebra.common.plugin.Operation SI -> SI
    geogebra.common.plugin.Operation EI -> EI
    geogebra.common.plugin.Operation CBRT -> CBRT
    geogebra.common.plugin.Operation RANDOM -> RANDOM
    geogebra.common.plugin.Operation CONJUGATE -> CONJUGATE
    geogebra.common.plugin.Operation ARG -> ARG
    geogebra.common.plugin.Operation FUNCTION -> FUNCTION
    geogebra.common.plugin.Operation FUNCTION_NVAR -> FUNCTION_NVAR
    geogebra.common.plugin.Operation VEC_FUNCTION -> VEC_FUNCTION
    geogebra.common.plugin.Operation DERIVATIVE -> DERIVATIVE
    geogebra.common.plugin.Operation ELEMENT_OF -> ELEMENT_OF
    geogebra.common.plugin.Operation SUBSTITUTION -> SUBSTITUTION
    geogebra.common.plugin.Operation INTEGRAL -> INTEGRAL
    geogebra.common.plugin.Operation IF -> IF
    geogebra.common.plugin.Operation IF_ELSE -> IF_ELSE
    geogebra.common.plugin.Operation $VAR_ROW -> $VAR_ROW
    geogebra.common.plugin.Operation $VAR_COL -> $VAR_COL
    geogebra.common.plugin.Operation $VAR_ROW_COL -> $VAR_ROW_COL
    geogebra.common.plugin.Operation ARBCONST -> ARBCONST
    geogebra.common.plugin.Operation ARBINT -> ARBINT
    geogebra.common.plugin.Operation ARBCOMPLEX -> ARBCOMPLEX
    geogebra.common.plugin.Operation SUM -> SUM
    geogebra.common.plugin.Operation ZETA -> ZETA
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> $SWITCH_TABLE$geogebra$common$plugin$Operation
    geogebra.common.plugin.Operation[] ENUM$VALUES -> ENUM$VALUES
    boolean isSimpleFunction(geogebra.common.plugin.Operation) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
    boolean isPlusorMinus() -> a
    geogebra.common.plugin.Operation[] values() -> values
    geogebra.common.plugin.Operation valueOf(java.lang.String) -> valueOf
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.plugin.Operation$1 -> geogebra.common.plugin.b:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$10 -> geogebra.common.plugin.c:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$11 -> geogebra.common.plugin.d:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$12 -> geogebra.common.plugin.e:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$13 -> geogebra.common.plugin.f:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$14 -> geogebra.common.plugin.g:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$2 -> geogebra.common.plugin.h:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$3 -> geogebra.common.plugin.i:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$4 -> geogebra.common.plugin.j:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$5 -> geogebra.common.plugin.k:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$6 -> geogebra.common.plugin.l:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$7 -> geogebra.common.plugin.m:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$8 -> geogebra.common.plugin.n:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.Operation$9 -> geogebra.common.plugin.o:
    geogebra.common.kernel.arithmetic.ExpressionValue handle(geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.plugin.ScriptManager -> geogebra.common.plugin.p:
    geogebra.common.main.App app -> a
    boolean listenersEnabled -> a
    java.util.HashMap updateListenerMap -> a
    java.util.ArrayList addListeners -> a
    java.util.ArrayList removeListeners -> b
    java.util.ArrayList renameListeners -> c
    java.util.ArrayList updateListeners -> d
    java.util.ArrayList clearListeners -> e
    geogebra.common.plugin.ScriptManager$JavaToJavaScriptView javaToJavaScriptView -> a
    void disableListeners() -> a
    void enableListeners() -> b
    void resetListeners() -> c
    void registerAddListener(java.lang.String) -> a
    void registerGlobalListener(java.util.ArrayList,java.lang.String,java.lang.String) -> a
    void unregisterAddListener(java.lang.String) -> b
    void registerRemoveListener(java.lang.String) -> c
    void unregisterRemoveListener(java.lang.String) -> d
    void registerClearListener(java.lang.String) -> e
    void unregisterClearListener(java.lang.String) -> f
    void registerRenameListener(java.lang.String) -> g
    void unregisterRenameListener(java.lang.String) -> h
    void registerUpdateListener(java.lang.String) -> i
    void unregisterUpdateListener(java.lang.String) -> j
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> a
    void unregisterObjectUpdateListener(java.lang.String) -> k
    void initJavaScriptView() -> d
    void initJavaScriptViewWithoutJavascript() -> e
    void ggbOnInit() -> f
    void initJavaScript() -> g
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
geogebra.common.plugin.ScriptManager$JavaToJavaScriptView -> geogebra.common.plugin.p$a:
    geogebra.common.plugin.ScriptManager this$0 -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void clearView() -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void notifyListeners(java.util.ArrayList,java.lang.Object[]) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void reset() -> g
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void repaintView() -> b
    int getViewID() -> a
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    boolean isShowing() -> isShowing
geogebra.common.sound.SoundManager -> geogebra.common.k.a:
    void pauseResumeSound(boolean) -> a
    void playSequenceNote(int,double,int,int) -> a
    void playSequenceFromString(java.lang.String,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void playMidiFile(java.lang.String) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
geogebra.common.util.AbstractImageManager -> geogebra.common.l.a:
    java.lang.String createImage(java.lang.String,geogebra.common.main.App) -> a
geogebra.common.util.AutoCompleteDictionary -> geogebra.common.l.b:
    java.lang.String lookup(java.lang.String) -> a
    java.util.List getCompletions(java.lang.String) -> a
    java.util.List getCompletionsKorean(java.lang.String) -> b
geogebra.common.util.Base64 -> geogebra.common.l.c:
    java.lang.String encode(byte[],int) -> a
    byte[] decode(java.lang.String) -> a
geogebra.common.util.Cloner -> geogebra.common.l.d:
    double[] clone(double[]) -> a
geogebra.common.util.Complex -> geogebra.common.l.e:
    geogebra.common.util.Complex ZERO -> a
    geogebra.common.util.Complex ONE -> b
    geogebra.common.util.Complex I -> c
    double[] ZERO_ -> a
    double[] ONE_ -> b
    double[] I_ -> c
    double[] z -> d
    double abs(double[]) -> a
    double[] add(double[],double[]) -> a
    double arg(double[]) -> b
    double[] divide(double,double[]) -> a
    double[] divide(double[],double[]) -> b
    double[] exp(double[]) -> a
    double[] gamma(double[]) -> b
    double[] ln(double[]) -> c
    double[] lnGamma(double[]) -> d
    double[] lnSin(double[]) -> e
    double[] multiply(double,double[]) -> b
    double[] multiply(double[],double[]) -> c
    double[] power(double,double[]) -> c
    double[] power(double[],double[]) -> d
    double[] sin(double[]) -> f
    double[] subtract(double[],double[]) -> e
    java.lang.String toString() -> toString
    java.lang.String toString(double[]) -> a
    java.lang.String toString(double[],java.text.DecimalFormat) -> a
geogebra.common.util.CopyPaste -> geogebra.common.l.f:
    java.lang.StringBuilder copiedXML -> a
    java.util.ArrayList copiedXMLlabels -> a
    java.lang.StringBuilder copiedXMLforSameWindow -> b
    java.util.ArrayList copiedXMLlabelsforSameWindow -> b
    geogebra.common.euclidian.EuclidianViewInterfaceCommon copySource -> a
    java.lang.Object copyObject -> a
    java.lang.Object copyObject2 -> b
    boolean isEmpty() -> a
    void removeFixedSliders(java.util.ArrayList) -> a
    void removeDependentFromAxes(java.util.ArrayList,geogebra.common.main.App) -> a
    void removeHavingMacroPredecessors(java.util.ArrayList) -> b
    void addSubGeos(java.util.ArrayList) -> c
    java.util.ArrayList addPredecessorGeos(java.util.ArrayList) -> a
    java.util.ArrayList addAlgosDependentFromInside(java.util.ArrayList) -> b
    java.util.ArrayList removeFreeNonselectedGeoNumerics(java.util.ArrayList,java.util.ArrayList) -> a
    void beforeSavingToXML(java.util.ArrayList,java.util.ArrayList,boolean) -> a
    void afterSavingToXML(java.util.ArrayList,java.util.ArrayList) -> a
    void copyToXML(geogebra.common.main.App,java.util.ArrayList) -> a
    void handleLabels(geogebra.common.main.App,java.util.ArrayList) -> b
    boolean pasteFast(geogebra.common.main.App) -> a
    void pasteFromXML(geogebra.common.main.App) -> a
    void pastePutDownCallback(geogebra.common.main.App) -> b
geogebra.common.util.Country -> geogebra.common.l.g:
    geogebra.common.util.Country France -> a
    geogebra.common.util.Country UnitedKingdom -> b
    geogebra.common.util.Country UnitedStatesofAmerica -> c
    geogebra.common.util.Country Andorra -> d
    geogebra.common.util.Country UnitedArabEmirates -> e
    geogebra.common.util.Country Afghanistan -> f
    geogebra.common.util.Country AntiguaBarbuda -> g
    geogebra.common.util.Country Anguilla -> h
    geogebra.common.util.Country Albania -> i
    geogebra.common.util.Country Armenia -> j
    geogebra.common.util.Country NetherlandsAntilles -> k
    geogebra.common.util.Country Angola -> l
    geogebra.common.util.Country Argentina -> m
    geogebra.common.util.Country AmericanSamoa -> n
    geogebra.common.util.Country Austria -> o
    geogebra.common.util.Country Australia -> p
    geogebra.common.util.Country Aruba -> q
    geogebra.common.util.Country Azerbaijan -> r
    geogebra.common.util.Country BosniaandHerzegovina -> s
    geogebra.common.util.Country Barbados -> t
    geogebra.common.util.Country Bangladesh -> u
    geogebra.common.util.Country Belgium -> v
    geogebra.common.util.Country BurkinaFaso -> w
    geogebra.common.util.Country Bulgaria -> x
    geogebra.common.util.Country Bahrain -> y
    geogebra.common.util.Country Burundi -> z
    geogebra.common.util.Country Benin -> A
    geogebra.common.util.Country Bermuda -> B
    geogebra.common.util.Country BruneiDarussalam -> C
    geogebra.common.util.Country Bolivia -> D
    geogebra.common.util.Country Brazil -> E
    geogebra.common.util.Country Bahamas -> F
    geogebra.common.util.Country Bhutan -> G
    geogebra.common.util.Country BouvetIsland -> H
    geogebra.common.util.Country Botswana -> I
    geogebra.common.util.Country Belarus -> J
    geogebra.common.util.Country Belize -> K
    geogebra.common.util.Country Canada -> L
    geogebra.common.util.Country CentralAfricanRepublic -> M
    geogebra.common.util.Country Congo -> N
    geogebra.common.util.Country Switzerland -> O
    geogebra.common.util.Country CoteDivoire -> P
    geogebra.common.util.Country CookIslands -> Q
    geogebra.common.util.Country Chile -> R
    geogebra.common.util.Country Cameroon -> S
    geogebra.common.util.Country China -> T
    geogebra.common.util.Country Colombia -> U
    geogebra.common.util.Country CostaRica -> V
    geogebra.common.util.Country Cuba -> W
    geogebra.common.util.Country CapeVerde -> X
    geogebra.common.util.Country ChristmasIsland -> Y
    geogebra.common.util.Country Cyprus -> Z
    geogebra.common.util.Country CzechRepublic -> aa
    geogebra.common.util.Country Germany -> ab
    geogebra.common.util.Country Djibouti -> ac
    geogebra.common.util.Country Denmark -> ad
    geogebra.common.util.Country Dominica -> ae
    geogebra.common.util.Country DominicanRepublic -> af
    geogebra.common.util.Country Algeria -> ag
    geogebra.common.util.Country Ecuador -> ah
    geogebra.common.util.Country Estonia -> ai
    geogebra.common.util.Country Egypt -> aj
    geogebra.common.util.Country WesternSahara -> ak
    geogebra.common.util.Country Eritrea -> al
    geogebra.common.util.Country Spain -> am
    geogebra.common.util.Country Ethiopia -> an
    geogebra.common.util.Country Finland -> ao
    geogebra.common.util.Country Fiji -> ap
    geogebra.common.util.Country FalklandIslands -> aq
    geogebra.common.util.Country Micronesia -> ar
    geogebra.common.util.Country FaroeIslands -> as
    geogebra.common.util.Country Gabon -> at
    geogebra.common.util.Country Grenada -> au
    geogebra.common.util.Country Georgia -> av
    geogebra.common.util.Country Ghana -> aw
    geogebra.common.util.Country Gibraltar -> ax
    geogebra.common.util.Country Greenland -> ay
    geogebra.common.util.Country Gambia -> az
    geogebra.common.util.Country Guinea -> aA
    geogebra.common.util.Country EquatorialGuinea -> aB
    geogebra.common.util.Country Greece -> aC
    geogebra.common.util.Country SouthGeorgiaandtheSouthSandwichIslands -> aD
    geogebra.common.util.Country Guatemala -> aE
    geogebra.common.util.Country Guam -> aF
    geogebra.common.util.Country GuineaBissau -> aG
    geogebra.common.util.Country Guyana -> aH
    geogebra.common.util.Country HongKong -> aI
    geogebra.common.util.Country HeardMcDonaldIslands -> aJ
    geogebra.common.util.Country Honduras -> aK
    geogebra.common.util.Country Croatia -> aL
    geogebra.common.util.Country Haiti -> aM
    geogebra.common.util.Country Hungary -> aN
    geogebra.common.util.Country Indonesia -> aO
    geogebra.common.util.Country Ireland -> aP
    geogebra.common.util.Country Israel -> aQ
    geogebra.common.util.Country India -> aR
    geogebra.common.util.Country BritishIndianOceanTerritory -> aS
    geogebra.common.util.Country Iraq -> aT
    geogebra.common.util.Country IranIslamicRepublicof -> aU
    geogebra.common.util.Country Iceland -> aV
    geogebra.common.util.Country Italy -> aW
    geogebra.common.util.Country Jamaica -> aX
    geogebra.common.util.Country Jordan -> aY
    geogebra.common.util.Country Japan -> aZ
    geogebra.common.util.Country Kenya -> ba
    geogebra.common.util.Country Kyrgyzstan -> bb
    geogebra.common.util.Country Cambodia -> bc
    geogebra.common.util.Country Kiribati -> bd
    geogebra.common.util.Country Comoros -> be
    geogebra.common.util.Country StKittsandNevis -> bf
    geogebra.common.util.Country KoreaDemocraticPeoplesRepublicof -> bg
    geogebra.common.util.Country KoreaRepublicof -> bh
    geogebra.common.util.Country Kuwait -> bi
    geogebra.common.util.Country CaymanIslands -> bj
    geogebra.common.util.Country Kazakhstan -> bk
    geogebra.common.util.Country LaoPeoplesDemocraticRepublic -> bl
    geogebra.common.util.Country Lebanon -> bm
    geogebra.common.util.Country SaintLucia -> bn
    geogebra.common.util.Country Liechtenstein -> bo
    geogebra.common.util.Country SriLanka -> bp
    geogebra.common.util.Country Liberia -> bq
    geogebra.common.util.Country Lesotho -> br
    geogebra.common.util.Country Lithuania -> bs
    geogebra.common.util.Country Luxembourg -> bt
    geogebra.common.util.Country Latvia -> bu
    geogebra.common.util.Country Libya -> bv
    geogebra.common.util.Country Morocco -> bw
    geogebra.common.util.Country Monaco -> bx
    geogebra.common.util.Country MoldovaRepublicof -> by
    geogebra.common.util.Country Madagascar -> bz
    geogebra.common.util.Country MarshallIslands -> bA
    geogebra.common.util.Country Mali -> bB
    geogebra.common.util.Country Mongolia -> bC
    geogebra.common.util.Country Myanmar -> bD
    geogebra.common.util.Country Macau -> bE
    geogebra.common.util.Country NorthernMarianaIslands -> bF
    geogebra.common.util.Country Mauritania -> bG
    geogebra.common.util.Country Monserrat -> bH
    geogebra.common.util.Country Malta -> bI
    geogebra.common.util.Country Mauritius -> bJ
    geogebra.common.util.Country Maldives -> bK
    geogebra.common.util.Country Malawi -> bL
    geogebra.common.util.Country Mexico -> bM
    geogebra.common.util.Country Malaysia -> bN
    geogebra.common.util.Country Mozambique -> bO
    geogebra.common.util.Country Namibia -> bP
    geogebra.common.util.Country NewCaledonia -> bQ
    geogebra.common.util.Country Niger -> bR
    geogebra.common.util.Country NorfolkIsland -> bS
    geogebra.common.util.Country Nigeria -> bT
    geogebra.common.util.Country Nicaragua -> bU
    geogebra.common.util.Country Netherlands -> bV
    geogebra.common.util.Country Norway -> bW
    geogebra.common.util.Country Nepal -> bX
    geogebra.common.util.Country Nauru -> bY
    geogebra.common.util.Country Niue -> bZ
    geogebra.common.util.Country NewZealand -> ca
    geogebra.common.util.Country Oman -> cb
    geogebra.common.util.Country Panama -> cc
    geogebra.common.util.Country Peru -> cd
    geogebra.common.util.Country PapuaNewGuinea -> ce
    geogebra.common.util.Country Philippines -> cf
    geogebra.common.util.Country Pakistan -> cg
    geogebra.common.util.Country Poland -> ch
    geogebra.common.util.Country Pitcairn -> ci
    geogebra.common.util.Country PuertoRico -> cj
    geogebra.common.util.Country Portugal -> ck
    geogebra.common.util.Country Palau -> cl
    geogebra.common.util.Country Paraguay -> cm
    geogebra.common.util.Country Qatar -> cn
    geogebra.common.util.Country Romania -> co
    geogebra.common.util.Country RussianFederation -> cp
    geogebra.common.util.Country Rwanda -> cq
    geogebra.common.util.Country SaudiArabia -> cr
    geogebra.common.util.Country SolomonIslands -> cs
    geogebra.common.util.Country Seychelles -> ct
    geogebra.common.util.Country Sudan -> cu
    geogebra.common.util.Country Sweden -> cv
    geogebra.common.util.Country Singapore -> cw
    geogebra.common.util.Country StHelena -> cx
    geogebra.common.util.Country Slovenia -> cy
    geogebra.common.util.Country SvalbardJanMayenIslands -> cz
    geogebra.common.util.Country Slovakia -> cA
    geogebra.common.util.Country SierraLeone -> cB
    geogebra.common.util.Country SanMarino -> cC
    geogebra.common.util.Country Senegal -> cD
    geogebra.common.util.Country Somalia -> cE
    geogebra.common.util.Country Suriname -> cF
    geogebra.common.util.Country SaoTomePrincipe -> cG
    geogebra.common.util.Country ElSalvador -> cH
    geogebra.common.util.Country Syria -> cI
    geogebra.common.util.Country Swaziland -> cJ
    geogebra.common.util.Country TurksCaicosIslands -> cK
    geogebra.common.util.Country Chad -> cL
    geogebra.common.util.Country Togo -> cM
    geogebra.common.util.Country Thailand -> cN
    geogebra.common.util.Country Tajikistan -> cO
    geogebra.common.util.Country Tokelau -> cP
    geogebra.common.util.Country Turkmenistan -> cQ
    geogebra.common.util.Country Tunisia -> cR
    geogebra.common.util.Country Tonga -> cS
    geogebra.common.util.Country EastTimor -> cT
    geogebra.common.util.Country Turkey -> cU
    geogebra.common.util.Country TrinidadTobago -> cV
    geogebra.common.util.Country Tuvalu -> cW
    geogebra.common.util.Country TaiwanProvinceofChina -> cX
    geogebra.common.util.Country Tanzania -> cY
    geogebra.common.util.Country Ukraine -> cZ
    geogebra.common.util.Country Uganda -> da
    geogebra.common.util.Country Uruguay -> db
    geogebra.common.util.Country Uzbekistan -> dc
    geogebra.common.util.Country VaticanCityState -> dd
    geogebra.common.util.Country StVincenttheGrenadines -> de
    geogebra.common.util.Country Venezuela -> df
    geogebra.common.util.Country BritishVirginIslands -> dg
    geogebra.common.util.Country UnitedStatesVirginIslands -> dh
    geogebra.common.util.Country VietNam -> di
    geogebra.common.util.Country Vanuatu -> dj
    geogebra.common.util.Country WallisFutunaIslands -> dk
    geogebra.common.util.Country Samoa -> dl
    geogebra.common.util.Country Yemen -> dm
    geogebra.common.util.Country Mayotte -> dn
    geogebra.common.util.Country Yugoslavia -> do
    geogebra.common.util.Country SouthAfrica -> dp
    geogebra.common.util.Country Zambia -> dq
    geogebra.common.util.Country Zimbabwe -> dr
    geogebra.common.util.Country Macedonia -> ds
    geogebra.common.util.Country Serbia -> dt
    geogebra.common.util.Country Palestine -> du
    geogebra.common.util.Country SouthSudan -> dv
    geogebra.common.util.Country CongoDemocraticRepublicOf -> dw
    java.lang.String iso -> a
    java.lang.String name -> b
    geogebra.common.util.Country defaultCountry -> dx
    geogebra.common.util.Country[] ENUM$VALUES -> a
    java.lang.String getISO() -> a
    java.lang.String toString() -> toString
    geogebra.common.util.Country[] values() -> values
    geogebra.common.util.Country valueOf(java.lang.String) -> valueOf
geogebra.common.util.DoubleWithError -> geogebra.common.l.h:
    double value -> a
    double error -> b
    boolean asymmetricError -> a
    double minError -> c
    double getError() -> a
    double getPlusError() -> b
    double getMinError() -> c
    boolean hasAsymmetricError() -> a
    double getValue() -> d
    java.lang.String toString() -> toString
geogebra.common.util.GeoGebraLogger -> geogebra.common.l.i:
    java.util.Set reportedImplementationNeeded -> a
    geogebra.common.util.GeoGebraLogger$Level EMERGENCY -> a
    geogebra.common.util.GeoGebraLogger$Level ALERT -> b
    geogebra.common.util.GeoGebraLogger$Level CRITICAL -> c
    geogebra.common.util.GeoGebraLogger$Level ERROR -> d
    geogebra.common.util.GeoGebraLogger$Level WARN -> e
    geogebra.common.util.GeoGebraLogger$Level NOTICE -> f
    geogebra.common.util.GeoGebraLogger$Level INFO -> g
    geogebra.common.util.GeoGebraLogger$Level DEBUG -> h
    geogebra.common.util.GeoGebraLogger$Level TRACE -> i
    java.lang.StringBuilder memoryLog -> a
    geogebra.common.util.GeoGebraLogger$Level logLevel -> j
    geogebra.common.util.GeoGebraLogger$LogDestination logDestination -> a
    boolean timeShown -> a
    boolean callerShown -> b
    java.lang.StringBuilder getEntireLog() -> a
    void setLogLevel(java.lang.String) -> a
    void setLogDestination(geogebra.common.util.GeoGebraLogger$LogDestination) -> a
    geogebra.common.util.GeoGebraLogger$LogDestination getLogDestination() -> a
    void setTimeShown(boolean) -> a
    void log(geogebra.common.util.GeoGebraLogger$Level,java.lang.String) -> a
    void print(java.lang.String,geogebra.common.util.GeoGebraLogger$Level) -> a
    void setLogFile(java.lang.String) -> b
    java.lang.String getTimeInfo() -> a
    java.lang.String getCaller() -> b
geogebra.common.util.GeoGebraLogger$Level -> geogebra.common.l.i$a:
    int priority -> a
    java.lang.String text -> a
    geogebra.common.util.GeoGebraLogger this$0 -> a
    int getPriority() -> a
geogebra.common.util.GeoGebraLogger$LogDestination -> geogebra.common.l.i$b:
    geogebra.common.util.GeoGebraLogger$LogDestination FILE -> a
    geogebra.common.util.GeoGebraLogger$LogDestination CONSOLE -> b
    geogebra.common.util.GeoGebraLogger$LogDestination WEB_CONSOLE -> c
    geogebra.common.util.GeoGebraLogger$LogDestination CONSOLES -> d
    geogebra.common.util.GeoGebraLogger$LogDestination[] ENUM$VALUES -> a
    geogebra.common.util.GeoGebraLogger$LogDestination[] values() -> values
    geogebra.common.util.GeoGebraLogger$LogDestination valueOf(java.lang.String) -> valueOf
geogebra.common.util.GgbMat -> geogebra.common.l.j:
    boolean isUndefined -> a
    void inverseImmediate() -> a
    double determinant() -> a
    void reducedRowEchelonFormImmediate() -> b
    void transposeImmediate() -> c
    void getGeoList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.Construction) -> a
    void getMyList(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.Kernel) -> a
    boolean isUndefined() -> y_
    void setIsUndefined(boolean) -> a
    boolean hasOnlyIntegers() -> b
geogebra.common.util.HttpRequest -> geogebra.common.l.k:
    int DEFAULT_TIMEOUT -> a
    int timeout -> b
    boolean processed -> a
    java.lang.Boolean success -> a
    java.lang.String responseText -> a
    java.lang.String getResponse() -> a
    java.lang.String sendRequestGetResponseSync(java.lang.String) -> a
geogebra.common.util.Korean -> geogebra.common.l.l:
    java.lang.StringBuilder sb -> a
    java.util.HashMap koreanLeadToTail -> a
    void init() -> a
    java.lang.String flattenKorean(java.lang.String) -> a
    boolean isKoreanMultiChar(char) -> a
    boolean isKoreanLeadChar(char) -> b
    boolean isKoreanVowelChar(char) -> c
    void appendKoreanMultiChar(java.lang.StringBuilder,char) -> a
    java.lang.String mergeDoubleCharacters(java.lang.String) -> b
geogebra.common.util.LaTeXCache -> geogebra.common.l.m:
    void remove() -> a
    java.lang.Object getCachedLaTeXKey(java.lang.String,int,int,geogebra.common.awt.GColor) -> a
geogebra.common.util.Language -> geogebra.common.l.n:
    geogebra.common.util.Language Albanian -> a
    geogebra.common.util.Language Arabic -> b
    geogebra.common.util.Language Arabic_Tunisia -> c
    geogebra.common.util.Language Basque -> d
    geogebra.common.util.Language Bosnian -> e
    geogebra.common.util.Language Catalan -> f
    geogebra.common.util.Language Chinese_Simplified -> g
    geogebra.common.util.Language Chinese_Traditional -> h
    geogebra.common.util.Language Croatian -> i
    geogebra.common.util.Language Czech -> j
    geogebra.common.util.Language Danish -> k
    geogebra.common.util.Language Dutch_Belgium -> l
    geogebra.common.util.Language Dutch -> m
    geogebra.common.util.Language English_US -> n
    geogebra.common.util.Language English_UK -> o
    geogebra.common.util.Language English_Australia -> p
    geogebra.common.util.Language Estonian -> q
    geogebra.common.util.Language Filipino -> r
    geogebra.common.util.Language Finnish -> s
    geogebra.common.util.Language French -> t
    geogebra.common.util.Language Galician -> u
    geogebra.common.util.Language German -> v
    geogebra.common.util.Language German_Austria -> w
    geogebra.common.util.Language Greek -> x
    geogebra.common.util.Language Hebrew -> y
    geogebra.common.util.Language Hindi -> z
    geogebra.common.util.Language Hungarian -> A
    geogebra.common.util.Language Icelandic -> B
    geogebra.common.util.Language Indonesian -> C
    geogebra.common.util.Language Italian -> D
    geogebra.common.util.Language Japanese -> E
    geogebra.common.util.Language Kazakh -> F
    geogebra.common.util.Language Korean -> G
    geogebra.common.util.Language Lithuanian -> H
    geogebra.common.util.Language Malayalam -> I
    geogebra.common.util.Language Macedonian -> J
    geogebra.common.util.Language Norwegian_Bokmal -> K
    geogebra.common.util.Language Norwegian_Nynorsk -> L
    geogebra.common.util.Language Persian -> M
    geogebra.common.util.Language Polish -> N
    geogebra.common.util.Language Portuguese_Brazil -> O
    geogebra.common.util.Language Portuguese_Portugal -> P
    geogebra.common.util.Language Russian -> Q
    geogebra.common.util.Language Serbian -> R
    geogebra.common.util.Language Slovak -> S
    geogebra.common.util.Language Slovenian -> T
    geogebra.common.util.Language Spanish -> U
    geogebra.common.util.Language Swedish -> V
    geogebra.common.util.Language Turkish -> W
    geogebra.common.util.Language Vietnamese -> X
    geogebra.common.util.Language Yiddish -> Y
    java.lang.String localeGWT -> a
    java.lang.String locale -> b
    java.lang.String name -> c
    geogebra.common.util.Country[] countries -> a
    java.lang.String flagName -> d
    boolean fullyTranslated -> a
    boolean enableInGWT -> b
    java.lang.String testChar -> e
    java.lang.String countryFromGeoIP -> f
    geogebra.common.util.Language[] ENUM$VALUES -> a
    java.lang.String getCountry(geogebra.common.main.App,java.lang.String,java.lang.String,boolean) -> a
    geogebra.common.util.Language getLanguage(java.lang.String) -> a
    java.lang.String getDisplayName(java.lang.String) -> a
    java.lang.String getTestChar(java.lang.String) -> b
    geogebra.common.util.Language[] values() -> values
    geogebra.common.util.Language valueOf(java.lang.String) -> valueOf
geogebra.common.util.LowerCaseDictionary -> geogebra.common.l.o:
    java.util.TreeSet treeSet -> a
    geogebra.common.util.NormalizerMinimal normalizer -> a
    void addEntry(java.lang.String) -> a
    boolean removeEntry(java.lang.String) -> a
    java.util.Iterator getIterator() -> a
    java.lang.String lookup(java.lang.String) -> a
    java.util.List getCompletions(java.lang.String) -> a
    java.util.List getCompletionsKorean(java.lang.String) -> b
geogebra.common.util.MaxSizeHashMap -> geogebra.common.l.p:
    int maxSize -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
geogebra.common.util.MyMath -> geogebra.common.l.q:
    double LOG10 -> a
    double LOG2 -> b
    double cbrt(double) -> a
    double sgn(geogebra.common.kernel.Kernel,double) -> a
    double cosh(double) -> b
    double sinh(double) -> c
    double tanh(double) -> d
    double csch(double) -> e
    double sech(double) -> f
    double coth(double) -> g
    double acosh(double) -> h
    double asinh(double) -> i
    double atanh(double) -> j
    double csc(double) -> k
    double sec(double) -> l
    double cot(double) -> m
    double[][] adjoint(double,double,double,double,double,double,double,double,double) -> a
    double nextMultiple(double,double) -> a
    double nextPrettyNumber(double) -> n
    double length(double,double) -> b
    double[][] multiply(double[][],double[][]) -> a
    double binomial(double,double) -> c
    double binomBig(double,double) -> d
    double binomLog(double,double) -> e
geogebra.common.util.MyMath2 -> geogebra.common.l.r:
    int factorialTop -> a
    double[] factorialTable -> a
    double C2sqrtPi -> b
    double EULER -> a
    double TMIN -> c
    int MAXIT -> b
    double gammaIncomplete(double,double) -> a
    double gammaIncompleteRegularized(double,double) -> b
    double beta(double,double) -> c
    double betaIncomplete(double,double,double) -> a
    double betaIncompleteRegularized(double,double,double) -> b
    double factorial(double) -> a
    double gamma(double) -> b
    double erf(double,double,double) -> c
    double inverf(double) -> c
    double psi(double) -> d
    double logGamma(double) -> e
    double polyGamma(geogebra.common.kernel.arithmetic.NumberValue,double) -> a
    org.apache.commons.math.complex.Complex cisi(double) -> a
    double ci(double) -> f
    double si(double) -> g
    double ei(double) -> h
    double erf(double) -> i
    double zeta(double) -> j
geogebra.common.util.MyMathExact -> geogebra.common.l.s:
geogebra.common.util.MyMathExact$MyDecimal -> geogebra.common.l.s$a:
    int fixedScale -> a
    int roundingMode -> b
    int getScale() -> a
    geogebra.common.util.MyMathExact$MyDecimal copy() -> a
    geogebra.common.util.MyMathExact$MyDecimal negate() -> b
    geogebra.common.util.MyMathExact$MyDecimal add(geogebra.common.util.MyMathExact$MyDecimal) -> a
    geogebra.common.util.MyMathExact$MyDecimal multiply(geogebra.common.util.MyMathExact$MyDecimal) -> b
    geogebra.common.util.MyMathExact$MyDecimal subtract(geogebra.common.util.MyMathExact$MyDecimal) -> c
    geogebra.common.util.MyMathExact$MyDecimal divide(geogebra.common.util.MyMathExact$MyDecimal) -> d
    geogebra.common.util.MyMathExact$MyDecimal sqrt() -> c
    java.math.BigDecimal negate() -> negate
geogebra.common.util.MyMathExact$MyDecimalMatrix -> geogebra.common.l.s$b:
    int fixedScale -> a
    int rowD -> b
    int colD -> c
    geogebra.common.util.MyMathExact$MyDecimal[][] data -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    int getScale() -> c
    geogebra.common.util.MyMathExact$MyDecimal getEntry(int,int) -> a
    void setEntry(int,int,geogebra.common.util.MyMathExact$MyDecimal) -> a
    geogebra.common.util.MyMathExact$MyDecimalMatrix copy() -> a
    geogebra.common.util.MyMathExact$MyDecimal[] getColumn(int) -> a
    void setColumn(int,geogebra.common.util.MyMathExact$MyDecimal[]) -> a
    geogebra.common.util.MyMathExact$MyDecimal[] getRow(int) -> b
    void setRow(int,geogebra.common.util.MyMathExact$MyDecimal[]) -> b
    geogebra.common.util.MyMathExact$MyDecimalMatrix multiply(geogebra.common.util.MyMathExact$MyDecimalMatrix) -> a
geogebra.common.util.NormalizerMinimal -> geogebra.common.l.t:
    java.util.HashMap hm -> a
    java.lang.String transform(java.lang.String) -> a
    java.lang.String transformStatic(java.lang.String) -> b
geogebra.common.util.NumberFormatAdapter -> geogebra.common.l.u:
    int getMaximumFractionDigits() -> getMaximumFractionDigits
    java.lang.String format(double) -> format
geogebra.common.util.Riemann -> geogebra.common.l.v:
    double[] chi(double[]) -> a
    double[] zeta(double[]) -> b
geogebra.common.util.ScientificFormatAdapter -> geogebra.common.l.w:
    int getSigDigits() -> a
    void setSigDigits(int) -> a
    void setMaxWidth(int) -> b
    java.lang.String format(double) -> a
geogebra.common.util.SpreadsheetTraceSettings -> geogebra.common.l.x:
    int traceColumn1 -> a
    int traceColumn2 -> b
    int traceRow1 -> c
    int traceRow2 -> d
    int tracingRow -> e
    int numRows -> f
    int headerOffset -> g
    java.util.ArrayList lastTrace -> a
    boolean doColumnReset -> a
    boolean needsColumnReset -> b
    boolean doRowLimit -> c
    boolean showLabel -> d
    boolean showTraceList -> e
    boolean doTraceGeoCopy -> f
geogebra.common.util.StringUtil -> geogebra.common.l.y:
    char[] hexChar -> a
    geogebra.common.util.StringUtil prototype -> a
    java.lang.StringBuilder sb -> a
    java.lang.StringBuilder sbReplaceExp -> b
    int[] isLetter -> a
    java.lang.String convertToHex(byte[]) -> a
    java.lang.String toHexString(char) -> a
    java.lang.String toHexString(geogebra.common.awt.GColor) -> a
    java.lang.String toHTMLString(java.lang.String) -> a
    java.lang.String encodeXML(java.lang.String) -> b
    void encodeXML(java.lang.StringBuilder,java.lang.String) -> a
    boolean isRightToLeftChar(char) -> a
    java.lang.String toLaTeXString(java.lang.String,boolean) -> a
    java.lang.String string(java.lang.String,int) -> a
    java.lang.String removeSpaces(java.lang.String) -> c
    java.lang.StringBuilder resetStringBuilder(java.lang.StringBuilder) -> a
    boolean isNumber(java.lang.String) -> a
    java.lang.String toLower(java.lang.String) -> d
    java.lang.String toUpper(java.lang.String) -> e
    java.lang.String toLowerCase(java.lang.String) -> f
    java.lang.String toUpperCase(java.lang.String) -> g
    double parseDouble(java.lang.String) -> a
    java.lang.String repeat(char,int) -> a
    boolean isLetterOrDigit(char) -> b
    boolean isLetterOrDigitOrUnderscore(char) -> c
    boolean isDigit(char) -> d
    boolean isLetter(char) -> e
    boolean isNotEqual(java.lang.String) -> b
    boolean isInequality(java.lang.String) -> c
    java.lang.String ignoreIndices(java.lang.String) -> h
    int checkBracketsBackward(java.lang.String) -> a
    boolean representsMultipleExpressions(java.lang.String) -> d
geogebra.common.util.TextObject -> geogebra.common.l.z:
    java.lang.String getText() -> getText
    void setText(java.lang.String) -> setText
    void wrapSetText(java.lang.String) -> a_
geogebra.common.util.Unicode -> geogebra.common.l.A:
    java.lang.String degree -> a
    java.lang.String PI_STRING -> b
    boolean isSuperscriptDigit(char) -> a
geogebra.euclidian.DrawEquationD -> geogebra.b.a:
    javax.swing.JLabel jl -> a
    boolean drawEquationJLaTeXMathFirstCall -> a
    java.lang.Object initJLaTeXMath -> a
    java.awt.Dimension drawEquationJLaTeXMath(geogebra.main.AppD,geogebra.common.kernel.geos.GeoElement,java.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.GFont,boolean,java.awt.Color,java.awt.Color,boolean,java.lang.Integer,java.lang.Float) -> a
    void setUseJavaFontsForLaTeX(geogebra.common.main.App,boolean) -> a
    geogebra.common.awt.GDimension drawEquation(geogebra.common.main.App,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D,int,int,java.lang.String,geogebra.common.awt.GFont,boolean,geogebra.common.awt.GColor,geogebra.common.awt.GColor,boolean) -> a
    java.awt.Dimension drawEquation(geogebra.main.AppD,geogebra.common.kernel.geos.GeoElement,java.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.GFont,boolean,geogebra.common.awt.GColor,geogebra.common.awt.GColor,boolean,java.lang.Integer,java.lang.Float) -> a
    void drawLatexImageIcon(geogebra.main.AppD,javax.swing.ImageIcon,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
geogebra.euclidian.EuclidianControllerD -> geogebra.b.b:
    void setApplication(geogebra.common.main.App) -> a
    geogebra.main.AppD getApplication() -> a
    void setView(geogebra.common.euclidian.EuclidianView) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void initToolTipManager() -> f
    void resetToolTipManager() -> o
    geogebra.common.kernel.geos.GeoElement[] createCircle2ForPoints3D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void mouseWheelMoved(java.awt.event.MouseWheelEvent) -> mouseWheelMoved
    geogebra.common.main.App getApplication() -> a
geogebra.euclidian.EuclidianStaticD -> geogebra.b.c:
    geogebra.common.awt.GRectangle doDrawMultilineLaTeX(geogebra.common.main.App,geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.GGraphics2D,geogebra.common.awt.GFont,geogebra.common.awt.GColor,geogebra.common.awt.GColor,java.lang.String,int,int,boolean) -> b
    void drawWithValueStrokePure(java.awt.Shape,java.awt.Graphics2D) -> a
    void doDrawWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> d
    void doFillWithValueStrokePure(geogebra.common.awt.GShape,geogebra.common.awt.GGraphics2D) -> a
    java.awt.BasicStroke getDefaultStrokeAwt() -> a
    java.lang.Object doSetInterpolationHint(geogebra.common.awt.GGraphics2D,boolean) -> b
    void doResetInterpolationHint(geogebra.common.awt.GGraphics2D,java.lang.Object) -> b
geogebra.euclidian.EuclidianStyleBarD -> geogebra.b.d:
    geogebra.euclidian.EuclidianControllerD ec -> a
    geogebra.common.euclidian.EuclidianViewInterfaceCommon ev -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.color.ColorPopupMenuButton btnColor -> a
    geogebra.gui.color.ColorPopupMenuButton btnBgColor -> b
    geogebra.gui.color.ColorPopupMenuButton btnTextColor -> c
    geogebra.gui.util.PopupMenuButton btnLineStyle -> a
    geogebra.gui.util.PopupMenuButton btnPointStyle -> b
    geogebra.gui.util.PopupMenuButton btnTextSize -> c
    geogebra.gui.util.PopupMenuButton btnTableTextJustify -> d
    geogebra.gui.util.PopupMenuButton btnTableTextBracket -> e
    geogebra.gui.util.PopupMenuButton btnLabelStyle -> f
    geogebra.gui.util.PopupMenuButton btnPointCapture -> g
    geogebra.gui.util.PopupMenuButton btnDeleteSize -> h
    geogebra.gui.util.MyToggleButton btnPen -> b
    geogebra.gui.util.MyToggleButton btnShowGrid -> c
    geogebra.gui.util.MyToggleButton btnShowAxes -> d
    geogebra.gui.util.MyToggleButton btnBold -> e
    geogebra.gui.util.MyToggleButton btnItalic -> f
    geogebra.gui.util.MyToggleButton btnDelete -> g
    geogebra.gui.util.MyToggleButton btnTableTextLinesV -> h
    geogebra.gui.util.MyToggleButton btnTableTextLinesH -> i
    geogebra.gui.util.MyToggleButton btnFixPosition -> a
    geogebra.gui.util.PopupMenuButton[] popupBtnList -> a
    geogebra.gui.util.MyToggleButton[] toggleBtnList -> a
    java.util.HashMap defaultGeoMap -> c
    java.util.ArrayList defaultGeos -> a
    geogebra.common.kernel.geos.GeoElement oldDefaultGeo -> a
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    int mode -> b
    boolean isIniting -> a
    boolean needUndo -> b
    java.lang.Integer oldDefaultMode -> a
    boolean modeChanged -> c
    geogebra.common.kernel.algos.AlgoTableText tableText -> a
    java.util.HashMap lineStyleMap -> a
    java.util.HashMap pointStyleMap -> b
    void setMode(int) -> b
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    void restoreDefaultGeo() -> b
    void updateStyleBar() -> c
    void initGUI() -> j
    void setActionCommands() -> d
    void addButtons() -> k
    void addGraphicsDecorationsButtons() -> e
    geogebra.gui.util.PopupMenuButton[] newPopupBtnList() -> a
    geogebra.gui.util.MyToggleButton[] newToggleBtnList() -> a
    void addBtnPointCapture() -> f
    void addBtnRotateView() -> g
    void createButtons() -> h
    void createColorButton() -> l
    void createBgColorButton() -> m
    boolean checkGeoText(java.lang.Object[]) -> a
    void createTextButtons() -> n
    void createTableTextButtons() -> o
    void updateGUI() -> i
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void processSource(java.lang.Object,java.util.ArrayList) -> a
    void updateButtonPointCapture(int) -> a
    void setLabels() -> a
    int getPointCaptureSelectedIndex() -> a
    geogebra.gui.util.MyToggleButton access$0(geogebra.euclidian.EuclidianStyleBarD) -> a
    geogebra.gui.util.MyToggleButton access$1(geogebra.euclidian.EuclidianStyleBarD) -> b
    geogebra.gui.util.PopupMenuButton access$2(geogebra.euclidian.EuclidianStyleBarD) -> a
    geogebra.gui.util.PopupMenuButton access$3(geogebra.euclidian.EuclidianStyleBarD) -> b
geogebra.euclidian.EuclidianStyleBarD$1 -> geogebra.b.e:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$10 -> geogebra.b.f:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$11 -> geogebra.b.g:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$12 -> geogebra.b.h:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    java.awt.Dimension val$bgColorIconSize -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$13 -> geogebra.b.i:
    java.awt.Color geoColor -> a
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    java.awt.Dimension val$textColorIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBarD$14 -> geogebra.b.j:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$15 -> geogebra.b.k:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$16 -> geogebra.b.l:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$17 -> geogebra.b.m:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$18 -> geogebra.b.n:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$19 -> geogebra.b.o:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$2 -> geogebra.b.p:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$20 -> geogebra.b.q:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$3 -> geogebra.b.r:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$4 -> geogebra.b.s:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$5 -> geogebra.b.t:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBarD$6 -> geogebra.b.u:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    java.awt.Dimension val$lineStyleIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBarD$7 -> geogebra.b.v:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    java.awt.Dimension val$pointStyleIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBarD$8 -> geogebra.b.w:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBarD$9 -> geogebra.b.x:
    geogebra.euclidian.EuclidianStyleBarD this$0 -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianViewD -> geogebra.b.y:
    java.awt.RenderingHints defRenderingHints -> a
    java.awt.Image resetImage -> a
    java.awt.Image playImage -> b
    java.awt.Image pauseImage -> c
    java.awt.Cursor defaultCursor -> a
    void initView(boolean) -> m
    void setDragCursor() -> A
    void setGrabbingCursor() -> F
    void setTransparentCursor() -> x
    void setMoveCursor() -> D
    void setResizeXAxisCursor() -> B
    void setResizeYAxisCursor() -> C
    void setHitCursor() -> z
    void setDefaultCursor() -> y
    void initCursor() -> m
    java.awt.Cursor getCursorForImage(java.awt.Image) -> a
    void setDefRenderingHints(geogebra.common.awt.GGraphics2D) -> m
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void exportPaint(java.awt.Graphics2D,double) -> a
    void exportPaint(geogebra.common.awt.GGraphics2D,double,boolean) -> a
    void exportPaintPre(geogebra.common.awt.GGraphics2D,double) -> a
    void exportPaintPre(geogebra.common.awt.GGraphics2D,double,boolean) -> b
    java.awt.image.BufferedImage getExportImage(double) -> a
    java.awt.image.BufferedImage getExportImage(double,boolean) -> a
    java.awt.image.BufferedImage createBufferedImage(int,int,boolean) -> a
    void drawResetIcon(geogebra.common.awt.GGraphics2D) -> k
    java.awt.Image getResetImage() -> a
    java.awt.Image getPlayImage() -> b
    java.awt.Image getPauseImage() -> c
    void drawAnimationButtons(geogebra.common.awt.GGraphics2D) -> o
    boolean hitAnimationButton(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean drawPlayButtonInThisView() -> p
    geogebra.euclidian.EuclidianControllerD getEuclidianController() -> a
    geogebra.common.awt.GGraphics2D getGraphicsForPen() -> b
    void doDrawPoints(geogebra.common.kernel.geos.GeoImage,java.util.List,geogebra.common.awt.GColor,int,int) -> a
    void setBoldAxes(boolean) -> j
    java.awt.Image getExportImage(double) -> a
    geogebra.common.euclidian.EuclidianController getEuclidianController() -> a
geogebra.euclidian.EuclidianViewJPanel -> geogebra.b.z:
    geogebra.common.euclidian.EuclidianView view -> a
    java.awt.Color bgColor -> a
    int temporaryWidth -> a
    int temporaryHeight -> b
    geogebra.awt.GGraphics2DD g2 -> a
    java.awt.Color getBackground() -> getBackground
    void setBackground(java.awt.Color) -> setBackground
    void paintChildren(java.awt.Graphics) -> paintChildren
    int getWidth() -> getWidth
    int getHeight() -> getHeight
    java.awt.Rectangle getBounds() -> getBounds
    void setToolTipText(java.lang.String) -> setToolTipText
    void paint(java.awt.Graphics) -> paint
geogebra.euclidian.EuclidianViewTransferHandler -> geogebra.b.A:
    geogebra.euclidianND.EuclidianViewND ev -> a
    geogebra.main.AppD app -> a
    java.awt.datatransfer.DataFlavor textReaderFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    boolean debug -> a
    void setSupportedFlavours() -> a
    int getSourceActions(javax.swing.JComponent) -> getSourceActions
    boolean canImport(javax.swing.JComponent,java.awt.datatransfer.DataFlavor[]) -> canImport
    boolean importData(javax.swing.JComponent,java.awt.datatransfer.Transferable) -> importData
    void requestViewFocus() -> b
    java.awt.datatransfer.Transferable createTransferable(javax.swing.JComponent) -> createTransferable
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
geogebra.euclidian.HatchingHandlerD -> geogebra.b.B:
    java.awt.image.BufferedImage bufferedImage -> a
    void dosetHatching(geogebra.common.awt.GGraphics2D,geogebra.common.awt.GBasicStroke,geogebra.common.awt.GColor,geogebra.common.awt.GColor,float,double,double) -> a
    void doSetTexture(geogebra.common.awt.GGraphics2D,geogebra.common.kernel.geos.GeoElement,float) -> a
geogebra.euclidian.LatexConvertor -> geogebra.b.C:
    geogebra.common.kernel.commands.AlgebraProcessor env -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.String getLaTeXString(java.lang.String) -> a
geogebra.euclidian.LatexConvertorFactory -> geogebra.b.D:
    geogebra.common.kernel.Kernel kernel -> a
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter getExternalConverter() -> a
    geogebra.common.kernel.commands.AlgebraProcessor getCurrentGeoGebraEnv() -> a
geogebra.euclidian.MyZoomerD -> geogebra.b.E:
    javax.swing.Timer timer -> a
    void stopTimer() -> c
    boolean hasTimer() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void startTimer() -> d
geogebra.euclidian.PolyBezier -> geogebra.b.F:
    int n -> a
    int max_capacity -> b
    double[] x -> a
    double[] y -> b
    java.awt.geom.GeneralPath gp -> a
    void setNumberOfPoints(int) -> a
    void buildGeneralPath() -> a
    double[] tobezier(double[],double[],int) -> a
    double[] spline(double[],double[],int,double,double) -> a
geogebra.euclidian.clipping.DoubleArrayFactory -> geogebra.b.a.a:
    java.util.Map map -> a
    java.util.Map createMap() -> a
    double[] getArray(int) -> a
    void putArray(double[]) -> a
geogebra.euclidian.event.ActionEventD -> geogebra.b.b.a:
    java.awt.event.ActionEvent event -> a
    geogebra.euclidian.event.ActionEventD wrapEvent(java.awt.event.ActionEvent) -> a
geogebra.euclidian.event.ActionListenerD -> geogebra.b.b.b:
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.euclidian.event.FocusEvent -> geogebra.b.b.c:
    java.util.LinkedList pool -> a
    java.awt.event.FocusEvent event -> a
    geogebra.euclidian.event.FocusEvent wrapEvent(java.awt.event.FocusEvent) -> a
    void release() -> a
geogebra.euclidian.event.FocusListener -> geogebra.b.b.d:
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.euclidian.event.KeyEvent -> geogebra.b.b.e:
    java.util.LinkedList pool -> a
    java.awt.event.KeyEvent event -> a
    geogebra.euclidian.event.KeyEvent wrapEvent(java.awt.event.KeyEvent) -> a
    void release() -> a
    char getKeyChar() -> a
geogebra.euclidian.event.KeyListener -> geogebra.b.b.f:
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.euclidian.event.MouseEvent -> geogebra.b.b.g:
    java.util.LinkedList pool -> a
    java.awt.event.MouseEvent event -> a
    geogebra.common.euclidian.event.AbstractEvent wrapEvent(java.awt.event.MouseEvent) -> a
    geogebra.common.awt.GPoint getPoint() -> a
    boolean isAltDown() -> a
    boolean isShiftDown() -> b
    java.awt.event.MouseEvent getEvent(geogebra.common.euclidian.event.AbstractEvent) -> a
    void release() -> a
    int getX() -> a
    int getY() -> b
    boolean isRightClick() -> c
    boolean isControlDown() -> d
    int getClickCount() -> c
    boolean isMetaDown() -> e
    double getWheelRotation() -> a
    boolean isMiddleClick() -> f
    boolean isPopupTrigger() -> g
geogebra.euclidianND.EuclidianViewND -> geogebra.c.a:
    geogebra.euclidian.EuclidianViewJPanel evjpanel -> a
    java.awt.Graphics2D g2Dtemp -> a
    void setCursor(java.awt.Cursor) -> a
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    void paintBackground(geogebra.common.awt.GGraphics2D) -> e
    void add(geogebra.common.javax.swing.GBox) -> a
    void remove(geogebra.common.javax.swing.GBox) -> b
    javax.swing.JPanel getJPanel() -> a
    void requestFocus() -> E
    geogebra.common.awt.GFont getFont() -> h
    java.awt.Point getMousePosition() -> a
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> a
    boolean isShowing() -> isShowing
    boolean requestFocusInWindow() -> l
    void setPreferredSize(java.awt.Dimension) -> a
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    void revalidate() -> G
    void addMouseListener(java.awt.event.MouseListener) -> a
    void removeMouseListener(java.awt.event.MouseListener) -> b
    void addMouseMotionListener(java.awt.event.MouseMotionListener) -> a
    void removeMouseMotionListener(java.awt.event.MouseMotionListener) -> b
    void addMouseWheelListener(java.awt.event.MouseWheelListener) -> a
    void removeMouseWheelListener(java.awt.event.MouseWheelListener) -> b
    void dispatchEvent(java.awt.event.ComponentEvent) -> a
    void setBorder(javax.swing.border.Border) -> a
    void addComponentListener(java.awt.event.ComponentListener) -> a
    void setSize(java.awt.Dimension) -> b
    java.awt.Dimension getPreferredSize() -> a
    geogebra.main.AppD getApplication() -> a
    void initPanel(boolean) -> o
    void setToolTipText(java.lang.String) -> a
    int getWidth() -> s
    int getHeight() -> t
    void updateSize() -> r
    void createImage(java.awt.GraphicsConfiguration) -> a
    void drawActionObjects(geogebra.common.awt.GGraphics2D) -> l
    void clearView() -> d
    geogebra.common.awt.GColor getBackgroundCommon() -> c
    void setBackground(geogebra.common.awt.GColor) -> b
    java.awt.Graphics2D getTempGraphics2D() -> a
    geogebra.common.awt.GGraphics2D getTempGraphics2D(geogebra.common.awt.GFont) -> a
    void setAntialiasing(java.awt.Graphics2D) -> a
    void setAntialiasing(geogebra.common.awt.GGraphics2D) -> n
    void setHeight(int) -> j
    void setWidth(int) -> k
    void setStyleBarMode(int) -> l
    geogebra.euclidian.EuclidianStyleBarD newEuclidianStyleBar() -> a
    geogebra.common.euclidian.EuclidianStyleBar getStyleBar() -> a
    geogebra.euclidian.MyZoomerD newZoomer() -> a
    geogebra.euclidian.EuclidianControllerD getEuclidianController() -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    java.awt.Image getExportImage(double) -> a
    geogebra.common.euclidian.MyZoomer newZoomer() -> a
    geogebra.common.main.App getApplication() -> a
    geogebra.common.euclidian.EuclidianController getEuclidianController() -> a
geogebra.export.AnimationExportDialog -> geogebra.d.a:
    geogebra.main.AppD app -> a
    javax.swing.JComboBox cbSliders -> a
    javax.swing.JCheckBox cbLoop -> a
    javax.swing.JTextField tfTimeBetweenFrames -> a
    javax.swing.JButton cancelButton -> a
    javax.swing.JButton exportButton -> b
    void initGUI() -> b
    void export() -> a
geogebra.export.AnimationExportDialog$1 -> geogebra.d.b:
    geogebra.export.AnimationExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.AnimationExportDialog$2 -> geogebra.d.c:
    geogebra.export.AnimationExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog -> geogebra.d.d:
    javax.swing.JCheckBox cbDrawingPadPicture -> a
    javax.swing.JCheckBox cbScreenshotPicture -> b
    javax.swing.JCheckBox cbColor -> c
    javax.swing.JCheckBox cbIcons -> d
    geogebra.export.GraphicSizePanel sizePanel -> a
    boolean kernelChanged -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView prot -> a
    geogebra.main.AppD app -> a
    void initGUI() -> a
    void centerOnScreen() -> b
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void exportHTML(boolean,boolean,boolean,boolean) -> a
    java.awt.image.BufferedImage getCenterPanelImage() -> a
    javax.swing.JCheckBox access$0(geogebra.export.ConstructionProtocolExportDialog) -> a
    geogebra.export.GraphicSizePanel access$1(geogebra.export.ConstructionProtocolExportDialog) -> a
    javax.swing.JCheckBox access$2(geogebra.export.ConstructionProtocolExportDialog) -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$3(geogebra.export.ConstructionProtocolExportDialog) -> a
    javax.swing.JCheckBox access$4(geogebra.export.ConstructionProtocolExportDialog) -> c
    javax.swing.JCheckBox access$5(geogebra.export.ConstructionProtocolExportDialog) -> d
    geogebra.main.AppD access$6(geogebra.export.ConstructionProtocolExportDialog) -> a
    void access$7(geogebra.export.ConstructionProtocolExportDialog,boolean,boolean,boolean,boolean) -> a
geogebra.export.ConstructionProtocolExportDialog$1 -> geogebra.d.e:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$2 -> geogebra.d.f:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$3 -> geogebra.d.g:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$4 -> geogebra.d.h:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$5 -> geogebra.d.i:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$6 -> geogebra.d.j:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$7 -> geogebra.d.k:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.ConstructionProtocolExportDialog access$0(geogebra.export.ConstructionProtocolExportDialog$7) -> a
geogebra.export.ConstructionProtocolExportDialog$7$1 -> geogebra.d.l:
    geogebra.export.ConstructionProtocolExportDialog$7 this$1 -> a
    void run() -> run
geogebra.export.ConstructionProtocolExportDialog$8 -> geogebra.d.m:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.ConstructionProtocolExportDialog access$0(geogebra.export.ConstructionProtocolExportDialog$8) -> a
geogebra.export.ConstructionProtocolExportDialog$8$1 -> geogebra.d.n:
    geogebra.export.ConstructionProtocolExportDialog$8 this$1 -> a
    void run() -> run
geogebra.export.ConstructionProtocolExportDialog$9 -> geogebra.d.o:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.GeoGebraTubeExportDesktop -> geogebra.d.p:
    javax.swing.JDialog progressDialog -> a
    javax.swing.JProgressBar progressBar -> a
    javax.swing.JLabel statusLabel -> a
    javax.swing.JButton abortButton -> a
    void setMaximum(int) -> a
    void setMinimum(int) -> b
    void setIndeterminate(boolean) -> a
    void setValue(int) -> c
    void setEnabled(boolean) -> b
    void uploadWorksheet(java.util.ArrayList) -> a
    void showDialog() -> a
    void pack() -> b
    void hideDialog() -> c
    void statusLabelSetText(java.lang.String) -> a
    java.lang.String encode(java.lang.String) -> a
    java.lang.String getBase64Tools(java.util.ArrayList) -> a
geogebra.export.GeoGebraTubeExportDesktop$1 -> geogebra.d.q:
    geogebra.export.GeoGebraTubeExportDesktop this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog -> geogebra.d.r:
    geogebra.main.AppD app -> a
    javax.swing.JComboBox cbFormat -> a
    javax.swing.JComboBox cbDPI -> b
    javax.swing.JLabel sizeLabel -> a
    javax.swing.JButton cancelButton -> a
    double exportScale -> a
    int pixelWidth -> a
    int pixelHeight -> b
    java.text.NumberFormat sizeLabelFormat -> a
    boolean textAsShapes -> a
    boolean transparent -> b
    boolean EMFPlus -> c
    int FORMAT_PNG -> c
    int FORMAT_PDF -> d
    int FORMAT_EPS -> e
    int FORMAT_SVG -> f
    int FORMAT_EMF -> g
    geogebra.euclidian.EuclidianViewD specifiedEuclidianView -> a
    geogebra.euclidian.EuclidianViewD getEuclidianView() -> a
    void setVisible(boolean) -> setVisible
    void initGUI() -> a
    int getDPI() -> a
    void loadPreferences() -> b
    void savePreferences() -> c
    void updateSizeLabel() -> d
    void centerOnScreen() -> e
    boolean exportEPS(boolean) -> b
    boolean exportEMF(boolean,boolean) -> b
    boolean exportPDF(boolean) -> c
    boolean exportSVG(boolean) -> d
    boolean exportPNG(boolean) -> a
    boolean exportPNG(boolean,boolean) -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void sendToClipboard(java.io.File) -> a
    void exportSVG(geogebra.main.AppD,geogebra.euclidian.EuclidianViewD,java.io.File,boolean,int,int,double) -> a
    void exportEMF(geogebra.main.AppD,geogebra.euclidian.EuclidianViewD,java.io.File,boolean,int,int,double) -> b
    void exportPDF(geogebra.main.AppD,geogebra.euclidian.EuclidianViewD,java.io.File,boolean,int,int,double) -> c
    void exportEPS(geogebra.main.AppD,geogebra.euclidian.EuclidianViewD,java.io.File,boolean,int,int,double) -> d
    void exportPNG(geogebra.euclidian.EuclidianViewD,java.io.File,boolean,int,double) -> a
    void access$0(geogebra.export.GraphicExportDialog) -> a
    javax.swing.JComboBox access$1(geogebra.export.GraphicExportDialog) -> a
    javax.swing.JComboBox access$2(geogebra.export.GraphicExportDialog) -> b
    boolean access$3(geogebra.export.GraphicExportDialog,boolean) -> a
    boolean access$4(geogebra.export.GraphicExportDialog,boolean,boolean) -> a
    boolean access$5(geogebra.export.GraphicExportDialog,boolean) -> b
    boolean access$6(geogebra.export.GraphicExportDialog,boolean) -> c
geogebra.export.GraphicExportDialog$1 -> geogebra.d.s:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$2 -> geogebra.d.t:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$3 -> geogebra.d.u:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$cbTransparent -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$4 -> geogebra.d.v:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$cbEMFPlus -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$5 -> geogebra.d.w:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$textAsShapesCB -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$6 -> geogebra.d.x:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$textAsShapesCB -> a
    javax.swing.JPanel val$dpiPanel -> a
    javax.swing.JLabel val$resolutionInDPILabel -> a
    javax.swing.JCheckBox val$cbEMFPlus -> b
    javax.swing.JCheckBox val$cbTransparent -> c
    javax.swing.JPanel val$p -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$7 -> geogebra.d.y:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$8 -> geogebra.d.z:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.GraphicExportDialog access$0(geogebra.export.GraphicExportDialog$8) -> a
geogebra.export.GraphicExportDialog$8$1 -> geogebra.d.A:
    geogebra.export.GraphicExportDialog$8 this$1 -> a
    void run() -> run
geogebra.export.GraphicExportDialog$9 -> geogebra.d.B:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.GraphicExportDialog access$0(geogebra.export.GraphicExportDialog$9) -> a
geogebra.export.GraphicExportDialog$9$1 -> geogebra.d.C:
    geogebra.export.GraphicExportDialog$9 this$1 -> a
    void run() -> run
geogebra.export.GraphicSizePanel -> geogebra.d.D:
    int width -> a
    int height -> b
    double ratio -> a
    javax.swing.JTextField tfWidth -> a
    javax.swing.JTextField tfHeight -> b
    boolean keepRatio -> a
    void setValues(int,int,boolean) -> a
    int getSelectedWidth() -> a
    int getSelectedHeight() -> b
    void setEnabled(boolean) -> setEnabled
    void updateValues(java.lang.Object) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.export.PrintGridable -> geogebra.d.E:
    geogebra.gui.view.Gridable gridable -> a
    int[] colWidths -> a
    int[] rowHeights -> b
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    int appendTitleAndAuthor(java.awt.Graphics2D,geogebra.main.AppD,java.lang.String) -> a
geogebra.export.PrintPreview -> geogebra.d.F:
    int m_orientation -> a
    int m_scale -> b
    java.awt.print.Printable m_target -> a
    javax.swing.JComboBox m_cbScale -> a
    javax.swing.JComboBox m_cbOrientation -> b
    javax.swing.JComboBox m_cbView -> c
    javax.swing.JScrollPane ps -> a
    geogebra.export.PrintPreview$PreviewContainer m_preview -> a
    geogebra.main.AppD app -> a
    javax.swing.JPanel tempPanel -> a
    javax.swing.JPanel panelForTitleAndScaling -> b
    java.awt.event.ActionListener lst -> a
    boolean kernelChanged -> a
    java.awt.Graphics tempGraphics -> a
    void initPrintPreview(java.awt.print.Printable,int) -> a
    java.lang.String[] getAvailableViews() -> a
    javax.swing.JPanel createPanelForScaling() -> a
    void loadPreferences() -> a
    void savePreferences() -> b
    void setVisible(boolean) -> setVisible
    void centerOnScreen() -> c
    void initPages() -> d
    java.awt.print.PageFormat getDefaultPageFormat() -> a
    void updatePages() -> e
    boolean pageExists(int) -> a
    void setOrientation(int) -> a
    void setScale(int) -> b
    void access$0(geogebra.export.PrintPreview,int) -> a
    void access$1(geogebra.export.PrintPreview,int) -> b
    void access$2(geogebra.export.PrintPreview) -> a
    void access$3(geogebra.export.PrintPreview) -> b
geogebra.export.PrintPreview$1 -> geogebra.d.G:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$1) -> a
geogebra.export.PrintPreview$1$1 -> geogebra.d.H:
    geogebra.export.PrintPreview$1 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$2 -> geogebra.d.I:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$2) -> a
geogebra.export.PrintPreview$2$1 -> geogebra.d.J:
    geogebra.export.PrintPreview$2 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$3 -> geogebra.d.K:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$3) -> a
geogebra.export.PrintPreview$3$1 -> geogebra.d.L:
    geogebra.export.PrintPreview$3 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$4 -> geogebra.d.M:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$4) -> a
geogebra.export.PrintPreview$4$1 -> geogebra.d.N:
    geogebra.export.PrintPreview$4 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$5 -> geogebra.d.O:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$5) -> a
geogebra.export.PrintPreview$5$1 -> geogebra.d.P:
    geogebra.export.PrintPreview$5 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$6 -> geogebra.d.Q:
    geogebra.export.PrintPreview this$0 -> a
    javax.swing.JCheckBox val$cbEVscalePanel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.PrintPreview$PagePreview -> geogebra.d.F$a:
    int m_w -> a
    int m_h -> b
    java.awt.print.Printable target -> a
    java.awt.print.PageFormat format -> a
    int pageIndex -> c
    double scale -> a
    java.awt.image.BufferedImage img -> a
    geogebra.export.PrintPreview this$0 -> a
    void setPageFormat(java.awt.print.PageFormat) -> a
    java.awt.print.PageFormat getPageFormat() -> a
    void setScale(int) -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    java.awt.Dimension getMinimumSize() -> getMinimumSize
    void updateBufferedImage() -> b
    void update() -> a
    void paint(java.awt.Graphics) -> paint
geogebra.export.PrintPreview$PreviewContainer -> geogebra.d.F$b:
    int H_GAP -> a
    int V_GAP -> b
    geogebra.export.PrintPreview this$0 -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    java.awt.Dimension getMinimumSize() -> getMinimumSize
    void doLayout() -> doLayout
    int getNumberOfPages() -> getNumberOfPages
    java.awt.print.PageFormat getPageFormat(int) -> getPageFormat
    java.awt.print.Printable getPrintable(int) -> getPrintable
geogebra.export.PrintScalePanel -> geogebra.d.R:
    javax.swing.JTextField tfScale1 -> a
    javax.swing.JTextField tfScale2 -> b
    java.util.Vector listeners -> a
    geogebra.common.euclidian.EuclidianView ev -> a
    java.text.NumberFormat nf -> a
    java.awt.event.ActionListener al -> a
    void updateTextFields() -> a
    void fireTextFieldUpdate() -> b
    void addActionListener(java.awt.event.ActionListener) -> a
    void notifyListeners() -> c
    void access$0(geogebra.export.PrintScalePanel) -> a
geogebra.export.PrintScalePanel$1 -> geogebra.d.S:
    geogebra.export.PrintScalePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.PrintScalePanel$2 -> geogebra.d.T:
    geogebra.export.PrintScalePanel this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
geogebra.export.SVGExtensions -> geogebra.d.U:
    void startGroup(java.lang.String) -> a
    void endGroup(java.lang.String) -> b
geogebra.export.ScalingPrintGridable -> geogebra.d.V:
    double scale -> a
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
geogebra.export.WorksheetExportDialog -> geogebra.d.W:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.algebra.InputPanelD textAbove -> a
    geogebra.gui.view.algebra.InputPanelD textBelow -> b
    geogebra.gui.view.algebra.InputPanelD textAboveUpload -> c
    geogebra.gui.view.algebra.InputPanelD textBelowUpload -> d
    javax.swing.JCheckBox cbEnableRightClick -> a
    javax.swing.JCheckBox cbEnableLabelDrags -> b
    javax.swing.JCheckBox cbShowResetIcon -> c
    javax.swing.JCheckBox cbShowMenuBar -> d
    javax.swing.JCheckBox cbSavePrint -> e
    javax.swing.JCheckBox cbShowToolBar -> f
    javax.swing.JCheckBox cbShowToolBarHelp -> g
    javax.swing.JCheckBox cbShowInputField -> h
    javax.swing.JCheckBox cbUseBrowserForJavaScript -> i
    javax.swing.JCheckBox cbAllowRescaling -> j
    javax.swing.JCheckBox cbRemoveLinebreaks -> k
    javax.swing.JCheckBox cbIncludeHTML5 -> l
    javax.swing.JComboBox cbFileType -> a
    javax.swing.JComboBox cbAllWorksheets -> b
    javax.swing.JButton exportButton -> a
    javax.swing.JButton helpButton -> b
    geogebra.export.GraphicSizePanel sizePanel -> a
    boolean kernelChanged -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.main.GeoGebraPreferencesD ggbPref -> a
    geogebra.gui.GuiManagerD guiManager -> a
    boolean removeLineBreaks -> b
    geogebra.gui.inputfield.MyTextField titleField -> a
    geogebra.gui.TitlePanel titlePanel -> a
    javax.swing.JTabbedPane modeSwitch -> b
    javax.swing.JPanel modeUploadPanel -> a
    javax.swing.JPanel modeHtmlPanel -> b
    java.lang.String[] enableLabelDrags -> a
    java.lang.String[] showResetIcon -> b
    java.lang.String[] enableRightClick -> c
    java.lang.String[] errorDialogsActive -> d
    java.lang.String[] showMenuBar -> e
    java.lang.String[] showToolBar -> f
    java.lang.String[] showToolBarHelp -> g
    java.lang.String[] showAlgebraInput -> h
    java.lang.String[] useBrowserForJS -> i
    java.lang.String[] allowRescaling -> j
    java.lang.String[] java_arguments -> k
    java.lang.String[] cache_archive -> l
    java.lang.String[] cache_version -> m
    java.lang.StringBuilder sb2 -> a
    void checkEuclidianView() -> a
    void initGUI() -> b
    void loadPreferences() -> c
    void addHeight() -> d
    void savePreferences() -> e
    javax.swing.JPanel createUploadPanel() -> a
    javax.swing.JPanel createGeneralSettingsTab() -> b
    javax.swing.JPanel createAdvancedSettingsTab() -> c
    void setVisible(boolean) -> setVisible
    void centerOnScreen() -> f
    void exportToClipboard(int) -> a
    void exportHTMLtoFile() -> g
    void exportAllOpenFilesToHTMLasTabs() -> h
    void exportAllOpenFilesToHTML() -> i
    boolean appendBase64(geogebra.main.AppD,java.lang.StringBuilder) -> a
    java.lang.String getMediaWiki() -> a
    void appendWithLineBreak(java.lang.StringBuilder,java.lang.String) -> a
    java.lang.String getGoogleGadget() -> b
    java.lang.String getHTML(geogebra.main.AppD,java.io.File,java.lang.String,java.lang.String) -> a
    void appendText(java.lang.StringBuilder,java.lang.String) -> b
    void appendTitle(java.lang.StringBuilder,java.lang.String) -> c
    void appendJavaScript(java.lang.StringBuilder) -> a
    java.lang.String getFooter(geogebra.common.kernel.Construction,boolean) -> a
    java.lang.String getAppletTag(geogebra.main.AppD,int,int,boolean,boolean,boolean,boolean) -> a
    void appletParam(java.lang.StringBuilder,java.lang.String[],boolean,int) -> a
    void appletParam(java.lang.StringBuilder,java.lang.String[],java.lang.String,int) -> a
    void appendGgbAppletParameters(java.lang.StringBuilder,int) -> a
    void appendAllAppletParameters(java.lang.StringBuilder,int) -> b
    void access$0(geogebra.export.WorksheetExportDialog,boolean) -> a
    boolean access$1(geogebra.export.WorksheetExportDialog) -> a
    geogebra.main.AppD access$2(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JTabbedPane access$3(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JComboBox access$4(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JComboBox access$5(geogebra.export.WorksheetExportDialog) -> b
    void access$6(geogebra.export.WorksheetExportDialog) -> a
    void access$7(geogebra.export.WorksheetExportDialog,int) -> a
    void access$8(geogebra.export.WorksheetExportDialog) -> b
    void access$9(geogebra.export.WorksheetExportDialog) -> c
    javax.swing.JButton access$10(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.view.algebra.InputPanelD access$11(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.view.algebra.InputPanelD access$12(geogebra.export.WorksheetExportDialog) -> b
    geogebra.gui.view.algebra.InputPanelD access$13(geogebra.export.WorksheetExportDialog) -> c
    geogebra.gui.view.algebra.InputPanelD access$14(geogebra.export.WorksheetExportDialog) -> d
    geogebra.common.kernel.Kernel access$15(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.inputfield.MyTextField access$16(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.TitlePanel access$17(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JCheckBox access$18(geogebra.export.WorksheetExportDialog) -> a
    void access$19(geogebra.export.WorksheetExportDialog,boolean) -> b
    javax.swing.JCheckBox access$20(geogebra.export.WorksheetExportDialog) -> b
    geogebra.gui.GuiManagerD access$21(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JCheckBox access$22(geogebra.export.WorksheetExportDialog) -> c
    javax.swing.JCheckBox access$23(geogebra.export.WorksheetExportDialog) -> d
    geogebra.export.GraphicSizePanel access$24(geogebra.export.WorksheetExportDialog) -> a
geogebra.export.WorksheetExportDialog$1 -> geogebra.d.X:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$10 -> geogebra.d.Y:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$11 -> geogebra.d.Z:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$12 -> geogebra.d.aa:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$2 -> geogebra.d.ab:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$3 -> geogebra.d.ac:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.WorksheetExportDialog access$0(geogebra.export.WorksheetExportDialog$3) -> a
geogebra.export.WorksheetExportDialog$3$1 -> geogebra.d.ad:
    geogebra.export.WorksheetExportDialog$3 this$1 -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$4 -> geogebra.d.ae:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.export.WorksheetExportDialog$5 -> geogebra.d.af:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$6 -> geogebra.d.ag:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
geogebra.export.WorksheetExportDialog$7 -> geogebra.d.ah:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$8 -> geogebra.d.ai:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$9 -> geogebra.d.aj:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.epsgraphics.ColorMode -> geogebra.d.a.a:
    geogebra.export.epsgraphics.ColorMode COLOR_CMYK -> a
    geogebra.export.epsgraphics.ColorMode COLOR_RGB -> b
    geogebra.export.epsgraphics.ColorMode GRAYSCALE -> c
    geogebra.export.epsgraphics.ColorMode BLACK_AND_WHITE -> d
    geogebra.export.epsgraphics.ColorMode[] ENUM$VALUES -> a
    geogebra.export.epsgraphics.ColorMode[] values() -> values
    geogebra.export.epsgraphics.ColorMode valueOf(java.lang.String) -> valueOf
geogebra.export.epsgraphics.EpsDocument -> geogebra.d.a.b:
    java.io.OutputStream stream -> a
    int minX -> a
    int minY -> b
    int maxX -> c
    int maxY -> d
    boolean _isClipSet -> a
    java.lang.String title -> a
    java.io.BufferedWriter bufferedWriter -> a
    geogebra.export.epsgraphics.EpsGraphics _lastG -> a
    void append(geogebra.export.epsgraphics.EpsGraphics,java.lang.String) -> a
    void write(java.io.Writer) -> a
    void writeFooter(java.io.Writer) -> b
    void flush() -> a
    void close() -> b
    boolean isClipSet() -> a
    void setClipSet(boolean) -> a
geogebra.export.epsgraphics.EpsGraphics -> geogebra.d.a.c:
    java.awt.Stroke currentStroke -> a
    java.awt.Color color -> a
    java.awt.geom.AffineTransform _clipTransform -> a
    java.awt.Color _backgroundColor -> b
    java.awt.Paint _paint -> a
    java.awt.Composite _composite -> a
    java.awt.BasicStroke _stroke -> a
    java.awt.Font _font -> a
    java.awt.Shape _clip -> a
    java.awt.geom.AffineTransform _transform -> b
    boolean _accurateTextMode -> a
    geogebra.export.epsgraphics.EpsDocument _document -> a
    java.awt.font.FontRenderContext _fontRenderContext -> a
    geogebra.export.epsgraphics.ColorMode colorMode -> a
    int[] $SWITCH_TABLE$geogebra$export$epsgraphics$ColorMode -> a
    void methodNotSupported() -> d
    boolean getAccurateTextMode() -> a
    void flush() -> a
    void close() -> b
    void append(java.lang.String) -> a
    java.awt.geom.Point2D transform(double,double) -> a
    void draw(java.awt.Shape,java.lang.String) -> a
    java.lang.String toHexString(int) -> a
    void draw3DRect(int,int,int,int,boolean) -> draw3DRect
    void fill3DRect(int,int,int,int,boolean) -> fill3DRect
    void draw(java.awt.Shape) -> draw
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    void drawString(java.lang.String,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void fill(java.awt.Shape) -> fill
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    void setComposite(java.awt.Composite) -> setComposite
    void setPaint(java.awt.Paint) -> setPaint
    void setStroke(java.awt.Stroke) -> setStroke
    void appendStroke() -> c
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    void setRenderingHints(java.util.Map) -> setRenderingHints
    void addRenderingHints(java.util.Map) -> addRenderingHints
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    void translate(int,int) -> translate
    void translate(double,double) -> translate
    void rotate(double) -> rotate
    void rotate(double,double,double) -> rotate
    void scale(double,double) -> scale
    void shear(double,double) -> shear
    void transform(java.awt.geom.AffineTransform) -> transform
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    java.awt.geom.AffineTransform getTransform() -> getTransform
    java.awt.Paint getPaint() -> getPaint
    java.awt.Composite getComposite() -> getComposite
    void setBackground(java.awt.Color) -> setBackground
    java.awt.Color getBackground() -> getBackground
    java.awt.Stroke getStroke() -> getStroke
    void clip(java.awt.Shape) -> clip
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.awt.Graphics create(int,int,int,int) -> create
    java.awt.Color getColor() -> getColor
    void setColor(java.awt.Color) -> setColor
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    java.awt.Font getFont() -> getFont
    void setFont(java.awt.Font) -> setFont
    java.awt.FontMetrics getFontMetrics() -> getFontMetrics
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    java.awt.Rectangle getClipBounds() -> getClipBounds
    void clipRect(int,int,int,int) -> clipRect
    void setClip(int,int,int,int) -> setClip
    java.awt.Shape getClip() -> getClip
    void setClip(java.awt.Shape) -> setClip
    void copyArea(int,int,int,int,int,int) -> copyArea
    void drawLine(int,int,int,int) -> drawLine
    void fillRect(int,int,int,int) -> fillRect
    void drawRect(int,int,int,int) -> drawRect
    void clearRect(int,int,int,int) -> clearRect
    void drawRoundRect(int,int,int,int,int,int) -> drawRoundRect
    void fillRoundRect(int,int,int,int,int,int) -> fillRoundRect
    void drawOval(int,int,int,int) -> drawOval
    void fillOval(int,int,int,int) -> fillOval
    void drawArc(int,int,int,int,int,int) -> drawArc
    void fillArc(int,int,int,int,int,int) -> fillArc
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawPolygon(java.awt.Polygon) -> drawPolygon
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillPolygon(java.awt.Polygon) -> fillPolygon
    void drawChars(char[],int,int,int,int) -> drawChars
    void drawBytes(byte[],int,int,int,int) -> drawBytes
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    void dispose() -> dispose
    void finalize() -> finalize
    java.lang.String toString() -> toString
    boolean hitClip(int,int,int,int) -> hitClip
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    java.awt.Graphics create() -> create
    int[] $SWITCH_TABLE$geogebra$export$epsgraphics$ColorMode() -> a
geogebra.export.pstricks.AsymptoteFrame -> geogebra.d.b.a:
    javax.swing.JComboBox comboFontSizeMore -> a
    java.lang.String[] format -> a
    java.lang.String[] fontsizelist -> b
    void initGui() -> a
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
    int getFontSize() -> a
geogebra.export.pstricks.ExportFrame -> geogebra.d.b.b:
    java.lang.String TEXT_XUNIT -> a
    java.lang.String TEXT_YUNIT -> b
    java.lang.String TEXT_WIDTH -> c
    java.lang.String TEXT_HEIGHT -> d
    java.lang.String TEXT_XMAX -> e
    java.lang.String TEXT_XMIN -> f
    java.lang.String TEXT_YMAX -> g
    java.lang.String TEXT_YMIN -> h
    geogebra.export.pstricks.TextValue textXUnit -> a
    geogebra.export.pstricks.TextValue textYUnit -> b
    geogebra.export.pstricks.TextValue textwidth -> c
    geogebra.export.pstricks.TextValue textheight -> d
    javax.swing.JLabel labelwidth -> a
    javax.swing.JLabel labelheight -> b
    javax.swing.JLabel labelXUnit -> c
    javax.swing.JLabel labelYUnit -> d
    javax.swing.JLabel labelFontSize -> e
    javax.swing.JLabel labelFormat -> f
    geogebra.export.pstricks.TextValue textXmin -> e
    geogebra.export.pstricks.TextValue textXmax -> f
    geogebra.export.pstricks.TextValue textYmin -> g
    geogebra.export.pstricks.TextValue textYmax -> h
    javax.swing.JLabel labelXmin -> g
    javax.swing.JLabel labelXmax -> h
    javax.swing.JLabel labelYmin -> i
    javax.swing.JLabel labelYmax -> j
    java.lang.String[] msg -> c
    javax.swing.JComboBox comboFontSize -> b
    javax.swing.JComboBox comboFormat -> c
    javax.swing.JComboBox comboFill -> d
    javax.swing.JLabel labelFill -> k
    javax.swing.JPanel panel -> a
    javax.swing.JButton button -> a
    javax.swing.JButton button_copy -> b
    javax.swing.JCheckBox jcbPointSymbol -> a
    javax.swing.JCheckBox jcbGrayscale -> b
    javax.swing.JCheckBox jcbShowAxes -> c
    javax.swing.JCheckBox jcbAsyCompact -> d
    javax.swing.JCheckBox jcbAsyCse5 -> e
    javax.swing.JCheckBox jcbDotColors -> f
    javax.swing.JCheckBox jcbPairName -> g
    javax.swing.JScrollPane js -> a
    javax.swing.JTextArea textarea -> a
    geogebra.main.AppD app -> a
    double width -> a
    double height -> b
    javax.swing.JButton buttonSave -> c
    java.io.File currentFile -> a
    geogebra.export.pstricks.GeoGebraExport ggb -> a
    geogebra.export.pstricks.ExportFrame$ListenKey listenKey -> a
    void centerOnScreen() -> b
    boolean isGrayscale() -> d
    boolean getExportPointSymbol() -> e
    double getXUnit() -> a
    double getYUnit() -> b
    double getLatexHeight() -> c
    double getLatexWidth() -> d
    void write(java.lang.StringBuilder) -> a
    int getFontSize() -> a
    int getFormat() -> b
    boolean getShowAxes() -> f
    boolean getAsyCompact() -> g
    boolean getAsyCompactCse5() -> h
    boolean getKeepDotColors() -> i
    boolean getUsePairNames() -> j
    int getFillType() -> c
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
    boolean isBeamer() -> a
    geogebra.export.pstricks.GeoGebraExport access$0(geogebra.export.pstricks.ExportFrame) -> a
geogebra.export.pstricks.ExportFrame$1 -> geogebra.d.b.c:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$2 -> geogebra.d.b.d:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    geogebra.export.pstricks.GeoGebraExport val$ggb -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$3 -> geogebra.d.b.e:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$4 -> geogebra.d.b.f:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$ListenKey -> geogebra.d.b.b$a:
    geogebra.export.pstricks.ExportFrame ef -> a
    geogebra.export.pstricks.ExportFrame this$0 -> b
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.export.pstricks.GeoGebraExport -> geogebra.d.b.g:
    int beamerSlideNumber -> a
    double PRECISION_XRANGE_FUNCTION -> a
    java.lang.StringBuilder code -> a
    java.lang.StringBuilder codePoint -> b
    java.lang.StringBuilder codePreamble -> c
    java.lang.StringBuilder codeFilledObject -> d
    java.lang.StringBuilder codeBeginDoc -> e
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction construction -> a
    geogebra.euclidianND.EuclidianViewND euclidianView -> a
    geogebra.export.pstricks.ExportFrame frame -> a
    java.util.HashMap CustomColor -> a
    double xunit -> b
    double yunit -> c
    double xmin -> d
    double xmax -> e
    double ymin -> f
    double ymax -> g
    int format -> b
    boolean isBeamer -> a
    geogebra.main.AppD getApp() -> a
    java.lang.String format(double) -> a
    void refreshSelectionRectangle() -> a
    void setxmin(double) -> a
    void setxmax(double) -> b
    void setymin(double) -> c
    void setymax(double) -> d
    double getxmin() -> a
    double getxmax() -> b
    double getymin() -> c
    double getymax() -> d
    void initGui() -> e
    void setBeamer(boolean) -> a
    java.lang.String sci2dec(double) -> b
    java.lang.String createCustomColor(int,int,int) -> a
    void drawGeoElement(geogebra.common.kernel.geos.GeoElement,boolean,boolean) -> a
    boolean isSinglePointConic(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDoubleLineConic(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isEmpty(geogebra.common.kernel.geos.GeoElement) -> c
    int resizePt(int) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void createFrame() -> b
    void generateAllCode() -> c
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    double getXmin() -> e
    void setXmin(double) -> e
    double getXmax() -> f
    void setXmax(double) -> f
    double getYmin() -> g
    double getYmax() -> h
    double getXunit() -> i
    void setXunit(double) -> g
    double getYunit() -> j
    void setYunit(double) -> h
    void mark(double[],double[],int,geogebra.common.kernel.geos.GeoElement) -> a
    void markAngle(geogebra.common.kernel.geos.GeoAngle,double,double[],double,double) -> a
    void drawAllElements() -> d
    void startBeamer(java.lang.StringBuilder) -> a
    void endBeamer(java.lang.StringBuilder) -> b
    java.lang.String getImplicitExpr(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToAsymptote -> geogebra.d.b.h:
    boolean eurosym -> b
    boolean compact -> c
    boolean compactcse5 -> d
    boolean grayscale -> e
    boolean dotColors -> f
    boolean pairName -> g
    int parabolaCount -> c
    int hyperbolaCount -> d
    int arcCount -> e
    int functionCount -> f
    int implicitFuncCount -> g
    int fillType -> h
    int fontsize -> i
    java.lang.StringBuilder codeBeginPic -> f
    java.lang.StringBuilder codePointDecl -> g
    java.lang.StringBuilder codeColors -> h
    java.lang.StringBuilder codeEndDoc -> i
    java.util.ArrayList pointList -> a
    java.util.Map unicodeTable -> a
    java.util.Map pairNameTable -> b
    java.util.Map functionTable -> c
    java.util.Map implicitPolyTable -> d
    java.util.Set usepackage -> a
    java.util.Set importpackage -> b
    void createFrame() -> b
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void drawSpecialPoint(geogebra.common.kernel.geos.GeoPoint) -> b
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void initUnitAndVariable() -> g
    void initPointDeclarations() -> h
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    boolean ColorEquals(geogebra.common.awt.GColor,geogebra.common.awt.GColor) -> a
    void drawGrid() -> i
    void drawAxis() -> j
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint,java.lang.StringBuilder,double) -> a
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint,java.lang.StringBuilder) -> a
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.GColor,java.lang.StringBuilder) -> a
    void ColorLightCode(geogebra.common.awt.GColor,double,java.lang.StringBuilder) -> a
    void addText(java.lang.String,boolean,int) -> a
    void packSpaceBetween(java.lang.String[]) -> a
    void packSpaceBetween(java.lang.StringBuilder,java.lang.String[]) -> a
    void packSpaceAfter(java.lang.String[]) -> b
    void packSpaceAfter(java.lang.StringBuilder,java.lang.String[]) -> b
    void packSpace(java.lang.String[]) -> c
    void packSpace(java.lang.StringBuilder,java.lang.String[]) -> c
    void startDraw() -> e
    void startDraw(java.lang.StringBuilder) -> c
    void endDraw(geogebra.common.kernel.geos.GeoElement) -> a
    void endDraw(geogebra.common.kernel.geos.GeoElement,java.lang.StringBuilder) -> a
    void startTransparentFill(java.lang.StringBuilder) -> d
    void endTransparentFill(geogebra.common.kernel.geos.GeoElement,java.lang.StringBuilder) -> b
    void endPoint(geogebra.common.awt.GColor) -> a
    void addPoint(java.lang.String,java.lang.String,java.lang.StringBuilder) -> a
    void initUnicodeTextTable() -> f
    java.lang.StringBuilder convertUnicodeToText(java.lang.StringBuilder) -> a
    java.lang.String convertUnicodeToText(java.lang.String) -> a
    java.lang.String convertUnicodeToLatex(java.lang.String) -> b
    java.lang.String parseFunction(java.lang.String) -> c
    java.lang.String killSpace(java.lang.String) -> d
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToPgf -> geogebra.d.b.i:
    int functionIdentifier -> c
    boolean forceGnuplot -> b
    boolean gnuplotWarning -> c
    boolean hatchWarning -> d
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void addText(java.lang.String,boolean,int) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian,java.lang.StringBuilder) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String replaceX(java.lang.String,java.lang.String) -> a
    java.lang.String killSpace(java.lang.String) -> a
    boolean warningFunc(java.lang.String,java.lang.String) -> a
    void addWarningGnuplot() -> e
    void addWarningHatch() -> f
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawGrid() -> g
    void drawAxis() -> h
    java.lang.String footnotesize(java.lang.String) -> b
    void writePoint(double,double,java.lang.StringBuilder) -> a
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.GColor,java.lang.StringBuilder) -> a
    void createFrame() -> b
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToPstricks -> geogebra.d.b.j:
    boolean eurosym -> b
    java.lang.StringBuilder codeBeginPic -> f
    void createFrame() -> b
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String killSpace(java.lang.String) -> a
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void initUnitAndVariable() -> e
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawGrid() -> f
    void drawAxis() -> g
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint) -> b
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.GColor,java.lang.StringBuilder) -> a
    void addText(java.lang.String,boolean,int,geogebra.awt.GColorD) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
geogebra.export.pstricks.PgfFrame -> geogebra.d.b.k:
    java.lang.String[] format -> a
    javax.swing.JCheckBox forceGnuplot -> h
    void initGui() -> a
    boolean getGnuplot() -> k
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
geogebra.export.pstricks.PstricksFrame -> geogebra.d.b.l:
    java.lang.String[] format -> a
    void initGui() -> a
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
geogebra.export.pstricks.TextValue -> geogebra.d.b.m:
    boolean ALLOW_NEGATIVE -> a
    javax.swing.JFrame jf -> a
    java.lang.String actionCommand -> a
    double getValue() -> a
    void setValue(double) -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    java.lang.String toString() -> toString
geogebra.factories.AwtFactoryD -> geogebra.e.a:
    geogebra.common.awt.GColor newColor(int) -> a
    geogebra.common.awt.GColor newColor(int,int,int) -> a
    geogebra.common.awt.GColor newColor(int,int,int,int) -> a
    geogebra.common.awt.GColor newColor(float,float,float,float) -> a
    geogebra.common.awt.GColor newColor(float,float,float) -> a
    geogebra.common.awt.GAffineTransform newAffineTransform() -> a
    geogebra.common.awt.GRectangle2D newRectangle2D() -> a
    geogebra.common.awt.GRectangle newRectangle(int,int,int,int) -> a
    geogebra.common.awt.GBufferedImage newBufferedImage(int,int,int) -> a
    geogebra.common.awt.GDimension newDimension(int,int) -> a
    geogebra.common.awt.GPoint2D newPoint2D() -> a
    geogebra.common.awt.GPoint2D newPoint2D(double,double) -> a
    geogebra.common.awt.GRectangle newRectangle(int,int) -> a
    geogebra.common.awt.GGeneralPath newGeneralPath() -> a
    geogebra.common.awt.GBasicStroke newMyBasicStroke(float) -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float,int,int,float,float[],float) -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float) -> b
    geogebra.common.awt.GBasicStroke newBasicStrokeJoinMitre(float) -> c
    geogebra.common.awt.GLine2D newLine2D() -> a
    geogebra.common.awt.GRectangle newRectangle(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GRectangle newRectangle() -> a
    geogebra.awt.GEllipse2DDoubleD newEllipse2DDouble() -> a
    geogebra.common.awt.GEllipse2DFloat newEllipse2DFloat(int,int,int,int) -> a
    geogebra.common.awt.GArc2D newArc2D() -> a
    geogebra.common.awt.GArea newArea() -> a
    geogebra.common.awt.GArea newArea(geogebra.common.awt.GShape) -> a
    geogebra.common.awt.GGeneralPath newGeneralPath(int) -> a
    geogebra.common.awt.GCubicCurve2D newCubicCurve2D() -> a
    geogebra.common.awt.GBasicStroke newBasicStroke(float,int,int) -> a
    geogebra.common.awt.font.GTextLayout newTextLayout(java.lang.String,geogebra.common.awt.GFont,geogebra.common.awt.GFontRenderContext) -> a
    geogebra.common.awt.GAlphaComposite newAlphaComposite(int,float) -> a
    geogebra.common.awt.GGradientPaint newGradientPaint(int,int,geogebra.common.awt.GColor,int,int,geogebra.common.awt.GColor) -> a
    geogebra.common.euclidian.event.FocusListener newFocusListener(java.lang.Object) -> a
    geogebra.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
    geogebra.euclidian.event.ActionListenerD newActionListener(geogebra.common.euclidian.event.ActionListenerI) -> a
    geogebra.common.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
    geogebra.common.awt.GEllipse2DDouble newEllipse2DDouble() -> a
    geogebra.common.euclidian.event.ActionListener newActionListener(geogebra.common.euclidian.event.ActionListenerI) -> a
geogebra.factories.CASFactoryD -> geogebra.e.b:
    geogebra.common.cas.mpreduce.CASmpreduce newMPReduce(geogebra.common.cas.CASparser,geogebra.common.cas.CasParserTools,geogebra.common.kernel.Kernel) -> a
geogebra.factories.FactoryD -> geogebra.e.c:
    geogebra.common.gui.menubar.RadioButtonMenuBar newRadioButtonMenuBar(geogebra.common.main.App) -> a
    geogebra.common.javax.swing.GOptionPane newGOptionPane() -> a
    geogebra.common.gui.dialog.TextInputDialog newTextInputDialog(geogebra.common.main.App,java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND,int,int,boolean) -> a
    geogebra.common.main.InfoBar newInfoBar(geogebra.common.main.App) -> a
geogebra.factories.FormatFactoryD -> geogebra.e.d:
    geogebra.common.util.ScientificFormatAdapter getScientificFormat(int,int,boolean) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(int) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(java.lang.String,int) -> a
geogebra.factories.LaTeXFactoryD -> geogebra.e.e:
    geogebra.common.util.LaTeXCache newLaTeXCache() -> a
geogebra.factories.SwingFactoryD -> geogebra.e.f:
    geogebra.common.gui.inputfield.AutoCompleteTextField newAutoCompleteTextField(int,geogebra.common.main.App,geogebra.common.euclidian.Drawable) -> a
    geogebra.common.javax.swing.GLabel newJLabel(java.lang.String) -> a
    geogebra.common.javax.swing.GBox createHorizontalBox() -> a
    geogebra.javax.swing.GComboBoxD newJComboBox() -> a
    geogebra.common.javax.swing.AbstractJComboBox newJComboBox() -> a
geogebra.factories.UtilFactoryD -> geogebra.e.g:
    geogebra.common.util.HttpRequest newHttpRequest() -> a
geogebra.gui.AngleTextField -> geogebra.gui.a:
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.ContextMenuChooseGeoD -> geogebra.gui.b:
    geogebra.common.euclidian.EuclidianView view -> a
    java.util.TreeSet metas -> a
    java.util.ArrayList selectedGeos -> b
    geogebra.common.awt.GPoint loc -> a
    javax.swing.JMenu selectAnotherMenu -> a
    void addSelectAnotherMenu() -> w
    void addGeo(geogebra.common.kernel.geos.GeoElement) -> a
    java.util.ArrayList access$0(geogebra.gui.ContextMenuChooseGeoD) -> a
    java.util.ArrayList access$1(geogebra.gui.ContextMenuChooseGeoD) -> b
    geogebra.common.awt.GPoint access$2(geogebra.gui.ContextMenuChooseGeoD) -> a
geogebra.gui.ContextMenuChooseGeoD$GeoAction -> geogebra.gui.b$a:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.gui.ContextMenuChooseGeoD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuChooseGeoD$MyMouseAdapter -> geogebra.gui.b$b:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.gui.ContextMenuChooseGeoD this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra.gui.ContextMenuGeoElementD -> geogebra.gui.c:
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    javax.swing.JPopupMenu wrappedPopup -> a
    void addPointItems() -> w
    void addLineItems() -> x
    void addVectorItems() -> y
    void addConicItems() -> z
    void addUserInputItem() -> A
    void addNumberItems() -> B
    void addPin() -> C
    void addPlaneItems() -> D
    void addViewForValueStringItems() -> E
    void addForAllItems() -> F
    void addAction(javax.swing.Action) -> a
    void addItem(javax.swing.JMenuItem) -> a
    void setTitle(java.lang.String) -> a
    void setMenuShortCutAccelerator(javax.swing.JMenuItem,char) -> a
    javax.swing.JPopupMenu getWrappedPopup() -> a
    void showValueStringRegardingACmd() -> u
    void recordToSpreadSheetCmd() -> v
geogebra.gui.ContextMenuGeoElementD$1 -> geogebra.gui.d:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$10 -> geogebra.gui.e:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$11 -> geogebra.gui.f:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    geogebra.common.kernel.geos.GeoUserInputElement val$inputElement -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$12 -> geogebra.gui.g:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    geogebra.common.kernel.geos.GeoUserInputElement val$inputElement -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$13 -> geogebra.gui.h:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    javax.swing.JCheckBoxMenuItem val$cbItem -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$14 -> geogebra.gui.i:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    geogebra.common.kernel.kernelND.ViewCreator val$plane -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$15 -> geogebra.gui.j:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$16 -> geogebra.gui.k:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$17 -> geogebra.gui.l:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$18 -> geogebra.gui.m:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$19 -> geogebra.gui.n:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$2 -> geogebra.gui.o:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$20 -> geogebra.gui.p:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$21 -> geogebra.gui.q:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$22 -> geogebra.gui.r:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$23 -> geogebra.gui.s:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    geogebra.common.kernel.geos.GeoNumeric val$num -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$24 -> geogebra.gui.t:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$25 -> geogebra.gui.u:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$26 -> geogebra.gui.v:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$27 -> geogebra.gui.w:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$28 -> geogebra.gui.x:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.ContextMenuGeoElementD$3 -> geogebra.gui.y:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$4 -> geogebra.gui.z:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$5 -> geogebra.gui.A:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$6 -> geogebra.gui.B:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$7 -> geogebra.gui.C:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$8 -> geogebra.gui.D:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElementD$9 -> geogebra.gui.E:
    geogebra.gui.ContextMenuGeoElementD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGraphicsWindowD -> geogebra.gui.F:
    double px -> a
    double py -> b
    javax.swing.ImageIcon iconZoom -> a
    void toggleShowConstructionProtocolNavigation() -> w
    void addMiProperties() -> x
    void addAxesAndGridCheckBoxes() -> y
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void showOptionsDialog() -> z
    void addZoomItems(javax.swing.JMenu) -> a
    void addAxesRatioItems(javax.swing.JMenu) -> b
    void zoom(double) -> a
    void zoomYaxis(double) -> b
    void access$0(geogebra.gui.ContextMenuGraphicsWindowD,double) -> a
    void access$1(geogebra.gui.ContextMenuGraphicsWindowD,double) -> b
geogebra.gui.ContextMenuGraphicsWindowD$1 -> geogebra.gui.G:
    geogebra.gui.ContextMenuGraphicsWindowD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGraphicsWindowD$2 -> geogebra.gui.H:
    geogebra.gui.ContextMenuGraphicsWindowD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGraphicsWindowD$3 -> geogebra.gui.I:
    geogebra.gui.ContextMenuGraphicsWindowD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane -> geogebra.gui.J:
    geogebra.main.AppD app -> a
    geogebra.gui.DynamicTextInputPane thisPane -> a
    javax.swing.text.DefaultStyledDocument doc -> a
    java.lang.StringBuilder sb -> a
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String,geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String,int,geogebra.gui.dialog.TextInputDialog) -> a
    java.lang.String buildGeoGebraString(boolean) -> a
    void setText(geogebra.common.kernel.geos.GeoText,geogebra.gui.dialog.TextInputDialog) -> a
    void splitString(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.gui.dialog.TextInputDialog) -> a
    void insertString(int,java.lang.String,javax.swing.text.AttributeSet) -> a
    geogebra.gui.DynamicTextInputPane access$0(geogebra.gui.DynamicTextInputPane) -> a
    geogebra.main.AppD access$1(geogebra.gui.DynamicTextInputPane) -> a
geogebra.gui.DynamicTextInputPane$DynamicTextField -> geogebra.gui.J$a:
    int mode -> a
    geogebra.gui.dialog.TextInputDialog id -> a
    javax.swing.JPopupMenu contextMenu -> a
    geogebra.gui.DynamicTextInputPane this$0 -> a
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    int getMode() -> a
    void setMode(int) -> a
    void createContextMenu() -> b
    geogebra.gui.dialog.TextInputDialog access$0(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    void access$1(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    javax.swing.JPopupMenu access$2(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    void access$3(geogebra.gui.DynamicTextInputPane$DynamicTextField,int) -> a
    geogebra.gui.DynamicTextInputPane access$4(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
geogebra.gui.DynamicTextInputPane$DynamicTextField$1 -> geogebra.gui.K:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.gui.DynamicTextInputPane$DynamicTextField$2 -> geogebra.gui.L:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
geogebra.gui.DynamicTextInputPane$DynamicTextField$3 -> geogebra.gui.M:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane$DynamicTextField$4 -> geogebra.gui.N:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane$DynamicTextField$MyKeyListener -> geogebra.gui.J$a$a:
    geogebra.gui.DynamicTextInputPane$DynamicTextField tf -> b
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.FileDropTargetListener -> geogebra.gui.O:
    java.awt.datatransfer.DataFlavor urlFlavor -> a
    geogebra.main.AppD app -> a
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    boolean handleFileDrop(java.awt.datatransfer.Transferable) -> a
    boolean isGGBFile(java.lang.String) -> a
    boolean isGGTFile(java.lang.String) -> b
    java.util.ArrayList getGGBfiles(java.awt.datatransfer.Transferable) -> a
geogebra.gui.GeoGebraKeys -> geogebra.gui.P:
    java.lang.StringBuilder altCodes -> a
    boolean altPressed -> a
    geogebra.main.AppD app -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.GuiManagerD -> geogebra.gui.Q:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.DialogManagerD dialogManager -> a
    geogebra.gui.dialog.DialogManagerD$Factory dialogManagerFactory -> a
    geogebra.gui.inputbar.AlgebraInput algebraInput -> a
    geogebra.gui.view.algebra.AlgebraControllerD algebraController -> a
    geogebra.gui.view.algebra.AlgebraViewD algebraView -> a
    geogebra.cas.view.CASViewD casView -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView spreadsheetView -> a
    geogebra.euclidian.EuclidianViewD euclidianView2 -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView constructionProtocolView -> a
    geogebra.gui.menubar.GeoGebraMenuBar menuBar -> a
    javax.swing.JMenuBar menuBar2 -> a
    geogebra.gui.toolbar.ToolbarContainer toolbarPanel -> a
    boolean htmlLoaded -> a
    geogebra.gui.layout.LayoutD layout -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalculator -> a
    geogebra.gui.view.data.DataAnalysisViewD dataView -> a
    java.awt.datatransfer.DataFlavor urlFlavor -> a
    java.awt.datatransfer.DataFlavor uriListFlavor -> b
    javax.swing.AbstractAction showAxesAction -> a
    javax.swing.AbstractAction showGridAction -> b
    javax.swing.AbstractAction undoAction -> c
    javax.swing.AbstractAction redoAction -> d
    geogebra.gui.layout.panels.PropertiesDockPanel propertiesDockPanel -> a
    geogebra.gui.view.properties.PropertiesViewD propertiesView -> a
    java.util.HashMap plotPanelIDMap -> a
    int lastUsedPlotPanelID -> a
    geogebra.gui.ContextMenuGraphicsWindowD drawingPadpopupMenu -> a
    geogebra.gui.ContextMenuGeoElementD popupMenu -> a
    boolean setModeFinished -> b
    geogebra.common.gui.VirtualKeyboardListener currentKeyboardListener -> a
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard kb -> a
    geogebra.gui.virtualkeyboard.VirtualKeyboard virtualKeyboard -> a
    java.util.ArrayList recentSymbolList -> a
    geogebra.gui.inputbar.InputBarHelpPanel inputHelpPanel -> a
    int[] $SWITCH_TABLE$geogebra$common$gui$GuiManager$Help -> a
    void initialize() -> E
    void updateLayout() -> P
    void initLayoutPanels() -> Q
    geogebra.gui.layout.panels.PropertiesDockPanel getPropertiesDockPanel() -> a
    geogebra.gui.layout.panels.EuclidianDockPanel newEuclidianDockPanel() -> a
    geogebra.gui.layout.panels.Euclidian2DockPanel newEuclidian2DockPanel() -> a
    boolean isInputFieldSelectionListener() -> c
    geogebra.cas.view.CASViewD getCasView() -> a
    geogebra.gui.view.algebra.AlgebraViewD getAlgebraView() -> a
    geogebra.common.kernel.View getPropertiesView() -> f
    geogebra.gui.view.algebra.AlgebraViewD newAlgebraView(geogebra.gui.view.algebra.AlgebraControllerD) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView getConstructionProtocolView() -> a
    geogebra.common.kernel.View getConstructionProtocolData() -> a
    void startEditing(geogebra.common.kernel.geos.GeoElement) -> a
    void setScrollToShow(boolean) -> c
    void resetSpreadsheet() -> F
    boolean hasSpreadsheetView() -> d
    boolean hasAlgebraViewShowing() -> k
    boolean hasAlgebraView() -> a
    boolean hasProbabilityCalculator() -> e
    geogebra.gui.view.probcalculator.ProbabilityCalculator getProbabilityCalculator() -> a
    geogebra.gui.view.data.DataAnalysisViewD getDataAnalysisView() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView getSpreadsheetView() -> a
    void updateSpreadsheetColumnWidths() -> h
    void getSpreadsheetViewXML(java.lang.StringBuilder,boolean) -> a
    void getConsProtocolXML(java.lang.StringBuilder) -> a
    void getProbabilityCalculatorXML(java.lang.StringBuilder) -> b
    java.util.HashMap getPlotPanelIDMap() -> a
    int assignPlotPanelID(geogebra.gui.view.data.PlotPanelEuclidianView) -> a
    geogebra.gui.view.data.PlotPanelEuclidianView getPlotPanelView(int) -> a
    geogebra.euclidian.EuclidianViewD getEuclidianView2() -> a
    geogebra.euclidian.EuclidianViewD newEuclidianView(boolean[],boolean,int) -> a
    boolean hasEuclidianView2() -> i
    boolean hasEuclidianView2EitherShowingOrNot() -> j
    geogebra.common.euclidian.EuclidianView getActiveEuclidianView() -> a
    void attachSpreadsheetView() -> f
    void detachSpreadsheetView() -> C
    void attachAlgebraView() -> r
    void detachAlgebraView() -> D
    void attachCasView() -> s
    void detachCasView() -> A
    void attachConstructionProtocolView() -> t
    void detachConstructionProtocolView() -> B
    void attachProbabilityCalculatorView() -> u
    void detachProbabilityCalculatorView() -> z
    void attachDataAnalysisView() -> v
    void detachDataAnalysisView() -> w
    void attachPropertiesView() -> q
    void detachPropertiesView() -> p
    void setShowAuxiliaryObjects(boolean) -> a
    void initAlgebraController() -> ac
    javax.swing.JComponent getAlgebraInput() -> a
    geogebra.common.javax.swing.GTextComponent getAlgebraInputTextField() -> a
    geogebra.common.main.DialogManager getDialogManager() -> a
    void setLayout(geogebra.common.gui.Layout) -> a
    geogebra.gui.layout.LayoutD getLayout() -> a
    java.awt.Container getToolbarPanelContainer() -> a
    geogebra.gui.toolbar.ToolbarContainer getToolbarPanel() -> a
    void updateToolbar() -> J
    void setShowView(boolean,int) -> a
    void setShowView(boolean,int,boolean) -> a
    boolean showView(int) -> a
    void setShowToolBarHelp(boolean) -> d
    void setShowConstructionProtocolNavigation(boolean) -> e
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    boolean isConsProtNavigationPlayButtonVisible() -> l
    boolean isConsProtNavigationProtButtonVisible() -> m
    void updateConstructionProtocol() -> i
    boolean isUsingConstructionProtocol() -> b
    int getToolBarHeight() -> c
    java.lang.String getDefaultToolbarString() -> a
    void updateFonts() -> e
    void setLabels() -> M
    void initMenubar() -> R
    void updateMenubar() -> a
    void updateMenubarSelection() -> b
    void updateMenuWindow() -> G
    void updateMenuFile() -> H
    javax.swing.JMenuBar getMenuBar() -> a
    void updateMenuBarLayout() -> S
    void showAboutDialog() -> T
    void showPrintPreview() -> U
    void showDrawingPadPopup(java.awt.Component,geogebra.common.awt.GPoint) -> a
    void showPopupMenu(java.util.ArrayList,java.awt.Component,geogebra.common.awt.GPoint) -> a
    void showPopupChooseGeo(java.util.ArrayList,java.util.ArrayList,geogebra.euclidianND.EuclidianViewND,geogebra.common.awt.GPoint) -> a
    boolean loadImage(java.awt.datatransfer.Transferable,boolean) -> a
    java.awt.Color showColorChooser(geogebra.common.awt.GColor) -> a
    java.lang.String[] getImageFromTransferable(java.awt.datatransfer.Transferable) -> a
    java.lang.String getImageFromFile() -> b
    java.lang.String getImageFromFile(java.io.File) -> a
    java.io.File getDataFile() -> a
    boolean saveCurrentFile() -> h
    boolean save() -> f
    boolean saveAs() -> n
    java.io.File showSaveDialog(java.lang.String,java.io.File,java.lang.String,boolean,boolean) -> a
    java.io.File showSaveDialog(java.lang.String[],java.io.File,java.lang.String[],boolean,boolean) -> a
    java.io.File addExtension(java.io.File,java.lang.String) -> a
    java.io.File removeExtension(java.io.File) -> a
    void openURL() -> V
    void openFile() -> l
    void doOpenFiles(java.io.File[],boolean) -> a
    void doOpenFiles(java.io.File[],boolean,java.lang.String) -> a
    void allowGUIToRefresh() -> K
    boolean handleGGBFileDrop(java.awt.datatransfer.Transferable) -> a
    boolean loadFile(java.io.File,boolean) -> a
    java.net.URL getEscapedUrl(java.lang.String) -> a
    boolean loadBase64File(java.io.File) -> a
    boolean loadURL_GGB(java.lang.String) -> b
    boolean loadURL_base64(java.lang.String) -> c
    boolean loadFromApplet(java.lang.String) -> d
    void updateGUIafterLoadFile(boolean,boolean) -> a
    boolean initActions() -> o
    void updateCheckBoxesForShowConstructinProtocolNavigation() -> W
    void updateActions() -> g
    void redo() -> c
    void undo() -> d
    int getMenuBarHeight() -> d
    int getAlgebraInputHeight() -> e
    javax.swing.AbstractAction getShowAxesAction() -> a
    javax.swing.AbstractAction getShowGridAction() -> b
    geogebra.gui.toolbar.Toolbar getGeneralToolbar() -> a
    java.lang.String getToolbarDefinition() -> c
    void removeFromToolbarDefinition(int) -> c
    void addToToolbarDefinition(int) -> d
    void showURLinBrowser(java.net.URL) -> a
    void openToolHelp() -> X
    void openToolHelp(java.lang.String) -> e
    void openHelp(java.lang.String,geogebra.common.gui.GuiManager$Help) -> a
    void showURLinBrowser(java.lang.String) -> d
    java.net.URL getHelpURL(geogebra.common.gui.GuiManager$Help,java.lang.String) -> a
    java.lang.String getCreatedWithHTML(boolean) -> a
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    int setToolbarMode(int) -> a
    javax.swing.AbstractAction getRedoAction() -> c
    javax.swing.AbstractAction getUndoAction() -> d
    void updateFrameSize() -> Y
    void updateFrameTitle() -> L
    java.lang.Object createFrame() -> a
    void exitAll() -> I
    void setCurrentTextfield(geogebra.common.gui.VirtualKeyboardListener,boolean) -> a
    void insertStringIntoTextfield(java.lang.String,boolean,boolean,boolean) -> a
    void toggleKeyboard(boolean) -> f
    geogebra.gui.virtualkeyboard.VirtualKeyboard getVirtualKeyboard() -> a
    boolean showVirtualKeyboard() -> p
    boolean noMenusOpen() -> g
    java.util.ArrayList getRecentSymbolList() -> a
    void setFontRecursive(java.awt.Container,java.awt.Font) -> a
    void setLabelsRecursive(java.awt.Container) -> a
    boolean hasInputHelpPanel() -> q
    void reInitHelpPanel() -> Z
    java.awt.Component getInputHelpPanel() -> a
    void setFocusedPanel(java.awt.event.MouseEvent,boolean) -> a
    void setFocusedPanel(int,boolean) -> a
    void setFocusedPanel(geogebra.gui.layout.DockPanel,boolean) -> a
    void updateAlgebraInput() -> j
    void updatePropertiesView() -> aa
    void mouseReleasedForPropertiesView(boolean) -> b
    void mousePressedForPropertiesView() -> k
    void showPopupMenu(java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    void showPopupChooseGeo(java.util.ArrayList,java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    void setFocusedPanel(geogebra.common.euclidian.event.AbstractEvent,boolean) -> a
    void loadImage(geogebra.common.kernel.geos.GeoPoint,java.lang.Object,boolean) -> a
    boolean loadImage(geogebra.common.kernel.geos.GeoPoint,boolean,java.awt.datatransfer.Transferable) -> a
    void showDrawingPadPopup(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.GPoint) -> a
    void showPropertiesViewSliderTab() -> ab
    void showGraphicExport() -> m
    void showPSTricksExport() -> n
    void showWebpageExport() -> o
    void clearInputbar() -> O
    int getInputHelpPanelMinimumWidth() -> a
    int getActiveToolbarId() -> b
    void getAlgebraViewXML(java.lang.StringBuilder,boolean) -> b
    void applyAlgebraViewSettings() -> N
    geogebra.common.kernel.View getDataAnalysisView() -> e
    geogebra.common.kernel.View getCasView() -> b
    geogebra.common.kernel.View getAlgebraView() -> h
    geogebra.common.kernel.View getEuclidianView2() -> g
    geogebra.common.kernel.View getProbabilityCalculator() -> d
    geogebra.common.kernel.View getSpreadsheetView() -> c
    geogebra.common.gui.Layout getLayout() -> a
    java.lang.Object getInputHelpPanel() -> b
    geogebra.common.kernel.View getPlotPanelView(int) -> a
    int[] $SWITCH_TABLE$geogebra$common$gui$GuiManager$Help() -> a
geogebra.gui.GuiManagerD$1 -> geogebra.gui.R:
    geogebra.gui.GuiManagerD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManagerD$2 -> geogebra.gui.S:
    geogebra.gui.GuiManagerD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManagerD$3 -> geogebra.gui.T:
    geogebra.gui.GuiManagerD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManagerD$4 -> geogebra.gui.U:
    geogebra.gui.GuiManagerD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ImageResizer -> geogebra.gui.V:
    java.awt.image.BufferedImage resizeImage(java.awt.image.BufferedImage,int,int) -> a
geogebra.gui.MySmallJButton -> geogebra.gui.W:
    void setSmallSize(int,int) -> a
geogebra.gui.NumberComboBox -> geogebra.gui.X:
    geogebra.common.util.NumberFormatAdapter nf -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setValue(double) -> a
    double getValue() -> a
geogebra.gui.TitlePanel -> geogebra.gui.Y:
    javax.swing.JTextField titleField -> a
    javax.swing.JTextField authorField -> b
    javax.swing.JFormattedTextField dateField -> a
    java.util.ArrayList listeners -> a
    geogebra.common.kernel.Construction cons -> a
    void updateData() -> a
    java.lang.String configureDate(geogebra.common.kernel.Construction) -> a
    java.lang.String loadAuthor() -> a
    boolean saveAuthor(java.lang.String) -> a
    void fireTextFieldUpdate(javax.swing.JTextField) -> a
    void addActionListener(java.awt.event.ActionListener) -> a
    void notifyListeners() -> b
    void access$0(geogebra.gui.TitlePanel,javax.swing.JTextField) -> a
geogebra.gui.TitlePanel$1 -> geogebra.gui.Z:
    geogebra.gui.TitlePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.TitlePanel$2 -> geogebra.gui.aa:
    geogebra.gui.TitlePanel this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.ToolNameIconPanel -> geogebra.gui.ab:
    javax.swing.JTextField tfCmdName -> a
    javax.swing.JTextField tfToolHelp -> b
    javax.swing.JTextField tfToolName -> c
    javax.swing.JCheckBox cbShowInToolBar -> a
    javax.swing.JLabel labelIcon -> a
    java.lang.String iconFileName -> a
    javax.swing.JButton btIconFile -> a
    geogebra.main.AppD app -> a
    boolean editHappens -> a
    geogebra.gui.dialog.ToolManagerDialog managerDialog -> a
    geogebra.common.kernel.Macro macro -> a
    void updateMacro() -> a
    void setFromMacro(geogebra.common.kernel.Macro) -> a
    void init(geogebra.gui.dialog.ToolManagerDialog,geogebra.common.kernel.Macro) -> a
    void requestFocus() -> requestFocus
    java.lang.String getCommandName() -> a
    java.lang.String getToolName() -> b
    void setToolName(java.lang.String) -> a
    java.lang.String getToolHelp() -> c
    void setToolHelp(java.lang.String) -> b
    boolean showInToolBar() -> a
    void setIconFileName(java.lang.String) -> c
    java.lang.String getIconFileName() -> d
    void updateCmdName(java.lang.Object) -> a
    java.lang.String defaultToolName() -> e
    void access$0(geogebra.gui.ToolNameIconPanel,java.lang.Object) -> a
    javax.swing.JCheckBox access$1(geogebra.gui.ToolNameIconPanel) -> a
    javax.swing.JLabel access$2(geogebra.gui.ToolNameIconPanel) -> a
    javax.swing.JButton access$3(geogebra.gui.ToolNameIconPanel) -> a
    void access$4(geogebra.gui.ToolNameIconPanel) -> a
    boolean access$5(geogebra.gui.ToolNameIconPanel) -> a
geogebra.gui.ToolNameIconPanel$1 -> geogebra.gui.ac:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.gui.ToolNameIconPanel$2 -> geogebra.gui.ad:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.ToolNameIconPanel$3 -> geogebra.gui.ae:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    geogebra.main.AppD val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ToolNameIconPanel$4 -> geogebra.gui.af:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    geogebra.main.AppD val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.app.GeoGebraFrame -> geogebra.gui.a.a:
    java.util.ArrayList instances -> a
    geogebra.gui.app.GeoGebraFrame activeInstance -> a
    geogebra.gui.FileDropTargetListener dropTargetListener -> a
    geogebra.main.AppD app -> a
    java.util.List instanceListener -> a
    void dispose() -> dispose
    geogebra.main.AppD getApplication() -> a
    void setApplication(geogebra.main.AppD) -> a
    int getInstanceNumber() -> a
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    java.util.Locale getLocale() -> getLocale
    void setVisible(boolean) -> setVisible
    void updateSize() -> a
    void main(geogebra.CommandLineArguments) -> a
    void init(geogebra.CommandLineArguments,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.gui.app.GeoGebraFrame getActiveInstance() -> a
    void initMacSpecifics() -> b
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.main.AppD createApplication(geogebra.CommandLineArguments,javax.swing.JFrame) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.common.kernel.Macro) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.common.kernel.Macro,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.gui.app.GeoGebraFrame$AppThread createAppThread(geogebra.main.AppD) -> a
    java.lang.Long versionToLong(java.lang.String) -> a
    int getInstanceCount() -> b
    java.util.ArrayList getInstances() -> a
    geogebra.gui.app.GeoGebraFrame getInstance(int) -> a
    void updateAllTitles() -> c
    geogebra.gui.app.GeoGebraFrame getInstanceWithFile(java.io.File) -> a
    boolean isIconified() -> a
    geogebra.gui.FileDropTargetListener getDropTargetListener() -> a
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void checkCommandLineExport(geogebra.main.AppD) -> b
geogebra.gui.app.GeoGebraFrame$1 -> geogebra.gui.a.b:
    geogebra.main.AppD val$app -> a
    void run() -> run
geogebra.gui.app.GeoGebraFrame$2 -> geogebra.gui.a.c:
    geogebra.main.AppD val$app -> a
    int val$dpi -> a
    java.lang.String val$filename -> a
    java.lang.String val$extension -> b
    void run() -> run
geogebra.gui.app.GeoGebraFrame$AppThread -> geogebra.gui.a.a$a:
    geogebra.main.AppD app -> a
    geogebra.gui.app.GeoGebraFrame this$0 -> a
    void run() -> run
    void checkVersion() -> a
geogebra.gui.app.MacApplicationListener -> geogebra.gui.a.d:
    void initMacApplicationListener() -> a
    geogebra.gui.app.GeoGebraFrame getGGBInstance() -> a
    void handleQuit(com.apple.eawt.ApplicationEvent) -> handleQuit
    void handleAbout(com.apple.eawt.ApplicationEvent) -> handleAbout
    void handleOpenFile(com.apple.eawt.ApplicationEvent) -> handleOpenFile
    void handlePrintFile(com.apple.eawt.ApplicationEvent) -> handlePrintFile
    void handleOpenApplication(com.apple.eawt.ApplicationEvent) -> handleOpenApplication
    void handlePreferences(com.apple.eawt.ApplicationEvent) -> handlePreferences
    void handleReOpenApplication(com.apple.eawt.ApplicationEvent) -> handleReOpenApplication
geogebra.gui.app.MyFileFilter -> geogebra.gui.a.e:
    java.util.ArrayList filters -> a
    java.lang.String description -> a
    java.lang.String fullDescription -> b
    boolean useExtensionsInDescription -> a
    boolean accept(java.io.File) -> accept
    java.lang.String getExtension(java.io.File) -> a
    void addExtension(java.lang.String) -> a
    java.lang.String toString() -> toString
    java.lang.String getDescription() -> getDescription
    void setDescription(java.lang.String) -> b
    boolean isExtensionListInDescription() -> a
    java.lang.String getExtension() -> a
geogebra.gui.app.NewInstanceListener -> geogebra.gui.a.f:
    void newInstance(geogebra.gui.app.GeoGebraFrame) -> a
geogebra.gui.autocompletion.AutoCompletion -> geogebra.gui.b.a:
    geogebra.gui.autocompletion.FileChooserCompletionListCellRenderer FC_CELL_RENDERER -> a
    boolean caseInsensitivePaths -> a
    boolean initCaseInsenitvePaths() -> a
    void install(javax.swing.JFileChooser,boolean) -> a
    java.lang.String fileToString(java.io.File) -> b
    javax.swing.JTextField getInternalTextField(java.awt.Container) -> a
    void install(javax.swing.JTextField,geogebra.gui.autocompletion.CompletionProvider,javax.swing.ListCellRenderer,int) -> a
    java.lang.String access$0(java.io.File) -> a
geogebra.gui.autocompletion.AutoCompletion$1 -> geogebra.gui.b.b:
    javax.swing.JFileChooser val$fileChooser -> a
    boolean val$caseInsensitiveCompletion -> a
    java.util.List getCompletionOptions(java.lang.String) -> a
    java.lang.String toString(java.io.File) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.AutoCompletion$1$1 -> geogebra.gui.b.c:
    geogebra.gui.autocompletion.AutoCompletion$1 this$1 -> a
    javax.swing.filechooser.FileFilter val$fileChooserFileFilter -> a
    boolean accept(java.io.File) -> accept
geogebra.gui.autocompletion.AutoCompletion$1$2 -> geogebra.gui.b.d:
    geogebra.gui.autocompletion.AutoCompletion$1 this$1 -> a
    java.lang.String toString(java.io.File) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.CommandCompletionListCellRenderer -> geogebra.gui.b.e:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.autocompletion.CompletionProvider -> geogebra.gui.b.f:
    java.util.List getCompletionOptions(java.lang.String) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.CompletionsPopup -> geogebra.gui.b.g:
    geogebra.gui.inputfield.AutoCompleteTextFieldD textField -> a
    int maxPopupRowCount -> a
    javax.swing.JPopupMenu popup -> a
    geogebra.gui.autocompletion.DelegatingListModel listModel -> a
    javax.swing.JList list -> a
    javax.swing.event.DocumentListener textFieldDocListener -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    int current_length -> b
    void setFont(java.awt.Font) -> a
    void registerListeners() -> c
    void placePopup() -> a
    void showCompletions() -> b
    void showPopup() -> d
    boolean isPopupVisible() -> a
    void hidePopup() -> e
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> a
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD access$0(geogebra.gui.autocompletion.CompletionsPopup) -> a
    java.awt.event.KeyListener access$1(geogebra.gui.autocompletion.CompletionsPopup) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$3(geogebra.gui.autocompletion.CompletionsPopup,java.awt.event.KeyListener[]) -> a
    int access$4(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$5(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$6(geogebra.gui.autocompletion.CompletionsPopup,int) -> a
    void access$7(geogebra.gui.autocompletion.CompletionsPopup,java.awt.event.MouseEvent) -> a
    boolean access$8(geogebra.gui.autocompletion.CompletionsPopup) -> a
geogebra.gui.autocompletion.CompletionsPopup$1 -> geogebra.gui.b.h:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
geogebra.gui.autocompletion.CompletionsPopup$2 -> geogebra.gui.b.i:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.autocompletion.CompletionsPopup$3 -> geogebra.gui.b.j:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.autocompletion.CompletionsPopup$4 -> geogebra.gui.b.k:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.autocompletion.CompletionsPopup$5 -> geogebra.gui.b.l:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void ancestorMoved(java.awt.event.HierarchyEvent) -> ancestorMoved
geogebra.gui.autocompletion.CompletionsPopup$PopupListener -> geogebra.gui.b.g$a:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
geogebra.gui.autocompletion.DelegatingListModel -> geogebra.gui.b.m:
    java.util.List delegate -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    void setDataList(java.util.List) -> a
geogebra.gui.autocompletion.FileChooserCompletionListCellRenderer -> geogebra.gui.b.n:
    javax.swing.Icon DIRECTORY_ICON -> a
    javax.swing.Icon UNKNOWN_FILE_ICON -> b
    java.util.Map FILE_EXT_ICONS -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    javax.swing.Icon getIcon(java.io.File) -> a
    javax.swing.Icon loadIcon(java.lang.String) -> a
geogebra.gui.autocompletion.OptionsPopup -> geogebra.gui.b.o:
    javax.swing.JTextField textField -> a
    geogebra.gui.autocompletion.CompletionProvider completionProvider -> a
    int maxPopupRowCount -> a
    javax.swing.JPopupMenu popup -> a
    geogebra.gui.autocompletion.DelegatingListModel listModel -> a
    javax.swing.JList list -> a
    javax.swing.event.DocumentListener documentListener -> a
    java.lang.String userInput -> a
    int popupRowCount -> b
    void registerListeners() -> a
    void showCompletion() -> b
    void showOptionsPopup() -> c
    void adjustPopupSize(int) -> a
    boolean isOptionsPopupVisible() -> a
    void hideOptionsPopup() -> d
    void updateText() -> e
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> b
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void access$0(geogebra.gui.autocompletion.OptionsPopup) -> a
    void access$1(geogebra.gui.autocompletion.OptionsPopup,java.awt.event.KeyEvent) -> a
    void access$2(geogebra.gui.autocompletion.OptionsPopup) -> b
    void access$3(geogebra.gui.autocompletion.OptionsPopup,java.awt.event.MouseEvent) -> a
geogebra.gui.autocompletion.OptionsPopup$1 -> geogebra.gui.b.p:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
geogebra.gui.autocompletion.OptionsPopup$2 -> geogebra.gui.b.q:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.autocompletion.OptionsPopup$3 -> geogebra.gui.b.r:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.autocompletion.OptionsPopup$4 -> geogebra.gui.b.s:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.autocompletion.SortedArrayCompletionProvider -> geogebra.gui.b.t:
    java.lang.Comparable[] sortedCompletionOptions -> a
    boolean caseInsensitiveCompletion -> a
    java.util.List getCompletionOptions(java.lang.String) -> a
    boolean isValidCompletionOpiton(java.lang.String,java.lang.String) -> a
geogebra.gui.color.ColorPopupMenuButton -> geogebra.gui.c.a:
    geogebra.main.AppD app -> a
    int colorSetType -> a
    geogebra.common.awt.GColor[] colorSet -> a
    geogebra.common.awt.GColor defaultColor -> a
    java.util.HashMap lookupMap -> a
    boolean hasSlider -> b
    java.awt.Dimension iconSize -> a
    void updateColorTable() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    javax.swing.ImageIcon getButtonIcon() -> a
    int getColorIndex(java.awt.Color) -> a
    geogebra.common.awt.GColor getSelectedColor() -> a
    geogebra.common.awt.GColor[] getColorArray(int) -> a
    void setDefaultColor(float,geogebra.common.awt.GColor) -> a
    java.lang.String[] getToolTipArray() -> a
    javax.swing.ImageIcon[] getColorSwatchIcons(geogebra.common.awt.GColor[],float,java.awt.Dimension,int) -> a
    javax.swing.ImageIcon[] createDummyIcons(java.awt.Dimension) -> a
geogebra.gui.color.DefaultRGBChooserPanel -> geogebra.gui.c.b:
    boolean internalChange -> a
    javax.swing.event.ChangeListener colorChanger -> a
    javax.swing.event.ChangeListener spinnerHandler -> b
    javax.swing.JSlider R -> a
    javax.swing.JSlider G -> b
    javax.swing.JSlider B -> c
    javax.swing.JLabel redLabel -> a
    javax.swing.JLabel greenLabel -> b
    javax.swing.JLabel blueLabel -> c
    javax.swing.JSpinner RSpinner -> a
    javax.swing.JSpinner GSpinner -> b
    javax.swing.JSpinner BSpinner -> c
    geogebra.gui.color.DefaultRGBChooserPanel$MyPreviewPanel previewPanel -> a
    geogebra.main.AppD app -> a
    javax.swing.JComponent getPreview() -> a
    java.lang.String getDisplayName() -> getDisplayName
    void updateChooser() -> updateChooser
    void buildChooser() -> buildChooser
    void uninstallChooserPanel(javax.swing.JColorChooser) -> uninstallChooserPanel
    void uninstallListeners() -> b
    void installListeners() -> c
    javax.swing.Icon getSmallDisplayIcon() -> getSmallDisplayIcon
    javax.swing.Icon getLargeDisplayIcon() -> getLargeDisplayIcon
    void paint(java.awt.Graphics) -> paint
    void setLabels() -> a
    boolean access$0(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSlider access$1(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSlider access$2(geogebra.gui.color.DefaultRGBChooserPanel) -> b
    javax.swing.JSlider access$3(geogebra.gui.color.DefaultRGBChooserPanel) -> c
    javax.swing.JSpinner access$4(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSpinner access$5(geogebra.gui.color.DefaultRGBChooserPanel) -> b
    javax.swing.JSpinner access$6(geogebra.gui.color.DefaultRGBChooserPanel) -> c
geogebra.gui.color.DefaultRGBChooserPanel$MyPreviewPanel -> geogebra.gui.c.b$a:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.color.DefaultRGBChooserPanel$SliderHandler -> geogebra.gui.c.b$b:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.color.DefaultRGBChooserPanel$SpinnerHandler -> geogebra.gui.c.b$c:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.color.GeoGebraColorChooser -> geogebra.gui.c.c:
    geogebra.main.AppD app -> a
    boolean isNullSelection -> a
    boolean isNullSelection() -> a
    void setLabels() -> a
    void updateFonts() -> b
    boolean access$0(geogebra.gui.color.GeoGebraColorChooser) -> a
    void access$1(geogebra.gui.color.GeoGebraColorChooser,boolean) -> a
geogebra.gui.color.GeoGebraColorChooser$MyColorSelectionModel -> geogebra.gui.c.c$a:
    geogebra.gui.color.GeoGebraColorChooser this$0 -> a
    void setSelectedColor(java.awt.Color) -> setSelectedColor
geogebra.gui.color.GeoGebraColorChooserPanel -> geogebra.gui.c.d:
    geogebra.main.AppD app -> a
    geogebra.gui.color.GeoGebraColorChooser enclosingChooser -> a
    geogebra.gui.color.GeoGebraColorChooserPanel myChooser -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$MainSwatchPanel mainSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$RecentSwatchPanel recentSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$PrimarySwatchPanel primarySwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$CustomSwatchPanel customSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchListener swatchListener -> a
    java.util.ArrayList swatchPanelList -> a
    javax.swing.JButton btnCustomColor -> a
    javax.swing.JLabel lblRecent -> a
    javax.swing.JLabel lblCustom -> b
    javax.swing.JPanel recentPanel -> a
    javax.swing.JPanel customPanel -> b
    java.lang.String getDisplayName() -> getDisplayName
    int getMnemonic() -> getMnemonic
    int getDisplayedMnemonicIndex() -> getDisplayedMnemonicIndex
    javax.swing.Icon getSmallDisplayIcon() -> getSmallDisplayIcon
    javax.swing.Icon getLargeDisplayIcon() -> getLargeDisplayIcon
    void installChooserPanel(javax.swing.JColorChooser) -> installChooserPanel
    void buildChooser() -> buildChooser
    void createGUIElements() -> c
    void uninstallChooserPanel(javax.swing.JColorChooser) -> uninstallChooserPanel
    void updateChooser() -> updateChooser
    boolean setSwatchPanelSelection(java.awt.Color) -> a
    void setLabels() -> a
    void updateFonts() -> b
    java.awt.Color access$0(geogebra.gui.color.GeoGebraColorChooserPanel) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener -> geogebra.gui.c.d$a:
    javax.swing.JColorChooser chooser -> a
    java.awt.event.ActionListener okActionListener -> a
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.color.GeoGebraColorChooserPanel access$0(geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener$1 -> geogebra.gui.c.e:
    geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.color.GeoGebraColorChooserPanel$CustomSwatchPanel -> geogebra.gui.c.d$b:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initSwatchCount() -> b
    void initColors() -> c
    void addCustomColor(java.awt.Color) -> a
    boolean setSelectionFromColor(java.awt.Color) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$MainSwatchPanel -> geogebra.gui.c.d$c:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
geogebra.gui.color.GeoGebraColorChooserPanel$PrimarySwatchPanel -> geogebra.gui.c.d$d:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
geogebra.gui.color.GeoGebraColorChooserPanel$RecentSwatchPanel -> geogebra.gui.c.d$e:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
    void initSwatchCount() -> b
    void setMostRecentColor(java.awt.Color) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchListener -> geogebra.gui.c.d$f:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel -> geogebra.gui.c.d$g:
    geogebra.common.awt.GColor[] colors -> a
    java.awt.Dimension swatchSize -> a
    java.awt.Dimension gap -> b
    java.awt.Dimension numSwatches -> c
    java.awt.Dimension selectedSwatch -> d
    java.awt.Dimension hoverSwatch -> e
    java.awt.Dimension prevHoverSwatch -> f
    int swatchCount -> a
    java.awt.Dimension cell -> g
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> b
    boolean isFocusTraversable() -> isFocusTraversable
    void initValues() -> a
    void initColors() -> c
    void initSwatchCount() -> b
    void updateHoverSwatch(int,int) -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.lang.String getToolTipText(java.awt.event.MouseEvent) -> getToolTipText
    java.awt.Color getColorForLocation(int,int) -> a
    void setCellFromLocation(int,int,java.awt.Dimension) -> a
    java.awt.Color getColorForCell(int,int) -> b
    boolean getCellForColor(java.awt.Color,java.awt.Dimension) -> a
    boolean setSelectionFromColor(java.awt.Color) -> a
    void setSelectionFromLocation(int,int) -> b
    boolean isSwatchLocation(int,int) -> a
    boolean isSwatchCell(int,int) -> b
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel$SwatchMouseListener -> geogebra.gui.c.d$g$a:
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel this$1 -> a
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel$SwatchMouseMotionListener -> geogebra.gui.c.d$g$b:
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel this$1 -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.dialog.AngleInputDialog -> geogebra.gui.d.a:
    javax.swing.JRadioButton rbCounterClockWise -> a
    javax.swing.JRadioButton rbClockWise -> b
    boolean success -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.AxesStyleListRenderer -> geogebra.gui.d.b:
    int style -> a
    int WIDTH -> b
    int HEIGHT -> c
    int arrowSize -> d
    int filledArrowLength -> e
    int pointSize -> f
    java.awt.geom.Line2D$Double tempLine -> a
    java.awt.geom.GeneralPath gp -> a
    java.awt.BasicStroke borderStroke -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.ButtonDialog -> geogebra.gui.d.c:
    javax.swing.text.JTextComponent tfCaption -> a
    javax.swing.text.JTextComponent tfScript -> b
    javax.swing.JPanel btPanel -> a
    javax.swing.DefaultComboBoxModel comboModel -> a
    geogebra.common.kernel.geos.GeoElement linkedGeo -> a
    boolean textField -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JPanel optionPane -> b
    geogebra.main.AppD app -> a
    geogebra.common.kernel.geos.GeoElement geoResult -> b
    geogebra.common.kernel.geos.GeoButton button -> a
    int x -> a
    int y -> b
    void createGUI() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void access$0(geogebra.gui.dialog.ButtonDialog,geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.ButtonDialog$1 -> geogebra.gui.d.d:
    geogebra.gui.dialog.ButtonDialog this$0 -> a
    javax.swing.JComboBox val$cbAdd -> a
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.dialog.CheckboxCreationDialog -> geogebra.gui.d.e:
    javax.swing.text.JTextComponent tfCaption -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel btPanel -> b
    javax.swing.DefaultListModel listModel -> a
    javax.swing.DefaultComboBoxModel comboModel -> a
    java.awt.Point location -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.geos.GeoBoolean geoBoolean -> a
    void initLists() -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void createGUI(java.lang.String) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void apply() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void setVisible(boolean) -> setVisible
    javax.swing.DefaultComboBoxModel access$0(geogebra.gui.dialog.CheckboxCreationDialog) -> a
geogebra.gui.dialog.CheckboxCreationDialog$1 -> geogebra.gui.d.f:
    geogebra.gui.dialog.CheckboxCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ColorFunctionPanel -> geogebra.gui.d.g:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfRed -> a
    javax.swing.JTextField tfGreen -> b
    javax.swing.JTextField tfBlue -> c
    javax.swing.JTextField tfAlpha -> d
    javax.swing.JButton btRemove -> a
    javax.swing.JLabel nameLabelR -> a
    javax.swing.JLabel nameLabelG -> b
    javax.swing.JLabel nameLabelB -> c
    javax.swing.JLabel nameLabelA -> d
    javax.swing.JComboBox cbColorSpace -> a
    int colorSpace -> a
    boolean allowSetComboBoxLabels -> a
    java.lang.String defaultR -> a
    java.lang.String defaultG -> b
    java.lang.String defaultB -> c
    java.lang.String defaultA -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    boolean processed -> b
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> c
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.Object[] access$0(geogebra.gui.dialog.ColorFunctionPanel) -> a
    javax.swing.JTextField access$1(geogebra.gui.dialog.ColorFunctionPanel) -> a
    javax.swing.JTextField access$2(geogebra.gui.dialog.ColorFunctionPanel) -> b
    javax.swing.JTextField access$3(geogebra.gui.dialog.ColorFunctionPanel) -> c
    javax.swing.JTextField access$4(geogebra.gui.dialog.ColorFunctionPanel) -> d
geogebra.gui.dialog.ColorFunctionPanel$1 -> geogebra.gui.d.h:
    geogebra.gui.dialog.ColorFunctionPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.DashListRenderer -> geogebra.gui.d.i:
    java.util.HashMap dashStrokeMap -> a
    java.awt.BasicStroke dashStroke -> a
    boolean nullValue -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DecorationAngleListRenderer -> geogebra.gui.d.j:
    java.awt.geom.Line2D$Double tick -> a
    java.awt.geom.Arc2D$Double arc -> a
    java.awt.geom.GeneralPath polygon -> a
    int id -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void drawTick(double) -> a
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DecorationListRenderer -> geogebra.gui.d.k:
    int id -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DialogManagerD -> geogebra.gui.d.l:
    geogebra.gui.dialog.options.OptionsDialog optionsDialog -> a
    geogebra.gui.dialog.options.OptionsDialog$Factory optionsDialogFactory -> a
    geogebra.gui.view.functioninspector.FunctionInspector functionInspector -> a
    geogebra.gui.util.GeoGebraFileChooser fileChooser -> a
    geogebra.gui.view.data.DataSourceDialog dataSourceDialog -> a
    java.util.ResourceBundle rbJavaUI -> a
    java.util.Locale currentLocale -> a
    void updateFonts() -> e
    void setLabels() -> f
    void showPropertiesDialog() -> b
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showPropertiesDialog(geogebra.common.main.OptionType,java.util.ArrayList) -> a
    void showToolbarConfigDialog() -> c
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showRedefineDialog(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showDataSourceDialog(int,boolean) -> a
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.GPoint,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    void showNumberInputDialogRegularPolygon(java.lang.String,geogebra.common.kernel.geos.GeoPoint,geogebra.common.kernel.geos.GeoPoint) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.EuclidianView) -> a
    void showNumberInputDialogRotate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    void closeAll() -> a
    boolean showSliderCreationDialog(int,int) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    void initFileChooser() -> g
    void updateJavaUILanguage() -> h
    geogebra.gui.util.GeoGebraFileChooser getFileChooser() -> a
    void setFileChooser(geogebra.gui.util.GeoGebraFileChooser) -> a
    void setOptionsDialogFactory(geogebra.gui.dialog.options.OptionsDialog$Factory) -> a
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    boolean confirm(java.lang.String) -> a
    void openToolHelp() -> d
geogebra.gui.dialog.DialogManagerD$Factory -> geogebra.gui.d.l$a:
    geogebra.gui.dialog.DialogManagerD create(geogebra.main.AppD) -> a
geogebra.gui.dialog.DialogManagerD$FileFilterChangedListener -> geogebra.gui.d.l$b:
    geogebra.gui.dialog.DialogManagerD this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.dialog.GraphicsViewLocationPanel -> geogebra.gui.d.m:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox cbGraphicsView -> a
    javax.swing.JCheckBox cbGraphicsView2 -> b
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.AppD app -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.IneqStylePanel -> geogebra.gui.d.n:
    geogebra.gui.dialog.PropertiesPanel propertiesPanel -> a
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showOnAxis -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.InputDialogAngleFixed -> geogebra.gui.d.o:
    java.lang.String defaultRotateAngle -> c
    geogebra.common.kernel.geos.GeoSegment[] segments -> a
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.dialog.InputDialogCirclePointRadius -> geogebra.gui.d.p:
    geogebra.common.kernel.geos.GeoPoint geoPoint1 -> a
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.gui.dialog.InputDialogD -> geogebra.gui.d.q:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.main.GeoElementSelectionListener sl -> a
    geogebra.gui.view.algebra.InputPanelD inputPanel -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel buttonsPanel -> b
    javax.swing.JPanel btPanel -> c
    javax.swing.JPanel btPanel2 -> d
    javax.swing.JLabel msgLabel -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JButton btProperties -> c
    javax.swing.JButton btOK -> d
    javax.swing.JButton btHelp -> e
    javax.swing.JCheckBox checkBox -> a
    javax.swing.JDialog wrappedDialog -> a
    void createGUI(java.lang.String,java.lang.String,boolean,int,int,boolean,boolean,boolean,boolean,geogebra.common.gui.view.algebra.DialogType) -> a
    void loadBtPanel(boolean) -> b
    void centerOnScreen() -> a
    void showSymbolTablePopup(boolean) -> c
    void addHelpButton(java.lang.String) -> b
    javax.swing.JPanel getButtonPanel() -> a
    void setLabels(java.lang.String) -> c
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void insertString(java.lang.String) -> a
    void insertString(java.lang.String,boolean) -> a
    java.lang.String getText() -> a
    void setRelativeCaretPosition(int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> a
    void setVisibleForTools(boolean) -> d
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void updateFonts() -> c
geogebra.gui.dialog.InputDialogD$1 -> geogebra.gui.d.r:
    geogebra.gui.dialog.InputDialogD this$0 -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
geogebra.gui.dialog.InputDialogDilate -> geogebra.gui.d.s:
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogOpenURL -> geogebra.gui.d.t:
    void setLabels(java.lang.String) -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
geogebra.gui.dialog.InputDialogRadius -> geogebra.gui.d.u:
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogRegularPolygon -> geogebra.gui.d.v:
    geogebra.common.kernel.geos.GeoPoint geoPoint1 -> a
    geogebra.common.kernel.geos.GeoPoint geoPoint2 -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogRotate -> geogebra.gui.d.w:
    geogebra.common.kernel.geos.GeoPolygon[] polys -> a
    geogebra.common.kernel.geos.GeoPoint[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    java.lang.String defaultRotateAngle -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.dialog.InputDialogSegmentFixed -> geogebra.gui.d.x:
    geogebra.common.kernel.geos.GeoPoint geoPoint1 -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.LanguageDialog -> geogebra.gui.d.y:
    geogebra.main.AppD app -> a
    javax.swing.AbstractAction setFlagIconAction -> a
    java.util.HashMap lblList -> a
    java.util.Locale oldLocale -> a
    javax.swing.JButton btnOK -> a
    javax.swing.JButton btnCancel -> b
    javax.swing.JPanel createButtonPanel() -> a
    javax.swing.JPanel createLanguageSelectionPanel() -> b
    void initActions() -> c
    void setFlag() -> a
    void setLabels() -> b
    geogebra.main.AppD access$0(geogebra.gui.dialog.LanguageDialog) -> a
    java.util.Locale access$1(geogebra.gui.dialog.LanguageDialog) -> a
geogebra.gui.dialog.LanguageDialog$1 -> geogebra.gui.d.z:
    geogebra.gui.dialog.LanguageDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.LanguageDialog$2 -> geogebra.gui.d.A:
    geogebra.gui.dialog.LanguageDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.LanguageDialog$3 -> geogebra.gui.d.B:
    geogebra.gui.dialog.LanguageDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.dialog.LanguageDialog access$0(geogebra.gui.dialog.LanguageDialog$3) -> a
geogebra.gui.dialog.LanguageDialog$3$1 -> geogebra.gui.d.C:
    geogebra.gui.dialog.LanguageDialog$3 this$1 -> a
    void run() -> run
geogebra.gui.dialog.MyCellRenderer -> geogebra.gui.d.D:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.NamePanel -> geogebra.gui.d.E:
    geogebra.gui.inputfield.AutoCompleteTextFieldD tfName -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD tfDefinition -> b
    geogebra.gui.inputfield.AutoCompleteTextFieldD tfCaption -> c
    boolean actionPerforming -> a
    boolean redefinitionFailed -> b
    java.lang.Runnable doActionStopped -> a
    javax.swing.JLabel nameLabel -> a
    javax.swing.JLabel defLabel -> b
    javax.swing.JLabel captionLabel -> c
    geogebra.gui.view.algebra.InputPanelD inputPanelName -> a
    geogebra.gui.view.algebra.InputPanelD inputPanelDef -> b
    geogebra.gui.view.algebra.InputPanelD inputPanelCap -> c
    geogebra.common.gui.dialog.handler.RenameInputHandler nameInputHandler -> a
    geogebra.common.gui.dialog.handler.RedefineInputHandler defInputHandler -> a
    geogebra.common.kernel.geos.GeoElement currentGeo -> a
    geogebra.main.AppD app -> a
    int rows -> a
    void setLabels() -> a
    void updateGUI(boolean,boolean) -> a
    void setLayout() -> c
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateDef(geogebra.common.kernel.geos.GeoElement) -> b
    void updateName(geogebra.common.kernel.geos.GeoElement) -> c
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    java.lang.String getDefText(geogebra.common.kernel.geos.GeoElement) -> a
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    void access$0(geogebra.gui.dialog.NamePanel,boolean) -> a
geogebra.gui.dialog.NamePanel$1 -> geogebra.gui.d.F:
    geogebra.gui.dialog.NamePanel this$0 -> a
    void run() -> run
geogebra.gui.dialog.PointStyleListRenderer -> geogebra.gui.d.G:
    int pointStyle -> a
    int pointSize -> b
    java.awt.geom.Ellipse2D$Double circle -> a
    java.awt.geom.Line2D$Double line1 -> a
    java.awt.geom.Line2D$Double line2 -> b
    java.awt.geom.Line2D$Double line3 -> c
    java.awt.geom.Line2D$Double line4 -> d
    java.awt.geom.GeneralPath gp -> a
    java.awt.BasicStroke borderStroke -> a
    java.awt.BasicStroke[] crossStrokes -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
    void getPath() -> a
geogebra.gui.dialog.PropertiesPanel -> geogebra.gui.d.H:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.color.GeoGebraColorChooser colChooser -> a
    geogebra.gui.dialog.NamePanel namePanel -> a
    geogebra.gui.dialog.PropertiesPanel$ShowObjectPanel showObjectPanel -> a
    geogebra.gui.dialog.PropertiesPanel$SelectionAllowedPanel selectionAllowed -> a
    geogebra.gui.dialog.PropertiesPanel$ShowTrimmedIntersectionLines showTrimmedIntersectionLines -> a
    geogebra.gui.dialog.PropertiesPanel$ColorPanel colorPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LabelPanel labelPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TooltipPanel tooltipPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LayerPanel layerPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CoordPanel coordPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineEqnPanel lineEqnPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ConicEqnPanel conicEqnPanel -> a
    geogebra.gui.dialog.PropertiesPanel$PointSizePanel pointSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$PointStylePanel pointStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel textOptionsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ArcSizePanel arcSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineStylePanel lineStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineStyleHiddenPanel lineStylePanelHidden -> a
    geogebra.gui.dialog.PropertiesPanel$DecoSegmentPanel decoSegmentPanel -> a
    geogebra.gui.dialog.PropertiesPanel$DecoAnglePanel decoAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$RightAnglePanel rightAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$FillingPanel fillingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$FadingPanel fadingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LodPanel lodPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CheckBoxInterpolateImage checkBoxInterpolateImage -> a
    geogebra.gui.dialog.PropertiesPanel$TracePanel tracePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AnimatingPanel animatingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$FixPanel fixPanel -> a
    geogebra.gui.dialog.IneqStylePanel ineqStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$CheckBoxFixPanel checkBoxFixPanel -> a
    geogebra.gui.dialog.PropertiesPanel$AllowReflexAnglePanel allowReflexAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AllowOutlyingIntersectionsPanel allowOutlyingIntersectionsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$AuxiliaryObjectPanel auxPanel -> a
    geogebra.gui.properties.AnimationStepPanel animStepPanel -> a
    geogebra.gui.dialog.TextfieldSizePanel textFieldSizePanel -> a
    geogebra.gui.properties.AnimationSpeedPanel animSpeedPanel -> a
    geogebra.gui.properties.SliderPanel sliderPanel -> a
    geogebra.gui.dialog.PropertiesPanel$SlopeTriangleSizePanel slopeTriangleSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$StartPointPanel startPointPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CornerPointsPanel cornerPointsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel textEditPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel scriptEditPanel -> a
    geogebra.gui.dialog.PropertiesPanel$BackgroundImagePanel bgImagePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AbsoluteScreenLocationPanel absScreenLocPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ListsAsComboBoxPanel comboBoxPanel -> a
    geogebra.gui.dialog.ShowConditionPanel showConditionPanel -> a
    geogebra.gui.dialog.ColorFunctionPanel colorFunctionPanel -> a
    geogebra.gui.dialog.GraphicsViewLocationPanel graphicsViewLocationPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TabPanel basicTab -> a
    geogebra.gui.dialog.PropertiesPanel$TabPanel colorTab -> b
    geogebra.gui.dialog.PropertiesPanel$TabPanel styleTab -> c
    geogebra.gui.dialog.PropertiesPanel$TabPanel lineStyleTab -> d
    geogebra.gui.dialog.PropertiesPanel$TabPanel sliderTab -> e
    geogebra.gui.dialog.PropertiesPanel$TabPanel textTab -> f
    geogebra.gui.dialog.PropertiesPanel$TabPanel positionTab -> g
    geogebra.gui.dialog.PropertiesPanel$TabPanel algebraTab -> h
    geogebra.gui.dialog.PropertiesPanel$TabPanel scriptTab -> i
    geogebra.gui.dialog.PropertiesPanel$TabPanel advancedTab -> j
    boolean isDefaults -> a
    javax.swing.JTabbedPane tabs -> a
    java.util.ArrayList tabPanelList -> a
    void applyModifications() -> b
    void showSliderTab() -> c
    void setSliderMinValue() -> d
    void initTabs() -> f
    void setLabels() -> a
    void updateFonts() -> e
    void updateTabs(java.lang.Object[]) -> b
    boolean updateTabPanel(geogebra.gui.dialog.PropertiesPanel$TabPanel,java.util.ArrayList,java.lang.Object[]) -> b
    void updateSelection(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    void updateOneGeoDefinition(geogebra.common.kernel.geos.GeoElement) -> b
    void updateOneGeoName(geogebra.common.kernel.geos.GeoElement) -> c
    java.lang.String replaceEqualsSigns(java.lang.String) -> a
    boolean access$0(geogebra.gui.dialog.PropertiesPanel$TabPanel,java.util.ArrayList,java.lang.Object[]) -> a
    geogebra.gui.color.GeoGebraColorChooser access$1(geogebra.gui.dialog.PropertiesPanel) -> a
    boolean access$2(geogebra.gui.dialog.PropertiesPanel) -> a
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel access$3(geogebra.gui.dialog.PropertiesPanel) -> a
geogebra.gui.dialog.PropertiesPanel$1 -> geogebra.gui.d.I:
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$AbsoluteScreenLocationPanel -> geogebra.gui.d.H$a:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox cbAbsScreenLoc -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$AllowOutlyingIntersectionsPanel -> geogebra.gui.d.H$b:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox outlyingIntersectionsCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$AllowReflexAnglePanel -> geogebra.gui.d.H$c:
    java.lang.Object[] geos -> a
    javax.swing.JLabel intervalLabel -> a
    javax.swing.JComboBox intervalCombo -> a
    boolean hasOrientation -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    void setComboLabels() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    int getIndex() -> a
    void setSelectedIndex(int) -> a
    void updateFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$AnimatingPanel -> geogebra.gui.d.H$d:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showAnimatingCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ArcSizePanel -> geogebra.gui.d.H$e:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    void setMinValue() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void updateFonts() -> c
    void updateSliderFonts() -> d
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$AuxiliaryObjectPanel -> geogebra.gui.d.H$f:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox auxCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$BackgroundImagePanel -> geogebra.gui.d.H$g:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox isBGimage -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$CheckBoxFixPanel -> geogebra.gui.d.H$h:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox checkboxFixCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$CheckBoxInterpolateImage -> geogebra.gui.d.H$i:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox checkbox -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ColorPanel -> geogebra.gui.d.H$j:
    java.lang.Object[] geos -> a
    javax.swing.JLabel previewLabel -> a
    javax.swing.JLabel currentColorLabel -> b
    geogebra.gui.dialog.PropertiesPanel$ColorPanel$PreviewPanel previewPanel -> a
    javax.swing.JPanel opacityPanel -> a
    javax.swing.JPanel colorChooserContainer -> b
    javax.swing.JRadioButton rbtnForegroundColor -> a
    javax.swing.JRadioButton rbtnBackgroundColor -> b
    javax.swing.JButton btnClearBackground -> a
    javax.swing.JSlider opacitySlider -> a
    javax.swing.JPanel previewMetaPanel -> c
    boolean allFillable -> a
    boolean hasBackground -> b
    java.awt.Color selectedColor -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    javax.swing.JPanel update() -> a
    void updateToolTipText() -> c
    java.lang.String getToolTipText(java.awt.Color) -> a
    void updateColor(java.awt.Color,float,boolean) -> a
    void clearBackgroundColor() -> d
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateSliderFonts() -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.gui.dialog.PropertiesPanel access$0(geogebra.gui.dialog.PropertiesPanel$ColorPanel) -> a
geogebra.gui.dialog.PropertiesPanel$ColorPanel$PreviewPanel -> geogebra.gui.d.H$j$a:
    java.awt.Color alphaFillColor -> a
    geogebra.gui.dialog.PropertiesPanel$ColorPanel this$1 -> a
    void setPreview(java.awt.Color,float) -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.dialog.PropertiesPanel$ConicEqnPanel -> geogebra.gui.d.H$k:
    java.lang.Object[] geos -> a
    javax.swing.DefaultComboBoxModel eqnCBmodel -> a
    javax.swing.JComboBox eqnCB -> a
    javax.swing.JLabel eqnLabel -> a
    int implicitIndex -> a
    int explicitIndex -> b
    int specificIndex -> c
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$CoordPanel -> geogebra.gui.d.H$l:
    java.lang.Object[] geos -> a
    javax.swing.JLabel coordLabel -> a
    javax.swing.JComboBox coordCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$CornerPointsPanel -> geogebra.gui.d.H$m:
    java.lang.Object[] geos -> a
    javax.swing.JLabel[] labelLocation -> a
    javax.swing.JComboBox[] cbLocation -> a
    javax.swing.DefaultComboBoxModel[] cbModel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$DecoAnglePanel -> geogebra.gui.d.H$n:
    javax.swing.JComboBox decoCombo -> a
    javax.swing.JLabel decoLabel -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$DecoSegmentPanel -> geogebra.gui.d.H$o:
    javax.swing.JComboBox decoCombo -> a
    javax.swing.JLabel decoLabel -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$FadingPanel -> geogebra.gui.d.H$p:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void updateFonts() -> b
    void updateSliderFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$FillingPanel -> geogebra.gui.d.H$q:
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel$FillingPanel fillingPanel -> a
    javax.swing.JSlider fillingSlider -> a
    javax.swing.JSlider angleSlider -> b
    javax.swing.JSlider distanceSlider -> c
    javax.swing.JComboBox cbFillType -> a
    javax.swing.JCheckBox cbFillInverse -> a
    javax.swing.JPanel transparencyPanel -> a
    javax.swing.JPanel hatchFillPanel -> b
    javax.swing.JPanel imagePanel -> c
    javax.swing.JPanel anglePanel -> d
    javax.swing.JPanel distancePanel -> e
    javax.swing.JLabel lblFillType -> a
    javax.swing.JButton btnOpenFile -> a
    geogebra.gui.util.PopupMenuButton btnImage -> a
    javax.swing.JLabel lblFillInverse -> b
    boolean hasGeoButton -> a
    java.util.ArrayList imgFileNameList -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setAllEnabled(boolean) -> a
    void setLabels() -> a
    javax.swing.JPanel createImagePanel() -> a
    void updateFillTypePanel(int) -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$FixPanel -> geogebra.gui.d.H$r:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showFixCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$LabelPanel -> geogebra.gui.d.H$s:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showLabelCB -> a
    javax.swing.JComboBox labelModeCB -> a
    boolean showNameValueComboBox -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
geogebra.gui.dialog.PropertiesPanel$LayerPanel -> geogebra.gui.d.H$t:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox layerModeCB -> a
    javax.swing.JLabel layerLabel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$LineEqnPanel -> geogebra.gui.d.H$u:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox eqnCB -> a
    javax.swing.JLabel eqnLabel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$LineStyleHiddenPanel -> geogebra.gui.d.H$v:
    java.lang.Object[] geos -> a
    javax.swing.JRadioButton[] buttons -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
geogebra.gui.dialog.PropertiesPanel$LineStylePanel -> geogebra.gui.d.H$w:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    javax.swing.JPanel thicknessPanel -> a
    javax.swing.JLabel dashLabel -> a
    javax.swing.JComboBox dashCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    int maxMinimumThickness(java.lang.Object[]) -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateSliderFonts() -> c
geogebra.gui.dialog.PropertiesPanel$ListsAsComboBoxPanel -> geogebra.gui.d.H$x:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox cbComboBox -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$LodPanel -> geogebra.gui.d.H$y:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void updateFonts() -> b
    void updateSliderFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$PointSizePanel -> geogebra.gui.d.H$z:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void updateFonts() -> b
    void updateSliderFonts() -> c
geogebra.gui.dialog.PropertiesPanel$PointStylePanel -> geogebra.gui.d.H$A:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox cbStyle -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
geogebra.gui.dialog.PropertiesPanel$RightAnglePanel -> geogebra.gui.d.H$B:
    javax.swing.JCheckBox emphasizeRightAngle -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel -> geogebra.gui.d.H$C:
    geogebra.gui.dialog.ScriptInputDialog clickDialog -> a
    geogebra.gui.dialog.ScriptInputDialog updateDialog -> b
    geogebra.gui.dialog.ScriptInputDialog globalDialog -> c
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel clickScriptPanel -> a
    javax.swing.JPanel updateScriptPanel -> b
    javax.swing.JPanel globalScriptPanel -> c
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void applyModifications() -> b
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel$1 -> geogebra.gui.d.J:
    geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel this$1 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$SelectionAllowedPanel -> geogebra.gui.d.H$D:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox selectionAllowedCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ShowObjectPanel -> geogebra.gui.d.H$E:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showObjectCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$ShowTrimmedIntersectionLines -> geogebra.gui.d.H$F:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showTrimmedLinesCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$SlopeTriangleSizePanel -> geogebra.gui.d.H$G:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void updateFonts() -> b
    void updateSliderFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$StartPointPanel -> geogebra.gui.d.H$H:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    javax.swing.JComboBox cbLocation -> a
    javax.swing.DefaultComboBoxModel cbModel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> c
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$TabPanel -> geogebra.gui.d.H$I:
    java.lang.String title -> a
    java.util.ArrayList panelList -> a
    boolean makeVisible -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setTitle(java.lang.String) -> a
    void update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    void addToTabbedPane(javax.swing.JTabbedPane) -> a
geogebra.gui.dialog.PropertiesPanel$TextEditPanel -> geogebra.gui.d.H$J:
    geogebra.gui.dialog.TextInputDialog td -> a
    javax.swing.JPanel editPanel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void applyModifications() -> b
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.gui.dialog.TextInputDialog access$0(geogebra.gui.dialog.PropertiesPanel$TextEditPanel) -> a
geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel -> geogebra.gui.d.H$K:
    java.lang.Object[] geos -> a
    javax.swing.JLabel decimalLabel -> a
    javax.swing.JComboBox cbFont -> a
    javax.swing.JComboBox cbSize -> b
    javax.swing.JComboBox cbDecimalPlaces -> c
    javax.swing.JToggleButton btBold -> a
    javax.swing.JToggleButton btItalic -> b
    javax.swing.JPanel secondLine -> a
    boolean secondLineVisible -> a
    boolean justDisplayFontSize -> b
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel editPanel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setEditPanel(geogebra.gui.dialog.PropertiesPanel$TextEditPanel) -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.JPanel update() -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel$ComboBoxRenderer -> geogebra.gui.d.H$K$a:
    javax.swing.JSeparator separator -> a
    geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.PropertiesPanel$TooltipPanel -> geogebra.gui.d.H$L:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox tooltipModeCB -> a
    javax.swing.JLabel label -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel$TracePanel -> geogebra.gui.d.H$M:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showTraceCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.ScriptInputDialog -> geogebra.gui.d.K:
    geogebra.common.kernel.geos.GeoElement geo -> b
    boolean global -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType scriptType -> a
    boolean updateScript -> b
    javax.swing.JComboBox languageSelector -> a
    boolean handlingDocumentEventOff -> c
    boolean editOccurred -> d
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType -> a
    void setGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void setGlobal() -> b
    javax.swing.JPanel getInputPanel(int,int,boolean) -> a
    boolean processInput() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void applyModifications() -> d
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void handleDocumentEvent() -> e
    void updateFonts() -> c
    boolean access$0(geogebra.gui.dialog.ScriptInputDialog) -> a
    boolean access$1(geogebra.gui.dialog.ScriptInputDialog) -> b
    geogebra.common.kernel.geos.GeoElement$ScriptType access$2(geogebra.gui.dialog.ScriptInputDialog) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType() -> a
geogebra.gui.dialog.ScriptInputDialog$TextInputHandler -> geogebra.gui.d.K$a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.ScriptInputDialog this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.ShowConditionPanel -> geogebra.gui.d.L:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfCondition -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    boolean processed -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> c
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.SliderDialog -> geogebra.gui.d.M:
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JRadioButton rbNumber -> a
    javax.swing.JRadioButton rbAngle -> b
    javax.swing.JRadioButton rbInteger -> c
    geogebra.gui.view.algebra.InputPanelD tfLabel -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JCheckBox cbRandom -> a
    geogebra.main.AppD app -> a
    geogebra.gui.properties.SliderPanel sliderPanel -> a
    geogebra.common.kernel.geos.GeoElement geoResult -> a
    geogebra.common.kernel.geos.GeoNumeric number -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    void createGUI() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabelFieldFocus() -> b
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.dialog.TextInputDialog -> geogebra.gui.d.N:
    geogebra.gui.DynamicTextInputPane editor -> a
    geogebra.gui.dialog.TextPreviewPanel textPreviewer -> a
    geogebra.gui.dialog.TextInputDialog textInputDialog -> a
    javax.swing.JCheckBox cbLaTeX -> b
    javax.swing.JToolBar toolBar -> a
    javax.swing.JPanel previewPanel -> e
    javax.swing.JPanel editPanel -> f
    javax.swing.JPanel toolPanel -> g
    geogebra.gui.util.PopupMenuButton btInsertLaTeX -> a
    geogebra.gui.util.PopupMenuButton btInsertUnicode -> b
    geogebra.gui.util.PopupMenuButton btInsertGeo -> c
    javax.swing.JLabel previewHeader -> b
    javax.swing.JLabel editHeader -> c
    geogebra.common.kernel.geos.GeoText editGeo -> a
    boolean isLaTeX -> c
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    boolean isTextMode -> d
    geogebra.gui.util.SelectionTable recentSymbolTable -> a
    java.util.ArrayList recentSymbolList -> b
    javax.swing.JList geoList -> a
    boolean isIniting -> a
    boolean isBtnInsertLatexLoaded -> b
    javax.swing.undo.UndoManager undo -> a
    javax.swing.text.Document doc -> a
    java.util.HashMap laTexButtonTitleMap -> a
    boolean handlingDocumentEventOff -> e
    boolean editOccurred -> f
    void reInitEditor(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createAdditionalGUI() -> i
    void buildInsertUnicodeButton() -> j
    javax.swing.JMenu createMenuItem(java.lang.String[],int,int) -> a
    void buildInsertLaTeXButton() -> k
    void updateInsertLaTeXButtonLabels() -> b
    java.lang.String[] getGeoObjectList() -> a
    void buildInsertGeoButton() -> l
    javax.swing.JToolBar createRecentSymbolTable() -> a
    void addRecentSymbol(java.lang.String) -> d
    void updateRecentSymbolTable() -> d
    void setLabels() -> e
    void setLabels(java.lang.String) -> c
    void setGeoText(geogebra.common.kernel.geos.GeoText) -> a
    javax.swing.JPanel getToolBar() -> b
    javax.swing.JPanel getInputPanel() -> c
    javax.swing.JPanel getPreviewPanel() -> d
    boolean isLaTeX() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> a
    void exitTextField(geogebra.gui.DynamicTextInputPane$DynamicTextField,boolean) -> a
    void updateFonts() -> c
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void applyModifications() -> f
    void handleDocumentEvent() -> g
    void updatePreviewText() -> m
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void insertEmptyDynamicText() -> h
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String) -> a
    boolean access$0(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.DynamicTextInputPane access$1(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.common.kernel.geos.GeoText access$2(geogebra.gui.dialog.TextInputDialog) -> a
    javax.swing.JList access$3(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.util.PopupMenuButton access$4(geogebra.gui.dialog.TextInputDialog) -> a
    java.lang.String[] access$5(geogebra.gui.dialog.TextInputDialog) -> a
    java.util.ArrayList access$6(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.util.SelectionTable access$7(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.dialog.TextInputDialog access$8(geogebra.gui.dialog.TextInputDialog) -> a
geogebra.gui.dialog.TextInputDialog$1 -> geogebra.gui.d.O:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void undoableEditHappened(javax.swing.event.UndoableEditEvent) -> undoableEditHappened
geogebra.gui.dialog.TextInputDialog$2 -> geogebra.gui.d.P:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$3 -> geogebra.gui.d.Q:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$4 -> geogebra.gui.d.R:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$5 -> geogebra.gui.d.S:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.dialog.TextInputDialog$6 -> geogebra.gui.d.T:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.dialog.TextInputDialog$7 -> geogebra.gui.d.U:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.dialog.TextInputDialog$MyKeyListener -> geogebra.gui.d.N$a:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.dialog.TextInputDialog$TextInputHandler -> geogebra.gui.d.N$b:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.TextPreviewPanel -> geogebra.gui.d.V:
    geogebra.euclidian.EuclidianControllerD ec -> a
    boolean[] showAxes -> a
    boolean showGrid -> f
    geogebra.common.kernel.geos.GeoText previewGeoIndependent -> a
    geogebra.common.kernel.geos.GeoText previewGeoDependent -> b
    geogebra.common.kernel.algos.AlgoDependentText textAlgo -> a
    geogebra.common.kernel.Construction cons -> a
    boolean isIndependent -> g
    java.awt.Dimension d -> a
    javax.swing.ImageIcon testIcon -> a
    javax.swing.JTextPane dummyText -> a
    int padding -> e
    void removePreviewGeoText() -> H
    void attachView() -> a
    void updatePreviewText(geogebra.common.kernel.geos.GeoText,java.lang.String,boolean) -> a
    void updateViewportSize(geogebra.common.kernel.geos.GeoText) -> a
    void updateVisualProperties(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText,boolean,boolean) -> a
    void locateTextGeo(geogebra.common.kernel.geos.GeoText) -> b
    int getViewID() -> a
geogebra.gui.dialog.TextfieldSizePanel -> geogebra.gui.d.W:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    geogebra.gui.inputfield.MyTextField tfTextfieldSize -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.ToolCreationDialog -> geogebra.gui.d.X:
    geogebra.main.AppD app -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.gui.ToolNameIconPanel namePanel -> a
    geogebra.gui.dialog.ToolCreationDialog$OutputListModel outputList -> a
    geogebra.gui.dialog.ToolCreationDialog$InputListModel inputList -> a
    javax.swing.DefaultComboBoxModel cbInputAddList -> a
    javax.swing.DefaultComboBoxModel cbOutputAddList -> b
    boolean allowMultiple -> a
    geogebra.common.kernel.Macro newTool -> a
    void setVisible(boolean) -> setVisible
    boolean createTool() -> a
    void finish() -> a
    void overwriteMacro(geogebra.common.kernel.Macro) -> b
    void updateInputList() -> b
    javax.swing.JComboBox removeListeningJComboBox(javax.swing.DefaultComboBoxModel) -> b
    geogebra.common.kernel.geos.GeoElement[] toGeoElements(javax.swing.DefaultListModel) -> a
    void initLists() -> c
    boolean possibleInput(geogebra.common.kernel.geos.GeoElement) -> b
    void initGUI() -> d
    void setFromMacro(geogebra.common.kernel.Macro) -> a
    javax.swing.JPanel createNavigationPanel() -> a
    javax.swing.JPanel createInputOutputPanel(geogebra.main.AppD,javax.swing.DefaultListModel,javax.swing.DefaultComboBoxModel,boolean,boolean,java.awt.event.ActionListener) -> a
    javax.swing.JPanel createListUpDownRemovePanel(geogebra.main.AppD,javax.swing.JList,javax.swing.JComboBox,boolean,boolean,boolean,java.awt.event.ActionListener) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    javax.swing.JComboBox access$0(javax.swing.DefaultComboBoxModel) -> a
    boolean access$1(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.gui.dialog.ToolCreationDialog$OutputListModel access$2(geogebra.gui.dialog.ToolCreationDialog) -> a
    javax.swing.JTabbedPane access$3(geogebra.gui.dialog.ToolCreationDialog) -> a
    void access$4(geogebra.gui.dialog.ToolCreationDialog) -> a
    void access$5(geogebra.gui.dialog.ToolCreationDialog) -> b
    geogebra.main.AppD access$6(geogebra.gui.dialog.ToolCreationDialog) -> a
    boolean access$7(geogebra.gui.dialog.ToolCreationDialog) -> a
    geogebra.gui.dialog.ToolCreationDialog$InputListModel access$8(geogebra.gui.dialog.ToolCreationDialog) -> a
    geogebra.gui.ToolNameIconPanel access$9(geogebra.gui.dialog.ToolCreationDialog) -> a
geogebra.gui.dialog.ToolCreationDialog$1 -> geogebra.gui.d.Y:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void removeElement(java.lang.Object) -> removeElement
geogebra.gui.dialog.ToolCreationDialog$2 -> geogebra.gui.d.Z:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    javax.swing.JButton val$btNext -> a
    javax.swing.JButton val$btBack -> b
    javax.swing.JButton val$btCancel -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolCreationDialog$3 -> geogebra.gui.d.aa:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    javax.swing.JButton val$btBack -> a
    javax.swing.JButton val$btNext -> b
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.ToolCreationDialog$4 -> geogebra.gui.d.ab:
    javax.swing.JComboBox val$cbAdd -> a
    javax.swing.DefaultListModel val$listModel -> a
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.dialog.ToolCreationDialog$5 -> geogebra.gui.d.ac:
    javax.swing.JList val$list -> a
    javax.swing.JButton val$btUp -> a
    javax.swing.JButton val$btDown -> b
    javax.swing.JButton val$btRemove -> c
    javax.swing.JComboBox val$cbAdd -> a
    boolean val$allowMultiple -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolCreationDialog$InputListModel -> geogebra.gui.d.X$a:
    javax.swing.DefaultComboBoxModel cbInputAddList -> a
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ToolCreationDialog$OutputListModel -> geogebra.gui.d.X$b:
    javax.swing.DefaultComboBoxModel cbOutputAddList -> a
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ToolManagerDialog -> geogebra.gui.d.ad:
    geogebra.main.AppD app -> a
    javax.swing.DefaultListModel toolsModel -> a
    void setVisible(boolean) -> setVisible
    void updateToolBar(javax.swing.DefaultListModel) -> a
    void deleteTools(javax.swing.JList,javax.swing.DefaultListModel) -> a
    void initGUI() -> a
    void openTools(javax.swing.JList) -> a
    void insertTools(javax.swing.DefaultListModel) -> b
    void uploadToGeoGebraTube(javax.swing.JList) -> b
    void saveTools(javax.swing.JList) -> c
    geogebra.main.AppD access$0(geogebra.gui.dialog.ToolManagerDialog) -> a
    javax.swing.DefaultListModel access$1(geogebra.gui.dialog.ToolManagerDialog) -> a
    void access$2(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList,javax.swing.DefaultListModel) -> a
    void access$3(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> a
    void access$4(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> b
    void access$5(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> c
geogebra.gui.dialog.ToolManagerDialog$1 -> geogebra.gui.d.ae:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.JButton val$btClose -> a
    geogebra.gui.ToolNameIconPanel val$namePanel -> a
    javax.swing.JButton val$btDelete -> b
    javax.swing.JList val$toolList -> a
    javax.swing.JButton val$btOpen -> c
    javax.swing.JButton val$btSave -> d
    javax.swing.JButton val$btShare -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolManagerDialog$2 -> geogebra.gui.d.af:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.ListSelectionModel val$selModel -> a
    javax.swing.JList val$toolList -> a
    geogebra.gui.ToolNameIconPanel val$namePanel -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.dialog.ToolManagerDialog$3 -> geogebra.gui.d.ag:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    geogebra.common.kernel.Macro val$macro -> a
    void run() -> run
geogebra.gui.dialog.ToolManagerDialog$4 -> geogebra.gui.d.ah:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.JList val$toolList -> a
    void run() -> run
geogebra.gui.dialog.ToolManagerDialog$MacroCellRenderer -> geogebra.gui.d.ad$a:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.options.AxisPanel -> geogebra.gui.d.a.a:
    int axis -> a
    javax.swing.JCheckBox cbShowAxis -> a
    javax.swing.JCheckBox cbAxisNumber -> b
    javax.swing.JCheckBox cbManualTicks -> c
    javax.swing.JCheckBox cbPositiveAxis -> d
    javax.swing.JCheckBox cbDrawAtBorder -> e
    geogebra.gui.NumberComboBox ncbTickDist -> a
    javax.swing.JComboBox cbTickStyle -> a
    javax.swing.JComboBox cbAxisLabel -> b
    javax.swing.JComboBox cbUnitLabel -> c
    javax.swing.JTextField tfCross -> a
    javax.swing.JLabel crossAt -> a
    javax.swing.JLabel axisTicks -> b
    javax.swing.JLabel axisLabel -> c
    javax.swing.JLabel axisUnitLabel -> d
    javax.swing.JLabel stickToEdge -> e
    geogebra.main.AppD app -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    java.lang.String getString() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updatePanel() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setLabels() -> a
    double parseDouble(java.lang.String) -> a
    void updateFont() -> c
geogebra.gui.dialog.options.LanguageRenderer -> geogebra.gui.d.a.b:
    geogebra.common.main.App app -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.options.OptionPanelD -> geogebra.gui.d.a.c:
    void updateGUI() -> c
    void revalidate() -> d
    javax.swing.JPanel getWrappedPanel() -> a
    void applyModifications() -> e
    void setSelected(boolean) -> a
geogebra.gui.dialog.options.OptionsAdvancedD -> geogebra.gui.d.a.d:
    geogebra.main.AppD app -> a
    geogebra.common.main.settings.Settings settings -> a
    javax.swing.JPanel virtualKeyboardPanel -> a
    javax.swing.JPanel guiFontsizePanel -> b
    javax.swing.JPanel tooltipPanel -> c
    javax.swing.JPanel languagePanel -> d
    javax.swing.JPanel perspectivesPanel -> e
    javax.swing.JPanel miscPanel -> f
    javax.swing.JPanel angleUnitPanel -> g
    javax.swing.JPanel continuityPanel -> h
    javax.swing.JPanel usePathAndRegionParametersPanel -> i
    javax.swing.JPanel checkboxSizePanel -> j
    javax.swing.JPanel rightAnglePanel -> k
    javax.swing.JPanel coordinatesPanel -> l
    javax.swing.JLabel keyboardLanguageLabel -> a
    javax.swing.JLabel guiFontSizeLabel -> b
    javax.swing.JLabel widthLabel -> c
    javax.swing.JLabel heightLabel -> d
    javax.swing.JLabel opacityLabel -> e
    javax.swing.JLabel tooltipLanguageLabel -> f
    javax.swing.JLabel tooltipTimeoutLabel -> g
    javax.swing.JComboBox cbKeyboardLanguage -> a
    javax.swing.JComboBox cbTooltipLanguage -> b
    javax.swing.JComboBox cbTooltipTimeout -> c
    javax.swing.JComboBox cbGUIFont -> d
    javax.swing.JCheckBox cbKeyboardShowAutomatic -> a
    javax.swing.JCheckBox cbUseLocalDigits -> b
    javax.swing.JCheckBox cbUseLocalLabels -> c
    javax.swing.JCheckBox cbReturnAngleInverseTrig -> d
    javax.swing.JCheckBox cbIgnoreDocumentLayout -> e
    javax.swing.JCheckBox cbShowTitleBar -> f
    javax.swing.JCheckBox cbAllowStyleBar -> g
    javax.swing.JCheckBox cbEnableScripting -> h
    javax.swing.JCheckBox cbUseJavaFonts -> i
    javax.swing.JCheckBox cbReverseMouseWheel -> j
    javax.swing.JRadioButton angleUnitRadioDegree -> a
    javax.swing.JRadioButton angleUnitRadioRadian -> b
    javax.swing.JRadioButton continuityRadioOn -> c
    javax.swing.JRadioButton continuityRadioOff -> d
    javax.swing.JRadioButton usePathAndRegionParametersRadioOn -> e
    javax.swing.JRadioButton usePathAndRegionParametersRadioOff -> f
    javax.swing.JRadioButton checkboxSizeRadioRegular -> g
    javax.swing.JRadioButton checkboxSizeRadioLarge -> h
    javax.swing.JRadioButton rightAngleRadio1 -> i
    javax.swing.JRadioButton rightAngleRadio2 -> j
    javax.swing.JRadioButton rightAngleRadio3 -> k
    javax.swing.JRadioButton rightAngleRadio4 -> l
    javax.swing.JRadioButton coordinatesRadio1 -> m
    javax.swing.JRadioButton coordinatesRadio2 -> n
    javax.swing.JRadioButton coordinatesRadio3 -> o
    javax.swing.ButtonGroup angleUnitButtonGroup -> a
    javax.swing.ButtonGroup continuityButtonGroup -> b
    javax.swing.ButtonGroup usePathAndRegionParametersButtonGroup -> c
    javax.swing.ButtonGroup checkboxSizeButtonGroup -> d
    javax.swing.ButtonGroup rightAngleButtonGroup -> e
    javax.swing.ButtonGroup coordinatesButtonGroup -> f
    javax.swing.JTextField tfKeyboardWidth -> a
    javax.swing.JTextField tfKeyboardHeight -> b
    javax.swing.JSlider slOpacity -> a
    java.lang.String[] tooltipTimeouts -> a
    javax.swing.JPanel wrappedPanel -> m
    void initGUI() -> h
    void initVirtualKeyboardPanel() -> i
    void initGUIFontSizePanel() -> j
    void initLanguagePanel() -> k
    void initTooltipPanel() -> l
    void initPerspectivesPanel() -> m
    void initScriptingPanel() -> n
    void initAngleUnitPanel() -> o
    void initContinuityPanel() -> p
    void initUsePathAndRegionParametersPanel() -> q
    void initCheckboxSizePanel() -> r
    void initRightAnglePanel() -> s
    void initCoordinatesPanel() -> t
    void updateGUI() -> c
    void updateGUIFont() -> b
    void updateTooltipLanguages() -> f
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void handleEVOption(java.lang.Object,geogebra.euclidian.EuclidianViewD) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void changeWidthOrHeight(java.lang.Object) -> a
    void setLabels() -> a
    void setLabelsKeyboardLanguage() -> u
    void setLabelsGUIFontsize() -> v
    void setLabelsTooltipLanguages() -> w
    void setLabelsTooltipTimeouts() -> x
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void applyModifications() -> e
    void updateFont() -> g
    void setSelected(boolean) -> a
geogebra.gui.dialog.options.OptionsCASD -> geogebra.gui.d.a.e:
    geogebra.main.AppD app -> a
    geogebra.common.main.settings.CASSettings casSettings -> a
    javax.swing.JLabel timeoutLabel -> a
    javax.swing.JComboBox cbTimeout -> a
    javax.swing.JCheckBox cbShowRoots -> a
    javax.swing.JPanel wrappedPanel -> a
    void initGUI() -> f
    void updateGUI() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabels() -> a
    void applyModifications() -> e
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void updateFont() -> b
    void setSelected(boolean) -> a
geogebra.gui.dialog.options.OptionsDefaultsD -> geogebra.gui.d.a.f:
    geogebra.main.AppD app -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    javax.swing.JTree tree -> a
    javax.swing.tree.DefaultTreeCellRenderer treeCellRenderer -> a
    javax.swing.tree.DefaultTreeModel treeModel -> a
    javax.swing.tree.DefaultMutableTreeNode rootNode -> a
    javax.swing.tree.DefaultMutableTreeNode pointsNode -> b
    javax.swing.tree.DefaultMutableTreeNode pointsFreeNode -> c
    javax.swing.tree.DefaultMutableTreeNode pointsDepNode -> d
    javax.swing.tree.DefaultMutableTreeNode pointsPathNode -> e
    javax.swing.tree.DefaultMutableTreeNode pointsInRegionNode -> f
    javax.swing.tree.DefaultMutableTreeNode pointsComplexNode -> g
    javax.swing.tree.DefaultMutableTreeNode lineNode -> h
    javax.swing.tree.DefaultMutableTreeNode segmentNode -> i
    javax.swing.tree.DefaultMutableTreeNode vectorNode -> j
    javax.swing.tree.DefaultMutableTreeNode conicNode -> k
    javax.swing.tree.DefaultMutableTreeNode conicSectorNode -> l
    javax.swing.tree.DefaultMutableTreeNode rayNode -> m
    javax.swing.tree.DefaultMutableTreeNode numberNode -> n
    javax.swing.tree.DefaultMutableTreeNode angleNode -> o
    javax.swing.tree.DefaultMutableTreeNode functionNode -> p
    javax.swing.tree.DefaultMutableTreeNode polygonNode -> q
    javax.swing.tree.DefaultMutableTreeNode locusNode -> r
    javax.swing.tree.DefaultMutableTreeNode textNode -> s
    javax.swing.tree.DefaultMutableTreeNode imageNode -> t
    javax.swing.tree.DefaultMutableTreeNode booleanNode -> u
    javax.swing.tree.DefaultMutableTreeNode listNode -> v
    javax.swing.tree.DefaultMutableTreeNode inequalitiesNode -> w
    javax.swing.tree.DefaultMutableTreeNode functionNVarNode -> x
    javax.swing.JButton defaultsButton -> a
    geogebra.common.kernel.ConstructionDefaults defaults -> a
    javax.swing.JPanel wrappedPanel -> a
    java.util.Hashtable typeToNode -> a
    void initGUI() -> f
    void initNodes() -> g
    void createDefaultMap() -> h
    void updateGUI() -> c
    void setLabels() -> a
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void applyModifications() -> e
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void applyDefaults() -> i
    void updateFont() -> b
    void setSelected(boolean) -> a
    void access$0(geogebra.gui.dialog.options.OptionsDefaultsD) -> a
geogebra.gui.dialog.options.OptionsDefaultsD$1 -> geogebra.gui.d.a.g:
    geogebra.gui.dialog.options.OptionsDefaultsD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsDialog -> geogebra.gui.d.a.h:
    geogebra.main.AppD app -> a
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JButton saveButton -> a
    javax.swing.JButton closeButton -> b
    javax.swing.JButton restoreDefaultsButton -> c
    void setLabels() -> a
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.dialog.options.OptionsDialog$Factory -> geogebra.gui.d.a.h$a:
geogebra.gui.dialog.options.OptionsEuclidianD -> geogebra.gui.d.a.i:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    geogebra.gui.dialog.options.AxisPanel xAxisPanel -> a
    geogebra.gui.dialog.options.AxisPanel yAxisPanel -> b
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel dimPanel -> a
    javax.swing.JPanel stylePanel -> b
    javax.swing.JPanel typePanel -> c
    javax.swing.JPanel axesOptionsPanel -> d
    javax.swing.JPanel consProtocolPanel -> e
    javax.swing.JPanel miscPanel -> f
    javax.swing.JButton btBackgroundColor -> a
    javax.swing.JButton btAxesColor -> b
    javax.swing.JButton btGridColor -> c
    javax.swing.JCheckBox cbShowAxes -> a
    javax.swing.JCheckBox cbBoldAxes -> b
    javax.swing.JCheckBox cbShowGrid -> c
    javax.swing.JCheckBox cbBoldGrid -> d
    javax.swing.JCheckBox cbGridManualTick -> e
    javax.swing.JCheckBox cbShowMouseCoords -> f
    javax.swing.JCheckBox ckShowNavbar -> g
    javax.swing.JCheckBox ckNavPlay -> h
    javax.swing.JCheckBox ckOpenConsProtocol -> i
    javax.swing.JComboBox cbAxesStyle -> a
    javax.swing.JComboBox cbGridType -> b
    javax.swing.JComboBox cbGridStyle -> c
    javax.swing.JComboBox cbGridTickAngle -> d
    javax.swing.JComboBox cbTooltips -> e
    javax.swing.JTextField tfAxesRatioX -> e
    javax.swing.JTextField tfAxesRatioY -> f
    java.text.NumberFormat nfAxesRatio -> a
    geogebra.gui.NumberComboBox ncbGridTickX -> a
    geogebra.gui.NumberComboBox ncbGridTickY -> b
    javax.swing.JTextField tfMinX -> a
    javax.swing.JTextField tfMaxX -> b
    javax.swing.JTextField tfMinY -> c
    javax.swing.JTextField tfMaxY -> d
    javax.swing.JLabel[] dimLabel -> a
    javax.swing.JLabel axesRatioLabel -> a
    javax.swing.JLabel gridLabel1 -> b
    javax.swing.JLabel gridLabel2 -> c
    javax.swing.JLabel gridLabel3 -> d
    javax.swing.JLabel lblColor -> e
    javax.swing.JLabel tooltips -> f
    javax.swing.JLabel backgroundColor -> g
    javax.swing.JLabel color -> h
    javax.swing.JLabel lineStyle -> i
    boolean isIniting -> a
    javax.swing.JToggleButton cbLockRatio -> a
    javax.swing.JPanel wrappedPanel -> g
    boolean isSelected -> b
    javax.swing.Action showConsProtNavigationAction -> a
    javax.swing.Action showConsProtNavigationPlayAction -> b
    javax.swing.Action showConsProtNavigationOpenProtAction -> c
    void setView(geogebra.euclidianND.EuclidianViewND) -> a
    void initGUI() -> l
    void addTabs() -> f
    void initAxisPanels() -> g
    void initDimensionPanel() -> m
    void initAxesOptionsPanel() -> n
    void initMiscPanel() -> o
    javax.swing.JPanel buildBasicPanel() -> b
    void initGridTypePanel() -> p
    void initGridStylePanel() -> q
    javax.swing.JPanel buildGridPanel() -> c
    void updateMinMax() -> h
    void updateBounds() -> b
    void updateGUI() -> c
    void setLabels() -> a
    void setTabLabels() -> i
    void setLabelsForCbView() -> j
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    double parseDouble(java.lang.String) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setSelectedTab(int) -> a
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void applyModifications() -> e
    void updateFont() -> k
    void setSelected(boolean) -> a
    void initConsProtocolPanel() -> r
geogebra.gui.dialog.options.OptionsEuclidianD$1 -> geogebra.gui.d.a.j:
    geogebra.gui.dialog.options.OptionsEuclidianD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsEuclidianD$2 -> geogebra.gui.d.a.k:
    geogebra.gui.dialog.options.OptionsEuclidianD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsEuclidianD$3 -> geogebra.gui.d.a.l:
    geogebra.gui.dialog.options.OptionsEuclidianD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsLayoutD -> geogebra.gui.d.a.m:
    geogebra.main.AppD app -> a
    geogebra.common.main.settings.Settings settings -> a
    javax.swing.JPanel sideBarPanel -> a
    javax.swing.JPanel inputBarPanel -> b
    javax.swing.JPanel toolbarPanel -> c
    javax.swing.JPanel perspectivesPanel -> d
    javax.swing.JCheckBox ckShowInputHelp -> a
    javax.swing.JCheckBox ckIgnoreDocumentLayout -> b
    javax.swing.JCheckBox ckShowTitleBar -> c
    javax.swing.JCheckBox ckAllowStyleBar -> d
    javax.swing.JCheckBox ckShowInputBar -> e
    javax.swing.JCheckBox ckShowToolbar -> f
    javax.swing.JCheckBox ckShowToolHelp -> g
    javax.swing.JCheckBox ckShowMenuBar -> h
    javax.swing.JCheckBox ckShowSideBar -> i
    javax.swing.JToggleButton rbToolbarNorth -> a
    javax.swing.JToggleButton rbToolbarSouth -> b
    javax.swing.JToggleButton rbToolbarEast -> c
    javax.swing.JToggleButton rbToolbarWest -> d
    javax.swing.JToggleButton rbSidebarWest -> e
    javax.swing.JToggleButton rbSidebarEast -> f
    javax.swing.JRadioButton rbPespectiveSidebar -> a
    javax.swing.JRadioButton rbButtonSidebar -> b
    javax.swing.JToggleButton rbInputBarSouth -> g
    javax.swing.JToggleButton rbInputBarNorth -> h
    javax.swing.JLabel lblInputBarPosition -> a
    javax.swing.JLabel lblSidebarPosition -> b
    javax.swing.ButtonGroup inputbarPosGroup -> a
    javax.swing.ButtonGroup toolBarPosGroup -> b
    geogebra.gui.util.LayoutUtil$TitlePanel menuBarPanel -> a
    javax.swing.JPanel wrappedPanel -> e
    void initGUI() -> f
    void initPerspectivesPanel() -> g
    void initInputbarPanel() -> h
    void initSideBarPanel() -> i
    void initMenuBarPanel() -> j
    void initToolBarPanel() -> k
    void updateGUI() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setLabels() -> a
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void applyModifications() -> e
    void updateFont() -> b
    void setSelected(boolean) -> a
geogebra.gui.dialog.options.OptionsObjectD -> geogebra.gui.d.a.n:
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    geogebra.gui.color.GeoGebraColorChooser colChooser -> a
    geogebra.gui.view.algebra.AlgebraTree tree -> a
    javax.swing.JSplitPane splitPane -> a
    javax.swing.JScrollPane listScroller -> a
    javax.swing.JPanel wrappedPanel -> a
    boolean viewActive -> b
    int dividerLocation -> a
    boolean isSelected -> c
    void initGUI() -> f
    void showSliderTab() -> g
    void setLabels() -> a
    void setVisibleWithGeos(java.util.ArrayList) -> a
    void setVisible(boolean) -> b
    void setViewActive(boolean) -> c
    void setGeoTreeVisible() -> h
    void setGeoTreeNotVisible() -> i
    void updateSelection(java.util.ArrayList) -> b
    geogebra.gui.view.algebra.AlgebraTree getTree() -> a
    void updateGUI() -> c
    void updateIfInSelection(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void revalidate() -> d
    java.awt.Dimension getPreferredSize() -> a
    void setMinimumSize(java.awt.Dimension) -> a
    javax.swing.JPanel getWrappedPanel() -> a
    void applyModifications() -> e
    void updateFont() -> j
    void setSelected(boolean) -> a
geogebra.gui.dialog.options.OptionsSpreadsheetD -> geogebra.gui.d.a.o:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.JCheckBox cbShowFormulaBar -> a
    javax.swing.JCheckBox cbShowGrid -> b
    javax.swing.JCheckBox cbShowRowHeader -> c
    javax.swing.JCheckBox cbShowColumnHeader -> d
    javax.swing.JCheckBox cbShowHScrollbar -> e
    javax.swing.JCheckBox cbShowVScrollbar -> f
    javax.swing.JCheckBox cbShowBrowser -> g
    javax.swing.JCheckBox cbAllowSpecialEditor -> h
    javax.swing.JCheckBox cbAllowToolTips -> i
    javax.swing.JCheckBox cbPrependCommands -> j
    javax.swing.JCheckBox cbEnableAutoComplete -> k
    javax.swing.JTextField dirField -> a
    javax.swing.JTextField urlField -> b
    javax.swing.JButton browseButton -> a
    javax.swing.JButton restoreButton -> b
    javax.swing.JButton setCurrentButton -> c
    javax.swing.JRadioButton dirRadioButton -> a
    javax.swing.JRadioButton urlRadioButton -> b
    javax.swing.JPanel locationPanel -> a
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel wrappedPanel -> b
    geogebra.common.main.settings.SpreadsheetSettings settings() -> a
    void initGUI() -> f
    javax.swing.JPanel buildLayoutOptionsPanel() -> b
    javax.swing.JPanel buildBrowserOptionsPanel() -> c
    void setLabels() -> a
    void applyModifications() -> e
    void updateGUI() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    javax.swing.JPanel getWrappedPanel() -> a
    void revalidate() -> d
    void updateFont() -> b
    void setSelected(boolean) -> a
geogebra.gui.editor.GeoGebraContext -> geogebra.gui.e.a:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    geogebra.main.AppD app -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.GeoGebraEditorKit -> geogebra.gui.e.b:
    geogebra.gui.editor.GeoGebraContext preferences -> a
    geogebra.main.AppD app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.GeoGebraContext getStylePreferences() -> a
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.GeoGebraEditorPane -> geogebra.gui.e.c:
    javax.swing.Popup helpPopup -> a
    geogebra.main.AppD app -> a
    int rows -> a
    int cols -> b
    int rowHeight -> c
    int columnWidth -> d
    geogebra.gui.editor.Lexer lexer -> a
    boolean matchingEnable -> a
    geogebra.gui.editor.MatchingBlockManager matchLR -> a
    geogebra.gui.editor.MatchingBlockManager matchRL -> b
    java.awt.Point mousePoint -> a
    java.util.List kwListeners -> a
    int type -> e
    void setEditorKit(java.lang.String) -> a
    void setFont(java.awt.Font) -> setFont
    void updateFont(java.awt.Font) -> a
    java.awt.Dimension getPreferredSizeFromRowColumn(int,int) -> a
    void addKeywordListener(geogebra.gui.editor.KeywordListener) -> a
    void enableMatchingKeywords(boolean) -> a
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    geogebra.gui.editor.KeywordEvent getKeywordEvent(int) -> a
    void preventConcernedKeywordListener(int,java.util.EventObject,int) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
geogebra.gui.editor.GeoGebraLexer -> geogebra.gui.e.d:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    java.util.Set commands -> a
    java.util.Set variables -> b
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    java.lang.String yytext() -> a
    int yylength() -> c
    void zzScanError(int) -> b
    void yypushback(int) -> a
    int yylex() -> d
geogebra.gui.editor.GeoGebraView -> geogebra.gui.e.e:
    geogebra.gui.editor.ViewContext context -> a
    geogebra.gui.editor.Lexer lexer -> a
    boolean lexerValid -> a
    javax.swing.text.Document doc -> a
    javax.swing.text.Segment text -> a
    boolean isTabViewable -> b
    boolean isWhiteViewable -> c
    boolean enable -> d
    int tabType -> a
    java.lang.String tabCharacter -> a
    int numOfColumns -> b
    java.awt.Color lineColor -> a
    java.awt.Rectangle rect -> a
    java.util.Map desktopFontHints -> a
    boolean enableDesktopFontHints -> e
    int whiteHeight -> c
    int whiteWidth -> d
    boolean unselected -> f
    void paint(java.awt.Graphics,java.awt.Shape) -> paint
    java.awt.Shape modelToView(int,javax.swing.text.Position$Bias,int,javax.swing.text.Position$Bias,java.awt.Shape) -> modelToView
    int drawUnselectedText(java.awt.Graphics,int,int,int,int) -> drawUnselectedText
    int drawSelectedText(java.awt.Graphics,int,int,int,int) -> drawSelectedText
    void setTabRepresentation(int) -> a
    void paintTab(javax.swing.text.Segment,int,int,java.awt.Graphics,int) -> a
    void calculateHeight(java.awt.font.FontRenderContext,java.awt.Font) -> a
geogebra.gui.editor.HelpOnKeywordPanel -> geogebra.gui.e.f:
    geogebra.gui.editor.HelpOnKeywordPanel instance -> a
    javax.swing.JTextArea textarea -> a
    geogebra.gui.editor.HelpOnKeywordPanel getInstance(geogebra.main.AppD,java.lang.String) -> a
geogebra.gui.editor.JavascriptContext -> geogebra.gui.e.g:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.JavascriptEditorKit -> geogebra.gui.e.h:
    geogebra.gui.editor.JavascriptContext preferences -> a
    geogebra.main.AppD app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.JavascriptContext getStylePreferences() -> a
    javax.swing.text.Document createDefaultDocument() -> createDefaultDocument
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.JavascriptEditorKit$JavascriptDocument -> geogebra.gui.e.h$a:
    geogebra.gui.editor.GeoGebraEditorPane textcomponent -> a
    boolean isCommented(javax.swing.text.Element) -> a
    void setTextComponent(geogebra.gui.editor.GeoGebraEditorPane) -> a
    boolean isCommented(int) -> a
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void handleUpdate(javax.swing.event.DocumentEvent) -> a
    boolean handleElement(javax.swing.text.Element,boolean) -> a
geogebra.gui.editor.JavascriptLexer -> geogebra.gui.e.i:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    geogebra.gui.editor.JavascriptEditorKit$JavascriptDocument doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    void yybegin(int) -> a
    int yylength() -> c
    void zzScanError(int) -> c
    void yypushback(int) -> b
    int yylex() -> d
geogebra.gui.editor.KeywordAdapter -> geogebra.gui.e.j:
    int type -> a
    int getType() -> a
geogebra.gui.editor.KeywordAdapter$MouseOverAdapter -> geogebra.gui.e.j$a:
geogebra.gui.editor.KeywordEvent -> geogebra.gui.e.k:
    int start -> a
    int length -> b
    int type -> c
    java.util.EventObject event -> a
    int getStart() -> a
    int getLength() -> b
    int getType() -> c
geogebra.gui.editor.KeywordListener -> geogebra.gui.e.l:
    void caughtKeyword(geogebra.gui.editor.KeywordEvent) -> a
    int getType() -> a
geogebra.gui.editor.LaTeXContext -> geogebra.gui.e.m:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.LaTeXEditorKit -> geogebra.gui.e.n:
    geogebra.gui.editor.LaTeXContext preferences -> a
    geogebra.main.AppD app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.LaTeXContext getStylePreferences() -> a
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.LaTeXLexer -> geogebra.gui.e.o:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    int yylength() -> c
    void zzScanError(int) -> a
    int yylex() -> d
geogebra.gui.editor.Lexer -> geogebra.gui.e.p:
    int start -> b
    void setRange(int,int) -> a
    int yychar() -> a
    int yylength() -> c
    int scan() -> b
    int getKeyword(int,boolean) -> a
    void setDocument(javax.swing.text.Document) -> a
geogebra.gui.editor.MatchingBlockManager -> geogebra.gui.e.q:
    javax.swing.text.Document doc -> a
    geogebra.gui.editor.GeoGebraEditorPane pane -> a
    geogebra.gui.editor.MatchingBlockScanner scanner -> a
    javax.swing.text.Highlighter highlighter -> a
    geogebra.gui.editor.MatchingBlockScanner$MatchingPositions smpos -> a
    javax.swing.text.Highlighter$HighlightPainter kwPainter -> a
    javax.swing.text.Highlighter$HighlightPainter ocPainter -> b
    java.lang.Object first -> a
    java.lang.Object second -> b
    boolean insideOc -> a
    boolean insideKw -> b
    boolean ocIncluded -> c
    boolean kwIncluded -> d
    boolean lr -> e
    geogebra.gui.editor.MatchingBlockManager$MouseOverMatcher mouseover -> a
    void setPainterForOpenClose(boolean,boolean,java.awt.Color) -> a
    void setPainterForOpenClose(int,java.awt.Color) -> a
    void setPainterForOpenClose() -> a
    void setDefaults() -> b
    void activateMouseOver() -> c
    void update() -> d
    void searchMatchingBlock(int,int) -> a
    void createHighlights(geogebra.gui.editor.MatchingBlockScanner$MatchingPositions,boolean,boolean,javax.swing.text.Highlighter$HighlightPainter) -> a
    javax.swing.text.Document access$0(geogebra.gui.editor.MatchingBlockManager) -> a
    boolean access$1(geogebra.gui.editor.MatchingBlockManager) -> a
geogebra.gui.editor.MatchingBlockManager$GeoGebraKeywordsPainter -> geogebra.gui.e.q$a:
    java.awt.Color color -> a
    int type -> a
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    java.awt.Shape paintLayer(java.awt.Graphics,int,int,java.awt.Shape,javax.swing.text.JTextComponent,javax.swing.text.View) -> paintLayer
geogebra.gui.editor.MatchingBlockManager$InsideLinePainter -> geogebra.gui.e.q$b:
    boolean filled -> a
    boolean strict -> b
    java.awt.Color color -> a
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    void paint(java.awt.Graphics,int,int,java.awt.Shape,javax.swing.text.JTextComponent) -> paint
geogebra.gui.editor.MatchingBlockManager$MouseOverMatcher -> geogebra.gui.e.q$c:
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    void caughtKeyword(geogebra.gui.editor.KeywordEvent) -> a
geogebra.gui.editor.MatchingBlockManager$Parameters -> geogebra.gui.e.q$d:
    java.awt.Color color -> a
    boolean inside -> a
    boolean strict -> b
    boolean included -> c
    int type -> a
    boolean onmouseover -> d
geogebra.gui.editor.MatchingBlockScanner -> geogebra.gui.e.r:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> a
    int zzLexicalState -> b
    char[] zzBuffer -> b
    int zzMarkedPos -> c
    int zzCurrentPos -> d
    int zzStartRead -> e
    int zzEndRead -> f
    int yyline -> g
    int yychar -> h
    int yycolumn -> i
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int start -> j
    int end -> k
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    geogebra.gui.editor.MatchingBlockScanner$MatchingPositions getMatchingBlock(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    void yybegin(int) -> a
    int yylength() -> a
    void zzScanError(int) -> b
    int yylex() -> b
geogebra.gui.editor.MatchingBlockScanner$MatchingPositions -> geogebra.gui.e.r$a:
    int firstB -> a
    int firstE -> b
    int secondB -> c
    int secondE -> d
    geogebra.gui.editor.MatchingBlockScanner this$0 -> a
geogebra.gui.editor.ViewContext -> geogebra.gui.e.s:
    java.awt.Color[] tokenColors -> a
    java.awt.Font tokenFont -> a
    int[] tokenAttrib -> a
    void setTokenFont(java.awt.Font) -> a
geogebra.gui.infobar.InfoBarD -> geogebra.gui.f.a:
    java.lang.String origInfo -> a
    geogebra.common.main.App myApp -> a
    javax.swing.JFrame getFrame() -> a
    void show(java.lang.String) -> a
    void hide() -> a
geogebra.gui.inputbar.AlgebraInput -> geogebra.gui.g.a:
    geogebra.main.AppD app -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD inputField -> a
    javax.swing.JLabel inputLabel -> a
    javax.swing.JToggleButton btnHelpToggle -> a
    geogebra.gui.view.algebra.InputPanelD inputPanel -> a
    void initGUI() -> b
    boolean requestFocusInWindow() -> requestFocusInWindow
    void requestFocus() -> requestFocus
    boolean hasFocus() -> hasFocus
    void clear() -> c
    geogebra.gui.inputfield.AutoCompleteTextFieldD getTextField() -> a
    void updateOrientation(boolean) -> a
    void setLabels() -> a
    void updateFonts() -> d
    void insertCommand(java.lang.String) -> a
    void insertString(java.lang.String) -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.inputbar.AlgebraInput$1 -> geogebra.gui.g.b:
    geogebra.gui.inputbar.AlgebraInput this$0 -> a
    java.awt.Point getToolTipLocation(java.awt.event.MouseEvent) -> getToolTipLocation
geogebra.gui.inputbar.InputBarHelpPanel -> geogebra.gui.g.c:
    geogebra.main.AppD app -> a
    geogebra.gui.inputbar.InputBarHelpPanel thisPanel -> a
    java.awt.Color bgColor -> a
    java.awt.Color titleColor -> b
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree cmdTree -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree fcnTree -> b
    javax.swing.tree.DefaultMutableTreeNode functionTitleNode -> a
    javax.swing.tree.DefaultMutableTreeNode rootSubCommands -> b
    javax.swing.tree.DefaultMutableTreeNode rootAllCommands -> c
    javax.swing.tree.DefaultTreeModel cmdTreeModel -> a
    java.lang.String selectedCommand -> a
    java.lang.String rollOverCommand -> b
    java.lang.String selectedFunction -> c
    javax.swing.JPopupMenu contextMenu -> a
    javax.swing.JTextPane helpTextPane -> a
    javax.swing.JButton btnOnlineHelp -> a
    javax.swing.JButton btnRefresh -> b
    geogebra.gui.util.SelectionTable functionTable -> a
    javax.swing.JPanel tablePanel -> a
    javax.swing.JPanel syntaxHelpPanel -> b
    javax.swing.JSplitPane cmdSplitPane -> a
    javax.swing.JLabel titleLabel -> a
    javax.swing.JLabel syntaxLabel -> b
    javax.swing.JButton btnPaste -> c
    javax.swing.JScrollPane scroller -> a
    void createSyntaxPanel() -> d
    javax.swing.JPanel createButtonPanel() -> a
    void createFunctionPanel() -> e
    void setLabels() -> a
    void setLabels(boolean) -> a
    void updateFonts() -> b
    void createCommandTree() -> f
    void setCommands() -> c
    void addNodeInSortedOrder(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultMutableTreeNode) -> a
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void showSelectedSyntax() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doPaste() -> h
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    geogebra.gui.util.SelectionTable access$0(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree access$1(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$2(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> a
    void access$3(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> b
    javax.swing.JTextPane access$4(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$5(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    javax.swing.JPopupMenu access$6(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    java.awt.Color access$7(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$8(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> c
    java.lang.String access$9(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree access$10(geogebra.gui.inputbar.InputBarHelpPanel) -> b
    geogebra.gui.inputbar.InputBarHelpPanel access$11(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    javax.swing.JButton access$12(geogebra.gui.inputbar.InputBarHelpPanel) -> a
geogebra.gui.inputbar.InputBarHelpPanel$1 -> geogebra.gui.g.d:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.inputbar.InputBarHelpPanel$2 -> geogebra.gui.g.e:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.inputbar.InputBarHelpPanel$MyJTree -> geogebra.gui.g.c$a:
    int rollOverRow -> a
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
geogebra.gui.inputbar.InputBarHelpPanel$MyRenderer -> geogebra.gui.g.c$b:
    java.awt.Color selectionColor -> a
    java.awt.Color rollOverColor -> b
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener -> geogebra.gui.g.c$c:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void myPopupEvent(java.awt.event.MouseEvent) -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    geogebra.gui.inputbar.InputBarHelpPanel access$1(geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener) -> a
geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener$1 -> geogebra.gui.g.f:
    geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.inputbar.InputBarHelpPanel$TableSelectionListener -> geogebra.gui.g.c$d:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.AutoCompleteTextFieldD -> geogebra.gui.h.a:
    geogebra.main.AppD app -> a
    java.lang.StringBuilder curWord -> a
    int curWordStart -> a
    geogebra.common.util.AutoCompleteDictionary dict -> a
    boolean isCASInput -> a
    boolean autoComplete -> b
    int historyIndex -> b
    java.util.ArrayList history -> a
    boolean handleEscapeKey -> g
    java.util.List completions -> a
    java.lang.String cmdPrefix -> a
    geogebra.gui.autocompletion.CompletionsPopup completionsPopup -> a
    geogebra.gui.inputfield.HistoryPopupD historyPopup -> a
    geogebra.common.euclidian.draw.DrawTextField drawTextField -> a
    boolean isEqualsRequired -> h
    java.util.regex.Pattern syntaxArgPattern -> a
    boolean ctrlC -> c
    geogebra.common.kernel.geos.GeoTextField geoUsedForInputBox -> a
    java.util.ArrayList getHistory() -> a
    void addHistoryPopup(boolean) -> d
    void showPopupSymbolButton(boolean) -> a
    void setCASInput(boolean) -> e
    void setDictionary(geogebra.common.util.AutoCompleteDictionary) -> a
    void setAutoComplete(boolean) -> b
    java.util.List getCompletions() -> a
    boolean getAutoComplete() -> b
    java.lang.String getCurrentWord() -> a
    int getCurrentWordStart() -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setEqualsRequired(boolean) -> f
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void mergeKoreanDoubles() -> b
    void clearSelection() -> e
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void updateCurrentWord(boolean) -> g
    java.lang.String getWordAtPos(java.lang.String,int) -> a
    boolean moveToNextArgument(boolean) -> a
    java.util.List resetCompletions() -> b
    java.util.List getSyntaxes(java.util.List) -> a
    void startAutoCompletion() -> c
    void cancelAutoCompletion() -> d
    boolean validateAutoCompletion(int,java.util.List) -> a
    void addToHistory(java.lang.String) -> b
    java.lang.String getPreviousInput() -> b
    java.lang.String getNextInput() -> c
    void showCommandHelp(java.lang.String,boolean) -> a
    void showError(java.lang.Exception) -> a
    void showError(geogebra.common.main.MyError) -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setPopupsFont(java.awt.Font) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
    void addFocusListener(geogebra.common.euclidian.event.FocusListener) -> a
    void addKeyListener(geogebra.common.euclidian.event.KeyListener) -> a
    void wrapSetText(java.lang.String) -> a_
    void setUsedForInputBox(geogebra.common.kernel.geos.GeoTextField) -> a
    boolean usedForInputBox() -> a
    void requestFocus() -> requestFocus
    geogebra.gui.inputfield.HistoryPopupD access$0(geogebra.gui.inputfield.AutoCompleteTextFieldD) -> a
geogebra.gui.inputfield.AutoCompleteTextFieldD$1 -> geogebra.gui.h.b:
    geogebra.gui.inputfield.AutoCompleteTextFieldD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.inputfield.AutoCompleteTextFieldD$2 -> geogebra.gui.h.c:
    geogebra.gui.inputfield.AutoCompleteTextFieldD this$0 -> a
    java.lang.String val$s -> a
    void run() -> run
geogebra.gui.inputfield.BorderButtonD -> geogebra.gui.h.d:
    java.awt.Component borderOwner -> a
    javax.swing.ImageIcon[] icon -> a
    boolean[] isVisibleIcon -> a
    boolean[] isMouseOverIcon -> b
    java.awt.Rectangle[] iconRect -> a
    java.awt.event.ActionListener[] al -> a
    java.awt.Cursor otherCursor -> a
    boolean isMouseOverIconRegion -> a
    int maxIconCount -> a
    void paintBorder(java.awt.Component,java.awt.Graphics,int,int,int,int) -> paintBorder
    void setBorderButton(int,javax.swing.ImageIcon,java.awt.event.ActionListener) -> a
    void setIconVisible(int,boolean) -> a
    boolean isIconVisible(int) -> a
    int getTotalInsetWidth() -> a
    java.awt.Insets getBorderInsets(java.awt.Component) -> getBorderInsets
    boolean isBorderOpaque() -> isBorderOpaque
    void swapCursor() -> a
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.gui.inputfield.GeoGebraComboBoxEditor -> geogebra.gui.h.e:
    geogebra.gui.inputfield.MyTextField tf -> a
    void addActionListener(java.awt.event.ActionListener) -> addActionListener
    java.awt.Component getEditorComponent() -> getEditorComponent
    java.lang.Object getItem() -> getItem
    void removeActionListener(java.awt.event.ActionListener) -> removeActionListener
    void selectAll() -> selectAll
    void setItem(java.lang.Object) -> setItem
geogebra.gui.inputfield.HistoryPopupD -> geogebra.gui.h.f:
    geogebra.gui.inputfield.AutoCompleteTextFieldD textField -> a
    javax.swing.JPopupMenu popup -> a
    javax.swing.JList historyList -> a
    boolean isDownPopup -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    javax.swing.DefaultListModel model -> a
    void setFont(java.awt.Font) -> a
    void registerListeners() -> b
    void showPopup() -> a
    boolean isDownPopup() -> a
    void setDownPopup(boolean) -> a
    boolean isPopupVisible() -> b
    void hidePopup() -> c
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void undoPopupChange() -> d
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD access$0(geogebra.gui.inputfield.HistoryPopupD) -> a
    java.awt.event.KeyListener access$1(geogebra.gui.inputfield.HistoryPopupD) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.inputfield.HistoryPopupD) -> a
    void access$3(geogebra.gui.inputfield.HistoryPopupD,java.awt.event.KeyListener[]) -> a
    javax.swing.JList access$4(geogebra.gui.inputfield.HistoryPopupD) -> a
geogebra.gui.inputfield.HistoryPopupD$1 -> geogebra.gui.h.g:
    geogebra.gui.inputfield.HistoryPopupD this$0 -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.inputfield.HistoryPopupD$2 -> geogebra.gui.h.h:
    geogebra.gui.inputfield.HistoryPopupD this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.inputfield.HistoryPopupD$3 -> geogebra.gui.h.i:
    geogebra.gui.inputfield.HistoryPopupD this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.HistoryPopupD$HistoryListCellRenderer -> geogebra.gui.h.f$a:
    javax.swing.border.Border gridBorder -> a
    geogebra.gui.inputfield.HistoryPopupD this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.inputfield.HistoryPopupD$PopupListener -> geogebra.gui.h.f$b:
    java.awt.event.KeyListener[] listListeners -> a
    geogebra.gui.inputfield.HistoryPopupD this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
geogebra.gui.inputfield.MathTextField -> geogebra.gui.h.j:
    geogebra.gui.GeoGebraKeys ggbKeys -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.gui.inputfield.MyFormattedTextField -> geogebra.gui.h.k:
    geogebra.gui.GuiManagerD guiManager -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void insertString(java.lang.String) -> a
geogebra.gui.inputfield.MyTextField -> geogebra.gui.h.l:
    geogebra.main.AppD app -> a
    geogebra.gui.inputfield.SymbolTablePopupD tablePopup -> a
    geogebra.gui.inputfield.MyTextField thisField -> a
    javax.swing.ImageIcon icon -> a
    javax.swing.ImageIcon rollOverIcon -> b
    boolean showSymbolTableIcon -> a
    boolean caretUpdated -> d
    boolean caretShowing -> e
    geogebra.gui.inputfield.BorderButtonD borderBtn -> a
    javax.swing.border.Border defaultBorder -> a
    boolean enableColoring -> b
    java.awt.Color COLOR_MATCHED -> a
    java.awt.Color COLOR_UNMATCHED -> b
    boolean selectAllOnFocus -> f
    float pos -> a
    int caret -> a
    int scrollOffset -> b
    int width -> c
    int height -> d
    int textBottom -> e
    int fontHeight -> f
    java.awt.font.FontRenderContext frc -> a
    java.awt.Font font -> a
    java.awt.Graphics2D g2 -> a
    java.awt.Insets insets -> a
    void initField() -> b
    void enableColoring(boolean) -> c
    void setDefaultBorder() -> c
    void setBorderButton(int,javax.swing.ImageIcon,java.awt.event.ActionListener) -> a
    void setBorderButtonVisible(int,boolean) -> a
    boolean isBorderButtonVisible(int) -> a
    void setBorder(javax.swing.border.Border) -> setBorder
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void insertString(java.lang.String) -> a
    void setShowSymbolTableIcon(boolean) -> h
    void setOpenSymbolTableUpwards(boolean) -> i
    geogebra.gui.inputfield.SymbolTablePopupD getTablePopup() -> a
    void processKeyEvent(java.awt.event.KeyEvent) -> processKeyEvent
    void setLabels() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    float getLength(java.lang.String) -> a
    void drawText(java.lang.String,boolean,java.awt.Color) -> a
    void paste() -> paste
geogebra.gui.inputfield.SymbolTablePopupD -> geogebra.gui.h.m:
    geogebra.gui.inputfield.MyTextField textField -> a
    javax.swing.JPopupMenu popup -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    geogebra.gui.util.SelectionTable symbolTable -> a
    geogebra.main.AppD app -> a
    java.util.Locale locale -> a
    boolean openUpwards -> a
    void createSymbolTable() -> c
    void setLabels() -> a
    void registerListeners() -> d
    java.awt.Point getCaretPixelPosition() -> a
    void showPopup(boolean) -> a
    boolean isPopupVisible() -> a
    void hidePopup() -> e
    void setOpenUpwards(boolean) -> b
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void handlePopupSelection() -> b
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    geogebra.gui.inputfield.MyTextField access$0(geogebra.gui.inputfield.SymbolTablePopupD) -> a
    void access$1(geogebra.gui.inputfield.SymbolTablePopupD,java.awt.event.KeyListener[]) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.inputfield.SymbolTablePopupD) -> a
    java.awt.event.KeyListener access$3(geogebra.gui.inputfield.SymbolTablePopupD) -> a
geogebra.gui.inputfield.SymbolTablePopupD$1 -> geogebra.gui.h.n:
    geogebra.gui.inputfield.SymbolTablePopupD this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.SymbolTablePopupD$2 -> geogebra.gui.h.o:
    geogebra.gui.inputfield.SymbolTablePopupD this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.inputfield.SymbolTablePopupD$PopupListener -> geogebra.gui.h.m$a:
    geogebra.gui.inputfield.SymbolTablePopupD this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
geogebra.gui.layout.DnDState -> geogebra.gui.i.a:
    geogebra.gui.layout.DockPanel source -> a
    geogebra.gui.layout.DockPanel target -> b
    int region -> a
    geogebra.gui.layout.DockPanel getSource() -> a
    void setTarget(geogebra.gui.layout.DockPanel) -> a
    geogebra.gui.layout.DockPanel getTarget() -> b
    void setRegion(int) -> a
    int getRegion() -> a
    boolean isRegionOut() -> a
geogebra.gui.layout.DockBar -> geogebra.gui.i.b:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> a
    geogebra.gui.layout.PerspectivePanel popup -> a
    javax.swing.JPanel buttonPanel -> a
    javax.swing.JPanel slimSidebarPanel -> b
    geogebra.gui.layout.ViewButtonBar viewButtonBar -> a
    javax.swing.JLabel lblIcon -> a
    boolean isEastOrientation -> a
    boolean showButtonBar -> b
    geogebra.gui.layout.DockButton btnFileOpen -> a
    geogebra.gui.layout.DockButton btnFileSave -> b
    geogebra.gui.layout.DockButton btnPrint -> c
    geogebra.gui.layout.DockButton btnKeyboard -> d
    geogebra.gui.layout.DockButton btnPerspectives -> e
    geogebra.gui.layout.DockButton btnProperties -> f
    javax.swing.AbstractAction showKeyboardAction -> a
    boolean sideBarHasMouse -> c
    boolean fullScreen -> d
    void initGUI() -> h
    void registerListeners() -> i
    void buildButtonPanel() -> j
    geogebra.gui.layout.PerspectivePanel newPerspectivePanel() -> a
    javax.swing.JToolBar buildExtraButtonToolBar() -> a
    javax.swing.JPanel buildSlimSidebarPanel() -> a
    void setSidebarTriangle(boolean) -> a
    void updateLayout() -> b
    void showPopup() -> c
    void hidePopup() -> d
    void togglePopup() -> e
    void update() -> f
    void updateViewButtons() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabels() -> a
    void setSideBarHasMouse(boolean) -> b
    boolean sideBarHasMouse() -> a
    boolean isShowButtonBar() -> b
    void setShowButtonBar(boolean) -> c
    boolean isEastOrientation() -> c
    void setEastOrientation(boolean) -> d
    void initActions() -> k
    javax.swing.JPanel access$0(geogebra.gui.layout.DockBar) -> a
    void access$1(geogebra.gui.layout.DockBar,geogebra.gui.layout.PerspectivePanel) -> a
    geogebra.gui.layout.PerspectivePanel access$2(geogebra.gui.layout.DockBar) -> a
    geogebra.gui.layout.DockButton access$3(geogebra.gui.layout.DockBar) -> a
    geogebra.main.AppD access$4(geogebra.gui.layout.DockBar) -> a
geogebra.gui.layout.DockBar$1 -> geogebra.gui.i.c:
    geogebra.gui.layout.DockBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.DockBar$2 -> geogebra.gui.i.d:
    geogebra.gui.layout.DockBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.DockBar$3 -> geogebra.gui.i.e:
    geogebra.gui.layout.DockBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.DockBar$4 -> geogebra.gui.i.f:
    geogebra.gui.layout.DockBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.DockBar$5 -> geogebra.gui.i.g:
    geogebra.gui.layout.DockBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.DockBar$SidebarMouseListener -> geogebra.gui.i.b$a:
    geogebra.gui.layout.DockBar this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.layout.DockButton -> geogebra.gui.i.h:
    geogebra.main.AppD app -> a
    javax.swing.JToolTip tip -> a
    void setIcon(javax.swing.Icon) -> setIcon
    javax.swing.JToolTip createToolTip() -> createToolTip
    java.awt.Point getToolTipLocation(java.awt.event.MouseEvent) -> getToolTipLocation
geogebra.gui.layout.DockButton$ToolTipMouseAdapter -> geogebra.gui.i.h$a:
    int defaultInitialDelay -> a
    boolean preventToolTipDelay -> a
    geogebra.gui.layout.DockButton this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.layout.DockGlassPane -> geogebra.gui.i.i:
    boolean dragInProgress -> a
    java.awt.BasicStroke stroke -> a
    geogebra.gui.layout.DockManager dockManager -> a
    geogebra.gui.layout.DockPanel[] dockPanels -> a
    java.awt.Rectangle[] dockPanelsBounds -> a
    geogebra.gui.layout.DnDState dndState -> a
    java.awt.Rectangle previewRect -> a
    java.awt.Color color -> a
    java.awt.Color COLOR_DEFAULT -> b
    java.awt.Color COLOR_NOT_ENOUGH_SPACE -> c
    java.awt.Color COLOR_SAME_PLACE -> d
    void startDrag(geogebra.gui.layout.DnDState) -> a
    void stopDrag() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    void setColorEnoughHeight(geogebra.gui.layout.DockPanel) -> a
    void setColorEnoughWidth(geogebra.gui.layout.DockPanel) -> b
    void mouseDragged(java.awt.event.MouseEvent) -> a
    void eventDispatched(java.awt.AWTEvent) -> eventDispatched
geogebra.gui.layout.DockManager -> geogebra.gui.i.j:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> a
    boolean hasFullFocusSystem -> a
    geogebra.gui.layout.DockGlassPane glassPane -> a
    geogebra.gui.layout.DockSplitPane rootPane -> a
    geogebra.gui.layout.DockPanel focusedDockPanel -> a
    geogebra.gui.layout.panels.EuclidianDockPanelAbstract focusedEuclidianDockPanel -> a
    java.util.ArrayList dockPanels -> a
    geogebra.common.io.layout.Perspective restorePerspective -> a
    boolean isMaximized -> b
    java.util.List showDockPanelListener -> a
    void registerPanel(geogebra.gui.layout.DockPanel) -> a
    void applyPerspective(geogebra.common.io.layout.DockSplitPaneData[],geogebra.common.io.layout.DockPanelData[]) -> a
    void updateSplitPanesResizeWeight() -> f
    void drag(geogebra.gui.layout.DockPanel) -> b
    void drop(geogebra.gui.layout.DnDState) -> a
    void show(int) -> a
    void show(geogebra.gui.layout.DockPanel) -> c
    boolean hide(int,boolean) -> a
    boolean hide(geogebra.gui.layout.DockPanel) -> a
    void closePanel(int,boolean) -> a
    void closePanel(geogebra.gui.layout.DockPanel,boolean) -> a
    boolean containsLessThanTwoPanels() -> c
    boolean hide(geogebra.gui.layout.DockPanel,boolean) -> a
    void eventDispatched(java.awt.AWTEvent) -> eventDispatched
    void setFocusedPanel(geogebra.gui.layout.DockPanel) -> d
    void setFocusedPanel(geogebra.gui.layout.DockPanel,boolean) -> b
    boolean setFocusedPanel(int) -> a
    geogebra.gui.layout.DockPanel getFocusedPanel() -> a
    int getFocusedViewId() -> a
    geogebra.gui.layout.panels.EuclidianDockPanelAbstract getFocusedEuclidianPanel() -> a
    void moveFocus(boolean) -> a
    void markAlonePanel() -> g
    void unmarkAlonePanels() -> h
    java.util.Iterator getForwardBackwardIterator(boolean) -> a
    void setLabels() -> a
    void updateGlassPane() -> b
    void updatePanels() -> c
    void updateToolbars() -> d
    void setToolbarMode(int) -> b
    void updateFonts() -> e
    void scale(float,float) -> a
    void scale(float,float,geogebra.gui.layout.DockSplitPane) -> a
    geogebra.gui.layout.LayoutD getLayout() -> a
    geogebra.gui.layout.DockGlassPane getGlassPane() -> a
    geogebra.gui.layout.DockPanel getPanel(int) -> a
    geogebra.gui.layout.DockPanel[] getPanels() -> a
    geogebra.gui.layout.DockSplitPane getRoot() -> a
    boolean hasFullFocusSystem() -> a
    boolean isMaximized() -> b
    void undoMaximize(boolean) -> b
    void maximize(geogebra.gui.layout.DockPanel) -> e
geogebra.gui.layout.DockManager$1 -> geogebra.gui.i.k:
    geogebra.gui.layout.DockManager this$0 -> a
    java.util.ListIterator val$original -> a
    void remove() -> remove
    geogebra.gui.layout.DockPanel next() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
geogebra.gui.layout.DockPanel -> geogebra.gui.i.l:
    geogebra.gui.layout.DockManager dockManager -> a
    geogebra.main.AppD app -> a
    int id -> a
    java.lang.String title -> a
    boolean visible -> b
    boolean hasFocus -> a
    java.awt.Rectangle frameBounds -> a
    boolean openInFrame -> c
    boolean hasStyleBar -> d
    javax.swing.JComponent styleBar -> b
    javax.swing.JPanel styleBarButtonPanel -> c
    boolean showStyleBar -> e
    java.lang.String embeddedDef -> b
    int embeddedSize -> b
    javax.swing.JPanel titlePanel -> a
    javax.swing.JLabel titleLabel -> a
    javax.swing.JPanel buttonPanel -> b
    javax.swing.JButton closeButton -> a
    javax.swing.JButton windowButton -> b
    javax.swing.JButton unwindowButton -> c
    javax.swing.JButton unwindowButton2 -> d
    javax.swing.JButton toggleStyleBarButton -> e
    javax.swing.JButton toggleStyleBarButton2 -> f
    javax.swing.JButton maximizeButton -> g
    javax.swing.JPanel styleBarPanel -> d
    javax.swing.JPanel toolbarPanel -> e
    geogebra.gui.toolbar.ToolbarContainer toolbarContainer -> a
    geogebra.gui.toolbar.Toolbar toolbar -> a
    java.lang.String toolbarString -> c
    java.lang.String defaultToolbarString -> d
    java.awt.Window frame -> a
    javax.swing.JComponent component -> a
    int menuOrder -> c
    char menuShortcut -> a
    boolean isAlone -> f
    boolean isHidden -> g
    boolean isNewDialog -> h
    boolean isDialog -> i
    javax.swing.JMenuBar menubar -> a
    void setDialog(boolean) -> b
    javax.swing.ImageIcon getIcon() -> a
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent getComponent() -> c
    void focusGained() -> b
    void focusLost() -> c
    javax.swing.JComponent createFocusPanel() -> d
    void register(geogebra.gui.layout.DockManager) -> a
    void createButtons() -> u
    java.lang.String getPlainTitle() -> c
    void createFrame() -> d
    void removeFrame() -> e
    void updateTitleBar() -> f
    void setAlone(boolean) -> c
    boolean isAlone() -> b
    void setHidden(boolean) -> d
    void updatePanel() -> g
    void updateTitleBarIfNecessary() -> h
    javax.swing.JMenuBar loadMenuBar() -> a
    void updateToolbar() -> i
    void setToolbarMode(int) -> a
    void buildToolbarGui() -> j
    void updateLabels() -> k
    void updateFonts() -> l
    void updateTitle() -> m
    void closePanel(boolean) -> e
    void windowPanel() -> n
    void unwindowPanel() -> o
    void setStyleBar() -> v
    void toggleStyleBar() -> p
    void updateStyleBarVisibility() -> q
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    geogebra.gui.layout.DockSplitPane getParentSplitPane() -> a
    java.lang.String calculateEmbeddedDef() -> d
    geogebra.common.io.layout.DockPanelData createInfo() -> a
    boolean isInFrame() -> c
    void setOpenInFrame(boolean) -> f
    boolean isOpenInFrame() -> d
    void setShowStyleBar(boolean) -> g
    void updateToggleStyleBarButtons() -> w
    boolean isStyleBarVisible() -> i
    void setFrameBounds(java.awt.Rectangle) -> a
    java.awt.Rectangle getFrameBounds() -> a
    java.awt.Window getFrame() -> a
    void setEmbeddedDef(java.lang.String) -> a
    java.lang.String getEmbeddedDef() -> e
    void setEmbeddedSize(int) -> b
    int getEmbeddedSize() -> b
    boolean isVisible() -> isVisible
    void setVisible(boolean) -> setVisible
    boolean hasFocus() -> hasFocus
    void setFocus(boolean,boolean) -> a
    void setFocus(boolean) -> h
    void setActiveToolBar() -> r
    void setTitleLabelFocus() -> s
    boolean titleIsBold() -> e
    int getViewId() -> a
    java.lang.String getViewTitle() -> f
    int getMenuOrder() -> c
    boolean hasMenuShortcut() -> f
    char getMenuShortcut() -> a
    geogebra.gui.toolbar.Toolbar getToolbar() -> a
    boolean hasToolbar() -> g
    java.lang.String getToolbarString() -> a
    void setToolbarString(java.lang.String) -> b
    java.lang.String getDefaultToolbarString() -> b
    java.lang.String toString() -> toString
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    boolean isMaximized() -> h
    void toggleMaximize() -> t
    boolean updateResizeWeight() -> a
    void saveDividerLocation() -> a
    void updateDividerLocation(int,int) -> a
    void setDockPanelsVisible(boolean) -> a
    javax.swing.JButton access$0(geogebra.gui.layout.DockPanel) -> a
geogebra.gui.layout.DockPanel$1 -> geogebra.gui.i.m:
    geogebra.gui.layout.DockPanel this$0 -> a
    void setVisible(boolean) -> setVisible
geogebra.gui.layout.DockPanel$2 -> geogebra.gui.i.n:
    geogebra.gui.layout.DockPanel this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
geogebra.gui.layout.DockPanel$MenuOrderComparator -> geogebra.gui.i.l$a:
    int compare(geogebra.gui.layout.DockPanel,geogebra.gui.layout.DockPanel) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.layout.DockPanel$MyButtonHider -> geogebra.gui.i.l$b:
    geogebra.gui.layout.DockPanel this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.layout.DockSplitPane -> geogebra.gui.i.o:
    boolean dividerVisible -> a
    java.beans.PropertyChangeListener paneResizeListener -> a
    int savedDividerLocation -> a
    int savedSize -> b
    java.awt.Component getOpposite(java.awt.Component) -> a
    void setLeftComponent(java.awt.Component) -> setLeftComponent
    void setRightComponent(java.awt.Component) -> setRightComponent
    void replaceComponent(java.awt.Component,java.awt.Component) -> a
    void updateDivider() -> b
    void updateUI() -> updateUI
    void saveDividerLocation() -> a
    void updateDividerLocation(int,int) -> a
    int checkLocation(int,int) -> a
    void setDividerLocationRecursive(int,int,int) -> a
    void propagateDividerLocation(int,int,int) -> b
    boolean updateResizeWeight() -> a
    void setDockPanelsVisible(boolean) -> a
    void setLeftComponentCheckEmpty(java.awt.Component) -> a
    void setRightComponentCheckEmpty(java.awt.Component) -> b
geogebra.gui.layout.DockSplitPane$1 -> geogebra.gui.i.p:
    geogebra.gui.layout.DockSplitPane this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.layout.DockSplitPane$TreeReader -> geogebra.gui.i.o$a:
    geogebra.main.AppD app -> a
    java.util.ArrayList splitPaneInfo -> a
    int windowWidth -> a
    int windowHeight -> b
    geogebra.common.io.layout.DockSplitPaneData[] getInfo(geogebra.gui.layout.DockSplitPane) -> a
    void saveSplitPane(java.lang.String,geogebra.gui.layout.DockSplitPane) -> a
geogebra.gui.layout.LayoutD -> geogebra.gui.i.q:
    boolean isInitialized -> a
    geogebra.main.AppD app -> a
    geogebra.gui.layout.DockManager dockManager -> a
    void initialize(geogebra.main.AppD) -> a
    void registerPanel(geogebra.gui.layout.DockPanel) -> a
    void applyPerspective(geogebra.common.io.layout.Perspective) -> a
    void applyPerspective(java.lang.String) -> a
    geogebra.common.io.layout.Perspective createPerspective(java.lang.String) -> a
    geogebra.common.io.layout.Perspective[] getPerspectives() -> a
    geogebra.common.io.layout.Perspective getPerspective(int) -> a
    geogebra.common.io.layout.Perspective getPerspective(java.lang.String) -> b
    void addPerspective(geogebra.common.io.layout.Perspective) -> b
    void removePerspective(int) -> a
    void getXml(java.lang.StringBuilder,boolean) -> a
    boolean inExternalWindow(java.awt.Component) -> a
    boolean isOnlyVisible(int) -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    geogebra.main.AppD getApplication() -> a
    geogebra.gui.layout.DockManager getDockManager() -> a
    javax.swing.JComponent getRootComponent() -> a
    void showSaveDialog() -> a
    void showManageDialog() -> b
    geogebra.main.AppD access$0(geogebra.gui.layout.LayoutD) -> a
geogebra.gui.layout.LayoutD$1 -> geogebra.gui.i.r:
    geogebra.gui.layout.LayoutD this$0 -> a
    int compare(geogebra.common.io.layout.DockPanelData,geogebra.common.io.layout.DockPanelData) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.layout.LayoutD$ManagePerspectivesDialog -> geogebra.gui.i.q$a:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> b
    javax.swing.JList list -> a
    javax.swing.DefaultListModel listModel -> a
    javax.swing.JButton cancelButton -> a
    javax.swing.JButton removeButton -> b
    geogebra.gui.layout.LayoutD this$0 -> a
    void buildGUI() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateRemoveButton() -> b
geogebra.gui.layout.LayoutD$SaveInputHandler -> geogebra.gui.i.q$b:
    geogebra.gui.layout.LayoutD layout -> b
    geogebra.gui.layout.LayoutD this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.layout.PerspectivePanel -> geogebra.gui.i.s:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> a
    geogebra.gui.layout.DockBar dockBar -> a
    javax.swing.JButton btnLanguage -> a
    javax.swing.AbstractAction setLanguageAction -> a
    javax.swing.AbstractAction changePerspectiveAction -> b
    javax.swing.AbstractAction managePerspectivesAction -> c
    javax.swing.AbstractAction savePerspectiveAction -> d
    void setVisible(boolean) -> setVisible
    void superSetVisible(boolean) -> a
    void initItems() -> a
    void initActions() -> b
    geogebra.main.AppD access$0(geogebra.gui.layout.PerspectivePanel) -> a
geogebra.gui.layout.PerspectivePanel$1 -> geogebra.gui.i.t:
    geogebra.gui.layout.PerspectivePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.PerspectivePanel$2 -> geogebra.gui.i.u:
    geogebra.gui.layout.PerspectivePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.PerspectivePanel$3 -> geogebra.gui.i.v:
    geogebra.gui.layout.PerspectivePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.PerspectivePanel$4 -> geogebra.gui.i.w:
    geogebra.gui.layout.PerspectivePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.layout.ShowDockPanelListener -> geogebra.gui.i.x:
    void showDockPanel(geogebra.gui.layout.DockPanel) -> a
geogebra.gui.layout.ViewButton -> geogebra.gui.i.y:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.DockPanel panel -> a
    int viewId -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.layout.DockPanel getPanel() -> a
    int getViewId() -> a
geogebra.gui.layout.ViewButtonBar -> geogebra.gui.i.z:
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> a
    java.util.ArrayList viewButtons -> a
    void buildToolBar() -> c
    void createViewButtons() -> d
    void updateViewButtons() -> a
    void updateViewButtonVisibility() -> b
geogebra.gui.layout.panels.AlgebraDockPanel -> geogebra.gui.i.a.a:
    geogebra.main.AppD app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    void setActiveToolBar() -> r
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.CasDockPanel -> geogebra.gui.i.a.b:
    geogebra.main.AppD appCas -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    java.lang.String getDefaultToolbar() -> g
    void setActiveToolBar() -> r
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.ConstructionProtocolDockPanel -> geogebra.gui.i.a.c:
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.DataAnalysisViewDockPanel -> geogebra.gui.i.a.d:
    geogebra.main.AppD app -> b
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    java.lang.String getDefaultToolbar() -> g
geogebra.gui.layout.panels.ErrorDockPanel -> geogebra.gui.i.a.e:
    javax.swing.JComponent loadComponent() -> b
    void updatePanel() -> g
    void setFocus(boolean,boolean) -> a
geogebra.gui.layout.panels.Euclidian2DockPanel -> geogebra.gui.i.a.f:
    geogebra.main.AppD app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.EuclidianDockPanel -> geogebra.gui.i.a.g:
    geogebra.main.AppD app -> b
    javax.swing.JPanel panel -> c
    javax.swing.JComponent consProtNav -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.EuclidianDockPanelAbstract -> geogebra.gui.i.a.h:
    boolean hasEuclidianFocus -> b
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    void setEuclidianFocus(boolean) -> i
    boolean titleIsBold() -> e
    javax.swing.JComponent createFocusPanel() -> d
    boolean updateResizeWeight() -> a
geogebra.gui.layout.panels.ProbabilityCalculatorDockPanel -> geogebra.gui.i.a.i:
    geogebra.main.AppD app -> b
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
geogebra.gui.layout.panels.PropertiesDockPanel -> geogebra.gui.i.a.j:
    geogebra.main.AppD app -> b
    geogebra.gui.view.properties.PropertiesViewD view -> a
    javax.swing.JDialog dialog -> a
    void getPropertiesView() -> v
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    void updateTitleBarIfNecessary() -> h
    void windowPanel() -> n
    void unwindowPanel() -> o
    void closePanel(boolean) -> e
    javax.swing.ImageIcon getIcon() -> a
    void createFrame() -> d
    void updateLabels() -> k
    void updateTitleBar() -> f
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void closeDialog() -> u
    void setFocus(boolean,boolean) -> a
    void setVisible(boolean) -> setVisible
    void setFocus(boolean) -> h
geogebra.gui.layout.panels.SpreadsheetDockPanel -> geogebra.gui.i.a.k:
    geogebra.main.AppD app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    void focusGained() -> b
    void focusLost() -> c
    java.lang.String getDefaultToolbar() -> g
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.menubar.BaseMenu -> geogebra.gui.j.a:
    geogebra.main.AppD app -> a
    boolean initialized -> a
    void update() -> a
    void setMenuShortCutAccelerator(javax.swing.JMenuItem,char) -> a
    void setMenuShortCutShiftAccelerator(javax.swing.JMenuItem,char) -> b
    void setMenuShortCutShiftAltAccelerator(javax.swing.JMenuItem,char) -> c
    void menuDeselected(javax.swing.event.MenuEvent) -> menuDeselected
    void menuCanceled(javax.swing.event.MenuEvent) -> menuCanceled
    void menuSelected(javax.swing.event.MenuEvent) -> menuSelected
    void initActions() -> b
    void initItems() -> c
geogebra.gui.menubar.EditMenu -> geogebra.gui.j.b:
    javax.swing.AbstractAction deleteAction -> a
    javax.swing.AbstractAction invertAction -> b
    javax.swing.AbstractAction showhideAction -> c
    javax.swing.AbstractAction showhideLabelsAction -> d
    javax.swing.AbstractAction propertiesAction -> e
    javax.swing.AbstractAction selectAllAction -> f
    javax.swing.AbstractAction selectAllAncestorsAction -> g
    javax.swing.AbstractAction selectAllDescendantsAction -> h
    javax.swing.AbstractAction selectCurrentLayerAction -> i
    javax.swing.AbstractAction copyToClipboardAction -> j
    javax.swing.AbstractAction copyAction -> k
    javax.swing.AbstractAction pasteAction -> l
    javax.swing.AbstractAction insertImageFromClipboardAction -> m
    javax.swing.AbstractAction insertImageFromFileAction -> n
    javax.swing.JMenuItem deleteItem -> a
    javax.swing.JMenuItem invertItem -> b
    javax.swing.JMenuItem showhideItem -> c
    javax.swing.JMenuItem showhideLabelsItem -> d
    javax.swing.JMenuItem selectAllItem -> e
    javax.swing.JMenuItem selectAllAncestorsItem -> f
    javax.swing.JMenuItem selectAllDescendantsItem -> g
    javax.swing.JMenuItem selectCurrentLayerItem -> h
    javax.swing.JMenuItem copyToClipboardItem -> i
    javax.swing.JMenuItem copyItem -> j
    javax.swing.JMenuItem pasteItem -> k
    javax.swing.JMenuItem clipboardMenu -> l
    javax.swing.JSeparator selectionSeparator -> a
    javax.swing.JSeparator deleteSeparator -> b
    void initItems() -> c
    void initActions() -> b
    void update() -> a
    void updateSelection() -> d
    void menuSelected(javax.swing.event.MenuEvent) -> menuSelected
geogebra.gui.menubar.EditMenu$1 -> geogebra.gui.j.c:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$10 -> geogebra.gui.j.d:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$11 -> geogebra.gui.j.e:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$12 -> geogebra.gui.j.f:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$13 -> geogebra.gui.j.g:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$14 -> geogebra.gui.j.h:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$2 -> geogebra.gui.j.i:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$3 -> geogebra.gui.j.j:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$4 -> geogebra.gui.j.k:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$5 -> geogebra.gui.j.l:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$6 -> geogebra.gui.j.m:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$7 -> geogebra.gui.j.n:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$8 -> geogebra.gui.j.o:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$9 -> geogebra.gui.j.p:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu -> geogebra.gui.j.q:
    javax.swing.AbstractAction newWindowAction -> b
    javax.swing.AbstractAction deleteAll -> c
    javax.swing.AbstractAction saveAction -> d
    javax.swing.AbstractAction saveAsAction -> e
    javax.swing.AbstractAction loadAction -> f
    javax.swing.AbstractAction loadURLAction -> g
    javax.swing.AbstractAction exportWorksheet -> h
    javax.swing.AbstractAction shareAction -> i
    javax.swing.AbstractAction exportGraphicAction -> j
    javax.swing.AbstractAction exportAnimationAction -> k
    javax.swing.AbstractAction exportPgfAction -> l
    javax.swing.AbstractAction exportPSTricksAction -> m
    javax.swing.AbstractAction exportAsymptoteAction -> n
    javax.swing.AbstractAction exportGeoGebraTubeAction -> a
    javax.swing.AbstractAction drawingPadToClipboardAction -> o
    javax.swing.AbstractAction printEuclidianViewAction -> p
    javax.swing.AbstractAction exitAction -> q
    javax.swing.AbstractAction exitAllAction -> r
    void initItems() -> c
    void initActions() -> b
    void update() -> a
geogebra.gui.menubar.FileMenu$1 -> geogebra.gui.j.r:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$10 -> geogebra.gui.j.s:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$11 -> geogebra.gui.j.t:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$11) -> a
geogebra.gui.menubar.FileMenu$11$1 -> geogebra.gui.j.u:
    geogebra.gui.menubar.FileMenu$11 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$12 -> geogebra.gui.j.v:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$12) -> a
geogebra.gui.menubar.FileMenu$12$1 -> geogebra.gui.j.w:
    geogebra.gui.menubar.FileMenu$12 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$13 -> geogebra.gui.j.x:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$14 -> geogebra.gui.j.y:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$15 -> geogebra.gui.j.z:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$16 -> geogebra.gui.j.A:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$17 -> geogebra.gui.j.B:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$17) -> a
geogebra.gui.menubar.FileMenu$17$1 -> geogebra.gui.j.C:
    geogebra.gui.menubar.FileMenu$17 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$18 -> geogebra.gui.j.D:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$18) -> a
geogebra.gui.menubar.FileMenu$18$1 -> geogebra.gui.j.E:
    geogebra.gui.menubar.FileMenu$18 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$2 -> geogebra.gui.j.F:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$2) -> a
geogebra.gui.menubar.FileMenu$2$1 -> geogebra.gui.j.G:
    geogebra.gui.menubar.FileMenu$2 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$3 -> geogebra.gui.j.H:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$4 -> geogebra.gui.j.I:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$5 -> geogebra.gui.j.J:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$6 -> geogebra.gui.j.K:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$7 -> geogebra.gui.j.L:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$8 -> geogebra.gui.j.M:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$9 -> geogebra.gui.j.N:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.GeoGebraMenuBar -> geogebra.gui.j.O:
    geogebra.gui.menubar.BaseMenu fileMenu -> a
    geogebra.gui.menubar.BaseMenu editMenu -> b
    geogebra.gui.menubar.BaseMenu viewMenu -> c
    geogebra.gui.menubar.BaseMenu optionsMenu -> d
    geogebra.gui.menubar.BaseMenu toolsMenu -> e
    geogebra.gui.menubar.BaseMenu windowMenu -> f
    geogebra.gui.menubar.BaseMenu helpMenu -> g
    geogebra.main.AppD app -> a
    geogebra.gui.layout.LayoutD layout -> a
    int[] $SWITCH_TABLE$geogebra$common$main$CasType -> a
    void initMenubar() -> a
    void updateMenubar() -> b
    void updateSelection() -> c
    void updateMenuFile() -> d
    void updateMenuWindow() -> e
    void updateFonts() -> f
    void setMenuFontRecursive(javax.swing.JMenuItem,java.awt.Font) -> a
    void showPrintPreview(geogebra.main.AppD) -> a
    void showAboutDialog(geogebra.main.AppD) -> b
    void appendVersion(java.lang.StringBuilder,geogebra.main.AppD) -> a
    void copyDebugInfoToClipboard(geogebra.main.AppD) -> c
    int[] $SWITCH_TABLE$geogebra$common$main$CasType() -> a
geogebra.gui.menubar.GeoGebraMenuBar$3 -> geogebra.gui.j.P:
    geogebra.main.AppD val$app -> a
    void run() -> run
geogebra.gui.menubar.GeoGebraMenuBar$4 -> geogebra.gui.j.Q:
    geogebra.main.AppD val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu -> geogebra.gui.j.R:
    javax.swing.AbstractAction helpAction -> a
    javax.swing.AbstractAction tutorialAction -> b
    javax.swing.AbstractAction geogebratubeAction -> c
    javax.swing.AbstractAction infoAction -> d
    javax.swing.AbstractAction reportBugAction -> e
    void initItems() -> c
    void initActions() -> b
    void update() -> a
geogebra.gui.menubar.HelpMenu$1 -> geogebra.gui.j.S:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu$2 -> geogebra.gui.j.T:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu$3 -> geogebra.gui.j.U:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.LanguageActionListener -> geogebra.gui.j.V:
    geogebra.main.AppD app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.LanguageRadioButtonMenuItem -> geogebra.gui.j.W:
geogebra.gui.menubar.LoadFileListener -> geogebra.gui.j.X:
    geogebra.main.AppD app -> a
    java.io.File file -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenuD -> geogebra.gui.j.Y:
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.AbstractAction showOptionsAction -> a
    javax.swing.AbstractAction saveSettings -> b
    javax.swing.AbstractAction restoreDefaultSettings -> c
    void initItems(javax.swing.ImageIcon) -> a
    void addLanguageMenuItems(geogebra.main.AppD,javax.swing.JComponent,java.awt.event.ActionListener) -> a
    void initActions() -> b
    void update() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void initItems() -> c
    void actionPerformed(java.lang.String) -> a
geogebra.gui.menubar.OptionsMenuD$1 -> geogebra.gui.j.Z:
    geogebra.gui.menubar.OptionsMenuD this$0 -> a
    java.lang.String val$flagName -> a
    void run() -> run
geogebra.gui.menubar.OptionsMenuD$2 -> geogebra.gui.j.aa:
    geogebra.gui.menubar.OptionsMenuD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenuD$3 -> geogebra.gui.j.ab:
    geogebra.gui.menubar.OptionsMenuD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenuD$4 -> geogebra.gui.j.ac:
    geogebra.gui.menubar.OptionsMenuD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.RadioButtonMenuBarD -> geogebra.gui.j.ad:
    geogebra.main.AppD app -> a
    void addRadioButtonMenuItems(geogebra.common.gui.menubar.MyActionListener,java.lang.String[],java.lang.String[],int,boolean) -> a
    void setSelected(int) -> a
geogebra.gui.menubar.RadioButtonMenuBarD$1 -> geogebra.gui.j.ae:
    geogebra.gui.menubar.RadioButtonMenuBarD this$0 -> a
    geogebra.common.gui.menubar.MyActionListener val$alistener -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.RequestFocusListener -> geogebra.gui.j.af:
    javax.swing.JFrame frame -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu -> geogebra.gui.j.ag:
    javax.swing.AbstractAction toolbarConfigAction -> a
    javax.swing.AbstractAction showCreateToolsAction -> b
    javax.swing.AbstractAction showManageToolsAction -> c
    void updateItems() -> d
    void initActions() -> b
    void update() -> a
    void initItems() -> c
geogebra.gui.menubar.ToolsMenu$1 -> geogebra.gui.j.ah:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu$2 -> geogebra.gui.j.ai:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu$3 -> geogebra.gui.j.aj:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu -> geogebra.gui.j.ak:
    geogebra.gui.layout.LayoutD layout -> a
    javax.swing.AbstractAction showKeyboardAction -> a
    javax.swing.AbstractAction showAlgebraInputAction -> b
    javax.swing.AbstractAction refreshAction -> c
    javax.swing.AbstractAction recomputeAllViews -> d
    javax.swing.JCheckBoxMenuItem cbShowKeyboard -> a
    javax.swing.JCheckBoxMenuItem cbShowInputBar -> b
    geogebra.gui.menubar.ViewMenu$ShowViewAction[] showViews -> a
    javax.swing.JCheckBoxMenuItem[] cbViews -> a
    javax.swing.AbstractAction showLayoutOptionsAction -> e
    void initItems() -> c
    void initActions() -> b
    void update() -> a
    void initViewActions() -> d
    void initViewItems(javax.swing.JMenu) -> a
    void updateViews() -> e
geogebra.gui.menubar.ViewMenu$1 -> geogebra.gui.j.al:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$2 -> geogebra.gui.j.am:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$3 -> geogebra.gui.j.an:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$4 -> geogebra.gui.j.ao:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$5 -> geogebra.gui.j.ap:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$6 -> geogebra.gui.j.aq:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$ShowViewAction -> geogebra.gui.j.ak$a:
    geogebra.gui.layout.DockPanel panel -> a
    int viewId -> a
    javax.swing.JCheckBoxMenuItem cb -> a
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void setCheckBox(javax.swing.JCheckBoxMenuItem) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.WindowMenu -> geogebra.gui.j.ar:
    javax.swing.AbstractAction newWindowAction -> a
    void initItems() -> c
    void initActions() -> b
    void update() -> a
geogebra.gui.menubar.WindowMenu$1 -> geogebra.gui.j.as:
    geogebra.gui.menubar.WindowMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.WindowMenu access$0(geogebra.gui.menubar.WindowMenu$1) -> a
geogebra.gui.menubar.WindowMenu$1$1 -> geogebra.gui.j.at:
    geogebra.gui.menubar.WindowMenu$1 this$1 -> a
    void run() -> run
geogebra.gui.properties.AnimationSpeedPanel -> geogebra.gui.k.a:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfAnimSpeed -> a
    boolean partOfSliderPanel -> a
    javax.swing.JComboBox animationModeCB -> a
    javax.swing.JLabel modeLabel -> a
    javax.swing.JLabel speedLabel -> b
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    void setPartOfSliderPanel() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[],boolean) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> d
    void setType(int) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.properties.AnimationStepPanel -> geogebra.gui.k.b:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    geogebra.gui.AngleTextField tfAnimStep -> a
    boolean partOfSliderPanel -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    void setPartOfSliderPanel() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> d
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.properties.SliderPanel -> geogebra.gui.k.c:
    java.lang.Object[] geos -> a
    geogebra.gui.AngleTextField tfMin -> a
    geogebra.gui.AngleTextField tfMax -> b
    javax.swing.JTextField tfWidth -> a
    javax.swing.JTextField[] tfields -> a
    javax.swing.JLabel[] tLabels -> a
    javax.swing.JLabel lbWidthUnit -> a
    javax.swing.JCheckBox cbSliderFixed -> a
    javax.swing.JCheckBox cbRandom -> b
    javax.swing.JComboBox coSliderHorizontal -> a
    geogebra.main.AppD app -> a
    geogebra.gui.properties.AnimationStepPanel stepPanel -> a
    geogebra.gui.properties.AnimationSpeedPanel speedPanel -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    javax.swing.JPanel intervalPanel -> a
    javax.swing.JPanel sliderPanel -> b
    javax.swing.JPanel animationPanel -> c
    boolean useTabbedPane -> a
    boolean includeRandom -> b
    boolean actionPerforming -> c
    boolean widthUnit -> d
    void initPanels() -> c
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void setLabelForWidthUnit() -> d
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doCheckBoxActionPerformed(javax.swing.JCheckBox) -> a
    void doRandomActionPerformed(javax.swing.JCheckBox) -> b
    void doComboBoxActionPerformed(javax.swing.JComboBox) -> a
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.properties.UpdateablePropertiesPanel -> geogebra.gui.k.d:
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void setVisible(boolean) -> setVisible
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.toolbar.ModeCellRenderer -> geogebra.gui.l.a:
    geogebra.main.AppD app -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void handleRootNode(javax.swing.tree.DefaultMutableTreeNode) -> a
    void handleModeNode(int) -> a
    void handleSelection(boolean) -> a
geogebra.gui.toolbar.ModeToggleButtonGroup -> geogebra.gui.l.b:
    geogebra.common.javax.swing.GPopupMenu activePopMenu -> a
    void setActivePopupMenu(geogebra.common.javax.swing.GPopupMenu) -> a
    geogebra.common.javax.swing.GPopupMenu getActivePopupMenu() -> a
geogebra.gui.toolbar.ModeToggleMenu -> geogebra.gui.l.c:
    geogebra.gui.toolbar.ModeToggleButtonGroup bg -> a
    geogebra.gui.toolbar.MyJToggleButton tbutton -> a
    geogebra.gui.toolbar.MyJToggleButton mouseOverButton -> b
    javax.swing.JPopupMenu popMenu -> a
    java.util.ArrayList menuItemList -> a
    java.awt.event.ActionListener popupMenuItemListener -> a
    geogebra.main.AppD app -> a
    int size -> a
    geogebra.gui.toolbar.Toolbar toolbar -> a
    java.awt.Color bgColor -> a
    int getToolsCount() -> a
    javax.swing.JToggleButton getJToggleButton() -> a
    boolean selectMode(int) -> a
    int getFirstMode() -> b
    void selectItem(javax.swing.JMenuItem) -> a
    void addMode(int) -> a
    void addSeparator() -> a
    void setMouseOverButton(geogebra.gui.toolbar.MyJToggleButton) -> a
    javax.swing.JToggleButton getMouseOverButton() -> b
    void mouseOver() -> b
    void setPopupVisible(boolean) -> a
    boolean isPopupShowing() -> a
    void setMode(int) -> b
    void access$0(geogebra.gui.toolbar.ModeToggleMenu,javax.swing.JMenuItem) -> a
    geogebra.gui.toolbar.MyJToggleButton access$1(geogebra.gui.toolbar.ModeToggleMenu) -> a
geogebra.gui.toolbar.ModeToggleMenu$MenuItemListener -> geogebra.gui.l.c$a:
    geogebra.gui.toolbar.ModeToggleMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.MyJToggleButton -> geogebra.gui.l.d:
    int BORDER -> b
    int iconWidth -> c
    int iconHeight -> d
    java.awt.geom.GeneralPath gp -> a
    boolean showToolTipText -> c
    boolean popupTriangleHighlighting -> a
    boolean popupTriangleClicked -> b
    geogebra.gui.toolbar.ModeToggleMenu menu -> a
    java.awt.Color arrowColor -> a
    java.awt.Color selColor -> b
    java.awt.BasicStroke selStroke -> a
    javax.swing.Timer showMenuTimer -> a
    geogebra.gui.toolbar.Toolbar toolbar -> a
    int defaultInitialDelay -> a
    javax.swing.JToolTip tip -> a
    java.lang.String getToolTipText() -> getToolTipText
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setIcon(javax.swing.Icon) -> setIcon
    void paint(java.awt.Graphics) -> paint
    void initPath() -> a
    boolean popupTriangleClicked(int,int) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void doClick() -> doClick
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    javax.swing.JToolTip createToolTip() -> createToolTip
    java.awt.Point getToolTipLocation(java.awt.event.MouseEvent) -> getToolTipLocation
geogebra.gui.toolbar.MyJToggleButton$1 -> geogebra.gui.l.e:
    geogebra.gui.toolbar.MyJToggleButton this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.Toolbar -> geogebra.gui.l.f:
    geogebra.main.AppD app -> a
    geogebra.common.gui.layout.DockPanel dockPanel -> a
    int mode -> a
    java.util.ArrayList modeToggleMenus -> a
    void buildGui() -> a
    int setMode(int) -> a
    int getSelectedMode() -> a
    int getFirstMode() -> b
    void addCustomModesToToolbar(geogebra.gui.toolbar.ModeToggleButtonGroup) -> a
    geogebra.common.gui.layout.DockPanel getDockPanel() -> a
    java.lang.String getDefaultToolbarString() -> a
    java.lang.String getAllTools(geogebra.main.AppD) -> a
    boolean preventToolTipDelay() -> a
geogebra.gui.toolbar.ToolbarConfigDialog -> geogebra.gui.l.g:
    geogebra.main.AppD app -> a
    geogebra.gui.toolbar.ToolbarConfigPanel confPanel -> a
    void apply() -> a
    javax.swing.JPanel createButtonPanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarConfigDialog$1 -> geogebra.gui.l.h:
    geogebra.gui.toolbar.ToolbarConfigDialog this$0 -> a
    javax.swing.JButton val$btApply -> a
    javax.swing.JButton val$btCancel -> b
    javax.swing.JButton val$btDefaultToolbar -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarConfigDialog$KeyValue -> geogebra.gui.l.g$a:
    int key -> a
    java.lang.String value -> a
    geogebra.gui.toolbar.ToolbarConfigDialog this$0 -> a
    int getKey() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
geogebra.gui.toolbar.ToolbarConfigPanel -> geogebra.gui.l.i:
    geogebra.gui.layout.DockPanel dockPanel -> a
    javax.swing.JButton insertButton -> a
    javax.swing.JButton moveUpButton -> b
    javax.swing.JButton moveDownButton -> c
    javax.swing.JButton deleteButton -> d
    javax.swing.JTree tree -> a
    javax.swing.JScrollPane configScrollPane -> a
    javax.swing.JScrollPane modeScrollPane -> b
    javax.swing.JPanel selectionPanel -> a
    javax.swing.JList toolList -> a
    javax.swing.DefaultListModel toolListModel -> a
    geogebra.main.AppD app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean containsTool(javax.swing.tree.DefaultMutableTreeNode,java.lang.Integer) -> a
    void setToolbar(geogebra.gui.layout.DockPanel,java.lang.String) -> a
    void apply() -> a
    void resetDefaultToolbar() -> b
    java.lang.String getToolBarString() -> a
    void collapseAllRows() -> c
    java.util.Vector generateToolsVector(java.lang.String) -> a
    javax.swing.JTree generateTree() -> a
    javax.swing.tree.DefaultMutableTreeNode generateRootNode(java.util.Vector) -> a
    void sortToolList() -> d
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.toolbar.ToolbarConfigPanel$1 -> geogebra.gui.l.j:
    geogebra.gui.toolbar.ToolbarConfigPanel this$0 -> a
    void setExpandedState(javax.swing.tree.TreePath,boolean) -> setExpandedState
geogebra.gui.toolbar.ToolbarContainer -> geogebra.gui.l.k:
    boolean showHelp -> b
    geogebra.main.AppD app -> a
    boolean isMain -> c
    javax.swing.JPanel toolbarHelpPanel -> a
    javax.swing.JLabel modeNameLabel -> a
    geogebra.gui.toolbar.ToolbarContainer$ToolbarPanel toolbarPanel -> a
    java.util.ArrayList toolbars -> a
    int activeToolbar -> b
    int orientation -> a
    javax.swing.JPanel gluePanel -> b
    boolean showHelpBar -> a
    javax.swing.JLabel lblTest -> b
    int oldWidth -> c
    java.awt.event.MouseAdapter helpMouseAdapter -> a
    javax.swing.JPanel getToolbarHelpPanel() -> a
    void buildGui() -> a
    javax.swing.JPanel buildToolbarHelpPanel() -> b
    javax.swing.JPanel getGridButtonPanel() -> c
    int setMode(int) -> a
    void setOrientation(int) -> a
    void setActiveToolbar(geogebra.gui.toolbar.Toolbar) -> a
    void setActiveToolbar(int) -> b
    void updateToolbarPanel() -> b
    void addToolbar(geogebra.gui.toolbar.Toolbar) -> b
    void removeToolbar(geogebra.gui.toolbar.Toolbar) -> c
    geogebra.gui.toolbar.Toolbar getToolbar(int) -> a
    int getViewId(geogebra.gui.toolbar.Toolbar) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void updateHelpText() -> c
    void resolveMouseListener(int) -> c
    java.lang.String wrappedModeText(java.lang.String,java.lang.String,javax.swing.JPanel) -> a
    geogebra.gui.toolbar.Toolbar getFirstToolbar() -> a
    void setShowHelp(boolean) -> a
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    int getActiveToolbar() -> a
geogebra.gui.toolbar.ToolbarContainer$1 -> geogebra.gui.l.l:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    geogebra.gui.MySmallJButton val$btnProperties -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarContainer$2 -> geogebra.gui.l.m:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarContainer$3 -> geogebra.gui.l.n:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    java.lang.String val$modeName -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.toolbar.ToolbarContainer$PropertiesMenu -> geogebra.gui.l.k$a:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    void initMenu() -> a
    void openPropertiesView(geogebra.common.main.OptionType) -> a
geogebra.gui.toolbar.ToolbarContainer$PropertiesMenu$1 -> geogebra.gui.l.o:
    geogebra.gui.toolbar.ToolbarContainer$PropertiesMenu this$1 -> a
    geogebra.common.main.OptionType val$type -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarContainer$ToolbarPanel -> geogebra.gui.l.k$b:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    void show(java.lang.String) -> a
    void add(java.awt.Component,java.lang.String) -> a
geogebra.gui.util.AnimatedGifEncoder -> geogebra.gui.m.a:
    int width -> a
    int height -> b
    java.awt.Color transparent -> a
    int transIndex -> c
    int repeat -> d
    int delay -> e
    boolean started -> a
    java.io.OutputStream out -> a
    java.awt.image.BufferedImage image -> a
    byte[] pixels -> a
    byte[] indexedPixels -> b
    int colorDepth -> f
    byte[] colorTab -> c
    boolean[] usedEntry -> a
    int palSize -> g
    int dispose -> h
    boolean closeStream -> b
    boolean firstFrame -> c
    boolean sizeSet -> d
    int sample -> i
    void setDelay(int) -> a
    void setRepeat(int) -> b
    boolean addFrame(java.awt.image.BufferedImage) -> a
    boolean finish() -> a
    void setSize(int,int) -> a
    boolean start(java.io.OutputStream) -> a
    boolean start(java.io.File) -> a
    void analyzePixels() -> a
    int findClosest(java.awt.Color) -> a
    void getImagePixels() -> b
    void writeGraphicCtrlExt() -> c
    void writeImageDesc() -> d
    void writeLSD() -> e
    void writeNetscapeExt() -> f
    void writePalette() -> g
    void writePixels() -> h
    void writeShort(int) -> c
    void writeString(java.lang.String) -> a
geogebra.gui.util.BrowserLauncher -> geogebra.gui.m.b:
    void openURL(java.lang.String) -> a
geogebra.gui.util.FileTransferable -> geogebra.gui.m.c:
    java.awt.datatransfer.DataFlavor[] dataFlavors -> a
    java.util.List files -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.util.FullWidthLayout -> geogebra.gui.m.d:
    int vgap -> a
    int minWidth -> b
    int minHeight -> c
    int preferredWidth -> d
    int preferredHeight -> e
    boolean sizeUnknown -> a
    void calculateSizes(java.awt.Container) -> a
    java.awt.Dimension preferredLayoutSize(java.awt.Container) -> preferredLayoutSize
    java.awt.Dimension minimumLayoutSize(java.awt.Container) -> minimumLayoutSize
    void layoutContainer(java.awt.Container) -> layoutContainer
    void addLayoutComponent(java.lang.String,java.awt.Component) -> addLayoutComponent
    void removeLayoutComponent(java.awt.Component) -> removeLayoutComponent
    java.lang.String toString() -> toString
geogebra.gui.util.GeoGebraFileChooser -> geogebra.gui.m.e:
    geogebra.main.AppD app -> a
    int currentMode -> a
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel previewPanel -> a
    boolean showAccessory -> a
    int getMode() -> a
    void setMode(int) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    geogebra.main.AppD access$0(geogebra.gui.util.GeoGebraFileChooser) -> a
geogebra.gui.util.GeoGebraFileChooser$PreviewPanel -> geogebra.gui.m.e$a:
    geogebra.gui.util.GeoGebraFileChooser fileChooser -> b
    java.awt.image.BufferedImage img -> a
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel$ImagePanel imagePanel -> a
    javax.swing.JTextArea dataPreviewPanel -> a
    javax.swing.JPanel cards -> a
    java.awt.Label fileLabel -> a
    geogebra.gui.util.GeoGebraFileChooser this$0 -> a
    void setPreviewPanelType(int) -> a
    javax.swing.JScrollPane buildDataPanel() -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    void updateDataPreview(java.io.File) -> a
    void updateImage(java.io.File) -> b
    java.awt.image.BufferedImage access$0(geogebra.gui.util.GeoGebraFileChooser$PreviewPanel) -> a
    geogebra.gui.util.GeoGebraFileChooser access$1(geogebra.gui.util.GeoGebraFileChooser$PreviewPanel) -> a
geogebra.gui.util.GeoGebraFileChooser$PreviewPanel$ImagePanel -> geogebra.gui.m.e$a$a:
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel this$1 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.util.GeoGebraIcon -> geogebra.gui.m.f:
    javax.swing.ImageIcon createEmptyIcon(int,int) -> a
    javax.swing.ImageIcon createNullSymbolIcon(int,int) -> b
    javax.swing.ImageIcon createFileImageIcon(geogebra.main.AppD,java.lang.String,float,java.awt.Dimension) -> a
    javax.swing.ImageIcon createHGridIcon(java.awt.Dimension) -> a
    javax.swing.ImageIcon createVGridIcon(java.awt.Dimension) -> b
    javax.swing.ImageIcon createDownTriangleIcon(int) -> a
    javax.swing.ImageIcon createSymbolTableIcon(java.awt.Font,boolean) -> a
    void drawCenteredText(java.awt.Graphics2D,java.lang.String,int,int) -> a
    javax.swing.ImageIcon createUpDownTriangleIcon(boolean,boolean) -> a
    javax.swing.ImageIcon createColorSwatchIcon(float,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createLineStyleIcon(int,int,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createTextSymbolIcon(java.lang.String,java.awt.Font,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createCellGridIcon(java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createStringIcon(java.lang.String,java.awt.Font,boolean,boolean,boolean,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createLatexIcon(geogebra.main.AppD,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createPointStyleIcon(int,int,java.awt.Dimension,java.awt.Color,java.awt.Color) -> b
    javax.swing.ImageIcon ensureIconSize(javax.swing.ImageIcon,java.awt.Dimension) -> a
    void drawLatexImageIcon(geogebra.main.AppD,javax.swing.ImageIcon,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon joinIcons(javax.swing.ImageIcon,javax.swing.ImageIcon) -> a
geogebra.gui.util.GeoGebraIcon$PointStyleImage -> geogebra.gui.m.f$a:
    int pointStyle -> a
    int pointSize -> b
    java.awt.geom.Ellipse2D$Double circle -> a
    java.awt.geom.Line2D$Double line1 -> a
    java.awt.geom.Line2D$Double line2 -> b
    java.awt.geom.Line2D$Double line3 -> c
    java.awt.geom.Line2D$Double line4 -> d
    java.awt.geom.GeneralPath gp -> a
    java.awt.BasicStroke borderStroke -> a
    java.awt.BasicStroke[] crossStrokes -> a
    int h -> c
    int w -> d
    geogebra.gui.util.GeoGebraIcon this$0 -> a
    void drawPointStyle(java.awt.Color,java.awt.Color) -> a
    void getPath() -> a
geogebra.gui.util.HelpAction -> geogebra.gui.m.g:
    geogebra.main.AppD app -> a
    java.lang.String articleName -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.main.AppD access$0(geogebra.gui.util.HelpAction) -> a
    java.lang.String access$1(geogebra.gui.util.HelpAction) -> a
geogebra.gui.util.HelpAction$1 -> geogebra.gui.m.h:
    geogebra.gui.util.HelpAction this$0 -> a
    void run() -> run
geogebra.gui.util.IconTabbedPane -> geogebra.gui.m.i:
    void setUI(javax.swing.plaf.TabbedPaneUI) -> setUI
    void updateUI() -> updateUI
geogebra.gui.util.IconTabbedPane$IconTabbedPaneUI -> geogebra.gui.m.i$a:
    java.awt.Color bgColor -> a
    java.awt.Color bgActiveColor -> b
    java.awt.Color bgHoverColor -> c
    geogebra.gui.util.IconTabbedPane this$0 -> a
    void installDefaults() -> installDefaults
    void uninstallDefaults() -> uninstallDefaults
    void updateFont() -> a
    void paintTabBorder(java.awt.Graphics,int,int,int,int,int,int,boolean) -> paintTabBorder
    void paintTabBackground(java.awt.Graphics,int,int,int,int,int,int,boolean) -> paintTabBackground
    void setRolloverTab(int) -> setRolloverTab
    void paintTabArea(java.awt.Graphics,int,int) -> paintTabArea
    void layoutLabel(int,java.awt.FontMetrics,int,java.lang.String,javax.swing.Icon,java.awt.Rectangle,java.awt.Rectangle,java.awt.Rectangle,boolean) -> layoutLabel
    int calculateTabHeight(int,int,int) -> calculateTabHeight
    int calculateTabWidth(int,int,java.awt.FontMetrics) -> calculateTabWidth
    int getTabLabelShiftY(int,int,boolean) -> getTabLabelShiftY
    void paintContentBorderTopEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderTopEdge
    void paintFocusIndicator(java.awt.Graphics,int,java.awt.Rectangle[],int,java.awt.Rectangle,java.awt.Rectangle,boolean) -> paintFocusIndicator
    void paintContentBorderRightEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderRightEdge
    void paintContentBorderLeftEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderLeftEdge
    void paintContentBorderBottomEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderBottomEdge
geogebra.gui.util.ImageSelection -> geogebra.gui.m.j:
    java.awt.Image image -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.util.LZWEncoder -> geogebra.gui.m.k:
    int imgW -> m
    int imgH -> n
    byte[] pixAry -> b
    int initCodeSize -> o
    int remaining -> p
    int curPixel -> q
    int n_bits -> a
    int maxbits -> b
    int maxcode -> c
    int maxmaxcode -> d
    int[] htab -> a
    int[] codetab -> b
    int hsize -> e
    int free_ent -> f
    boolean clear_flg -> a
    int g_init_bits -> g
    int ClearCode -> h
    int EOFCode -> i
    int cur_accum -> j
    int cur_bits -> k
    int[] masks -> c
    int a_count -> l
    byte[] accum -> a
    void char_out(byte,java.io.OutputStream) -> a
    void cl_block(java.io.OutputStream) -> a
    void cl_hash(int) -> a
    void compress(int,java.io.OutputStream) -> a
    void encode(java.io.OutputStream) -> b
    void flush_char(java.io.OutputStream) -> c
    int MAXCODE(int) -> a
    int nextPixel() -> a
    void output(int,java.io.OutputStream) -> b
geogebra.gui.util.LatexTable -> geogebra.gui.m.l:
    geogebra.gui.dialog.TextInputDialog inputDialog -> a
    java.lang.String[] latexArray -> a
    geogebra.gui.util.PopupMenuButton popupButton -> a
    int caretPosition -> a
    int mode -> b
    java.awt.Component getComponent() -> getComponent
    javax.swing.MenuElement[] getSubElements() -> getSubElements
    void menuSelectionChanged(boolean) -> menuSelectionChanged
    void processKeyEvent(java.awt.event.KeyEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager) -> processKeyEvent
    void processMouseEvent(java.awt.event.MouseEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager) -> processMouseEvent
geogebra.gui.util.LayoutUtil -> geogebra.gui.m.m:
    int defaultHgap -> a
    int defaultVgap -> b
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
    javax.swing.JPanel flowPanel(int,java.awt.Component[]) -> a
    javax.swing.JPanel flowPanel(int,int,int,java.awt.Component[]) -> a
    javax.swing.JPanel flowPanelCenter(int,int,int,java.awt.Component[]) -> b
    javax.swing.JPanel flowPanelRight(int,int,int,java.awt.Component[]) -> c
    javax.swing.border.Border titleBorder(java.lang.String) -> a
geogebra.gui.util.LayoutUtil$TitlePanel -> geogebra.gui.m.m$a:
    void setTitle(java.lang.String) -> a
geogebra.gui.util.ListSeparatorRenderer -> geogebra.gui.m.n:
    javax.swing.JSeparator separator -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.util.MyToggleButton -> geogebra.gui.m.o:
    int myHeight -> a
    void initButton(int) -> a
    void setText(java.lang.String) -> setText
    void update(java.lang.Object[]) -> a
    void toggle() -> a
    void access$0(geogebra.gui.util.MyToggleButton) -> a
geogebra.gui.util.MyToggleButton$1 -> geogebra.gui.m.p:
    geogebra.gui.util.MyToggleButton this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.util.NeuQuant -> geogebra.gui.m.q:
    int alphadec -> a
    byte[] thepicture -> a
    int lengthcount -> b
    int samplefac -> c
    int[][] network -> a
    int[] netindex -> a
    int[] bias -> b
    int[] freq -> c
    int[] radpower -> d
    byte[] colorMap() -> a
    void inxbuild() -> a
    void learn() -> b
    int map(int,int,int) -> a
    byte[] process() -> b
    void unbiasnet() -> c
    void alterneigh(int,int,int,int,int) -> a
    void altersingle(int,int,int,int,int) -> b
    int contest(int,int,int) -> b
geogebra.gui.util.PopupMenuButton -> geogebra.gui.m.r:
    int mode -> a
    java.lang.Object[] data -> a
    geogebra.main.AppD app -> a
    geogebra.gui.util.PopupMenuButton thisButton -> a
    javax.swing.JPopupMenu myPopup -> a
    javax.swing.JSlider mySlider -> a
    java.awt.Color fgColor -> a
    int fontStyle -> b
    geogebra.gui.util.SelectionTable myTable -> a
    java.awt.Dimension iconSize -> a
    boolean hasTable -> b
    boolean keepVisible -> c
    boolean isDownwardPopup -> d
    boolean isStandardButton -> e
    boolean isFixedIcon -> f
    boolean isIniting -> g
    boolean popupIsVisible -> a
    void setFontStyle(int) -> a
    void setFgColor(java.awt.Color) -> a
    geogebra.gui.util.SelectionTable getMyTable() -> a
    void setIconSize(java.awt.Dimension) -> a
    void setDownwardPopup(boolean) -> a
    void setStandardButton(boolean) -> b
    boolean prepareToShowPopup() -> a
    void addPopupMenuItem(javax.swing.JComponent) -> a
    void removeAllMenuItems() -> b
    void setPopupMenu(javax.swing.JPopupMenu) -> a
    void processMouseEvent(java.awt.event.MouseEvent) -> processMouseEvent
    void update(java.lang.Object[]) -> a
    void updateGUI() -> a
    void initSlider() -> d
    void handlePopupActionEvent() -> c
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    int getSelectedIndex() -> a
    java.lang.Object getSelectedValue() -> a
    void setSelectedIndex(java.lang.Integer) -> a
    int getSliderValue() -> b
    void setSliderValue(int) -> b
    javax.swing.JSlider getMySlider() -> a
    void setKeepVisible(boolean) -> c
    void setToolTipArray(java.lang.String[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
    void setIcon(javax.swing.Icon) -> setIcon
    void setFixedIcon(javax.swing.Icon) -> a
    javax.swing.JPopupMenu access$0(geogebra.gui.util.PopupMenuButton) -> a
    geogebra.gui.util.PopupMenuButton access$1(geogebra.gui.util.PopupMenuButton) -> a
    boolean access$2(geogebra.gui.util.PopupMenuButton) -> a
    geogebra.gui.util.SelectionTable access$3(geogebra.gui.util.PopupMenuButton) -> a
    boolean access$4(geogebra.gui.util.PopupMenuButton) -> b
geogebra.gui.util.PopupMenuButton$1 -> geogebra.gui.m.s:
    geogebra.gui.util.PopupMenuButton this$0 -> a
    boolean val$hasTable -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.util.PopupMenuButton$2 -> geogebra.gui.m.t:
    geogebra.gui.util.PopupMenuButton this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.util.RestrictedFileSystemView -> geogebra.gui.m.u:
    java.lang.String newFolderString -> a
    java.io.File _defaultDirectory -> a
    boolean isRoot(java.io.File) -> isRoot
    java.lang.Boolean isTraversable(java.io.File) -> isTraversable
    java.lang.String getSystemDisplayName(java.io.File) -> getSystemDisplayName
    java.lang.String getSystemTypeDescription(java.io.File) -> getSystemTypeDescription
    javax.swing.Icon getSystemIcon(java.io.File) -> getSystemIcon
    boolean isParent(java.io.File,java.io.File) -> isParent
    java.io.File getChild(java.io.File,java.lang.String) -> getChild
    boolean isFileSystem(java.io.File) -> isFileSystem
    boolean isHiddenFile(java.io.File) -> isHiddenFile
    boolean isFileSystemRoot(java.io.File) -> isFileSystemRoot
    boolean isDrive(java.io.File) -> isDrive
    boolean isFloppyDrive(java.io.File) -> isFloppyDrive
    boolean isComputerNode(java.io.File) -> isComputerNode
    java.io.File[] getRoots() -> getRoots
    java.io.File getHomeDirectory() -> getHomeDirectory
    java.io.File getDefaultDirectory() -> getDefaultDirectory
    java.io.File createFileObject(java.io.File,java.lang.String) -> createFileObject
    java.io.File createFileObject(java.lang.String) -> createFileObject
    java.io.File[] getFiles(java.io.File,boolean) -> getFiles
    java.io.File getParentDirectory(java.io.File) -> getParentDirectory
    java.io.File createFileSystemRoot(java.io.File) -> createFileSystemRoot
    java.io.File createNewFolder(java.io.File) -> createNewFolder
geogebra.gui.util.RestrictedFileSystemView$FileSystemRoot -> geogebra.gui.m.u$a:
    boolean isDirectory() -> isDirectory
    java.lang.String getName() -> getName
geogebra.gui.util.SelectionTable -> geogebra.gui.m.v:
    geogebra.main.AppD app -> a
    geogebra.gui.util.SelectionTable$MyCellRenderer renderer -> a
    javax.swing.table.DefaultTableModel model -> a
    int rollOverRow -> a
    int rollOverColumn -> b
    int sliderValue -> c
    int horizontalAlignment -> d
    boolean showSelection -> b
    java.lang.Object[] data -> a
    int numRows -> e
    int numColumns -> f
    int rowHeight -> g
    int columnWidth -> h
    java.awt.Dimension iconSize -> a
    int mode -> i
    java.awt.Color fgColor -> a
    float alpha -> a
    boolean useColorSwatchBorder -> a
    java.lang.String[] toolTipArray -> a
    void setShowSelection(boolean) -> a
    void setHorizontalAlignment(int) -> a
    int getColumnWidth() -> a
    void setFgColor(java.awt.Color) -> a
    void setUseColorSwatchBorder(boolean) -> b
    void setToolTipArray(java.lang.String[]) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void populateModel(java.lang.Object[]) -> a
    javax.swing.ImageIcon[] createLatexIconArray(java.lang.String[]) -> a
    void setCellDimensions() -> b
    void updateFonts() -> a
    int getSelectedIndex() -> b
    void setSelectedIndex(int) -> b
    java.lang.Object getSelectedValue() -> a
    void setSliderValue(int) -> c
    javax.swing.ImageIcon getDataIcon(java.lang.Object) -> a
    int getMaxColumnWidth(javax.swing.JTable,int) -> a
    int getMaxRowHeight(javax.swing.JTable) -> a
    void access$0(geogebra.gui.util.SelectionTable,int) -> a
    void access$1(geogebra.gui.util.SelectionTable,int) -> b
    int access$2(geogebra.gui.util.SelectionTable) -> a
    int access$3(geogebra.gui.util.SelectionTable) -> b
    java.lang.String[] access$4(geogebra.gui.util.SelectionTable) -> a
    java.lang.Object[] access$5(geogebra.gui.util.SelectionTable) -> a
    int access$6(geogebra.gui.util.SelectionTable) -> c
    int access$7(geogebra.gui.util.SelectionTable) -> d
    geogebra.main.AppD access$8(geogebra.gui.util.SelectionTable) -> a
    boolean access$9(geogebra.gui.util.SelectionTable) -> a
geogebra.gui.util.SelectionTable$MyCellRenderer -> geogebra.gui.m.v$a:
    javax.swing.border.Border normalBorder -> a
    javax.swing.border.Border selectedBorder -> b
    javax.swing.border.Border rollOverBorder -> c
    javax.swing.border.Border paddingBorder -> d
    java.awt.Color selectionColor -> a
    java.awt.Color rollOverColor -> b
    geogebra.gui.util.SelectionTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.util.SelectionTable$RollOverListener -> geogebra.gui.m.v$b:
    geogebra.gui.util.SelectionTable this$0 -> a
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.util.SpecialNumberFormat -> geogebra.gui.m.w:
    geogebra.main.AppD app -> a
    geogebra.gui.util.SpecialNumberFormatInterface invoker -> a
    javax.swing.JMenu menuDecimalPlaces -> a
    int printFigures -> a
    int printDecimals -> b
    java.lang.String format(double) -> a
    javax.swing.JMenu createMenuDecimalPlaces() -> a
    void updateMenuDecimalPlaces() -> a
    void addRadioButtonMenuItems(javax.swing.JMenu,java.awt.event.ActionListener,java.lang.String[],java.lang.String[],int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.util.SpecialNumberFormatInterface -> geogebra.gui.m.x:
    void changedNumberFormat() -> g_
geogebra.gui.util.SpringUtilities -> geogebra.gui.m.y:
    javax.swing.SpringLayout$Constraints getConstraintsForCell(int,int,java.awt.Container,int) -> a
    void makeCompactGrid(java.awt.Container,int,int,int,int,int,int) -> a
geogebra.gui.util.TableSymbolsLaTeX -> geogebra.gui.m.z:
    java.lang.String[] miscSymbols -> a
    java.lang.String[] roots_fractions -> b
    java.lang.String[] sums -> c
    java.lang.String[] accents -> d
    java.lang.String[] accentsExtended -> e
    java.lang.String[] brackets -> f
    java.lang.String[] matrices -> g
    java.lang.String[] operators -> h
    java.lang.String[] relations -> i
    java.lang.String[] negations -> j
    java.lang.String[] arrows -> k
    java.lang.String[] mathfrak() -> a
    java.lang.String[] mathcal() -> b
    java.lang.String[] mathbb() -> c
    java.lang.String[] mathscr() -> d
geogebra.gui.util.TextLineNumber -> geogebra.gui.m.A:
    javax.swing.border.Border OUTER -> a
    javax.swing.text.JTextComponent component -> a
    boolean updateFont -> a
    int borderGap -> a
    java.awt.Color currentLineForeground -> a
    float digitAlignment -> a
    int minimumDisplayDigits -> b
    int lastDigits -> c
    int lastHeight -> d
    int lastLine -> e
    java.util.HashMap fonts -> a
    void setBorderGap(int) -> a
    java.awt.Color getCurrentLineForeground() -> a
    void setCurrentLineForeground(java.awt.Color) -> a
    void setDigitAlignment(float) -> a
    void setMinimumDisplayDigits(int) -> b
    void setPreferredWidth() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    boolean isCurrentLine(int) -> a
    java.lang.String getTextLineNumber(int) -> a
    int getOffsetX(int,int) -> a
    int getOffsetY(int,java.awt.FontMetrics) -> a
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void documentChanged() -> b
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    javax.swing.text.JTextComponent access$0(geogebra.gui.util.TextLineNumber) -> a
    int access$1(geogebra.gui.util.TextLineNumber) -> a
    void access$2(geogebra.gui.util.TextLineNumber) -> a
    void access$3(geogebra.gui.util.TextLineNumber,int) -> a
geogebra.gui.util.TextLineNumber$1 -> geogebra.gui.m.B:
    geogebra.gui.util.TextLineNumber this$0 -> a
    void run() -> run
geogebra.gui.view.CompressedAlgebraView -> geogebra.gui.n.a:
    int ups -> a
    javax.swing.Timer updateTimer -> a
    java.util.Set updateSet -> a
    java.awt.event.ActionListener updateListener -> a
    java.util.concurrent.locks.ReentrantLock lock -> a
    int rps -> b
    javax.swing.Timer repaintTimer -> b
    java.awt.event.ActionListener repaintListener -> b
    boolean needRepaint -> b
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateNow(geogebra.common.kernel.geos.GeoElement) -> g
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> b
    void repaintNow() -> c
    void repaint() -> repaint
geogebra.gui.view.CompressedRepaintListener -> geogebra.gui.n.b:
    geogebra.gui.view.CompressedView view -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.CompressedUpdateListener -> geogebra.gui.n.c:
    javax.swing.Timer updateTimer -> a
    java.util.Set updateSet -> a
    geogebra.gui.view.CompressedView view -> a
    java.util.concurrent.locks.ReentrantLock lock -> a
    boolean isWorking -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.CompressedView -> geogebra.gui.n.d:
    void updateNow(geogebra.common.kernel.geos.GeoElement) -> g
    void repaintNow() -> c
geogebra.gui.view.Gridable -> geogebra.gui.n.e:
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    geogebra.main.AppD getApplication() -> b
    java.awt.Component[][] getPrintComponents() -> a
geogebra.gui.view.algebra.AlgebraContextMenuD -> geogebra.gui.n.a.a:
    geogebra.main.AppD app -> a
    void initItems() -> a
    geogebra.main.AppD access$0(geogebra.gui.view.algebra.AlgebraContextMenuD) -> a
geogebra.gui.view.algebra.AlgebraContextMenuD$1 -> geogebra.gui.n.a.b:
    geogebra.gui.view.algebra.AlgebraContextMenuD this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraContextMenuD$2 -> geogebra.gui.n.a.c:
    geogebra.gui.view.algebra.AlgebraContextMenuD this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.algebra.AlgebraControllerD -> geogebra.gui.n.a.d:
    java.awt.dnd.DragSource ds -> a
    java.util.ArrayList geoLabelList -> a
    boolean checkDoubleClick(geogebra.common.kernel.geos.GeoElement,java.awt.event.MouseEvent) -> a
    boolean viewIsEditing() -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void setTree(geogebra.gui.view.algebra.AlgebraTree) -> a
    void enableDnD() -> a
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    void euclidianViewClick(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.kernel.geos.GeoElement,java.awt.event.MouseEvent) -> a
    void highlight(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.kernel.geos.GeoElement) -> a
    void highlight(geogebra.common.euclidian.EuclidianViewInterfaceCommon,java.util.ArrayList) -> a
    boolean leftPressCanSelectGeo(java.awt.event.MouseEvent,geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSelectionModeForClick(int) -> a
geogebra.gui.view.algebra.AlgebraControllerD$TransferableAlgebraView -> geogebra.gui.n.a.d$a:
    java.awt.datatransfer.DataFlavor algebraViewFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.util.ArrayList geoLabelList -> a
    geogebra.gui.view.algebra.AlgebraControllerD this$0 -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.view.algebra.AlgebraHelperBar -> geogebra.gui.n.a.e:
    geogebra.gui.view.algebra.AlgebraViewD algebraView -> a
    geogebra.main.AppD app -> a
    javax.swing.JButton toggleAuxiliary -> a
    geogebra.gui.util.PopupMenuButton toggleTypeTreeMode -> a
    javax.swing.JPopupMenu menu -> a
    void addButtons() -> a
    void updateStates() -> b
    void updateLabels() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void buildMenu() -> d
geogebra.gui.view.algebra.AlgebraHelperBar$1 -> geogebra.gui.n.a.f:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$2 -> geogebra.gui.n.a.g:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$3 -> geogebra.gui.n.a.h:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$4 -> geogebra.gui.n.a.i:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraInputDropTargetListener -> geogebra.gui.n.a.j:
    geogebra.main.AppD app -> a
    javax.swing.text.JTextComponent textComp -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    boolean debug -> a
    java.lang.String textImport -> a
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
geogebra.gui.view.algebra.AlgebraTree -> geogebra.gui.n.a.k:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.algebra.MyRendererForAlgebraTree renderer -> a
    geogebra.gui.view.algebra.AlgebraTreeController algebraController -> a
    javax.swing.tree.DefaultTreeModel model -> a
    javax.swing.tree.DefaultMutableTreeNode rootType -> a
    java.util.HashMap typeNodesMap -> a
    java.util.HashMap nodeTable -> b
    boolean renderLaTeX -> a
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$AlgebraView$SortMode -> a
    void initTree() -> e
    void initTreeCellRendererEditor() -> f
    geogebra.gui.view.algebra.MyRendererForAlgebraTree newMyRenderer(geogebra.main.AppD) -> a
    boolean isRenderLaTeX() -> a
    geogebra.common.gui.view.algebra.AlgebraView$SortMode getTreeMode() -> a
    void initModel() -> h
    void checkRemoveAuxiliaryNode() -> i
    void setLabels() -> a
    void setTreeLabels() -> j
    void setToolTipText(java.lang.String) -> setToolTipText
    geogebra.common.kernel.geos.GeoElement getGeoElementForLocation(javax.swing.JTree,int,int) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElementForPath(javax.swing.tree.TreePath) -> a
    java.util.ArrayList getGeoChildsForPath(javax.swing.tree.TreePath) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    boolean show(geogebra.common.kernel.geos.GeoElement) -> a
    void add(geogebra.common.kernel.geos.GeoElement,int) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void clearView() -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void clearTree() -> k
    void removeFromModel(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultTreeModel) -> a
    void removeFromModelForMode(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultTreeModel) -> b
    boolean showAuxiliaryObjects() -> b
    javax.swing.tree.DefaultMutableTreeNode getRoot() -> a
    int[][] getIndices(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    java.util.ArrayList getGeosBetween(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void addChilds(java.util.ArrayList,javax.swing.tree.DefaultMutableTreeNode,int,int) -> a
    javax.swing.tree.DefaultMutableTreeNode getParentNode(geogebra.common.kernel.geos.GeoElement,int) -> a
    int getInsertPosition(javax.swing.tree.DefaultMutableTreeNode,geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.algebra.AlgebraView$SortMode) -> a
    boolean compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.algebra.AlgebraView$SortMode) -> a
    void updateFonts() -> l
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$AlgebraView$SortMode() -> c
geogebra.gui.view.algebra.AlgebraTreeController -> geogebra.gui.n.a.l:
    geogebra.gui.view.algebra.AlgebraTree tree -> a
    void setTree(geogebra.gui.view.algebra.AlgebraTree) -> a
    boolean checkDoubleClick(geogebra.common.kernel.geos.GeoElement,java.awt.event.MouseEvent) -> a
    boolean isSelectionModeForClick(int) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void euclidianViewClick(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.kernel.geos.GeoElement,java.awt.event.MouseEvent) -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void rightPress(java.awt.event.MouseEvent,geogebra.common.awt.GPoint) -> a
    void leftPress(java.awt.event.MouseEvent) -> a
    boolean leftPressCanSelectGeo(java.awt.event.MouseEvent,geogebra.common.kernel.geos.GeoElement) -> a
    boolean setSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> a
    java.util.ArrayList groupAction(java.awt.event.MouseEvent,javax.swing.tree.TreePath,boolean) -> a
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    boolean viewIsEditing() -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void highlight(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.kernel.geos.GeoElement) -> a
    void highlight(geogebra.common.euclidian.EuclidianViewInterfaceCommon,java.util.ArrayList) -> a
geogebra.gui.view.algebra.AlgebraViewD -> geogebra.gui.n.a.m:
    geogebra.gui.view.algebra.AlgebraViewD$MyDefaultTreeCellEditor editor -> a
    geogebra.gui.inputfield.MathTextField editTF -> a
    javax.swing.tree.DefaultMutableTreeNode rootDependency -> b
    javax.swing.tree.DefaultMutableTreeNode depNode -> d
    javax.swing.tree.DefaultMutableTreeNode indNode -> e
    javax.swing.tree.DefaultMutableTreeNode auxiliaryNode -> c
    javax.swing.tree.DefaultMutableTreeNode rootOrder -> f
    javax.swing.tree.DefaultMutableTreeNode rootLayer -> g
    java.util.HashMap layerNodesMap -> c
    geogebra.common.gui.view.algebra.AlgebraView$SortMode treeMode -> a
    geogebra.common.kernel.geos.GeoElement selectedGeoElement -> a
    javax.swing.tree.DefaultMutableTreeNode selectedNode -> h
    geogebra.gui.view.algebra.AlgebraHelperBar helperBar -> a
    boolean attached -> a
    java.lang.StringBuilder sbXML -> a
    java.util.ArrayList collapsedNodes -> a
    boolean showAuxiliaryObjectsSettings -> b
    boolean settingsChanged -> c
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$AlgebraView$SortMode -> a
    void initTree() -> e
    geogebra.gui.view.algebra.MyRendererForAlgebraTree newMyRenderer(geogebra.main.AppD) -> a
    void initModel() -> h
    void checkRemoveAuxiliaryNode() -> i
    void removeAuxiliaryNode() -> m
    void attachView() -> n
    void detachView() -> o
    void updateFonts() -> l
    void initTreeCellRendererEditor() -> f
    void clearSelection() -> clearSelection
    boolean showAuxiliaryObjects() -> b
    void setShowAuxiliaryObjects(boolean) -> a
    geogebra.common.gui.view.algebra.AlgebraView$SortMode getTreeMode() -> a
    int getTreeModeValue() -> b
    void setTreeMode(int) -> a
    void setTreeMode(geogebra.common.gui.view.algebra.AlgebraView$SortMode) -> a
    geogebra.gui.view.algebra.AlgebraHelperBar getHelperBar() -> a
    geogebra.gui.view.algebra.AlgebraHelperBar newAlgebraHelperBar() -> b
    void startEditing(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setLabels() -> a
    void setTreeLabels() -> j
    javax.swing.tree.DefaultMutableTreeNode getParentNode(geogebra.common.kernel.geos.GeoElement,int) -> a
    void clearTree() -> k
    javax.swing.tree.DefaultMutableTreeNode getRoot() -> a
    java.util.ArrayList getGeosBetween(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void repaintView() -> b
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void reset() -> g
    void removeFromModelForMode(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultTreeModel) -> b
    void removeFromLayer(javax.swing.tree.DefaultTreeModel,int) -> a
    int getViewID() -> a
    geogebra.main.AppD getApplication() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    boolean show(geogebra.common.kernel.geos.GeoElement) -> a
    void updateCollapsedNodesIndices() -> c
    void getXML(java.lang.StringBuilder,boolean) -> a
    void setCollapsedNodes(int[]) -> a
    void applySettings() -> p
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    javax.swing.tree.DefaultMutableTreeNode access$1(geogebra.gui.view.algebra.AlgebraViewD) -> a
    geogebra.common.kernel.geos.GeoElement access$2(geogebra.gui.view.algebra.AlgebraViewD) -> a
    void access$3(geogebra.gui.view.algebra.AlgebraViewD,geogebra.common.kernel.geos.GeoElement) -> a
    void access$4(geogebra.gui.view.algebra.AlgebraViewD,javax.swing.tree.DefaultMutableTreeNode) -> a
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$AlgebraView$SortMode() -> c
    geogebra.gui.inputfield.MathTextField access$6(geogebra.gui.view.algebra.AlgebraViewD) -> a
geogebra.gui.view.algebra.AlgebraViewD$1 -> geogebra.gui.n.a.n:
    geogebra.gui.view.algebra.AlgebraViewD this$0 -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.view.algebra.AlgebraViewD$MyDefaultTreeCellEditor -> geogebra.gui.n.a.m$a:
    geogebra.gui.view.algebra.AlgebraViewD this$0 -> a
    void editingCanceled(javax.swing.event.ChangeEvent) -> editingCanceled
    void editingStopped(javax.swing.event.ChangeEvent) -> editingStopped
    boolean isCellEditable(java.util.EventObject) -> isCellEditable
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void storeSelection(javax.swing.tree.TreePath) -> a
    java.awt.Component getTreeCellEditorComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int) -> getTreeCellEditorComponent
geogebra.gui.view.algebra.AlgebraViewD$MyDefaultTreeCellEditor$WideEditorContainer -> geogebra.gui.n.a.m$a$a:
    javax.swing.JTree tree -> a
    javax.swing.tree.TreePath lastPath -> a
    int offset -> a
    java.awt.Component editingComponent -> a
    geogebra.gui.view.algebra.AlgebraViewD$MyDefaultTreeCellEditor this$1 -> a
    void doLayout() -> doLayout
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void updateContainer(javax.swing.JTree,javax.swing.tree.TreePath,int,java.awt.Component) -> a
geogebra.gui.view.algebra.InputPanelD -> geogebra.gui.n.a.o:
    geogebra.main.AppD app -> a
    javax.swing.text.JTextComponent textComponent -> a
    javax.swing.JPanel tfPanel -> a
    boolean showSymbolPopup -> a
    javax.swing.JScrollPane scrollPane -> a
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$DialogType -> a
    void setTextAreaLineWrap(boolean) -> a
    void setShowLineNumbering(boolean) -> b
    javax.swing.text.JTextComponent getTextComponent() -> a
    java.lang.String getText() -> a
    java.lang.String getSelectedText() -> b
    void selectText() -> a
    void setText(java.lang.String) -> b
    void insertString(java.lang.String) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void showSpecialChars(boolean) -> c
    void updateFonts() -> b
    int[] $SWITCH_TABLE$geogebra$common$gui$view$algebra$DialogType() -> a
geogebra.gui.view.algebra.MyCellEditor -> geogebra.gui.n.a.p:
    geogebra.main.AppD app -> a
    java.awt.Component getTreeCellEditorComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int) -> getTreeCellEditorComponent
geogebra.gui.view.algebra.MyComboBoxListener -> geogebra.gui.n.a.q:
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.view.algebra.MyRendererForAlgebraTree -> geogebra.gui.n.a.r:
    geogebra.main.AppD app -> a
    geogebra.gui.view.algebra.AlgebraTree view -> a
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.ImageIcon iconShown -> a
    javax.swing.ImageIcon iconHidden -> b
    javax.swing.ImageIcon latexIcon -> c
    java.lang.String latexStr -> a
    java.awt.Font latexFont -> a
    java.lang.String getDescription(geogebra.common.kernel.geos.GeoElement) -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
    java.lang.String getAlgebraDescriptionTextOrHTML(geogebra.common.kernel.geos.GeoElement) -> b
    javax.swing.ImageIcon joinIcons(javax.swing.ImageIcon,javax.swing.ImageIcon) -> a
    void setFont(java.awt.Font) -> setFont
geogebra.gui.view.algebra.MyRendererForAlgebraView -> geogebra.gui.n.a.s:
    java.lang.String getDescription(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu -> geogebra.gui.n.b.a:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView constprotView -> a
    void initItems() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$1 -> geogebra.gui.n.b.b:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$2 -> geogebra.gui.n.b.c:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$3 -> geogebra.gui.n.b.d:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation -> geogebra.gui.n.b.e:
    javax.swing.JButton btFirst -> b
    javax.swing.JButton btPrev -> c
    javax.swing.JButton btNext -> d
    javax.swing.JButton btLast -> e
    javax.swing.JButton btOpenWindow -> f
    javax.swing.JButton btPlay -> a
    javax.swing.JLabel lbSteps -> a
    javax.swing.JSpinner spDelay -> a
    double playDelay -> a
    javax.swing.JPanel playPanel -> a
    geogebra.main.AppD app -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView prot -> a
    boolean showPlayButton -> b
    boolean showConsProtButton -> c
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$AutomaticPlayer player -> a
    boolean isPlaying -> a
    boolean isPlayButtonVisible() -> a
    void setPlayButtonVisible(boolean) -> a
    boolean isConsProtButtonVisible() -> b
    void setConsProtButtonVisible(boolean) -> b
    double getPlayDelay() -> a
    void setPlayDelay(double) -> a
    void initGUI() -> b
    void setLabels() -> a
    void update() -> c
    void register(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void unregister() -> d
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setComponentsEnabled(boolean) -> c
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$1 -> geogebra.gui.n.b.f:
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$2 -> geogebra.gui.n.b.g:
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$AutomaticPlayer -> geogebra.gui.n.b.e$a:
    javax.swing.Timer timer -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void startAnimation() -> a
    void stopAnimation() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar -> geogebra.gui.n.b.h:
    geogebra.gui.view.consprotocol.ConstructionProtocolView cpView -> a
    geogebra.main.AppD app -> a
    geogebra.gui.util.PopupMenuButton btnColumns -> a
    geogebra.gui.util.PopupMenuButton btnOptions -> b
    javax.swing.JButton btnExport -> a
    javax.swing.JButton btnPrint -> b
    javax.swing.JButton btnHelp -> c
    javax.swing.JCheckBoxMenuItem miShowOnlyBreakpoints -> a
    javax.swing.JCheckBoxMenuItem miColorfulConstructionProtocol -> b
    void addButtons() -> a
    void setLabels() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$1 -> geogebra.gui.n.b.i:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$2 -> geogebra.gui.n.b.j:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$3 -> geogebra.gui.n.b.k:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$4 -> geogebra.gui.n.b.l:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5 -> geogebra.gui.n.b.m:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar access$0(geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5$1 -> geogebra.gui.n.b.n:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5 this$1 -> a
    void run() -> run
geogebra.gui.view.consprotocol.ConstructionProtocolView -> geogebra.gui.n.b.o:
    java.awt.Color COLOR_STEP_HIGHLIGHT -> a
    java.awt.Color COLOR_DRAG_HIGHLIGHT -> b
    java.awt.Color COLOR_DROP_HIGHLIGHT -> c
    javax.swing.JTable table -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData data -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.table.TableColumn[] tableColumns -> a
    boolean useColors -> a
    boolean addIcons -> b
    boolean dragging -> c
    int dragIndex -> a
    int dropIndex -> b
    boolean isViewAttached -> d
    java.util.ArrayList navigationBars -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation protNavBar -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView view -> a
    javax.swing.JScrollPane scrollPane -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar helperBar -> a
    javax.swing.AbstractAction exportHtmlAction -> a
    javax.swing.AbstractAction printPreviewAction -> b
    geogebra.main.AppD getApplication() -> a
    void registerNavigationBar(geogebra.gui.view.consprotocol.ConstructionProtocolNavigation) -> a
    void unregisterNavigationBar(geogebra.gui.view.consprotocol.ConstructionProtocolNavigation) -> b
    void updateNavigationBars() -> h
    int getLastStepNumber() -> a
    int getCurrentStepNumber() -> b
    void setConstructionStep(int) -> a
    void nextStep() -> a
    void previousStep() -> b
    void firstStep() -> c
    void lastStep() -> d
    void initGUI() -> e
    void setUseColors(boolean) -> a
    void setAddIcons(boolean) -> b
    boolean getAddIcons() -> a
    void update() -> f
    javax.swing.table.TableColumn[] getTableColumns() -> a
    boolean getUseColors() -> b
    boolean isColumnInModel(javax.swing.table.TableColumn) -> a
    void setVisible(boolean) -> setVisible
    void scrollToConstructionStep() -> g
    javax.swing.JTable getTable() -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData getData() -> a
    javax.swing.AbstractAction getExportHtmlAction() -> a
    javax.swing.AbstractAction getPrintPreviewAction() -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar getStyleBar() -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar newConstructionProtocolHelperBar() -> b
    void initActions() -> i
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    java.lang.String getHTML(java.io.File,java.lang.String) -> a
    java.lang.String getConsProtocolXML() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    void setColsVisibility(boolean[]) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$1(geogebra.gui.view.consprotocol.ConstructionProtocolView,int) -> a
    boolean access$2(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$3(geogebra.gui.view.consprotocol.ConstructionProtocolView,int) -> b
    int access$4(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    int access$5(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> b
    void access$6(geogebra.gui.view.consprotocol.ConstructionProtocolView,boolean) -> a
    boolean access$7(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> b
    java.awt.Color access$8() -> a
    java.awt.Color access$9() -> b
    java.awt.Color access$10() -> c
    javax.swing.table.TableColumn[] access$11(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    boolean access$12(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> c
    void access$13(geogebra.gui.view.consprotocol.ConstructionProtocolView,boolean) -> b
    java.util.ArrayList access$14(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$15(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$1 -> geogebra.gui.n.b.p:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$1) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$1$1 -> geogebra.gui.n.b.q:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$1 this$1 -> a
    void run() -> run
geogebra.gui.view.consprotocol.ConstructionProtocolView$2 -> geogebra.gui.n.b.r:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$2) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$2$1 -> geogebra.gui.n.b.s:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$2 this$1 -> a
    void run() -> run
    java.lang.String tableHeader(geogebra.common.kernel.Construction) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData -> geogebra.gui.n.b.o$a:
    java.lang.String title -> a
    boolean isVisible -> a
    int prefWidth -> a
    int minWidth -> b
    int alignment -> c
    boolean initShow -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.lang.String getTitle() -> a
    java.lang.String getTranslatedTitle() -> b
    int getPreferredWidth() -> a
    int getMinWidth() -> b
    int getAlignment() -> c
    boolean getInitShow() -> a
    void setVisible(boolean) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnKeeper -> geogebra.gui.n.b.o$b:
    javax.swing.table.TableColumn column -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData colData -> a
    boolean isBreakPointColumn -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionKeyListener -> geogebra.gui.n.b.o$c:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionMouseListener -> geogebra.gui.n.b.o$d:
    int minIndex -> a
    int maxIndex -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableCellEditor -> geogebra.gui.n.b.o$e:
    geogebra.gui.view.algebra.InputPanelD inputPanel -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    boolean stopCellEditing() -> stopCellEditing
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableCellRenderer -> geogebra.gui.n.b.o$f:
    javax.swing.JCheckBox cbTemp -> a
    javax.swing.JLabel iTemp -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData -> geogebra.gui.n.b.o$g:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData[] columns -> a
    java.util.ArrayList rowList -> a
    java.util.HashMap geoMap -> a
    int columnsCount -> a
    boolean notifyUpdateCalled -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    int getLastStepNumber() -> b
    int getCurrentStepNumber() -> c
    void setConstructionStepForRow(int) -> a
    boolean moveInConstructionList(int,int) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement(int) -> a
    int getConstructionIndex(int) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$RowData getRow(int) -> a
    void initView() -> a
    void notifyAddAll(int) -> b
    void attachView() -> c
    void detachView() -> e
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    int getRowCount() -> getRowCount
    int getColumnCount() -> getColumnCount
    int getColumnNumber(geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    java.awt.Color getColorAt(int,int) -> a
    java.lang.Object getValueAt(int,int) -> getValueAt
    java.lang.String getPlainHTMLAt(int,int,java.lang.String) -> a
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void clearView() -> d
    void repaintView() -> b
    void updateRowNumbers(int) -> c
    void updateIndices() -> f
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void repaint() -> repaint
    void updateAll() -> h
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void reset() -> g
    void setValueAt(java.lang.Object,int,int) -> setValueAt
    int getViewID() -> a
    boolean hasFocus() -> hasFocus
    boolean isShowing() -> isShowing
    int access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData) -> a
    void access$1(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData,int) -> a
    void access$2(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData) -> a
    void access$3(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData,int) -> b
    java.awt.Color access$4(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData,int,int) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData$ColumnMovementListener -> geogebra.gui.n.b.o$g$a:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData this$1 -> a
    void columnAdded(javax.swing.event.TableColumnModelEvent) -> columnAdded
    void columnRemoved(javax.swing.event.TableColumnModelEvent) -> columnRemoved
    void columnMarginChanged(javax.swing.event.ChangeEvent) -> columnMarginChanged
    void columnMoved(javax.swing.event.TableColumnModelEvent) -> columnMoved
    void columnSelectionChanged(javax.swing.event.ListSelectionEvent) -> columnSelectionChanged
geogebra.gui.view.consprotocol.ConstructionProtocolView$HeaderRenderer -> geogebra.gui.n.b.o$h:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$RowData -> geogebra.gui.n.b.o$i:
    int rowNumber -> a
    int index -> b
    geogebra.common.kernel.geos.GeoElement geo -> a
    javax.swing.ImageIcon toolbarIcon -> a
    java.lang.String name -> a
    java.lang.String algebra -> b
    java.lang.String definition -> c
    java.lang.String command -> d
    java.lang.String caption -> e
    boolean includesIndex -> a
    java.lang.Boolean consProtocolVisible -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void updateAlgebraAndName() -> a
    void updateCaption() -> b
    void updateAll() -> c
geogebra.gui.view.data.ANOVATable -> geogebra.gui.n.c.a:
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.util.ArrayList getCategoryData(geogebra.common.kernel.geos.GeoList) -> a
    geogebra.gui.view.data.ANOVATable$AnovaStats anovaStats(java.util.Collection) -> a
geogebra.gui.view.data.ANOVATable$AnovaStats -> geogebra.gui.n.c.a$a:
    int dfbg -> a
    int dfwg -> b
    double F -> a
    double ssbg -> b
    double sswg -> c
    double sst -> d
    double msbg -> e
    double mswg -> f
    double P -> g
    int access$0(geogebra.gui.view.data.ANOVATable$AnovaStats) -> a
    int access$1(geogebra.gui.view.data.ANOVATable$AnovaStats) -> b
    double access$2(geogebra.gui.view.data.ANOVATable$AnovaStats) -> a
    double access$3(geogebra.gui.view.data.ANOVATable$AnovaStats) -> b
    double access$4(geogebra.gui.view.data.ANOVATable$AnovaStats) -> c
    double access$5(geogebra.gui.view.data.ANOVATable$AnovaStats) -> d
    double access$6(geogebra.gui.view.data.ANOVATable$AnovaStats) -> e
    double access$7(geogebra.gui.view.data.ANOVATable$AnovaStats) -> f
    double access$8(geogebra.gui.view.data.ANOVATable$AnovaStats) -> g
geogebra.gui.view.data.BasicStatTable -> geogebra.gui.n.c.b:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.view.data.DataAnalysisViewD daView -> a
    geogebra.gui.view.data.StatTable statTable -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$BasicStatTable$Stat -> a
    void initStatTable() -> b
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.util.ArrayList getStatList() -> a
    java.lang.String getStatName(geogebra.gui.view.data.BasicStatTable$Stat) -> a
    geogebra.common.kernel.algos.AlgoElement getAlgo(geogebra.gui.view.data.BasicStatTable$Stat,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.algos.AlgoElement getAlgoRawData(geogebra.gui.view.data.BasicStatTable$Stat,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.algos.AlgoElement getAlgoFrequency(geogebra.gui.view.data.BasicStatTable$Stat,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.algos.AlgoElement getAlgoClass(geogebra.gui.view.data.BasicStatTable$Stat,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> d
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> c
    int[] $SWITCH_TABLE$geogebra$gui$view$data$BasicStatTable$Stat() -> a
geogebra.gui.view.data.BasicStatTable$Stat -> geogebra.gui.n.c.b$a:
    geogebra.gui.view.data.BasicStatTable$Stat NULL -> a
    geogebra.gui.view.data.BasicStatTable$Stat LENGTH -> b
    geogebra.gui.view.data.BasicStatTable$Stat MEAN -> c
    geogebra.gui.view.data.BasicStatTable$Stat SD -> d
    geogebra.gui.view.data.BasicStatTable$Stat SAMPLE_SD -> e
    geogebra.gui.view.data.BasicStatTable$Stat SUM -> f
    geogebra.gui.view.data.BasicStatTable$Stat SIGMAXX -> g
    geogebra.gui.view.data.BasicStatTable$Stat MIN -> h
    geogebra.gui.view.data.BasicStatTable$Stat Q1 -> i
    geogebra.gui.view.data.BasicStatTable$Stat MEDIAN -> j
    geogebra.gui.view.data.BasicStatTable$Stat Q3 -> k
    geogebra.gui.view.data.BasicStatTable$Stat MAX -> l
    geogebra.gui.view.data.BasicStatTable$Stat MEANX -> m
    geogebra.gui.view.data.BasicStatTable$Stat MEANY -> n
    geogebra.gui.view.data.BasicStatTable$Stat SX -> o
    geogebra.gui.view.data.BasicStatTable$Stat SY -> p
    geogebra.gui.view.data.BasicStatTable$Stat PMCC -> q
    geogebra.gui.view.data.BasicStatTable$Stat SPEARMAN -> r
    geogebra.gui.view.data.BasicStatTable$Stat SXX -> s
    geogebra.gui.view.data.BasicStatTable$Stat SYY -> t
    geogebra.gui.view.data.BasicStatTable$Stat SXY -> u
    geogebra.gui.view.data.BasicStatTable$Stat RSQUARE -> v
    geogebra.gui.view.data.BasicStatTable$Stat SSE -> w
    geogebra.gui.view.data.BasicStatTable$Stat[] ENUM$VALUES -> a
    geogebra.gui.view.data.BasicStatTable$Stat[] values() -> values
    geogebra.gui.view.data.BasicStatTable$Stat valueOf(java.lang.String) -> valueOf
geogebra.gui.view.data.DataAnalysisControllerD -> geogebra.gui.n.c.c:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.view.data.DataAnalysisViewD view -> a
    geogebra.gui.view.data.StatGeo statGeo -> a
    geogebra.gui.view.data.DataSource dataSource -> a
    java.util.ArrayList dataArray -> a
    geogebra.common.kernel.geos.GeoList dataSelected -> a
    boolean leftToRight -> a
    boolean isValidData -> b
    geogebra.common.kernel.geos.GeoElement geoRegression -> a
    int mode() -> a
    java.util.ArrayList getDataArray() -> a
    geogebra.common.kernel.geos.GeoList getDataSelected() -> a
    boolean isValidData() -> a
    void setValidData(boolean) -> a
    void setLeftToRight(boolean) -> b
    boolean isLeftToRight() -> b
    geogebra.common.kernel.geos.GeoElement getRegressionModel() -> a
    geogebra.gui.view.data.DataSource getDataSource() -> a
    void setDataSource(geogebra.gui.view.data.DataSource) -> a
    boolean isInDataSource(geogebra.common.kernel.geos.GeoElement) -> a
    void loadDataLists(boolean) -> c
    boolean isValidList(java.util.ArrayList) -> a
    void loadDataPanelArray() -> h
    void updateSelectedDataList(int,boolean) -> a
    java.lang.String[] getDataTitles() -> a
    void swapXY() -> a
    void updateDataAnalysisView() -> b
    void updateDataLists() -> c
    void updateAllPanels(boolean) -> d
    void handleRemovedDataGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void setRegressionGeo() -> d
    void removeRegressionGeo() -> e
    void disposeDataListSelected() -> f
    void removeStatGeos() -> g
    double[] getValueArray(geogebra.common.kernel.geos.GeoList) -> a
geogebra.gui.view.data.DataAnalysisStyleBar -> geogebra.gui.n.c.d:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD daView -> a
    int iconHeight -> a
    javax.swing.JButton btnRounding -> a
    javax.swing.JButton btnPrint -> b
    geogebra.gui.util.MyToggleButton btnShowStatistics -> a
    geogebra.gui.util.MyToggleButton btnShowPlot2 -> b
    geogebra.gui.util.MyToggleButton btnShowData -> c
    geogebra.gui.util.MyToggleButton btnDataSource -> d
    geogebra.gui.inputfield.MyTextField fldDataSource -> a
    geogebra.gui.util.MyToggleButton btnExport -> e
    geogebra.gui.util.MyToggleButton btnSwapXY -> f
    void createGUI() -> c
    void updateGUI() -> a
    javax.swing.JPanel createDataSourcePanel() -> a
    void buildRoundingButton() -> d
    void setLabels() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataAnalysisViewD -> geogebra.gui.n.c.e:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.data.StatGeo statGeo -> a
    geogebra.gui.view.data.DataAnalysisControllerD daCtrl -> a
    geogebra.gui.view.data.DataAnalysisStyleBar stylebar -> a
    int mode -> a
    boolean showDataPanel -> b
    boolean showStatPanel -> c
    boolean showDataDisplayPanel2 -> d
    boolean isIniting -> a
    java.awt.Color TABLE_GRID_COLOR -> a
    java.awt.Color TABLE_HEADER_COLOR -> b
    java.awt.Color HISTOGRAM_COLOR -> c
    java.awt.Color BOXPLOT_COLOR -> d
    java.awt.Color BARCHART_COLOR -> e
    java.awt.Color DOTPLOT_COLOR -> f
    java.awt.Color NQPLOT_COLOR -> g
    java.awt.Color REGRESSION_COLOR -> h
    java.awt.Color OVERLAY_COLOR -> i
    int printDecimals -> b
    int printFigures -> c
    geogebra.gui.view.data.DataAnalysisViewD$Regression regressionMode -> a
    int regressionOrder -> d
    geogebra.gui.view.data.DataPanel dataPanel -> a
    geogebra.gui.view.data.StatisticsPanel statisticsPanel -> a
    geogebra.gui.view.data.RegressionPanel regressionPanel -> a
    geogebra.gui.view.data.DataDisplayPanel dataDisplayPanel1 -> a
    geogebra.gui.view.data.DataDisplayPanel dataDisplayPanel2 -> b
    javax.swing.JSplitPane statDataPanel -> a
    javax.swing.JSplitPane displayPanel -> b
    javax.swing.JSplitPane comboPanelSplit -> c
    javax.swing.JPanel mainPanel -> a
    int defaultDividerSize -> e
    void setView(geogebra.gui.view.data.DataSource,int,boolean) -> a
    javax.swing.JComponent getStyleBar() -> a
    void buildStatisticsPanel() -> m
    void setDataPlotPanels() -> a
    geogebra.gui.view.data.DataPanel buildDataPanel() -> a
    void loadDataTable(java.util.ArrayList) -> a
    geogebra.gui.view.data.DataPanel getDataPanel() -> b
    void updateLayout() -> n
    void showMainPanel() -> c
    geogebra.gui.view.data.DataAnalysisControllerD getDaCtrl() -> a
    geogebra.gui.view.data.DataSource getDataSource() -> a
    geogebra.gui.view.data.DataVariable$GroupType groupType() -> a
    geogebra.gui.view.data.DataDisplayPanel getDataDisplayPanel1() -> a
    geogebra.gui.view.data.DataDisplayPanel getDataDisplayPanel2() -> b
    geogebra.gui.view.data.RegressionPanel getRegressionPanel() -> a
    geogebra.gui.view.data.StatisticsPanel getStatisticsPanel() -> a
    javax.swing.JComponent getDataAnalysisViewComponent() -> b
    boolean showDataDisplayPanel2() -> a
    boolean showDataPanel() -> b
    void setShowDataPanel(boolean) -> a
    void setShowStatistics(boolean) -> b
    boolean showStatPanel() -> c
    geogebra.gui.view.data.DataAnalysisControllerD getController() -> b
    geogebra.common.kernel.geos.GeoElement getRegressionModel() -> a
    geogebra.gui.view.data.StatGeo getStatGeo() -> a
    int getRegressionOrder() -> b
    void setRegressionMode(int) -> a
    geogebra.gui.view.data.DataAnalysisViewD$Regression getRegressionMode() -> a
    void setRegressionOrder(int) -> b
    geogebra.main.AppD getApp() -> a
    int getMode() -> c
    void setShowDataOptionsDialog(boolean) -> c
    boolean isNumericData() -> d
    void setShowComboPanel2(boolean) -> d
    void updateStatDataPanelVisibility() -> e
    void doPrint() -> f
    void updateGUI() -> h
    void updateFonts() -> i
    void setFontRecursive(java.awt.Container,java.awt.Font) -> a
    void setLabels() -> j
    void setLabelsRecursive(java.awt.Container) -> a
    java.lang.String format(double) -> a
    void updateRounding() -> o
    int getPrintDecimals() -> d
    int getPrintFigures() -> e
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void clearView() -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void repaintView() -> b
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void reset() -> g
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void attachView() -> k
    void detachView() -> l
    java.lang.String[] getDataTitles() -> a
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void paint(java.awt.Graphics,double) -> a
    int getViewID() -> a
    javax.swing.JPopupMenu getExportMenu() -> a
geogebra.gui.view.data.DataAnalysisViewD$1 -> geogebra.gui.n.c.f:
    geogebra.gui.view.data.DataAnalysisViewD this$0 -> a
    void run() -> run
geogebra.gui.view.data.DataAnalysisViewD$Regression -> geogebra.gui.n.c.e$a:
    geogebra.gui.view.data.DataAnalysisViewD$Regression NONE -> a
    geogebra.gui.view.data.DataAnalysisViewD$Regression LINEAR -> b
    geogebra.gui.view.data.DataAnalysisViewD$Regression LOG -> c
    geogebra.gui.view.data.DataAnalysisViewD$Regression POLY -> d
    geogebra.gui.view.data.DataAnalysisViewD$Regression POW -> e
    geogebra.gui.view.data.DataAnalysisViewD$Regression EXP -> f
    geogebra.gui.view.data.DataAnalysisViewD$Regression GROWTH -> g
    geogebra.gui.view.data.DataAnalysisViewD$Regression SIN -> h
    geogebra.gui.view.data.DataAnalysisViewD$Regression LOGISTIC -> i
    java.lang.String label -> a
    geogebra.gui.view.data.DataAnalysisViewD$Regression[] ENUM$VALUES -> a
    java.lang.String getLabel() -> a
    geogebra.gui.view.data.DataAnalysisViewD$Regression[] values() -> values
    geogebra.gui.view.data.DataAnalysisViewD$Regression valueOf(java.lang.String) -> valueOf
geogebra.gui.view.data.DataDisplayPanel -> geogebra.gui.n.c.g:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD daView -> a
    geogebra.gui.view.data.StatGeo statGeo -> a
    int mode -> a
    geogebra.gui.view.data.DataDisplayPanel$PlotType selectedPlot -> a
    geogebra.gui.view.data.StatPanelSettings settings -> a
    java.util.ArrayList plotGeoList -> a
    geogebra.common.kernel.geos.GeoElement[] boxPlotTitles -> a
    geogebra.common.kernel.geos.GeoElement histogram -> a
    geogebra.common.kernel.geos.GeoElement dotPlot -> b
    geogebra.common.kernel.geos.GeoElement frequencyPolygon -> c
    geogebra.common.kernel.geos.GeoElement normalCurve -> d
    geogebra.common.kernel.geos.GeoElement scatterPlot -> e
    geogebra.common.kernel.geos.GeoElement scatterPlotLine -> f
    geogebra.common.kernel.geos.GeoElement residualPlot -> g
    geogebra.common.kernel.geos.GeoElement nqPlot -> h
    geogebra.common.kernel.geos.GeoElement boxPlot -> i
    geogebra.common.kernel.geos.GeoElement barChart -> j
    geogebra.common.kernel.geos.GeoElement freqTableGeo -> k
    javax.swing.JPanel displayCardPanel -> a
    javax.swing.JPanel metaPlotPanel -> b
    javax.swing.JPanel plotPanelNorth -> c
    javax.swing.JPanel plotPanelSouth -> d
    geogebra.gui.view.data.PlotPanelEuclidianView plotPanel -> a
    javax.swing.JLabel imageContainer -> a
    javax.swing.JPanel controlPanel -> e
    javax.swing.JPanel controlCards -> f
    boolean hasControlPanel -> a
    javax.swing.JComboBox cbDisplayType -> a
    geogebra.gui.view.data.OptionsPanel optionsPanel -> a
    javax.swing.JToggleButton btnOptions -> a
    javax.swing.JPanel numClassesPanel -> g
    javax.swing.JSlider sliderNumClasses -> a
    javax.swing.JToolBar manualClassesPanel -> a
    javax.swing.JLabel lblStart -> b
    javax.swing.JLabel lblWidth -> c
    geogebra.gui.inputfield.AutoCompleteTextFieldD fldStart -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD fldWidth -> b
    javax.swing.JToolBar stemAdjustPanel -> b
    javax.swing.JLabel lblAdjust -> d
    javax.swing.JButton minus -> a
    javax.swing.JButton none -> b
    javax.swing.JButton plus -> c
    javax.swing.JPanel imagePanel -> h
    javax.swing.JLabel lblTitleX -> e
    javax.swing.JLabel lblTitleY -> f
    geogebra.gui.inputfield.MyTextField fldTitleX -> a
    geogebra.gui.inputfield.MyTextField fldTitleY -> b
    geogebra.gui.view.data.FrequencyTablePanel frequencyTable -> a
    javax.swing.JToggleButton btnExport -> b
    javax.swing.JTextField fldNumClasses -> a
    javax.swing.AbstractAction exportToEVAction -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType -> a
    void setPanel(geogebra.gui.view.data.DataDisplayPanel$PlotType,int) -> a
    void createGUI() -> f
    void setLabels() -> c
    void createDisplayTypeComboBox() -> g
    void updatePlotPanelLayout() -> h
    void createImagePanel() -> i
    void createNumClassesPanel() -> j
    void createStemPlotAdjustmentPanel() -> k
    void createManualClassesPanel() -> l
    javax.swing.JPopupMenu getExportMenu() -> a
    void updatePlot(boolean) -> a
    void showInvalidDataDisplay() -> m
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(java.lang.Object) -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void clearPlotGeoList() -> a
    void removeGeos() -> b
    void detachView() -> d
    void attachView() -> e
    javax.swing.JPanel flowPanel(javax.swing.JComponent[]) -> a
    javax.swing.JPanel flowPanelRight(javax.swing.JComponent[]) -> b
    void updateFonts(java.awt.Font) -> a
    void exportGeosToEV(int) -> a
    void prepareGeoForEV(geogebra.common.kernel.geos.GeoElement,int) -> a
    geogebra.main.AppD access$0(geogebra.gui.view.data.DataDisplayPanel) -> a
    geogebra.gui.view.data.StatPanelSettings access$1(geogebra.gui.view.data.DataDisplayPanel) -> a
    javax.swing.JTextField access$2(geogebra.gui.view.data.DataDisplayPanel) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType() -> a
geogebra.gui.view.data.DataDisplayPanel$1 -> geogebra.gui.n.c.h:
    geogebra.gui.view.data.DataDisplayPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataDisplayPanel$2 -> geogebra.gui.n.c.i:
    geogebra.gui.view.data.DataDisplayPanel this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.view.data.DataDisplayPanel$3 -> geogebra.gui.n.c.j:
    geogebra.gui.view.data.DataDisplayPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.data.DataDisplayPanel$4 -> geogebra.gui.n.c.k:
    geogebra.gui.view.data.DataDisplayPanel this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.data.DataDisplayPanel$MyRenderer -> geogebra.gui.n.c.g$a:
    javax.swing.JSeparator separator -> a
    geogebra.main.AppD app -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.data.DataDisplayPanel$PlotType -> geogebra.gui.n.c.g$b:
    geogebra.gui.view.data.DataDisplayPanel$PlotType HISTOGRAM -> a
    geogebra.gui.view.data.DataDisplayPanel$PlotType BOXPLOT -> b
    geogebra.gui.view.data.DataDisplayPanel$PlotType DOTPLOT -> c
    geogebra.gui.view.data.DataDisplayPanel$PlotType NORMALQUANTILE -> d
    geogebra.gui.view.data.DataDisplayPanel$PlotType STEMPLOT -> e
    geogebra.gui.view.data.DataDisplayPanel$PlotType BARCHART -> f
    geogebra.gui.view.data.DataDisplayPanel$PlotType SCATTERPLOT -> g
    geogebra.gui.view.data.DataDisplayPanel$PlotType RESIDUAL -> h
    geogebra.gui.view.data.DataDisplayPanel$PlotType MULTIBOXPLOT -> i
    java.lang.String key -> a
    geogebra.gui.view.data.DataDisplayPanel$PlotType[] ENUM$VALUES -> a
    java.lang.String getTranslatedKey(geogebra.main.AppD) -> a
    geogebra.gui.view.data.DataDisplayPanel$PlotType[] values() -> values
    geogebra.gui.view.data.DataDisplayPanel$PlotType valueOf(java.lang.String) -> valueOf
geogebra.gui.view.data.DataItem -> geogebra.gui.n.c.l:
    geogebra.gui.view.data.DataItem$SourceType sourceType -> a
    geogebra.common.plugin.GeoClass geoClass -> a
    java.util.ArrayList rangeList -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    java.lang.Double[] leftBorder -> a
    java.lang.String[] strInternal -> a
    java.lang.String description -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataItem$SourceType -> a
    void setDataItem(java.lang.Double[]) -> a
    java.util.ArrayList getRangeList() -> a
    geogebra.common.kernel.geos.GeoList getGeoList() -> a
    java.lang.Double[] getLeftBorder() -> a
    java.lang.String[] getStrInternal() -> a
    geogebra.gui.view.data.DataItem$SourceType getType() -> a
    void setGeoClass(geogebra.common.plugin.GeoClass) -> a
    java.lang.String getDescription() -> a
    void setDescription(java.lang.String) -> a
    void clearItem() -> a
    boolean isEmptyItem() -> a
    int getGeoCount() -> a
    java.lang.String getSourceString(geogebra.common.main.App) -> a
    java.lang.String getDataTitle(geogebra.common.main.App,boolean) -> a
    geogebra.common.kernel.geos.GeoList toGeoList(geogebra.common.main.App,boolean,boolean,boolean) -> a
    java.util.ArrayList rangeListCopy(java.util.ArrayList,boolean) -> a
    geogebra.common.gui.view.spreadsheet.CellRange rangeCopy(geogebra.common.gui.view.spreadsheet.CellRange,boolean) -> a
    geogebra.common.kernel.geos.GeoList dependentListCopy(geogebra.common.main.App,geogebra.common.kernel.geos.GeoList) -> a
    void swapXYCoords(geogebra.common.kernel.geos.GeoList) -> a
    java.lang.String[] toStringArray(boolean) -> a
    java.util.ArrayList toStringList(boolean) -> a
    boolean isValidDataType(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor crProcessor(geogebra.common.main.App) -> a
    geogebra.gui.view.spreadsheet.MyTableD spreadsheetTable(geogebra.common.main.App) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataItem$SourceType() -> a
geogebra.gui.view.data.DataItem$SourceType -> geogebra.gui.n.c.l$a:
    geogebra.gui.view.data.DataItem$SourceType SPREADSHEET -> a
    geogebra.gui.view.data.DataItem$SourceType LIST -> b
    geogebra.gui.view.data.DataItem$SourceType CLASS -> c
    geogebra.gui.view.data.DataItem$SourceType INTERNAL -> d
    geogebra.gui.view.data.DataItem$SourceType EMPTY -> e
    geogebra.gui.view.data.DataItem$SourceType[] ENUM$VALUES -> a
    geogebra.gui.view.data.DataItem$SourceType[] values() -> values
    geogebra.gui.view.data.DataItem$SourceType valueOf(java.lang.String) -> valueOf
geogebra.gui.view.data.DataPanel -> geogebra.gui.n.c.m:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD daView -> a
    geogebra.gui.view.data.DataAnalysisControllerD statController -> a
    javax.swing.JTable dataTable -> a
    javax.swing.JButton btnEnableAll -> a
    geogebra.gui.view.data.DataPanel$MyRowHeader rowHeader -> a
    geogebra.gui.view.data.DataPanel$MyColumnHeaderRenderer columnHeader -> a
    javax.swing.JScrollPane scrollPane -> a
    java.lang.Boolean[] selectionList -> a
    javax.swing.JLabel lblHeader -> a
    int preferredColumnWidth -> a
    java.awt.Color DISABLED_BACKGROUND_COLOR -> a
    java.awt.Color SELECTED_BACKGROUND_COLOR_HEADER -> b
    java.awt.Color TABLE_GRID_COLOR -> c
    java.awt.Color TABLE_HEADER_COLOR -> d
    void buildDataTable() -> b
    void createGUI() -> d
    void setLabels() -> c
    void updatePanel() -> a
    void updateFonts(java.awt.Font) -> a
    java.lang.Boolean[] updateSelectionList(java.util.ArrayList) -> a
    void populateDataTable(java.util.ArrayList) -> b
    void loadDataTable(java.util.ArrayList) -> a
    void setFont(java.awt.Font) -> setFont
    void setRowHeight() -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    java.awt.Color access$0() -> a
    java.awt.Color access$1() -> b
    geogebra.main.AppD access$2(geogebra.gui.view.data.DataPanel) -> a
    java.lang.Boolean[] access$3(geogebra.gui.view.data.DataPanel) -> a
    java.awt.Color access$4() -> c
    geogebra.gui.view.data.DataAnalysisControllerD access$5(geogebra.gui.view.data.DataPanel) -> a
    javax.swing.JButton access$6(geogebra.gui.view.data.DataPanel) -> a
    geogebra.gui.view.data.DataPanel$MyRowHeader access$7(geogebra.gui.view.data.DataPanel) -> a
geogebra.gui.view.data.DataPanel$1 -> geogebra.gui.n.c.n:
    geogebra.gui.view.data.DataPanel this$0 -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
geogebra.gui.view.data.DataPanel$CheckBoxIcon -> geogebra.gui.n.c.m$a:
    java.awt.Color highlightBackground -> a
    int csize -> a
    void paintIcon(boolean,boolean,java.awt.Graphics,int,int) -> a
    javax.swing.ImageIcon createCheckBoxImageIcon(boolean,boolean) -> a
geogebra.gui.view.data.DataPanel$Corner -> geogebra.gui.n.c.m$b:
    geogebra.gui.view.data.DataPanel this$0 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.data.DataPanel$MyCellRenderer -> geogebra.gui.n.c.m$c:
    geogebra.gui.view.data.DataPanel this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.data.DataPanel$MyColumnHeaderRenderer -> geogebra.gui.n.c.m$d:
    geogebra.gui.view.data.DataPanel this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.data.DataPanel$MyRowHeader -> geogebra.gui.n.c.m$e:
    javax.swing.JTable table -> a
    geogebra.gui.view.data.DataPanel dataPanel -> a
    geogebra.gui.view.data.DataPanel this$0 -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void enableAll() -> a
    boolean isAllEnabled() -> a
geogebra.gui.view.data.DataPanel$MyRowHeader$RowHeaderRenderer -> geogebra.gui.n.c.m$e$a:
    javax.swing.ImageIcon iconChecked -> a
    javax.swing.ImageIcon iconUnChecked -> b
    geogebra.gui.view.data.DataPanel$MyRowHeader this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.data.DataSource -> geogebra.gui.n.c.o:
    geogebra.gui.view.data.DataVariable$GroupType defaultGroupType -> a
    geogebra.main.AppD app -> a
    java.util.ArrayList dataList -> a
    int selectedIndex -> a
    boolean isEmpty() -> a
    void clearData() -> a
    int getSelectedIndex() -> a
    boolean enableHeader() -> b
    void setEnableHeader(boolean) -> a
    boolean isNumericData() -> c
    boolean isPointData() -> d
    geogebra.gui.view.data.DataVariable getSelectedDataVariable() -> a
    geogebra.gui.view.data.DataVariable$GroupType getGroupType() -> a
    double getClassStart() -> a
    void setClassStart(double) -> a
    double getClassWidth() -> b
    void setClassWidth(double) -> b
    geogebra.gui.view.spreadsheet.MyTableD spreadsheetTable() -> a
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor crProcessor() -> a
    void setDataItemToGeoSelection(int,int) -> a
    geogebra.gui.view.data.DataItem createDataItemFromGeoSelection() -> a
    java.lang.String[][] getTableData() -> a
    java.lang.String[][] getTableData(int) -> a
    java.lang.String[] getTitles() -> a
    java.lang.String[] getTitles(int) -> a
    java.lang.String[] getDescriptions() -> b
    java.util.ArrayList toGeoList(int,boolean,boolean,int) -> a
    java.util.ArrayList toGeoListAll(int,boolean,boolean) -> a
    void setDataListFromSelection(int) -> a
    void setDataListFromGeoList(int) -> b
    void setDataListFromSpreadsheet(int,geogebra.gui.view.data.DataVariable$GroupType) -> a
    void add1DCellRanges(java.util.ArrayList,java.util.ArrayList) -> a
    boolean isInDataSource(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.view.data.DataSourceDialog -> geogebra.gui.n.c.p:
    geogebra.main.AppD app -> a
    int mode -> a
    geogebra.gui.view.data.DataSourcePanel dataSourcePanel -> a
    javax.swing.JButton btnCancel -> a
    javax.swing.JButton btnOK -> b
    javax.swing.JLabel lblTitle -> a
    void createGUI() -> b
    void setVisible(boolean) -> setVisible
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> a
    void updateDialog(int,boolean) -> a
    void setLocation() -> c
geogebra.gui.view.data.DataSourcePanel -> geogebra.gui.n.c.q:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD dataView -> a
    javax.swing.JDialog invoker -> a
    geogebra.gui.view.data.DataSource dataSource -> a
    geogebra.gui.view.data.StatTable sourceTable -> a
    javax.swing.JPanel mainPanel -> a
    javax.swing.JPanel classesPanel -> b
    javax.swing.JPanel controlPanel -> c
    javax.swing.JLabel lblTitle -> a
    javax.swing.JLabel lblStart -> b
    javax.swing.JLabel lblWidth -> c
    geogebra.gui.view.data.DataSourcePanel$MyButton btnAdd -> a
    geogebra.gui.view.data.DataSourcePanel$MyButton btnClear -> b
    geogebra.gui.view.data.DataSourcePanel$MyButton btnDelete -> c
    geogebra.gui.view.data.DataSourcePanel$MyButton btnOptions -> d
    geogebra.gui.inputfield.MyTextField fldStart -> a
    geogebra.gui.inputfield.MyTextField fldWidth -> b
    double classStart -> a
    double classWidth -> b
    int mode -> b
    int btnHoverColumn -> a
    java.lang.String[] columnDataTitles -> a
    int selectedVarIndex() -> a
    java.lang.String[] getColumnDataTitles() -> a
    void updatePanel(int,boolean) -> a
    void buildGUI() -> d
    void createGUIElements() -> e
    void buildMainPanel() -> f
    void buildControlPanel() -> g
    void buildClassesPanel() -> h
    void setLabels() -> a
    void updateGUI() -> b
    void createSourceTable() -> i
    void setTableDimension(javax.swing.JTable) -> a
    void loadSourceTableFromDataSource() -> j
    void addDataToColumn(int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts(java.awt.Font) -> a
    void applySettings() -> c
    void setColumnHeaders(javax.swing.JTable) -> b
    javax.swing.JTable table() -> a
    javax.swing.JPopupMenu getOptionsMenu() -> a
    geogebra.main.AppD access$0(geogebra.gui.view.data.DataSourcePanel) -> a
    int access$1(geogebra.gui.view.data.DataSourcePanel) -> a
geogebra.gui.view.data.DataSourcePanel$1 -> geogebra.gui.n.c.r:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.gui.view.data.DataSourcePanel$10 -> geogebra.gui.n.c.s:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    javax.swing.JCheckBoxMenuItem val$itmHeader -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$2 -> geogebra.gui.n.c.t:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.view.data.DataSourcePanel$3 -> geogebra.gui.n.c.u:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$4 -> geogebra.gui.n.c.v:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$5 -> geogebra.gui.n.c.w:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    javax.swing.JCheckBoxMenuItem val$itmRawData -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$6 -> geogebra.gui.n.c.x:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    javax.swing.JCheckBoxMenuItem val$itmFrequency -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$7 -> geogebra.gui.n.c.y:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    javax.swing.JCheckBoxMenuItem val$itmClass -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$8 -> geogebra.gui.n.c.z:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$9 -> geogebra.gui.n.c.A:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    geogebra.gui.view.data.DataVariable val$var -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.DataSourcePanel$ColumnHeaderMouseListener -> geogebra.gui.n.c.q$a:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.data.DataSourcePanel$ColumnHeaderMouseMotionListener -> geogebra.gui.n.c.q$b:
    javax.swing.table.JTableHeader header -> a
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.view.data.DataSourcePanel$MyButton -> geogebra.gui.n.c.q$c:
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
geogebra.gui.view.data.DataSourcePanel$MyTableHeaderRenderer -> geogebra.gui.n.c.q$d:
    javax.swing.JLabel lblDataDescription -> a
    javax.swing.JLabel lblDataTitle -> b
    javax.swing.JLabel lblImportBtn -> c
    javax.swing.border.Border headerBorder -> a
    java.awt.Font font -> a
    javax.swing.ImageIcon importIcon -> a
    javax.swing.ImageIcon importIconRollover -> b
    java.awt.Rectangle rect -> a
    geogebra.gui.view.data.DataSourcePanel this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
    boolean isOverTraceButton(int,java.awt.Point,java.lang.Object) -> a
geogebra.gui.view.data.DataVariable -> geogebra.gui.n.c.B:
    geogebra.common.main.App app -> a
    geogebra.gui.view.data.DataVariable$GroupType groupType -> a
    geogebra.common.plugin.GeoClass geoClass -> a
    geogebra.gui.view.data.DataItem frequency -> a
    geogebra.gui.view.data.DataItem label -> b
    geogebra.gui.view.data.DataItem classes -> c
    java.util.ArrayList values -> a
    boolean enableHeader -> a
    double classStart -> a
    double classWidth -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataVariable$GroupType -> a
    void setDataVariableAsRawData(geogebra.common.plugin.GeoClass,java.util.ArrayList) -> a
    void setDataVariable(geogebra.gui.view.data.DataVariable$GroupType,geogebra.common.plugin.GeoClass,java.util.ArrayList,geogebra.gui.view.data.DataItem,geogebra.gui.view.data.DataItem,geogebra.gui.view.data.DataItem) -> a
    void setGroupType(geogebra.gui.view.data.DataVariable$GroupType) -> a
    geogebra.gui.view.data.DataVariable$GroupType getGroupType() -> a
    void setGeoClass(geogebra.common.plugin.GeoClass) -> a
    geogebra.common.plugin.GeoClass getGeoClass() -> a
    double getClassStart() -> a
    void setClassStart(double) -> a
    double getClassWidth() -> b
    void setClassWidth(double) -> b
    void updateAutomaticClasses() -> c
    boolean enableHeader() -> a
    void setEnableHeader(boolean) -> a
    java.util.ArrayList getValues() -> a
    void setDataItem(int,geogebra.gui.view.data.DataItem) -> a
    void removeLastValue() -> a
    void addNewValue() -> b
    java.util.ArrayList getItemList() -> b
    java.util.ArrayList getGeoListData(geogebra.common.main.App,int,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoList getPointList(boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoList createPointGeoList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,boolean,boolean) -> a
    java.util.ArrayList getStringData() -> c
    java.util.ArrayList getTitles(geogebra.common.main.App) -> a
    java.util.ArrayList getColumnNames() -> d
    boolean isInDataSource(geogebra.common.kernel.geos.GeoElement) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataVariable$GroupType() -> a
geogebra.gui.view.data.DataVariable$GroupType -> geogebra.gui.n.c.B$a:
    geogebra.gui.view.data.DataVariable$GroupType RAWDATA -> a
    geogebra.gui.view.data.DataVariable$GroupType FREQUENCY -> b
    geogebra.gui.view.data.DataVariable$GroupType CLASS -> c
    geogebra.gui.view.data.DataVariable$GroupType[] ENUM$VALUES -> a
    geogebra.gui.view.data.DataVariable$GroupType[] values() -> values
    geogebra.gui.view.data.DataVariable$GroupType valueOf(java.lang.String) -> valueOf
geogebra.gui.view.data.FrequencyTablePanel -> geogebra.gui.n.c.C:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    geogebra.gui.view.data.StatTable statTable -> a
    void setTableFromGeoFrequencyTable(geogebra.common.kernel.statistics.AlgoFrequencyTable,boolean) -> a
    void setTableSize() -> a
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> c
geogebra.gui.view.data.MultiVarStatPanel -> geogebra.gui.n.c.D:
    boolean isMinimalTable -> a
    void setMinimalTable(boolean) -> a
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.util.ArrayList getStatList() -> a
geogebra.gui.view.data.OneVarInferencePanel -> geogebra.gui.n.c.E:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    geogebra.gui.view.data.StatTable resultTable -> a
    javax.swing.JLabel lblHypParameter -> a
    javax.swing.JLabel lblTailType -> b
    javax.swing.JLabel lblNull -> c
    javax.swing.JLabel lblConfLevel -> d
    javax.swing.JLabel lblSigma -> e
    javax.swing.JLabel lblResultHeader -> f
    javax.swing.JButton btnCalculate -> a
    geogebra.gui.inputfield.MyTextField fldNullHyp -> a
    geogebra.gui.inputfield.MyTextField fldConfLevel -> b
    geogebra.gui.inputfield.MyTextField fldSigma -> c
    javax.swing.JRadioButton btnLeft -> a
    javax.swing.JRadioButton btnRight -> b
    javax.swing.JRadioButton btnTwo -> c
    javax.swing.JComboBox cbAltHyp -> a
    javax.swing.JPanel testPanel -> a
    javax.swing.JPanel intPanel -> b
    javax.swing.JPanel mainPanel -> c
    javax.swing.JPanel resultPanel -> d
    javax.swing.Box sigmaPanel -> a
    int fieldWidth -> a
    java.lang.String tail -> a
    double confLevel -> j
    double hypMean -> k
    double sigma -> l
    double testStat -> a
    double P -> b
    double df -> c
    double lower -> d
    double upper -> e
    double mean -> f
    double se -> g
    double me -> h
    double N -> i
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    org.apache.commons.math.distribution.NormalDistributionImpl normalDist -> a
    boolean isIniting -> a
    boolean isTest -> b
    boolean isZProcedure -> c
    int selectedPlot -> b
    void createGUIElements() -> b
    void updateMainPanel() -> d
    void setResultTable() -> e
    void updateResultTable() -> f
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> c
    void updateNumberField(javax.swing.JTextField,double) -> a
    void updateGUI() -> g
    void updateCBAlternativeHyp() -> h
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setSelectedPlot(int) -> a
    void updatePanel() -> a
    void evaluate() -> i
    double adjustedPValue(double,double,java.lang.String) -> a
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
    javax.swing.Box hBox(java.awt.Component[]) -> a
geogebra.gui.view.data.OptionsPanel -> geogebra.gui.n.c.F:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    geogebra.gui.view.data.StatPanelSettings settings -> a
    javax.swing.JCheckBox ckCumulative -> a
    javax.swing.JCheckBox ckManual -> b
    javax.swing.JCheckBox ckOverlayNormal -> c
    javax.swing.JCheckBox ckOverlayPolygon -> d
    javax.swing.JCheckBox ckShowFrequencyTable -> e
    javax.swing.JCheckBox ckShowHistogram -> f
    javax.swing.JRadioButton rbRelative -> a
    javax.swing.JRadioButton rbNormalized -> b
    javax.swing.JRadioButton rbFreq -> c
    javax.swing.JRadioButton rbLeftRule -> d
    javax.swing.JRadioButton rbRightRule -> e
    javax.swing.JLabel lblFreqType -> a
    javax.swing.JLabel lblOverlay -> b
    javax.swing.JLabel lblClassRule -> c
    javax.swing.JPanel freqPanel -> a
    javax.swing.JPanel showPanel -> b
    javax.swing.JPanel dimPanel -> c
    javax.swing.JCheckBox ckAutoWindow -> g
    javax.swing.JCheckBox ckShowGrid -> h
    javax.swing.JLabel lblXMin -> d
    javax.swing.JLabel lblXMax -> e
    javax.swing.JLabel lblYMin -> f
    javax.swing.JLabel lblYMax -> g
    javax.swing.JLabel lblXInterval -> h
    javax.swing.JLabel lblYInterval -> i
    geogebra.gui.inputfield.MyTextField fldXMin -> a
    geogebra.gui.inputfield.MyTextField fldXMax -> b
    geogebra.gui.inputfield.MyTextField fldYMin -> c
    geogebra.gui.inputfield.MyTextField fldYMax -> d
    geogebra.gui.inputfield.MyTextField fldXInterval -> e
    geogebra.gui.inputfield.MyTextField fldYInterval -> f
    boolean showYAxisSettings -> a
    javax.swing.JLabel lblBarWidth -> j
    geogebra.gui.inputfield.MyTextField fldBarWidth -> g
    javax.swing.JCheckBox ckAutoBarWidth -> i
    javax.swing.JPanel barChartWidthPanel -> d
    javax.swing.JCheckBox ckShowOutliers -> j
    javax.swing.JCheckBox ckShowLines -> k
    javax.swing.JPanel histogramPanel -> e
    javax.swing.JPanel graphPanel -> f
    javax.swing.JPanel classesPanel -> g
    javax.swing.JPanel scatterplotPanel -> h
    javax.swing.JPanel barChartPanel -> i
    javax.swing.JPanel boxPlotPanel -> j
    javax.swing.JPanel mainPanel -> k
    javax.swing.JTabbedPane tabbedPane -> a
    boolean isUpdating -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType -> a
    void setPanel(geogebra.gui.view.data.DataDisplayPanel$PlotType) -> a
    void createHistogramPanel() -> a
    void layoutHistogramPanel() -> b
    void layoutBarChartPanel() -> d
    void createBarChartPanel() -> e
    void createBoxPlotPanel() -> f
    void createScatterplotPanel() -> g
    void createGraphPanel() -> h
    javax.swing.JComponent insetPanel(int,javax.swing.JComponent[]) -> a
    void setLabels() -> c
    void updateGUI() -> i
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts(java.awt.Font) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType() -> a
geogebra.gui.view.data.PlotPanelEuclidianController -> geogebra.gui.n.c.G:
    void showDrawingPadPopup(geogebra.common.awt.GPoint) -> a
geogebra.gui.view.data.PlotPanelEuclidianView -> geogebra.gui.n.c.H:
    geogebra.euclidian.EuclidianControllerD ec -> a
    geogebra.gui.view.data.PlotPanelEuclidianView plotPanelEV -> a
    boolean[] showAxes -> a
    boolean showGrid -> f
    int viewID -> e
    geogebra.gui.view.data.PlotSettings plotSettings -> a
    geogebra.gui.view.data.PlotPanelEuclidianView$MyMouseListener myMouseListener -> a
    boolean overDragRegion -> g
    java.awt.dnd.DragSource ds -> a
    java.awt.Cursor grabbingCursor -> b
    java.awt.Cursor grabCursor -> c
    java.util.ArrayList actionList -> a
    javax.swing.AbstractAction exportToEVAction -> c
    java.awt.datatransfer.DataFlavor plotPanelFlavor -> a
    javax.swing.AbstractAction exportGraphicAction -> a
    javax.swing.AbstractAction drawingPadToClipboardAction -> b
    void setMode(int) -> c
    int getViewID() -> a
    void updateSize() -> r
    void updateSettings(geogebra.gui.view.data.PlotSettings) -> a
    void setEVParams() -> H
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void setMouseEnabled(boolean,boolean) -> b
    void setMouseMotionEnabled(boolean) -> p
    void setMouseWheelEnabled(boolean) -> q
    void setDefaultCursor() -> y
    javax.swing.JPopupMenu getContextMenu() -> a
    java.util.ArrayList getActionList() -> b
    void enableDnD() -> I
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    geogebra.gui.view.data.PlotPanelEuclidianView access$0(geogebra.gui.view.data.PlotPanelEuclidianView) -> a
    void access$1(geogebra.gui.view.data.PlotPanelEuclidianView,boolean) -> a
    javax.swing.AbstractAction access$2(geogebra.gui.view.data.PlotPanelEuclidianView) -> a
geogebra.gui.view.data.PlotPanelEuclidianView$1 -> geogebra.gui.n.c.I:
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.data.PlotPanelEuclidianView access$0(geogebra.gui.view.data.PlotPanelEuclidianView$1) -> a
geogebra.gui.view.data.PlotPanelEuclidianView$1$1 -> geogebra.gui.n.c.J:
    geogebra.gui.view.data.PlotPanelEuclidianView$1 this$1 -> a
    void run() -> run
geogebra.gui.view.data.PlotPanelEuclidianView$2 -> geogebra.gui.n.c.K:
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.data.PlotPanelEuclidianView access$0(geogebra.gui.view.data.PlotPanelEuclidianView$2) -> a
geogebra.gui.view.data.PlotPanelEuclidianView$2$1 -> geogebra.gui.n.c.L:
    geogebra.gui.view.data.PlotPanelEuclidianView$2 this$1 -> a
    void run() -> run
geogebra.gui.view.data.PlotPanelEuclidianView$ContextMenu -> geogebra.gui.n.c.H$a:
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
geogebra.gui.view.data.PlotPanelEuclidianView$MyMouseListener -> geogebra.gui.n.c.H$b:
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.data.PlotPanelEuclidianView$MyMouseMotionListener -> geogebra.gui.n.c.H$c:
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.view.data.PlotPanelEuclidianView$TransferablePlotPanel -> geogebra.gui.n.c.H$d:
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.lang.String plotPanelIdentifier -> a
    java.awt.Image image -> a
    geogebra.gui.view.data.PlotPanelEuclidianView this$0 -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.view.data.PlotSettings -> geogebra.gui.n.c.M:
    double xMin -> a
    double xMax -> b
    double xAxesInterval -> c
    boolean xAxesIntervalAuto -> a
    double yMin -> d
    double yMax -> e
    double yAxesInterval -> f
    boolean yAxesIntervalAuto -> b
    double[] gridInterval -> a
    boolean gridIntervalAuto -> c
    int pointCaptureStyle -> a
    boolean showYAxis -> d
    boolean showXAxis -> e
    boolean showArrows -> f
    boolean forceXAxisBuffer -> g
    boolean forceYAxisBuffer -> h
    boolean[] isEdgeAxis -> a
    boolean[] isPositiveOnly -> b
    boolean showGrid -> i
geogebra.gui.view.data.RegressionPanel -> geogebra.gui.n.c.N:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    javax.swing.JLabel lblRegEquation -> a
    javax.swing.JLabel lblEqn -> b
    javax.swing.JComboBox cbRegression -> a
    javax.swing.JComboBox cbPolyOrder -> b
    javax.swing.JLabel lblEvaluate -> c
    geogebra.gui.inputfield.MyTextField fldInputX -> a
    javax.swing.JLabel lblOutputY -> d
    java.lang.String[] regressionLabels -> a
    javax.swing.JLabel fldOutputY -> e
    boolean isIniting -> a
    javax.swing.JPanel predictionPanel -> a
    javax.swing.JPanel regressionPanel -> b
    javax.swing.JPanel createRegressionPanel() -> a
    void createPredictionPanel() -> e
    void updateRegressionPanel() -> a
    void clearPredictionPanel() -> b
    void setRegressionLabels() -> f
    void setLabels() -> c
    void setRegressionEquationLabel() -> d
    void setRegressionEquationLabelEmpty() -> g
    void updateGUI() -> h
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void updateFonts(java.awt.Font) -> a
geogebra.gui.view.data.StatGeo -> geogebra.gui.n.c.O:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    double xMinData -> a
    double xMaxData -> b
    double yMinData -> c
    double yMaxData -> d
    boolean histogramRight -> a
    boolean removeFromConstruction -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataAnalysisViewD$Regression -> b
    void getDataBounds(geogebra.common.kernel.geos.GeoList) -> a
    void getDataBounds(geogebra.common.kernel.geos.GeoList,boolean) -> a
    void getDataBounds(geogebra.common.kernel.geos.GeoList,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createHistogram(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings,boolean) -> a
    geogebra.common.kernel.algos.AlgoPolyLine createFrequencyPolygon(geogebra.common.kernel.statistics.AlgoHistogram,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createNormalCurveOverlay(geogebra.common.kernel.geos.GeoList) -> a
    void getHistogramSettings(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.data.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement createBarChartText(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement createBarChartNumeric(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> b
    double getPreferredBarWidth(geogebra.common.kernel.geos.GeoList) -> a
    double getPreferredBarWidth(double[]) -> a
    geogebra.common.kernel.geos.GeoElement createFrequencyTableGeo(geogebra.common.kernel.geos.GeoNumeric,geogebra.gui.view.data.DataDisplayPanel$PlotType) -> a
    void getBarChartSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement createBoxPlot(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> c
    void getBoxPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement[] createMultipleBoxPlot(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> a
    void getMultipleBoxPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> b
    geogebra.common.kernel.geos.GeoElement[] createBoxPlotTitles(geogebra.gui.view.data.DataAnalysisViewD,geogebra.gui.view.data.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement createDotPlot(geogebra.common.kernel.geos.GeoList) -> b
    void updateDotPlot(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.data.StatPanelSettings) -> b
    geogebra.common.kernel.geos.GeoElement createNormalQuantilePlot(geogebra.common.kernel.geos.GeoList) -> c
    void updateNormalQuantilePlot(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> c
    geogebra.common.kernel.geos.GeoElement createScatterPlotLine(geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoElement createScatterPlot(geogebra.common.kernel.geos.GeoList) -> e
    void getScatterPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.StatPanelSettings) -> d
    geogebra.common.kernel.geos.GeoElement createRegressionPlot(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.data.DataAnalysisViewD$Regression,int,boolean) -> a
    void getResidualPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.data.StatPanelSettings) -> c
    void setXYBounds(geogebra.gui.view.data.StatPanelSettings) -> a
    void setXYBounds(geogebra.gui.view.data.StatPanelSettings,double,double) -> a
    java.lang.String getStemPlotLatex(geogebra.common.kernel.geos.GeoList,int) -> a
    boolean removeFromConstruction() -> a
    void setRemoveFromConstruction(boolean) -> a
    void removeFromConstructionList(geogebra.common.kernel.algos.ConstructionElement) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataDisplayPanel$PlotType() -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$data$DataAnalysisViewD$Regression() -> b
geogebra.gui.view.data.StatPanelInterface -> geogebra.gui.n.c.P:
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> c
geogebra.gui.view.data.StatPanelSettings -> geogebra.gui.n.c.Q:
    geogebra.gui.view.data.DataSource dataSource -> a
    int frequencyType -> b
    boolean isCumulative -> j
    boolean useManualClasses -> k
    boolean hasOverlayNormal -> l
    boolean hasOverlayPolygon -> m
    boolean showFrequencyTable -> n
    boolean showHistogram -> o
    boolean showScatterplotLine -> p
    boolean showOutliers -> q
    double classStart -> g
    double classWidth -> h
    int numClasses -> c
    boolean isLeftRule -> r
    double barWidth -> i
    boolean isAutomaticBarWidth -> s
    boolean isAutomaticWindow -> t
    int stemAdjust -> d
    geogebra.gui.view.data.DataSource getDataSource() -> a
    void setDataSource(geogebra.gui.view.data.DataSource) -> a
    geogebra.gui.view.data.DataVariable$GroupType groupType() -> a
    boolean isNumericData() -> a
    boolean isPointList() -> b
geogebra.gui.view.data.StatTable -> geogebra.gui.n.c.R:
    geogebra.gui.view.data.StatTable$MyTable myTable -> a
    geogebra.gui.view.data.StatTable$MyRowHeader rowHeader -> a
    boolean isRowHeaderPainted -> a
    java.awt.Color TABLE_GRID_COLOR -> a
    java.awt.Color TABLE_HEADER_COLOR -> b
    java.awt.Color SELECTED_BACKGROUND_COLOR -> c
    javax.swing.table.DefaultTableModel tableModel -> a
    java.util.HashMap comboBoxEditorMap -> a
    java.util.HashMap comboBoxRendererMap -> b
    java.awt.event.ActionListener al -> a
    geogebra.main.AppD app -> a
    int alignment -> a
    geogebra.gui.view.data.StatTable$MyTable getTable() -> a
    void initTable() -> c
    void setStatTable(int,java.lang.String[],int,java.lang.String[]) -> a
    void clear() -> a
    void setComboBoxCells(java.util.HashMap,java.awt.event.ActionListener) -> a
    java.lang.Integer getComboCellEditorSelectedIndex(int,int) -> a
    boolean setComboCellSelectedIndex(int,int,int) -> a
    void setLabels(java.lang.String[],java.lang.String[]) -> a
    javax.swing.table.DefaultTableModel getModel() -> a
    void updateFonts(java.awt.Font) -> a
    void autoFitColumnWidth(int,int) -> a
    void autoFitRowHeight() -> b
    void setHorizontalAlignment(int) -> a
    int getHorizontalAlignment() -> a
    void setAllowCellEdit(boolean) -> a
    java.awt.Color access$0() -> a
    java.awt.Color access$1() -> b
    java.awt.Color access$2() -> c
    geogebra.gui.view.data.StatTable$MyTable access$3(geogebra.gui.view.data.StatTable) -> a
    java.awt.event.ActionListener access$4(geogebra.gui.view.data.StatTable) -> a
    java.util.HashMap access$5(geogebra.gui.view.data.StatTable) -> a
    java.util.HashMap access$6(geogebra.gui.view.data.StatTable) -> b
geogebra.gui.view.data.StatTable$Corner -> geogebra.gui.n.c.R$a:
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.data.StatTable$MyCellRenderer -> geogebra.gui.n.c.R$b:
    geogebra.gui.view.data.StatTable statTable -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.data.StatTable$MyComboBoxEditor -> geogebra.gui.n.c.R$c:
    javax.swing.JComboBox comboBox -> a
    int row -> a
    int column -> b
    geogebra.gui.view.data.StatTable this$0 -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    int getSelectedIndex() -> a
    void setSelectedIndex(int) -> a
geogebra.gui.view.data.StatTable$MyComboBoxRenderer -> geogebra.gui.n.c.R$d:
    javax.swing.JComboBox comboBox -> a
    javax.swing.JLabel label -> a
    geogebra.gui.view.data.StatTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.data.StatTable$MyRowHeader -> geogebra.gui.n.c.R$e:
    javax.swing.JTable table -> a
    geogebra.gui.view.data.StatTable statTable -> b
    geogebra.gui.view.data.StatTable this$0 -> a
    geogebra.gui.view.data.StatTable access$0(geogebra.gui.view.data.StatTable$MyRowHeader) -> a
geogebra.gui.view.data.StatTable$MyRowHeader$RowHeaderRenderer -> geogebra.gui.n.c.R$e$a:
    geogebra.gui.view.data.StatTable$MyRowHeader this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.data.StatTable$MyTable -> geogebra.gui.n.c.R$f:
    boolean allowCellEdit -> a
    geogebra.gui.view.data.StatTable this$0 -> a
    void setAllowCellEdit(boolean) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    java.awt.Component prepareEditor(javax.swing.table.TableCellEditor,int,int) -> prepareEditor
    javax.swing.table.TableCellEditor getCellEditor(int,int) -> getCellEditor
    javax.swing.table.TableCellRenderer getCellRenderer(int,int) -> getCellRenderer
geogebra.gui.view.data.StatisticsPanel -> geogebra.gui.n.c.S:
    javax.swing.JComboBox cbInferenceMode -> a
    java.util.HashMap labelMap -> a
    java.util.HashMap labelMapReverse -> b
    int selectedMode -> a
    geogebra.gui.view.data.BasicStatTable statTable -> a
    geogebra.gui.view.data.OneVarInferencePanel oneVarInferencePanel -> a
    geogebra.gui.view.data.TwoVarInferencePanel twoVarInferencePanel -> a
    geogebra.gui.view.data.ANOVATable anovaTable -> a
    geogebra.gui.view.data.MultiVarStatPanel minMVStatPanel -> a
    javax.swing.JPanel selectionPanel -> a
    javax.swing.JPanel inferencePanel -> b
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    geogebra.main.AppD app -> a
    void createStatTable() -> b
    void setInferencePanel() -> d
    void createSelectionPanel() -> e
    geogebra.gui.view.data.ANOVATable getAnovaTable() -> a
    geogebra.gui.view.data.OneVarInferencePanel getOneVarInferencePanel() -> a
    geogebra.gui.view.data.TwoVarInferencePanel getTwoVarInferencePanel() -> a
    geogebra.gui.view.data.MultiVarStatPanel getMinMVStatPanel() -> a
    void createInferenceTypeComboBox() -> f
    void createLabelMap() -> g
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> c
    void updatePanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.data.StatisticsPanel$MyRenderer -> geogebra.gui.n.c.S$a:
    javax.swing.JSeparator separator -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.data.TwoVarInferencePanel -> geogebra.gui.n.c.T:
    geogebra.main.AppD app -> a
    geogebra.gui.view.data.DataAnalysisViewD daView -> a
    geogebra.gui.view.data.StatTable resultTable -> a
    javax.swing.JComboBox cbTitle1 -> a
    javax.swing.JComboBox cbTitle2 -> b
    javax.swing.JComboBox cbAltHyp -> c
    javax.swing.JLabel lblTitle1 -> a
    javax.swing.JLabel lblTitle2 -> b
    javax.swing.JLabel lblHypParameter -> c
    javax.swing.JLabel lblTailType -> d
    javax.swing.JLabel lblNull -> e
    javax.swing.JLabel lblConfLevel -> f
    javax.swing.JLabel lblResultHeader -> g
    geogebra.gui.inputfield.MyTextField fldNullHyp -> a
    javax.swing.JPanel resultPanel -> a
    javax.swing.JCheckBox ckEqualVariances -> a
    geogebra.gui.inputfield.MyTextField fldConfLevel -> b
    int selectedInference -> a
    java.lang.String tail -> a
    double confLevel -> m
    double hypMean -> n
    double t -> a
    double P -> b
    double df -> c
    double lower -> d
    double upper -> e
    double se -> f
    double me -> g
    double n1 -> h
    double n2 -> i
    double diffMeans -> j
    double mean1 -> k
    double mean2 -> l
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    boolean pooled -> a
    boolean isIniting -> b
    javax.swing.JPanel testPanel -> b
    javax.swing.JPanel intPanel -> c
    javax.swing.JPanel mainPanel -> d
    boolean isTest -> c
    javax.swing.JPanel samplePanel -> e
    geogebra.gui.view.data.TwoVarStatPanel twoStatPanel -> a
    double meanDifference -> o
    void createGUIElements() -> b
    void updateMainPanel() -> d
    boolean isPairedData() -> a
    void updateGUI() -> e
    void updateNumberField(javax.swing.JTextField,double) -> a
    void updateCBAlternativeHyp() -> f
    void setSelectedInference(int) -> a
    void updateFonts(java.awt.Font) -> a
    java.lang.String getNullHypName() -> a
    void setLabels() -> c
    void updatePanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setResultTable() -> g
    void updateResultTable() -> h
    java.lang.Integer[] selectedDataIndex() -> a
    boolean evaluate() -> b
    double adjustedPValue(double,double,java.lang.String) -> a
    double getDegreeOfFreedom(double,double,double,double,boolean) -> a
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
geogebra.gui.view.data.TwoVarStatPanel -> geogebra.gui.n.c.U:
    geogebra.main.AppD app -> b
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.data.DataAnalysisViewD statDialog -> a
    geogebra.gui.view.data.StatTable$MyTable statTable -> a
    java.lang.Integer[] selectedDataIndex -> a
    java.awt.event.ActionListener parentActionListener -> a
    boolean isPairedData -> b
    boolean isIniting -> c
    double mean1 -> a
    double mean2 -> b
    double sd1 -> c
    double sd2 -> d
    double sdDifference -> e
    double meanDifference -> f
    long n1 -> a
    long n2 -> b
    void setTable(boolean) -> b
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> b
    int getColumnCount() -> c
    java.lang.Integer[] getSelectedDataIndex() -> a
    void updatePanel() -> c
    boolean evaluatePairedDifferences() -> a
    boolean evaluateSampleData() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.functioninspector.FunctionInspector -> geogebra.gui.n.d.a:
    java.awt.Color DISPLAY_GEO_COLOR -> a
    java.awt.Color DISPLAY_GEO2_COLOR -> b
    java.awt.Color EVEN_ROW_COLOR -> c
    java.awt.Color TABLE_GRID_COLOR -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.euclidian.EuclidianView activeEV -> a
    geogebra.gui.view.functioninspector.InspectorTable tableXY -> a
    geogebra.gui.view.functioninspector.InspectorTable tableInterval -> b
    javax.swing.table.DefaultTableModel modelXY -> a
    javax.swing.table.DefaultTableModel modelInterval -> b
    java.lang.String[] columnNames -> a
    java.util.ArrayList extraColumnList -> b
    javax.swing.JLabel lblGeoName -> b
    javax.swing.JLabel lblStep -> c
    javax.swing.JLabel lblInterval -> d
    geogebra.gui.inputfield.MyTextField fldStep -> a
    geogebra.gui.inputfield.MyTextField fldLow -> b
    geogebra.gui.inputfield.MyTextField fldHigh -> c
    javax.swing.JButton btnRemoveColumn -> f
    javax.swing.JToggleButton btnOscCircle -> a
    javax.swing.JToggleButton btnTangent -> b
    javax.swing.JToggleButton btnXYSegments -> c
    javax.swing.JToggleButton btnTable -> d
    geogebra.gui.util.PopupMenuButton btnAddColumn -> a
    geogebra.gui.util.PopupMenuButton btnOptions -> b
    javax.swing.JTabbedPane tabPanel -> a
    javax.swing.JPanel intervalTabPanel -> e
    javax.swing.JPanel pointTabPanel -> f
    javax.swing.JPanel headerPanel -> g
    javax.swing.JPanel helpPanel -> h
    geogebra.common.kernel.geos.GeoElement tangentLine -> b
    geogebra.common.kernel.geos.GeoElement oscCircle -> c
    geogebra.common.kernel.geos.GeoElement xSegment -> d
    geogebra.common.kernel.geos.GeoElement ySegment -> e
    geogebra.common.kernel.geos.GeoElement functionInterval -> f
    geogebra.common.kernel.geos.GeoElement integralGeo -> g
    geogebra.common.kernel.geos.GeoElement lengthGeo -> h
    geogebra.common.kernel.geos.GeoElement areaGeo -> i
    geogebra.common.kernel.geos.GeoFunction derivative -> a
    geogebra.common.kernel.geos.GeoFunction derivative2 -> b
    geogebra.common.kernel.geos.GeoFunction selectedGeo -> c
    geogebra.common.kernel.geos.GeoPoint testPoint -> a
    geogebra.common.kernel.geos.GeoPoint lowPoint -> b
    geogebra.common.kernel.geos.GeoPoint highPoint -> c
    geogebra.common.kernel.geos.GeoPoint minPoint -> d
    geogebra.common.kernel.geos.GeoPoint maxPoint -> e
    geogebra.common.kernel.geos.GeoList pts -> a
    java.util.ArrayList intervalTabGeoList -> c
    java.util.ArrayList pointTabGeoList -> d
    java.util.ArrayList hiddenGeoList -> e
    geogebra.common.kernel.geos.GeoElement[] rootGeos -> a
    java.util.ArrayList xyTableCopyList -> f
    boolean isIniting -> a
    double xMin -> a
    double xMax -> b
    double start -> c
    double step -> d
    double initialX -> e
    boolean isChangingValue -> b
    int pointCount -> a
    geogebra.gui.util.SpecialNumberFormat nf -> a
    javax.swing.JButton btnHelp -> g
    java.util.ArrayList property -> g
    java.util.ArrayList value -> h
    java.util.ArrayList value2 -> i
    void createTabPanel() -> f
    void createHeaderPanel() -> h
    void createHelpPanel() -> i
    void createTabIntervalPanel() -> j
    void createTabPointPanel() -> k
    void createGUIElements() -> l
    void createBtnAddColumn() -> m
    void setLabels() -> e
    java.lang.String getTitleString() -> b
    void updateGUI() -> n
    void handleTabChange() -> o
    void updateIntervalFields() -> p
    void updateIntervalTable() -> q
    void updateXYTable() -> r
    void updateExtraColumns() -> s
    void addColumn(int) -> b
    void removeColumn() -> t
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void setVisible(boolean) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void repaintView() -> b
    void reset() -> g
    void clearView() -> d
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void defineDisplayGeos() -> u
    void updateTestPoint() -> v
    void clearGeoList() -> w
    void updateFonts() -> c
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void changeStart(double) -> a
    void updateIntervalGeoVisiblity() -> x
    geogebra.gui.util.SpecialNumberFormat getMyNumberFormat() -> a
    void changedNumberFormat() -> g_
    void createOptionsButton() -> y
    void doCopyToSpreadsheet() -> z
    void processCellGeo(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    int getViewID() -> a
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    boolean isShowing() -> isShowing
    void access$0(geogebra.gui.view.functioninspector.FunctionInspector) -> a
    void access$1(geogebra.gui.view.functioninspector.FunctionInspector) -> b
    geogebra.main.AppD access$2(geogebra.gui.view.functioninspector.FunctionInspector) -> a
    void access$3(geogebra.gui.view.functioninspector.FunctionInspector) -> c
geogebra.gui.view.functioninspector.FunctionInspector$1 -> geogebra.gui.n.d.b:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.functioninspector.FunctionInspector$2 -> geogebra.gui.n.d.c:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.view.functioninspector.FunctionInspector$3 -> geogebra.gui.n.d.d:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.functioninspector.FunctionInspector access$0(geogebra.gui.view.functioninspector.FunctionInspector$3) -> a
geogebra.gui.view.functioninspector.FunctionInspector$3$1 -> geogebra.gui.n.d.e:
    geogebra.gui.view.functioninspector.FunctionInspector$3 this$1 -> a
    void run() -> run
geogebra.gui.view.functioninspector.FunctionInspector$4 -> geogebra.gui.n.d.f:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.functioninspector.InspectorTable -> geogebra.gui.n.d.g:
    geogebra.main.AppD app -> a
    geogebra.gui.view.functioninspector.FunctionInspector inspector -> a
    boolean doRedNegative -> a
    java.util.HashSet editableCell -> a
    int tableType -> a
    boolean isDoRedNegative() -> a
    void setCellEditable(int,int) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    void setMyCellEditor(int) -> a
geogebra.gui.view.functioninspector.InspectorTable$MyCellRenderer -> geogebra.gui.n.d.g$a:
    javax.swing.JTextField tf -> a
    javax.swing.border.Border editCellBorder -> a
    javax.swing.JTable table -> a
    javax.swing.border.Border paddingBorder -> b
    boolean doRedNegative -> a
    geogebra.gui.view.functioninspector.InspectorTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
    java.awt.Color rowColor(int) -> a
geogebra.gui.view.functioninspector.InspectorTable$MyEditor -> geogebra.gui.n.d.g$b:
    geogebra.gui.view.functioninspector.InspectorTable this$0 -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    boolean stopCellEditing() -> stopCellEditing
geogebra.gui.view.opencsv.CSVParser -> geogebra.gui.n.e.a:
    char separator -> a
    char quotechar -> b
    char escape -> c
    boolean strictQuotes -> a
    java.lang.String pending -> a
    boolean inField -> d
    boolean ignoreLeadingWhiteSpace -> b
    boolean ignoreQuotations -> c
    boolean anyCharactersAreTheSame(char,char,char) -> a
    boolean isSameCharacter(char,char) -> a
    java.lang.String[] parseLineMulti(java.lang.String) -> a
    java.lang.String[] parseLine(java.lang.String,boolean) -> a
    boolean isNextCharacterEscapedQuote(java.lang.String,boolean,int) -> b
    boolean isNextCharacterEscapable(java.lang.String,boolean,int) -> a
    boolean isAllWhiteSpace(java.lang.CharSequence) -> a
geogebra.gui.view.probcalculator.ChiSquarePanel -> geogebra.gui.n.f.a:
    geogebra.main.AppD app -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator statCalc -> a
    geogebra.gui.view.probcalculator.StatisticsCalculatorProcessor statProcessor -> a
    geogebra.gui.view.probcalculator.StatisticsCollection sc -> a
    javax.swing.JPanel pnlCount -> a
    javax.swing.JPanel pnlControl -> b
    javax.swing.JComboBox cbRows -> a
    javax.swing.JComboBox cbColumns -> b
    geogebra.gui.view.probcalculator.ChiSquarePanel$ChiSquareCell[][] cell -> a
    javax.swing.JCheckBox ckExpected -> a
    javax.swing.JCheckBox ckChiDiff -> b
    javax.swing.JCheckBox ckRowPercent -> c
    javax.swing.JCheckBox ckColPercent -> d
    javax.swing.JLabel lblRows -> a
    javax.swing.JLabel lblColumns -> b
    boolean showColumnMargin -> a
    void setLabels() -> a
    void createGUI() -> c
    void createGUIElements() -> d
    void createControlPanel() -> e
    void createCountPanel() -> f
    void updateGUI() -> b
    void updateVisibility() -> g
    void updateCellContent() -> h
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    geogebra.main.AppD access$0(geogebra.gui.view.probcalculator.ChiSquarePanel) -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator access$1(geogebra.gui.view.probcalculator.ChiSquarePanel) -> a
geogebra.gui.view.probcalculator.ChiSquarePanel$ChiSquareCell -> geogebra.gui.n.f.a$a:
    geogebra.gui.view.probcalculator.StatisticsCollection sc -> a
    geogebra.gui.inputfield.MyTextField fldInput -> a
    javax.swing.JLabel[] label -> a
    boolean isMarginCell -> a
    boolean isHeaderCell -> b
    int row -> a
    int column -> b
    geogebra.gui.view.probcalculator.ChiSquarePanel this$0 -> a
    void setColumns(int) -> a
    void hideAllLabels() -> a
    void hideAll() -> b
    geogebra.gui.inputfield.MyTextField getInputField() -> a
    void setLabelText(int,java.lang.String) -> a
    void setLabelVisible(int,boolean) -> a
    void setMarginCell(boolean) -> a
    void setHeaderCell(boolean) -> b
    void setVisualStyle() -> c
    void updateCellData() -> d
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabilityCalculator -> geogebra.gui.n.f.b:
    boolean hasIntegral -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.probcalculator.ProbabilityManager probManager -> a
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar styleBar -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST selectedDist -> a
    java.lang.String[][] parameterLabels -> a
    double[] parameters -> a
    boolean isCumulative -> b
    java.util.HashMap distributionMap -> a
    java.util.HashMap reverseDistributionMap -> b
    java.util.ArrayList plotGeoList -> a
    geogebra.common.kernel.geos.GeoPoint lowPoint -> a
    geogebra.common.kernel.geos.GeoPoint highPoint -> b
    geogebra.common.kernel.geos.GeoPoint curvePoint -> c
    geogebra.common.kernel.geos.GeoElement densityCurve -> a
    geogebra.common.kernel.geos.GeoElement integral -> b
    geogebra.common.kernel.geos.GeoElement ySegment -> c
    geogebra.common.kernel.geos.GeoElement xSegment -> d
    geogebra.common.kernel.geos.GeoElement discreteGraph -> e
    geogebra.common.kernel.geos.GeoElement discreteIntervalGraph -> f
    geogebra.common.kernel.geos.GeoElement normalOverlay -> g
    geogebra.common.kernel.geos.GeoList discreteValueList -> a
    geogebra.common.kernel.geos.GeoList discreteProbList -> b
    geogebra.common.kernel.geos.GeoList intervalProbList -> c
    geogebra.common.kernel.geos.GeoList intervalValueList -> d
    java.util.ArrayList pointList -> b
    javax.swing.JComboBox comboDistribution -> a
    javax.swing.JComboBox comboProbType -> b
    javax.swing.JTextField[] fldParameterArray -> a
    javax.swing.JTextField fldLow -> a
    javax.swing.JTextField fldHigh -> b
    javax.swing.JTextField fldResult -> c
    javax.swing.JLabel[] lblParameterArray -> a
    javax.swing.JLabel lblBetween -> a
    javax.swing.JLabel lblProbOf -> b
    javax.swing.JLabel lblEndProbOf -> c
    javax.swing.JLabel lblProb -> d
    javax.swing.JLabel lblDist -> e
    geogebra.gui.view.probcalculator.ProbabilityCalculator$MyToggleButton btnCumulative -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator$MyToggleButton btnIntervalLeft -> b
    geogebra.gui.view.probcalculator.ProbabilityCalculator$MyToggleButton btnIntervalBetween -> c
    geogebra.gui.view.probcalculator.ProbabilityCalculator$MyToggleButton btnIntervalRight -> d
    javax.swing.JSlider[] sliderArray -> a
    geogebra.gui.util.ListSeparatorRenderer comboRenderer -> a
    javax.swing.JPanel controlPanel -> a
    javax.swing.JPanel tablePanel -> b
    javax.swing.JSplitPane mainSplitPane -> a
    javax.swing.JSplitPane plotSplitPane -> b
    int defaultDividerSize -> a
    geogebra.gui.view.data.PlotPanelEuclidianView plotPanel -> a
    geogebra.gui.view.data.PlotSettings plotSettings -> a
    geogebra.gui.view.probcalculator.ProbabilityTable table -> a
    boolean isIniting -> c
    boolean isSettingAxisPoints -> d
    int probMode -> b
    double low -> a
    double high -> b
    double probability -> c
    int printDecimals -> c
    int printFigures -> d
    boolean showProbGeos -> e
    boolean showNormalOverlay -> f
    java.awt.Color COLOR_PDF -> a
    java.awt.Color COLOR_NORMALOVERLAY -> b
    java.awt.Color COLOR_PDF_FILL -> c
    java.awt.Color COLOR_POINT -> d
    boolean removeFromConstruction -> g
    int graphTypePDF -> e
    int graphTypeCDF -> f
    int graphType -> g
    javax.swing.JToggleButton btnExport -> a
    javax.swing.JLabel lblMeanSigma -> f
    javax.swing.JPanel plotPanelPlus -> c
    javax.swing.JPanel probCalcPanel -> d
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator statCalculator -> a
    java.util.TreeSet tempSet -> a
    javax.swing.AbstractAction exportToEVAction -> a
    int[] $SWITCH_TABLE$geogebra$common$main$settings$ProbabilityCalculatorSettings$DIST -> a
    void setProbabilityCalculator(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[],boolean) -> a
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar getStyleBar() -> a
    geogebra.gui.view.probcalculator.ProbabilityManager getProbManager() -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST getSelectedDist() -> a
    int getProbMode() -> b
    boolean isCumulative() -> a
    void setCumulative(boolean) -> a
    void setGraphType(int) -> a
    int getGraphType() -> c
    int getPrintDecimals() -> d
    int getPrintFigures() -> e
    geogebra.gui.view.data.PlotSettings getPlotSettings() -> a
    void setPlotSettings(geogebra.gui.view.data.PlotSettings) -> a
    boolean isShowNormalOverlay() -> b
    void setShowNormalOverlay(boolean) -> b
    boolean isDistributionTabOpen() -> c
    void createLayoutPanels() -> n
    void buildProbCalcPanel() -> o
    void addRemoveTable(boolean) -> c
    geogebra.gui.util.ListSeparatorRenderer getComboRenderer() -> a
    void createGUIElements() -> p
    void createControlPanel() -> q
    void createGeoElements() -> r
    geogebra.common.kernel.geos.GeoElement createNormalCurveOverlay(double,double) -> a
    void updatePlotSettings() -> a
    void setXAxisPoints() -> c
    java.util.TreeSet getTempSet() -> a
    double intervalProbability() -> a
    double inverseProbability(double) -> a
    boolean isValidInterval(int,double,double) -> a
    boolean isValidParameter(double,int) -> a
    void updateFonts() -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateAll() -> f
    void updateGUI() -> s
    void updateIntervalProbability() -> t
    void updateProbabilityType() -> u
    void updateDistribution() -> h
    void updateDiscreteTable() -> v
    void updatePrintFormat(int,int) -> a
    void setInterval(double,double) -> a
    void setMeanSigma() -> i
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void clearView() -> d
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void repaintView() -> b
    void reset() -> g
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateRounding() -> w
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void attachView() -> j
    void detachView() -> k
    void setLabels() -> l
    void setLabelArrays() -> x
    void setProbabilityComboBoxMenu() -> y
    void setDistributionComboBoxMenu() -> z
    geogebra.common.kernel.geos.GeoElement createGeoFromString(java.lang.String,boolean) -> a
    void removeGeos() -> m
    void clearPlotGeoList() -> A
    void hideAllGeosFromViews() -> B
    void hideGeoFromViews(geogebra.common.kernel.geos.GeoElement) -> g
    void hideToolTips() -> C
    geogebra.common.kernel.geos.GeoFunction buildDensityCurveExpression(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST) -> a
    void createDiscreteLists() -> D
    double[] getPlotDimensions() -> a
    int getDiscreteXMax() -> f
    int getDiscreteXMin() -> g
    java.lang.String format(double) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void getXML(java.lang.StringBuilder) -> a
    void removeFromAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> a
    void exportGeosToEV(int) -> b
    int getViewID() -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    geogebra.gui.view.data.PlotPanelEuclidianView getPlotPanel() -> a
    geogebra.main.AppD access$0(geogebra.gui.view.probcalculator.ProbabilityCalculator) -> a
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar access$1(geogebra.gui.view.probcalculator.ProbabilityCalculator) -> a
    int[] $SWITCH_TABLE$geogebra$common$main$settings$ProbabilityCalculatorSettings$DIST() -> a
geogebra.gui.view.probcalculator.ProbabilityCalculator$1 -> geogebra.gui.n.f.c:
    geogebra.gui.view.probcalculator.ProbabilityCalculator this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabilityCalculator$2 -> geogebra.gui.n.f.d:
    geogebra.gui.view.probcalculator.ProbabilityCalculator this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.probcalculator.ProbabilityCalculator$MyToggleButton -> geogebra.gui.n.f.b$a:
    geogebra.gui.view.probcalculator.ProbabilityCalculator this$0 -> a
geogebra.gui.view.probcalculator.ProbabilityManager -> geogebra.gui.n.f.e:
    geogebra.main.AppD app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    int[] $SWITCH_TABLE$geogebra$common$main$settings$ProbabilityCalculatorSettings$DIST -> a
    boolean isDiscrete(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST) -> a
    java.util.HashMap getDistributionMap() -> a
    java.util.HashMap getReverseDistributionMap() -> b
    java.lang.String[][] getParameterLabelArray(geogebra.main.AppD) -> a
    geogebra.common.kernel.statistics.AlgoDistribution getInverseCommand(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.statistics.AlgoDistribution getCommand(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    int getParmCount(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST) -> a
    double[] getDefaultParameters(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST) -> a
    double[] getPlotDimensions(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[],geogebra.common.kernel.geos.GeoElement,boolean) -> a
    double getContXMax(geogebra.common.kernel.geos.GeoFunction,double,double,double) -> a
    java.lang.Double[] getDistributionMeasures(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[]) -> a
    double getDiscreteYMax(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[],int,int) -> a
    double probability(double,double[],geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,boolean) -> a
    double intervalProbability(double,double,geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[],int) -> a
    double inverseProbability(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double,double[]) -> a
    int[] $SWITCH_TABLE$geogebra$common$main$settings$ProbabilityCalculatorSettings$DIST() -> a
geogebra.gui.view.probcalculator.ProbabilityTable -> geogebra.gui.n.f.f:
    geogebra.main.AppD app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    geogebra.gui.view.probcalculator.ProbabilityManager probManager -> a
    geogebra.gui.view.data.StatTable statTable -> a
    java.lang.String[] columnNames -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST distType -> a
    int xMin -> a
    int xMax -> b
    boolean isIniting -> a
    double[] parms -> a
    void setTable(geogebra.common.main.settings.ProbabilityCalculatorSettings$DIST,double[],int,int) -> a
    boolean isCumulative() -> a
    void updateFonts(java.awt.Font) -> a
    void setColumnNames() -> a
    void setLabels() -> b
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void setSelectionByRowValue(int,int) -> a
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar -> geogebra.gui.n.f.g:
    geogebra.main.AppD app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    int iconHeight -> a
    javax.swing.JButton btnRounding -> a
    javax.swing.JPopupMenu roundingPopup -> a
    geogebra.gui.util.MyToggleButton btnCumulative -> a
    geogebra.gui.util.MyToggleButton btnLineGraph -> b
    geogebra.gui.util.MyToggleButton btnGrid -> c
    geogebra.gui.util.MyToggleButton btnStepGraph -> d
    geogebra.gui.util.MyToggleButton btnBarGraph -> e
    geogebra.gui.util.MyToggleButton btnExport -> f
    geogebra.gui.util.MyToggleButton btnNormalOverlay -> g
    void createGUI() -> d
    void updateLayout() -> a
    void updateGUI() -> b
    void setLabels() -> c
    void buildOptionsButton() -> e
    void updateMenuDecimalPlaces(javax.swing.JPopupMenu) -> a
    javax.swing.JPopupMenu createRoundingPopup() -> a
    void addRadioButtonMenuItems(javax.swing.JPopupMenu,java.awt.event.ActionListener,java.lang.String[],java.lang.String[],int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$1 -> geogebra.gui.n.f.h:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$2 -> geogebra.gui.n.f.i:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$3 -> geogebra.gui.n.f.j:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.StatisticsCalculator -> geogebra.gui.n.f.k:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.probcalculator.StatisticsCollection sc -> a
    geogebra.gui.view.probcalculator.StatisticsCalculatorProcessor statProcessor -> a
    geogebra.gui.view.probcalculator.StatisticsCalculatorHTML statHTML -> a
    geogebra.gui.inputfield.MyTextField[] fldSampleStat1 -> a
    geogebra.gui.inputfield.MyTextField[] fldSampleStat2 -> b
    geogebra.gui.inputfield.MyTextField fldNullHyp -> a
    geogebra.gui.inputfield.MyTextField fldConfLevel -> b
    geogebra.gui.inputfield.MyTextField fldSigma -> c
    int fieldWidth -> a
    javax.swing.JLabel[] lblSampleStat1 -> a
    javax.swing.JLabel[] lblSampleStat2 -> b
    javax.swing.JLabel lblResult -> a
    javax.swing.JLabel lblHypParameter -> b
    javax.swing.JLabel lblTailType -> c
    javax.swing.JLabel lblNull -> d
    javax.swing.JLabel lblConfLevel -> e
    javax.swing.JLabel lblSigma -> f
    javax.swing.JLabel lblSampleHeader1 -> g
    javax.swing.JLabel lblSampleHeader2 -> h
    javax.swing.JRadioButton btnLeft -> a
    javax.swing.JRadioButton btnRight -> b
    javax.swing.JRadioButton btnTwo -> c
    javax.swing.JButton btnCalculate -> a
    javax.swing.JComboBox cbProcedure -> a
    javax.swing.JCheckBox ckPooled -> a
    javax.swing.JPanel panelBasicProcedures -> a
    javax.swing.JPanel panelControl -> b
    javax.swing.JPanel panelSample1 -> c
    javax.swing.JPanel panelSample2 -> d
    javax.swing.JPanel panelTestAndCI -> e
    geogebra.gui.view.probcalculator.ChiSquarePanel panelChiSquare -> a
    javax.swing.JEditorPane resultPane -> a
    javax.swing.JScrollPane scroller -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure selectedProcedure -> a
    java.util.HashMap mapNameToProcedure -> a
    java.util.HashMap mapProcedureToName -> b
    java.lang.StringBuilder bodyText -> a
    java.lang.String strMean -> a
    java.lang.String strSD -> b
    java.lang.String strSigma -> c
    java.lang.String strSuccesses -> d
    java.lang.String strN -> e
    java.lang.String strPooled -> f
    double[] s1 -> a
    double[] s2 -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure getSelectedProcedure() -> a
    java.util.HashMap getMapProcedureToName() -> a
    geogebra.gui.view.probcalculator.StatisticsCalculatorProcessor getStatProcessor() -> a
    geogebra.gui.view.probcalculator.StatisticsCollection getStatististicsCollection() -> a
    void createGUI() -> c
    void createControlPanel() -> d
    void setInputPanelLayout() -> e
    void createGUIElements() -> f
    void setLabels() -> a
    void setHypParameterLabel() -> g
    void setProcedureComboLabels() -> h
    void setLabelStrings() -> i
    void setSampleFieldLabels() -> j
    void setSampleFieldText() -> k
    void updateGUI() -> l
    void setPanelLayout() -> m
    void updateResult() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.awt.event.ActionEvent) -> a
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    double parseNumberText(java.lang.String) -> a
    void updateStatisticCollection() -> n
    java.lang.String format(double) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts(java.awt.Font) -> a
    void setStyleSheetFontSize(javax.swing.text.html.HTMLEditorKit,java.awt.Font) -> a
    void setStyleSheets(javax.swing.text.html.HTMLEditorKit) -> a
    void updateResultText() -> o
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure() -> a
    javax.swing.JScrollPane access$1(geogebra.gui.view.probcalculator.StatisticsCalculator) -> a
geogebra.gui.view.probcalculator.StatisticsCalculator$1 -> geogebra.gui.n.f.l:
    geogebra.gui.view.probcalculator.StatisticsCalculator this$0 -> a
    void run() -> run
geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure -> geogebra.gui.n.f.k$a:
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZMEAN_TEST -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZMEAN2_TEST -> b
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure TMEAN_TEST -> c
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure TMEAN2_TEST -> d
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZPROP_TEST -> e
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZPROP2_TEST -> f
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZMEAN_CI -> g
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZMEAN2_CI -> h
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure TMEAN_CI -> i
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure TMEAN2_CI -> j
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZPROP_CI -> k
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure ZPROP2_CI -> l
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure GOF_TEST -> m
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure CHISQ_TEST -> n
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure[] ENUM$VALUES -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure[] values() -> values
    geogebra.gui.view.probcalculator.StatisticsCalculator$Procedure valueOf(java.lang.String) -> valueOf
geogebra.gui.view.probcalculator.StatisticsCalculatorHTML -> geogebra.gui.n.f.m:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator statCalc -> a
    geogebra.gui.view.probcalculator.StatisticsCollection sc -> a
    java.lang.String strSample1 -> a
    java.lang.String strSample2 -> b
    java.lang.String strMean -> c
    java.lang.String strSD -> d
    java.lang.String strSigma -> e
    java.lang.String strSuccesses -> f
    java.lang.String strN -> g
    java.lang.String strSE -> h
    java.lang.String strDF -> i
    java.lang.String strUpper -> j
    java.lang.String strLower -> k
    java.lang.String strInterval -> l
    java.lang.String strP -> m
    java.lang.String strChiSq -> n
    java.lang.String strZ -> o
    java.lang.String strT -> p
    java.lang.String strPooled -> q
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure -> a
    java.lang.String format(double) -> a
    void setLabelStrings() -> a
    java.lang.StringBuilder getStatString() -> a
    java.lang.String isPooled() -> a
    java.lang.String getInterval(double,double) -> a
    java.lang.StringBuilder htmlTable(java.lang.String[][],boolean) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure() -> a
geogebra.gui.view.probcalculator.StatisticsCalculatorProcessor -> geogebra.gui.n.f.n:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.probcalculator.StatisticsCalculator statCalc -> a
    geogebra.gui.view.probcalculator.StatisticsCollection sc -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric n2 -> b
    geogebra.common.kernel.geos.GeoNumeric mean -> c
    geogebra.common.kernel.geos.GeoNumeric mean2 -> d
    geogebra.common.kernel.geos.GeoNumeric sd -> e
    geogebra.common.kernel.geos.GeoNumeric sd2 -> f
    geogebra.common.kernel.geos.GeoNumeric proportion -> g
    geogebra.common.kernel.geos.GeoNumeric proportion2 -> h
    geogebra.common.kernel.geos.GeoNumeric nullHyp -> i
    geogebra.common.kernel.geos.GeoNumeric level -> j
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoBoolean pooled -> a
    java.util.ArrayList geos -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution chisquared -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure -> a
    void createGeos() -> b
    void updateGeoValues() -> c
    void doCalculate() -> a
    void updateChiSq() -> d
    void updateGOF() -> e
    org.apache.commons.math.distribution.ChiSquaredDistribution getChiSquaredDistribution(double) -> a
    double parseStringData(java.lang.String) -> a
    void setTestResults(geogebra.common.kernel.geos.GeoElement) -> a
    void setIntervalResults(geogebra.common.kernel.geos.GeoElement) -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$probcalculator$StatisticsCalculator$Procedure() -> a
geogebra.gui.view.probcalculator.StatisticsCollection -> geogebra.gui.n.f.o:
    double mean -> a
    double mean2 -> b
    double sd -> c
    double sd2 -> d
    double nullHyp -> e
    double me -> f
    double lower -> g
    double upper -> h
    double se -> i
    double testStat -> j
    double P -> k
    double df -> l
    double level -> m
    double n -> n
    double n2 -> o
    double count -> p
    double count2 -> q
    double total -> r
    java.lang.String tail -> a
    boolean pooled -> a
    java.lang.String[][] chiSquareData -> a
    int rows -> a
    int columns -> b
    double[][] observed -> a
    double[][] expected -> b
    double[][] diff -> c
    double[] columnSum -> a
    double[] rowSum -> b
    void setChiSqData(int,int) -> a
    double getProportion() -> a
    double getProportion2() -> b
    void validate() -> a
geogebra.gui.view.properties.PropertiesStyleBarD -> geogebra.gui.n.g.a:
    geogebra.common.gui.view.properties.PropertiesView propertiesView -> a
    geogebra.main.AppD app -> a
    geogebra.gui.util.PopupMenuButton btnOption -> a
    javax.swing.JPopupMenu menu -> a
    javax.swing.JToolBar toolbar -> a
    javax.swing.JPanel wrappedPanel -> a
    java.util.HashMap buttonMap -> a
    javax.swing.AbstractButton objectButton -> a
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType -> a
    void buildGUI() -> a
    geogebra.gui.util.PopupMenuButton getBtnOption() -> a
    void updateGUI() -> b
    void buildMenu() -> c
    void setLabels() -> d
    void setObjectsToolTip() -> e
    void setObjectButtonEnable(boolean) -> a
    javax.swing.ImageIcon getTypeIcon(geogebra.common.main.OptionType) -> a
    javax.swing.JPanel getWrappedPanel() -> a
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType() -> a
geogebra.gui.view.properties.PropertiesStyleBarD$1 -> geogebra.gui.n.g.b:
    geogebra.gui.view.properties.PropertiesStyleBarD this$0 -> a
    geogebra.common.main.OptionType val$type -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.properties.PropertiesStyleBarD$2 -> geogebra.gui.n.g.c:
    geogebra.gui.view.properties.PropertiesStyleBarD this$0 -> a
    geogebra.common.main.OptionType val$type -> a
    javax.swing.JMenuItem val$mi -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.properties.PropertiesStyleBarD$PropertiesButton -> geogebra.gui.n.g.a$a:
    javax.swing.JToolTip tip -> a
    geogebra.gui.view.properties.PropertiesStyleBarD this$0 -> a
    javax.swing.JToolTip createToolTip() -> createToolTip
    java.awt.Point getToolTipLocation(java.awt.event.MouseEvent) -> getToolTipLocation
geogebra.gui.view.properties.PropertiesStyleBarD$ToolTipMouseAdapter -> geogebra.gui.n.g.a$b:
    int defaultInitialDelay -> a
    boolean preventToolTipDelay -> a
    geogebra.gui.view.properties.PropertiesStyleBarD this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.properties.PropertiesViewD -> geogebra.gui.n.g.d:
    geogebra.gui.view.properties.PropertiesStyleBarD styleBar -> a
    javax.swing.JPanel wrappedPanel -> a
    geogebra.gui.dialog.options.OptionsDefaultsD defaultsPanel -> a
    geogebra.gui.dialog.options.OptionsEuclidianD euclidianPanel -> a
    geogebra.gui.dialog.options.OptionsEuclidianD euclidianPanel2 -> b
    geogebra.gui.dialog.options.OptionsSpreadsheetD spreadsheetPanel -> a
    geogebra.gui.dialog.options.OptionsCASD casPanel -> a
    geogebra.gui.dialog.options.OptionsAdvancedD advancedPanel -> a
    geogebra.gui.dialog.options.OptionsLayoutD layoutPanel -> a
    java.lang.Object selectedOptionPanel -> a
    javax.swing.JPanel mainPanel -> b
    boolean isIniting -> b
    int mode -> a
    int selectedTab -> b
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$Construction$Constants -> b
    void initGUI() -> c
    void updatePropertiesView() -> e
    void updatePropertiesViewCheckConstants(java.util.ArrayList) -> b
    void updatePropertiesView(java.util.ArrayList) -> c
    void setOptionPanelRegardingFocus(boolean) -> c
    void mousePressedForPropertiesView() -> f
    void mouseReleasedForPropertiesView(boolean) -> a
    void setOptionPanel(geogebra.common.main.OptionType) -> a
    void applyModifications() -> h
    void setSelectedOptionPanelVisible(boolean) -> b
    void setOptionPanel(geogebra.common.main.OptionType,java.util.ArrayList) -> a
    void setOptionPanelWithoutCheck(geogebra.common.main.OptionType) -> b
    void updateEuclidianPanelsGUI() -> i
    geogebra.gui.dialog.options.OptionPanelD getOptionPanel(geogebra.common.main.OptionType) -> a
    geogebra.common.gui.view.properties.PropertiesStyleBar getStyleBar() -> a
    geogebra.gui.view.properties.PropertiesStyleBarD newPropertiesStyleBar() -> a
    void setLabels() -> j
    void updateStyleBar() -> s
    void updateTitleBar() -> k
    void attachView() -> l
    void detachView() -> m
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void repaintView() -> b
    void reset() -> g
    void clearView() -> d
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    int getViewID() -> a
    void updateSelection() -> a
    void updateSelection(java.util.ArrayList) -> a
    boolean stayInCurrentPanel() -> a
    void setObjectPanel(java.util.ArrayList) -> d
    void updateObjectPanelSelection(java.util.ArrayList) -> e
    void updateSelectedTab(geogebra.common.kernel.Construction$Constants) -> a
    java.util.ArrayList removeAllConstants(java.util.ArrayList) -> a
    void windowPanel() -> n
    void unwindowPanel() -> o
    void closeDialog() -> p
    void showSliderTab() -> q
    boolean hasFocus() -> hasFocus
    javax.swing.JPanel getWrappedPanel() -> a
    javax.swing.ImageIcon getTypeIcon(geogebra.main.AppD,geogebra.common.main.OptionType) -> a
    void updateFonts() -> r
    void repaint() -> repaint
    boolean isShowing() -> isShowing
    int[] $SWITCH_TABLE$geogebra$common$main$OptionType() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$Construction$Constants() -> b
geogebra.gui.view.spreadsheet.CopyPasteCutD -> geogebra.gui.n.h.a:
    void copy(int,int,int,int,boolean) -> a
    boolean paste(int,int,int,int) -> e
    boolean paste(int,int,int,int,java.awt.datatransfer.Transferable) -> a
    boolean pasteFromURL(java.net.URL) -> a
    boolean pasteFromURL(java.net.URL,geogebra.common.gui.view.spreadsheet.CellRange,boolean) -> a
    java.lang.String getExtension(java.lang.String) -> a
geogebra.gui.view.spreadsheet.CreateObjectDialog -> geogebra.gui.n.h.b:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor cp -> a
    java.util.ArrayList selectedCellRanges -> b
    int selectionType -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    int objectType -> b
    javax.swing.JList typeList -> a
    javax.swing.DefaultListModel model -> a
    javax.swing.JLabel lblObject -> b
    javax.swing.JLabel lblName -> c
    javax.swing.JLabel lblTake -> d
    javax.swing.JLabel lblOrder -> e
    javax.swing.JLabel lblXYOrder -> f
    javax.swing.JCheckBox ckSort -> b
    javax.swing.JCheckBox ckTranspose -> c
    javax.swing.JRadioButton btnValue -> a
    javax.swing.JRadioButton btnObject -> b
    javax.swing.JComboBox cbScanOrder -> a
    javax.swing.JComboBox cbTake -> b
    boolean isIniting -> a
    javax.swing.JPanel optionsPanel -> e
    javax.swing.JPanel typePanel -> f
    geogebra.gui.inputfield.MyTextField fldName -> a
    geogebra.common.kernel.geos.GeoElement newGeo -> b
    javax.swing.JScrollPane previewPanel -> a
    java.lang.String title -> c
    boolean keepNewGeo -> b
    javax.swing.JComboBox cbLeftRightOrder -> c
    javax.swing.JPanel cards -> g
    javax.swing.JLabel lblPreview -> g
    javax.swing.JPanel namePanel -> h
    void createAdditionalGUI() -> b
    void buildOptionsPanel() -> d
    void setLabels(java.lang.String) -> c
    void updateGUI() -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void setVisible(boolean) -> a
    void addNewGeoToConstruction() -> f
    void createNewGeo() -> g
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.view.spreadsheet.DataImport -> geogebra.gui.n.h.c:
    geogebra.gui.view.opencsv.CSVParser commaParser -> a
    geogebra.gui.view.opencsv.CSVParser tabParser -> b
    java.awt.datatransfer.DataFlavor HTMLflavor -> a
    boolean hasHTMLFlavor(java.awt.datatransfer.Transferable) -> a
    java.lang.String convertTransferableToString(java.awt.datatransfer.Transferable) -> a
    java.lang.String convertHTMLTableToCSV(java.lang.String) -> a
    java.lang.String[][] parseExternalData(geogebra.common.main.App,java.lang.String,java.lang.String[],boolean) -> a
    geogebra.gui.view.opencsv.CSVParser getCommaParser() -> a
    geogebra.gui.view.opencsv.CSVParser getTabParser() -> b
    java.lang.String[][] parseCSVdata(java.lang.String) -> b
    java.lang.String[][] parseTabData(java.lang.String) -> a
    java.lang.String adjustNumberString(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String[] getDefaultSeparators(geogebra.common.main.App) -> a
geogebra.gui.view.spreadsheet.DataImport$1 -> geogebra.gui.n.h.d:
    boolean foundTable -> a
    boolean firstInRow -> b
    boolean firstColumn -> c
    boolean finished -> d
    java.lang.StringBuilder val$sbHTML -> a
    void handleText(char[],int) -> handleText
    void handleStartTag(javax.swing.text.html.HTML$Tag,javax.swing.text.MutableAttributeSet,int) -> handleStartTag
geogebra.gui.view.spreadsheet.DialogCopyToSpreadsheet -> geogebra.gui.n.h.e:
    geogebra.gui.view.spreadsheet.SpreadsheetViewDnD dndHandler -> a
    geogebra.main.AppD app -> a
    javax.swing.JButton btnCancel -> a
    javax.swing.JButton btnCopy -> b
    javax.swing.JRadioButton rbFree -> a
    javax.swing.JRadioButton rbDependent -> b
    javax.swing.JCheckBox ckTranspose -> a
    void createGUI() -> b
    void createGUIElements() -> c
    void setLabels() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> setVisible
geogebra.gui.view.spreadsheet.FileBrowserPanel -> geogebra.gui.n.h.f:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel browserPanel -> a
    javax.swing.JTree tree -> a
    javax.swing.tree.DefaultTreeModel treeModel -> a
    geogebra.common.io.QDParser xmlParser -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel$MyFileTreeHandler handler -> a
    java.lang.Object root -> a
    java.io.File rootFile -> a
    java.net.URL rootURL -> a
    javax.swing.JButton minimizeButton -> a
    javax.swing.JButton menuButton -> b
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    int mode -> a
    java.lang.Object getRoot() -> a
    java.lang.String getRootString() -> a
    boolean setRoot(java.lang.String,int) -> a
    void setRoot(java.lang.Object,int) -> a
    boolean loadRootDirectory() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void updateFonts() -> a
    void addFileTree(javax.swing.tree.DefaultMutableTreeNode,java.io.File) -> a
    void sortFileList(java.io.File[]) -> a
    java.io.File getFileFromPath(javax.swing.tree.TreePath) -> a
    java.net.URL getURLFromPath(javax.swing.tree.TreePath) -> a
    void saveXMLTree(java.io.File) -> a
    java.lang.StringBuilder buildXMLFileTree(java.io.File) -> a
    void traverseDirectory(java.io.File,java.lang.StringBuilder) -> a
    javax.swing.ImageIcon dropDownIcon(javax.swing.ImageIcon,java.awt.Color) -> a
    geogebra.main.AppD access$0(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    java.io.File access$1(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    void access$2(geogebra.gui.view.spreadsheet.FileBrowserPanel,java.io.File) -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel access$3(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView access$4(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    int access$5(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$1 -> geogebra.gui.n.h.g:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra.gui.view.spreadsheet.FileBrowserPanel$2 -> geogebra.gui.n.h.h:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.view.spreadsheet.FileBrowserPanel$3 -> geogebra.gui.n.h.i:
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.view.spreadsheet.FileBrowserPanel$DataFileFilter -> geogebra.gui.n.h.f$a:
    boolean accept(java.io.File,java.lang.String) -> accept
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu -> geogebra.gui.n.h.f$b:
    javax.swing.JMenuItem menuItem -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel access$0(geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu) -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$1 -> geogebra.gui.n.h.j:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$2 -> geogebra.gui.n.h.k:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$3 -> geogebra.gui.n.h.l:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$MyFileTreeHandler -> geogebra.gui.n.h.f$c:
    javax.swing.tree.DefaultMutableTreeNode previousNode -> a
    javax.swing.tree.DefaultMutableTreeNode currentNode -> b
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    javax.swing.tree.DefaultMutableTreeNode getFileTree() -> a
    void startDocument() -> a
    void endDocument() -> b
    void text(java.lang.String) -> b
    int getConsStep() -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$MyRenderer -> geogebra.gui.n.h.f$d:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
geogebra.gui.view.spreadsheet.FormulaBar -> geogebra.gui.n.h.m:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    javax.swing.JButton btnCancelFormula -> a
    javax.swing.JButton btnAcceptFormula -> b
    geogebra.gui.inputfield.AutoCompleteTextFieldD fldFormula -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD fldCellName -> b
    boolean isIniting -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    int row -> a
    int column -> b
    javax.swing.event.DocumentListener documentListener -> a
    void setEditorText(java.lang.String) -> a
    void update() -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
    boolean editorHasFocus() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView access$0(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD access$1(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    javax.swing.JButton access$2(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    javax.swing.JButton access$3(geogebra.gui.view.spreadsheet.FormulaBar) -> b
    geogebra.gui.view.spreadsheet.MyCellEditor access$4(geogebra.gui.view.spreadsheet.FormulaBar) -> a
geogebra.gui.view.spreadsheet.FormulaBar$1 -> geogebra.gui.n.h.n:
    geogebra.gui.view.spreadsheet.FormulaBar this$0 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void updateCellEditor(javax.swing.event.DocumentEvent) -> a
geogebra.gui.view.spreadsheet.FormulaBar$BarButtonListener -> geogebra.gui.n.h.m$a:
    geogebra.gui.view.spreadsheet.FormulaBar this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.spreadsheet.InputDialogOpenDataFolderURL -> geogebra.gui.n.h.o:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    void setLabels(java.lang.String) -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
geogebra.gui.view.spreadsheet.MyCellEditor -> geogebra.gui.n.h.p:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.geos.GeoElement value -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD textField -> a
    int column -> a
    int row -> b
    boolean editing -> a
    boolean errorOnStopEditing -> b
    boolean allowProcessGeo -> c
    boolean enableAutoComplete -> d
    int tabReturnCol -> c
    void setAllowProcessGeo(boolean) -> a
    void setEnableAutoComplete(boolean) -> b
    void setText(java.lang.String) -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    void setEqualsRequired(boolean) -> c
    void setLabels() -> a
    java.lang.String getEditorInitString(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isEditing() -> a
    int getCaretPosition() -> a
    void addLabel(java.lang.String) -> b
    void setLabel(java.lang.String) -> c
    java.lang.String getEditingValue() -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    void cancelCellEditing() -> cancelCellEditing
    boolean stopCellEditing() -> stopCellEditing
    boolean stopCellEditing(int,int) -> a
    void moveSelectedCell(int,int) -> a
    boolean processGeo() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    javax.swing.DefaultCellEditor$EditorDelegate access$0(geogebra.gui.view.spreadsheet.MyCellEditor) -> a
    void access$1(geogebra.gui.view.spreadsheet.MyCellEditor,boolean) -> a
    geogebra.gui.inputfield.AutoCompleteTextFieldD access$2(geogebra.gui.view.spreadsheet.MyCellEditor) -> a
geogebra.gui.view.spreadsheet.MyCellEditor$1 -> geogebra.gui.n.h.q:
    geogebra.gui.view.spreadsheet.MyCellEditor this$0 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void updateFormulaBar(javax.swing.event.DocumentEvent) -> a
geogebra.gui.view.spreadsheet.MyCellEditor$SpreadsheetCellEditorKeyListener -> geogebra.gui.n.h.p$a:
    boolean isFormulaBarListener -> a
    geogebra.gui.view.spreadsheet.MyCellEditor this$0 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void checkCursorKeys(java.awt.event.KeyEvent) -> a
geogebra.gui.view.spreadsheet.MyCellEditorBoolean -> geogebra.gui.n.h.r:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.geos.GeoBoolean editGeo -> a
    javax.swing.JCheckBox checkBox -> a
    boolean editing -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    boolean stopCellEditing() -> stopCellEditing
geogebra.gui.view.spreadsheet.MyCellEditorButton -> geogebra.gui.n.h.s:
    javax.swing.JButton delegate -> a
    geogebra.common.kernel.geos.GeoButton editGeo -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    geogebra.common.kernel.geos.GeoButton access$0(geogebra.gui.view.spreadsheet.MyCellEditorButton) -> a
geogebra.gui.view.spreadsheet.MyCellEditorButton$1 -> geogebra.gui.n.h.t:
    geogebra.gui.view.spreadsheet.MyCellEditorButton this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.spreadsheet.MyCellEditorButton access$0(geogebra.gui.view.spreadsheet.MyCellEditorButton$1) -> a
geogebra.gui.view.spreadsheet.MyCellEditorButton$1$1 -> geogebra.gui.n.h.u:
    geogebra.gui.view.spreadsheet.MyCellEditorButton$1 this$1 -> a
    void run() -> run
geogebra.gui.view.spreadsheet.MyCellEditorList -> geogebra.gui.n.h.v:
    geogebra.common.kernel.geos.GeoList editGeo -> a
    javax.swing.JComboBox comboBox -> a
    javax.swing.DefaultComboBoxModel model -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.Object getCellEditorValue() -> getCellEditorValue
geogebra.gui.view.spreadsheet.MyCellEditorList$MyListCellRenderer -> geogebra.gui.n.h.v$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.MyCellRenderer -> geogebra.gui.n.h.w:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.ImageIcon latexIcon -> a
    javax.swing.ImageIcon emptyIcon -> b
    java.lang.String latexStr -> a
    geogebra.common.gui.view.spreadsheet.CellFormat formatHandler -> a
    geogebra.common.awt.GPoint cellPoint -> a
    java.lang.Integer alignment -> a
    java.lang.Integer traceBorder -> b
    java.lang.Integer fontStyle -> c
    boolean isCustomBGColor -> a
    javax.swing.border.Border cellPadding -> a
    javax.swing.border.Border bTop -> b
    javax.swing.border.Border bLeft -> c
    javax.swing.border.Border bBottom -> d
    javax.swing.border.Border bRight -> e
    javax.swing.border.Border bAll -> f
    javax.swing.JCheckBox checkBox -> a
    javax.swing.JButton button -> a
    javax.swing.JComboBox comboBox -> a
    javax.swing.DefaultComboBoxModel cbModel -> a
    java.awt.Color bgColor -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.MyCellRenderer$MyListCellRenderer -> geogebra.gui.n.h.w$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.MyTableD -> geogebra.gui.n.h.x:
    int tableMode -> l
    java.awt.Color SELECTED_BACKGROUND_COLOR -> a
    java.awt.Color SELECTED_BACKGROUND_COLOR_HEADER -> b
    java.awt.Color BACKGROUND_COLOR_HEADER -> c
    java.awt.Color TABLE_GRID_COLOR -> d
    java.awt.Color HEADER_GRID_COLOR -> e
    java.awt.Color SELECTED_RECTANGLE_COLOR -> f
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    geogebra.gui.view.spreadsheet.MyCellEditorBoolean editorBoolean -> a
    geogebra.gui.view.spreadsheet.MyCellEditorButton editorButton -> a
    geogebra.gui.view.spreadsheet.MyCellEditorList editorList -> a
    geogebra.common.gui.view.spreadsheet.RelativeCopy relativeCopy -> a
    geogebra.gui.view.spreadsheet.CopyPasteCutD copyPasteCut -> a
    geogebra.gui.view.spreadsheet.SpreadsheetColumnController$ColumnHeaderRenderer headerRenderer -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.table.DefaultTableModel tableModel -> a
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor crProcessor -> a
    geogebra.gui.view.spreadsheet.MyTableD$MyTableColumnModelListener columnModelListener -> a
    geogebra.common.gui.view.spreadsheet.CellFormat formatHandler -> a
    geogebra.common.kernel.geos.GeoElement targetCell -> a
    java.util.ArrayList selectedCellRanges -> a
    int minSelectionRow -> a
    int maxSelectionRow -> b
    int minSelectionColumn -> c
    int maxSelectionColumn -> d
    java.util.HashSet selectedColumnSet -> a
    java.util.HashSet selectedRowSet -> b
    int selectionType -> m
    boolean doShowDragHandle -> f
    java.awt.Color selectionRectangleColor -> g
    boolean isDragingDot -> a
    int dragingToRow -> e
    int dragingToColumn -> f
    boolean isOverDot -> b
    boolean isDragging2 -> c
    int minColumn2 -> g
    int maxColumn2 -> h
    int minRow2 -> i
    int maxRow2 -> j
    boolean isOverDnDRegion -> d
    boolean metaDown -> e
    java.util.HashSet cellResizeHeightSet -> c
    java.util.HashSet cellResizeWidthSet -> d
    java.util.ArrayList adjustedRowHeights -> b
    boolean doRecordRowHeights -> g
    int preferredColumnWidth -> k
    java.util.HashMap oneClickEditMap -> a
    java.awt.Cursor defaultCursor -> a
    java.awt.Cursor crossHairCursor -> b
    java.awt.Cursor handCursor -> c
    java.awt.Cursor grabbingCursor -> d
    java.awt.Cursor grabCursor -> e
    boolean isSelectAll -> h
    boolean isSelectNone -> i
    java.awt.Rectangle targetcellFrame -> a
    float[] dash1 -> a
    java.awt.BasicStroke dashed -> a
    boolean allowEditing -> j
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    java.util.ArrayList getSelectedCellRanges() -> a
    java.util.HashMap getOneClickEditMap() -> a
    geogebra.common.gui.view.spreadsheet.CopyPasteCut getCopyPasteCut() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.main.App getApplication() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView getView() -> a
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor getCellRangeProcessor() -> a
    geogebra.common.gui.view.spreadsheet.CellFormatInterface getCellFormatHandler() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorBoolean getEditorBoolean() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorButton getEditorButton() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorList getEditorList() -> a
    void updateColumnCount() -> b
    javax.swing.table.TableCellEditor getCellEditor(int,int) -> getCellEditor
    void setEnableAutoComplete(boolean) -> a
    void setEqualsRequired(boolean) -> b
    void setLabels() -> c
    int preferredColumnWidth() -> b
    void setPreferredColumnWidth(int) -> a
    void changeSelection(int,int,boolean,boolean) -> changeSelection
    void selectAll() -> selectAll
    void selectionChanged() -> a
    void setInitialCellSelection(int,int) -> a
    boolean setSelection(java.lang.String) -> a
    boolean setSelection(int,int) -> a
    boolean setSelection(int,int,int,int) -> a
    boolean setSelection(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void setSelectionType(int) -> b
    int getSelectionType() -> a
    void setRowSelectionInterval(int,int) -> setRowSelectionInterval
    void setColumnSelectionInterval(int,int) -> setColumnSelectionInterval
    boolean isSelectNone() -> b
    void setSelectNone(boolean) -> c
    boolean isSelectAll() -> a
    void setSelectAll(boolean) -> d
    java.util.ArrayList getSelectedColumnsList() -> b
    int[] getSelectedColumns() -> getSelectedColumns
    void setSelectionRectangleColor(java.awt.Color) -> a
    geogebra.common.awt.GPoint getPixel(int,int,boolean) -> a
    geogebra.common.awt.GPoint getMinSelectionPixel() -> a
    geogebra.common.awt.GPoint getMaxSelectionPixel() -> b
    geogebra.common.awt.GPoint getIndexFromPixel(int,int) -> a
    java.awt.Rectangle getCellBlockRect(int,int,int,int,boolean) -> a
    java.awt.Rectangle getSelectionRect(boolean) -> a
    void setTargetcellFrame(java.awt.Rectangle) -> a
    void paint(java.awt.Graphics) -> paint
    boolean editCellAt(int,int) -> editCellAt
    void handleControlDragSelect(java.awt.event.MouseEvent) -> a
    int convertColumnIndexToModel(int) -> convertColumnIndexToModel
    void setAllowEditing(boolean) -> e
    boolean isCellEditable(int,int) -> isCellEditable
    void updateEditor(java.lang.String) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setRowHeight(int,int) -> setRowHeight
    void setRowHeight(int) -> setRowHeight
    void resetRowHeights() -> d
    void resizeMarkedCells() -> e
    void setPreferredCellSize(int,int,boolean,boolean) -> a
    void fitColumn(int) -> c
    void fitRow(int) -> d
    void fitAll(boolean,boolean) -> a
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    int getTableMode() -> c
    void setTableMode(int) -> e
    boolean initAutoFunction() -> c
    void performAutoFunctionCreation(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void stopAutoFunction() -> f
    boolean createAutoFunctionCell(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void updateAutoFunction() -> g
    void copy(boolean) -> f
    boolean paste() -> d
    boolean cut() -> e
    boolean delete() -> f
    java.awt.Cursor createCursor(java.awt.Image,boolean) -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetViewInterface getView() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.gui.view.spreadsheet.MyTableD$MyTableColumnModelListener -> geogebra.gui.n.h.x$a:
    geogebra.gui.view.spreadsheet.MyTableD this$0 -> a
    void columnMarginChanged(javax.swing.event.ChangeEvent) -> columnMarginChanged
    void columnAdded(javax.swing.event.TableColumnModelEvent) -> columnAdded
    void columnMoved(javax.swing.event.TableColumnModelEvent) -> columnMoved
    void columnRemoved(javax.swing.event.TableColumnModelEvent) -> columnRemoved
    void columnSelectionChanged(javax.swing.event.ListSelectionEvent) -> columnSelectionChanged
geogebra.gui.view.spreadsheet.MyTableD$MyTableModelListener -> geogebra.gui.n.h.x$b:
    geogebra.gui.view.spreadsheet.MyTableD this$0 -> a
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.gui.view.spreadsheet.SpreadsheetBorders -> geogebra.gui.n.h.y:
    void drawFormatBorders(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTableD) -> a
    void handleRowOrColumnGridFormat(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTableD,int,int,byte) -> a
    void drawPartialBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTableD,int,int,int,int,byte) -> a
    void drawRowBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTableD,int) -> a
    void drawColumnBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTableD,int) -> b
    boolean isZeroBit(int,int) -> a
geogebra.gui.view.spreadsheet.SpreadsheetColumnController -> geogebra.gui.n.h.z:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    javax.swing.table.DefaultTableModel model -> a
    int column0 -> a
    boolean isResizing -> a
    int overTraceButtonColumn -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    geogebra.main.AppD access$0(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
    int access$1(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
    geogebra.gui.view.spreadsheet.MyTableD access$2(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
geogebra.gui.view.spreadsheet.SpreadsheetColumnController$ColumnHeaderRenderer -> geogebra.gui.n.h.z$a:
    java.awt.Color defaultBackground -> a
    javax.swing.JLabel lblHeader -> a
    javax.swing.JButton btnTrace -> a
    java.awt.BorderLayout layout -> a
    javax.swing.ImageIcon traceIcon -> a
    javax.swing.ImageIcon traceRollOverIcon -> b
    java.awt.Rectangle rect -> a
    geogebra.gui.view.spreadsheet.SpreadsheetColumnController this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
    boolean isOverTraceButton(int,java.awt.Point,java.lang.Object) -> a
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu -> geogebra.gui.n.h.A:
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    int row1 -> a
    int row2 -> b
    int column1 -> c
    int column2 -> d
    java.util.ArrayList selectedCellRanges -> a
    int selectionType -> e
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    java.util.ArrayList geos -> b
    geogebra.common.gui.view.spreadsheet.CellRangeProcessor cp -> a
    boolean isShiftDown -> a
    void initMenu() -> a
    java.lang.String getTitleString() -> a
    void setTitle(java.lang.String) -> a
    void addItem(java.awt.Component) -> a
    void addSubItem(javax.swing.JMenu,java.awt.Component) -> a
    boolean allFixed() -> a
    boolean isEmptySelection() -> b
    java.util.ArrayList access$0(geogebra.gui.view.spreadsheet.SpreadsheetContextMenu) -> a
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$1 -> geogebra.gui.n.h.B:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$10 -> geogebra.gui.n.h.C:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$11 -> geogebra.gui.n.h.D:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$12 -> geogebra.gui.n.h.E:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$13 -> geogebra.gui.n.h.F:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$14 -> geogebra.gui.n.h.G:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$15 -> geogebra.gui.n.h.H:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$16 -> geogebra.gui.n.h.I:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$17 -> geogebra.gui.n.h.J:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$18 -> geogebra.gui.n.h.K:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$19 -> geogebra.gui.n.h.L:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$2 -> geogebra.gui.n.h.M:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$20 -> geogebra.gui.n.h.N:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$21 -> geogebra.gui.n.h.O:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$22 -> geogebra.gui.n.h.P:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$3 -> geogebra.gui.n.h.Q:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    geogebra.common.kernel.geos.GeoElement val$geo -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$4 -> geogebra.gui.n.h.R:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$5 -> geogebra.gui.n.h.S:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$6 -> geogebra.gui.n.h.T:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$7 -> geogebra.gui.n.h.U:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$8 -> geogebra.gui.n.h.V:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$9 -> geogebra.gui.n.h.W:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetKeyListener -> geogebra.gui.n.h.X:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    javax.swing.table.DefaultTableModel model -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void letterOrDigitTyped() -> a
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.view.spreadsheet.SpreadsheetKeyListener$1 -> geogebra.gui.n.h.Y:
    geogebra.gui.view.spreadsheet.SpreadsheetKeyListener this$0 -> a
    javax.swing.text.JTextComponent val$f -> a
    void run() -> run
geogebra.gui.view.spreadsheet.SpreadsheetMouseListener -> geogebra.gui.n.h.Z:
    java.lang.String selectedCellName -> a
    java.lang.String prefix0 -> b
    java.lang.String postfix0 -> c
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    javax.swing.table.DefaultTableModel model -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    geogebra.common.gui.view.spreadsheet.RelativeCopy relativeCopy -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void handleAutoFillDown() -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void setTableCursor() -> b
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader -> geogebra.gui.n.h.aa:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$MyListModel listModel -> a
    int minSelectionRow -> b
    int maxSelectionRow -> c
    java.awt.Cursor resizeCursor -> a
    java.awt.Cursor otherCursor -> b
    int mouseYOffset -> d
    int resizingRow -> e
    boolean doRowResize -> a
    int row0 -> a
    void updateRowHeader() -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    int getResizingRow(java.awt.Point) -> a
    void swapCursor() -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    geogebra.main.AppD access$0(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    geogebra.gui.view.spreadsheet.MyTableD access$1(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    int access$2(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    int access$3(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> b
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$MyListModel -> geogebra.gui.n.h.aa$a:
    javax.swing.table.DefaultTableModel model -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    java.lang.Void changed() -> a
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$RowHeaderRenderer -> geogebra.gui.n.h.aa$b:
    javax.swing.JList rowHeader -> a
    java.awt.Color defaultBackground -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.SpreadsheetStyleBar -> geogebra.gui.n.h.ab:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    geogebra.common.gui.view.spreadsheet.CellFormat formatHandler -> a
    java.util.ArrayList selectedCells -> a
    geogebra.gui.util.MyToggleButton btnFormulaBar -> a
    geogebra.gui.util.MyToggleButton btnLeftAlign -> b
    geogebra.gui.util.MyToggleButton btnCenterAlign -> c
    geogebra.gui.util.MyToggleButton btnRightAlign -> d
    geogebra.gui.color.ColorPopupMenuButton btnBgColor -> a
    geogebra.gui.util.MyToggleButton btnBold -> e
    geogebra.gui.util.MyToggleButton btnItalic -> f
    boolean allowActionPerformed -> a
    geogebra.gui.util.PopupMenuButton btnBorderStyle -> a
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    void createButtons() -> c
    void setLabels() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateStyleBar() -> b
geogebra.gui.view.spreadsheet.SpreadsheetStyleBar$1 -> geogebra.gui.n.h.ac:
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar this$0 -> a
    java.awt.Dimension val$bgColorIconSize -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.gui.view.spreadsheet.SpreadsheetToolbarManager -> geogebra.gui.n.h.ad:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    geogebra.gui.view.spreadsheet.CreateObjectDialog id -> a
    void handleModeChange(int) -> a
geogebra.gui.view.spreadsheet.SpreadsheetView -> geogebra.gui.n.h.ae:
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    geogebra.main.SpreadsheetTableModelD tableModel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader rowHeader -> a
    javax.swing.table.JTableHeader tableHeader -> a
    int DEFAULT_COLUMN_WIDTH -> a
    geogebra.gui.view.spreadsheet.TraceDialog traceDialog -> a
    javax.swing.JScrollPane spreadsheet -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel fileBrowser -> a
    int defaultDividerLocation -> b
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar styleBar -> a
    javax.swing.JPanel restorePanel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetToolbarManager toolbarManager -> a
    int mode -> c
    javax.swing.JSplitPane splitPane -> a
    geogebra.gui.view.spreadsheet.FormulaBar formulaBar -> a
    javax.swing.JPanel spreadsheetPanel -> b
    geogebra.gui.view.spreadsheet.SpreadsheetViewDnD dndHandler -> a
    boolean scrollToShow -> b
    boolean allowSettingUpate -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void buildSpreadsheet() -> v
    void setDefaultSelection() -> e
    geogebra.main.AppD getApplication() -> b
    geogebra.common.gui.view.spreadsheet.MyTableInterface getSpreadsheetTable() -> a
    javax.swing.JViewport getRowHeader() -> a
    void rowHeaderRevalidate() -> a
    javax.swing.JViewport getColumnHeader() -> b
    void columnHeaderRevalidate() -> c
    javax.swing.table.JTableHeader getTableHeader() -> a
    int getMode() -> b
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar getSpreadsheetStyleBar() -> a
    void attachView() -> f
    void detachView() -> h
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void rename(geogebra.common.kernel.geos.GeoElement) -> a
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> b
    void repaintView() -> b
    void clearView() -> d
    void setMode(int,geogebra.common.kernel.ModeSetter) -> a
    void restart() -> i
    void reset() -> g
    void update(geogebra.common.kernel.geos.GeoElement) -> e
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> f
    void setScrollToShow(boolean) -> a
    geogebra.gui.view.spreadsheet.FormulaBar getFormulaBar() -> a
    void updateFormulaBar() -> j
    void showTraceDialog(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean isTraceDialogVisible() -> a
    geogebra.common.gui.view.spreadsheet.CellRange getTraceSelectionRange(int,int) -> a
    void setTraceDialogMode(boolean) -> b
    void getXML(java.lang.StringBuilder,boolean) -> a
    void setLabels() -> k
    void updateFonts() -> l
    void updateColumnWidths() -> m
    void setColumnWidthsFromSettings() -> n
    void setRowHeightsFromSettings() -> o
    void updateRowHeader() -> p
    void setSpreadsheetScrollPosition(int,int) -> a
    void expandSpreadsheetToViewport() -> q
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    boolean loadSpreadsheetFromURL(java.io.File) -> a
    boolean loadSpreadsheetFromURL(java.net.URL) -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel getFileBrowser() -> a
    void setShowFileBrowser(boolean) -> c
    boolean getShowBrowserPanel() -> b
    void minimizeBrowserPanel() -> r
    void restoreBrowserPanel() -> s
    javax.swing.JPanel getRestorePanel() -> a
    void initFileBrowser() -> t
    boolean setFileBrowserDirectory(java.lang.String,int) -> a
    void setEnableAutoComplete(boolean) -> d
    void setShowRowHeader(boolean) -> e
    void setShowColumnHeader(boolean) -> f
    void setShowVScrollBar(boolean) -> g
    void setShowHScrollBar(boolean) -> h
    void setShowGrid(boolean) -> i
    boolean getAllowToolTips() -> c
    void setAllowToolTips(boolean) -> j
    void setShowFormulaBar(boolean) -> k
    boolean getShowFormulaBar() -> d
    boolean isVisibleStyleBar() -> e
    void setColumnSelect(boolean) -> l
    boolean isColumnSelect() -> f
    void setAllowSpecialEditor(boolean) -> m
    boolean allowSpecialEditor() -> g
    void setEqualsRequired(boolean) -> n
    void updateCellFormat(java.lang.String) -> a
    void updateRowHeightSetting(int,int) -> b
    void updatePreferredRowHeight(int) -> a
    void updateAllColumnWidthSettings() -> u
    geogebra.common.main.settings.SpreadsheetSettings settings() -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    boolean hasViewFocus() -> h
    void requestFocus() -> requestFocus
    boolean hasFocus() -> hasFocus
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    int getViewID() -> a
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    geogebra.gui.view.spreadsheet.MyTableD access$1(geogebra.gui.view.spreadsheet.SpreadsheetView) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> c
    javax.swing.JPanel access$3(geogebra.gui.view.spreadsheet.SpreadsheetView) -> a
geogebra.gui.view.spreadsheet.SpreadsheetView$1 -> geogebra.gui.n.h.af:
    geogebra.gui.view.spreadsheet.SpreadsheetView this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.view.spreadsheet.SpreadsheetView$2 -> geogebra.gui.n.h.ag:
    geogebra.gui.view.spreadsheet.SpreadsheetView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.spreadsheet.SpreadsheetView$Corner -> geogebra.gui.n.h.ae$a:
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.spreadsheet.SpreadsheetViewDnD -> geogebra.gui.n.h.ah:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTableD table -> a
    java.awt.dnd.DragSource ds -> a
    java.awt.dnd.DropTarget dt -> a
    geogebra.common.awt.GPoint currentCell -> a
    boolean isTranspose -> b
    boolean isCopyByValue -> c
    boolean allowDrop -> a
    java.awt.datatransfer.DataFlavor HTMLflavor -> a
    void setAllowDrop(boolean) -> a
    boolean isTranspose() -> a
    void setTranspose(boolean) -> b
    boolean isCopyByValue() -> b
    void setCopyByValue(boolean) -> c
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    boolean handleHtmlFlavorDrop(java.awt.dnd.DropTargetDropEvent) -> a
    void handleDropComplete(java.awt.dnd.DropTargetDropEvent,boolean) -> a
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
geogebra.gui.view.spreadsheet.TraceDialog -> geogebra.gui.n.h.ai:
    geogebra.main.AppD app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.main.SpreadsheetTraceManager traceManager -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    javax.swing.JList traceGeoList -> a
    javax.swing.DefaultListModel traceGeoListModel -> a
    javax.swing.JSplitPane splitPane -> a
    javax.swing.JPanel tabbedPane -> a
    javax.swing.JPanel optionsPanel -> b
    javax.swing.JPanel listPanel -> c
    javax.swing.JPanel promptPanel -> d
    javax.swing.JPanel buttonPanel -> e
    javax.swing.JPanel leftButtonPanel -> f
    javax.swing.JTextField firstRowField -> a
    javax.swing.JTextField numRowsField -> b
    javax.swing.JCheckBox cbResetColumns -> a
    javax.swing.JCheckBox cbRowLimit -> b
    javax.swing.JCheckBox cbShowLabel -> c
    javax.swing.JCheckBox cbTraceList -> d
    javax.swing.JRadioButton traceModeValues -> a
    javax.swing.JRadioButton traceModeCopy -> b
    javax.swing.border.TitledBorder traceModeTitle -> a
    javax.swing.border.TitledBorder locationTitle -> b
    javax.swing.border.TitledBorder optionsTitle -> c
    javax.swing.JButton btRemove -> a
    javax.swing.JButton btAdd -> b
    javax.swing.JButton btClose -> c
    javax.swing.JButton btCancel -> d
    javax.swing.JButton btErase -> e
    javax.swing.JLabel prompt -> a
    int mode -> a
    geogebra.common.gui.view.spreadsheet.CellRange newTraceLocation -> a
    boolean isIniting -> a
    javax.swing.JLabel lblStartRow -> b
    java.lang.StringBuilder sb -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$TraceModesEnum -> a
    void setTraceDialogSelection(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void setVisible(boolean) -> setVisible
    void initGUI() -> d
    javax.swing.JPanel buildListPanel() -> a
    javax.swing.JPanel buildLocationPanel() -> b
    javax.swing.JPanel buildTraceModePanel() -> c
    javax.swing.JPanel buildOptionsPanel() -> d
    javax.swing.JPanel buildButtonPanel() -> e
    void setLabels() -> a
    void setTraceModeLabels() -> e
    void updateGUI() -> f
    void updateTraceGeoList() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void addTrace(geogebra.common.kernel.geos.GeoElement) -> a
    void removeTrace() -> h
    geogebra.common.kernel.geos.GeoElement getSelectedGeo() -> a
    geogebra.common.util.SpreadsheetTraceSettings getSettings() -> a
    void updateSelectedTraceGeo() -> i
    void clearSelectedTraceGeo() -> j
    geogebra.common.gui.view.spreadsheet.CellRange getTraceSelectionRange(int,int) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setMode(int) -> b
    void toolbarModeChanged(int) -> a
    void updateTraceDialog() -> b
    void closeDialog() -> c
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$TraceModesEnum() -> a
geogebra.gui.view.spreadsheet.TraceDialog$MyCellRenderer -> geogebra.gui.n.h.ai$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.virtualkeyboard.Keyboard -> geogebra.gui.virtualkeyboard.a:
    java.awt.Robot robot -> a
    void type(boolean,boolean,boolean,java.lang.CharSequence) -> a
    void type(char) -> a
    void doType(boolean,boolean,boolean,java.lang.String) -> a
    void doType(boolean,boolean,boolean,int[]) -> a
    void doType(int[]) -> a
    void doType(int[],int,int) -> a
geogebra.gui.virtualkeyboard.KeyboardKeys -> geogebra.gui.virtualkeyboard.b:
    java.lang.String UpperCase -> a
    java.lang.String LowerCase -> b
    java.lang.String getUpperCase() -> a
    void setUpperCase(java.lang.String) -> a
    java.lang.String getLowerCase() -> b
    void setLowerCase(java.lang.String) -> b
geogebra.gui.virtualkeyboard.VirtualKeyboard -> geogebra.gui.virtualkeyboard.VirtualKeyboard:
    javax.swing.JButton SpaceButton -> a
    javax.swing.JButton DummyButton -> b
    javax.swing.JToggleButton CapsLockButton -> a
    javax.swing.JToggleButton AltButton -> b
    javax.swing.JToggleButton AltGrButton -> c
    javax.swing.JToggleButton CtrlButton -> d
    javax.swing.JToggleButton MathButton -> e
    javax.swing.JToggleButton NumericButton -> f
    javax.swing.JToggleButton GreekButton -> g
    javax.swing.JToggleButton EnglishButton -> h
    java.lang.String ctrlText -> a
    java.lang.String altText -> b
    java.lang.String altGrText -> c
    java.lang.String escText -> d
    geogebra.main.AppD app -> a
    char wideChar -> r
    int buttonRows -> a
    int buttonCols -> b
    int buttonRowsNum -> c
    int buttonColsNum -> d
    double buttonSizeX -> a
    double buttonSizeY -> b
    double horizontalMultiplier -> c
    double verticalMultiplier -> d
    javax.swing.JButton[][] Buttons -> a
    int windowWidth -> e
    int windowHeight -> f
    float opacity -> a
    java.awt.Font currentFont -> a
    java.awt.Font[] fonts -> a
    java.lang.String fontName -> e
    boolean shrink -> a
    char KEYBOARD_NORMAL -> a
    char KEYBOARD_MATH -> b
    char KEYBOARD_NUMERIC -> c
    char KEYBOARD_ACUTE -> d
    char KEYBOARD_GRAVE -> e
    char KEYBOARD_UMLAUT -> f
    char KEYBOARD_CEDILLA -> g
    char KEYBOARD_CARON -> h
    char KEYBOARD_CIRCUMFLEX -> i
    char KEYBOARD_BREVE -> j
    char KEYBOARD_TILDE -> k
    char KEYBOARD_OGONEK -> l
    char KEYBOARD_DOT_ABOVE -> m
    char KEYBOARD_RING_ABOVE -> n
    char KEYBOARD_DIALYTIKA_TONOS -> o
    char KEYBOARD_DOUBLE_ACUTE -> p
    char KEYBOARD_SOLIDUS -> q
    char KEYBOARD_MODE -> s
    java.lang.StringBuilder sbAlt -> a
    java.lang.StringBuilder sb -> b
    java.util.HashMap characterIsTooWide -> a
    java.util.HashMap fontsHash -> b
    java.util.Hashtable myKeys -> a
    java.util.Locale kbLocale -> a
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard kb -> a
    javax.swing.Timer timer -> a
    java.lang.String timerInsertStr -> f
    void setFonts() -> h
    void updateOpacity() -> i
    void windowResized() -> b
    void initialize() -> j
    void updateButtons() -> c
    javax.swing.JButton getSpaceButton() -> a
    javax.swing.JButton getDummyButton() -> b
    void updateSpaceButton() -> k
    void updateCapsLockButton() -> l
    void updateCtrlButton() -> d
    void updateAltButton() -> e
    void updateAltGrButton() -> f
    void updateMathButton() -> m
    void updateNumericButton() -> n
    void setColor(javax.swing.JToggleButton) -> a
    void updateGreekButton() -> o
    void updateEnglishButton() -> p
    double minButtonSize() -> a
    javax.swing.JToggleButton getCapsLockButton() -> c
    javax.swing.JToggleButton getAltButton() -> d
    javax.swing.JToggleButton getAltGrButton() -> e
    javax.swing.JToggleButton getCtrlButton() -> f
    javax.swing.JToggleButton getMathButton() -> g
    void toggleNumeric(boolean) -> a
    javax.swing.JToggleButton getNumericButton() -> h
    boolean greek() -> a
    javax.swing.JToggleButton getGreekButton() -> a
    boolean english() -> b
    javax.swing.JToggleButton getEnglishButton() -> b
    void populateContentPane() -> q
    void insertText(java.lang.String) -> a
    java.lang.StringBuilder getAltStringBuilder() -> a
    void setMode(char,java.util.Locale) -> a
    boolean Upper() -> c
    void insertKeyText(geogebra.gui.virtualkeyboard.KeyboardKeys) -> a
    geogebra.gui.virtualkeyboard.KeyboardKeys getKey(int,int) -> a
    javax.swing.JButton getButton(int,int) -> a
    void buttonPressed(int,int) -> a
    java.lang.String processSpecialKeys(java.lang.String) -> a
    java.lang.String unicodeString(char,java.lang.String) -> a
    void updateButton(int,int) -> b
    void setTooltip(int,int) -> c
    java.awt.Font getCurrentFont() -> a
    java.awt.Font getFont(int,boolean) -> a
    void setKbLocale(java.util.Locale) -> a
    void readConf(geogebra.main.AppD,java.util.Locale,boolean) -> a
    void setLabels() -> a
    void doSetLabels() -> r
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard getKeyboard() -> a
    void startAutoRepeat(java.lang.String) -> b
    void insertAutoRepeatString() -> s
    void stopAutoRepeat() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setWindowWidth(int) -> a
    void setWindowHeight(int) -> b
    void setKeyboardOpacity(float) -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    char getKeyboardMode() -> a
    void setKEYBOARD_MODE(char) -> a
geogebra.gui.virtualkeyboard.VirtualKeyboard$1 -> geogebra.gui.virtualkeyboard.c:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    geogebra.main.AppD val$app -> a
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.virtualkeyboard.VirtualKeyboard$10 -> geogebra.gui.virtualkeyboard.d:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$11 -> geogebra.gui.virtualkeyboard.e:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$12 -> geogebra.gui.virtualkeyboard.f:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$13 -> geogebra.gui.virtualkeyboard.g:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    int val$i -> a
    int val$j -> b
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.virtualkeyboard.VirtualKeyboard$14 -> geogebra.gui.virtualkeyboard.h:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    int val$i -> a
    int val$j -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$2 -> geogebra.gui.virtualkeyboard.i:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.gui.virtualkeyboard.VirtualKeyboard$3 -> geogebra.gui.virtualkeyboard.j:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void run() -> run
geogebra.gui.virtualkeyboard.VirtualKeyboard$4 -> geogebra.gui.virtualkeyboard.k:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$5 -> geogebra.gui.virtualkeyboard.l:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$6 -> geogebra.gui.virtualkeyboard.m:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$7 -> geogebra.gui.virtualkeyboard.n:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$8 -> geogebra.gui.virtualkeyboard.o:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$9 -> geogebra.gui.virtualkeyboard.p:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard -> geogebra.gui.virtualkeyboard.q:
    java.awt.Robot robot -> b
    void type(char) -> a
    void typeNumPad(int) -> a
geogebra.io.MyImageIO -> geogebra.f.a:
    void write(java.awt.image.BufferedImage,java.lang.String,float,java.io.File) -> a
    void writeImage(javax.imageio.ImageWriter,java.awt.image.BufferedImage,double) -> a
geogebra.io.MyXMLio -> geogebra.f.b:
    geogebra.common.io.DocHandler handler -> a
    geogebra.common.io.DocHandler ggbDocHandler -> b
    geogebra.common.io.QDParser xmlParser -> a
    geogebra.common.io.DocHandler getGGBHandler() -> a
    void readZipFromInputStream(java.io.InputStream,boolean) -> a
    void readZipFromString(byte[]) -> a
    void readZip(java.util.zip.ZipInputStream,boolean) -> a
    java.awt.image.BufferedImage getPreviewImage(java.io.File) -> a
    void processXMLBuffer(byte[],boolean,boolean) -> a
    void doParseXML(java.io.Reader,boolean,boolean,boolean,boolean) -> a
    void readZipFromMemory(java.io.InputStream) -> a
    void processXMLString(java.lang.String,boolean,boolean,boolean) -> a
    void writeGeoGebraFile(java.io.File) -> a
    void writeGeoGebraFile(java.io.OutputStream,boolean) -> a
    void writeMacroFile(java.io.File,java.util.ArrayList) -> a
    void writeMacroStream(java.io.OutputStream,java.util.ArrayList) -> a
    void writeConstructionImages(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream) -> a
    void writeConstructionImages(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream,java.lang.String) -> a
    void writeThumbnail(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream,java.lang.String) -> b
    void writeMacroImages(java.util.ArrayList,java.util.zip.ZipOutputStream) -> a
    void writeMacroImages(java.util.ArrayList,java.util.zip.ZipOutputStream,java.lang.String) -> a
    void writeImageToZip(java.util.zip.ZipOutputStream,java.lang.String,java.awt.image.BufferedImage) -> a
    void writeImageToStream(java.io.OutputStream,java.lang.String,java.awt.image.BufferedImage) -> a
    void writeZipped(java.io.OutputStream,java.lang.StringBuilder) -> a
    java.lang.StringBuilder getUndoXML(geogebra.common.kernel.Construction) -> a
geogebra.javax.swing.BoxD -> geogebra.g.a.a:
    javax.swing.Box impl -> a
    javax.swing.Box getImpl() -> a
    void add(geogebra.common.javax.swing.GLabel) -> a
    void add(geogebra.common.gui.inputfield.AutoCompleteTextField) -> a
    void setVisible(boolean) -> a
    void setBounds(geogebra.common.awt.GRectangle) -> a
    geogebra.common.awt.GDimension getPreferredSize() -> a
    geogebra.common.awt.GRectangle getBounds() -> a
    void validate() -> a
    void revalidate() -> b
    void add(geogebra.common.javax.swing.AbstractJComboBox) -> a
geogebra.javax.swing.GComboBoxD -> geogebra.g.a.b:
    javax.swing.JComboBox impl -> a
    int selectedIndex -> a
    void setVisible(boolean) -> a
    java.lang.Object getItemAt(int) -> a
    void setFont(geogebra.common.awt.GFont) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
    void setFocusable(boolean) -> b
    void setEditable(boolean) -> c
    void addItem(java.lang.String) -> a
    void setSelectedIndex(int) -> a
    int getSelectedIndex() -> a
    java.awt.Component getJComboBox(geogebra.common.javax.swing.AbstractJComboBox) -> a
    void addActionListener(geogebra.common.euclidian.event.ActionListener) -> a
    void removeAllItems() -> a
    int getItemCount() -> b
geogebra.javax.swing.GLabelD -> geogebra.g.a.c:
    javax.swing.JLabel impl -> a
    javax.swing.JLabel getImpl() -> a
    void setVisible(boolean) -> a
    void setText(java.lang.String) -> a
    void setOpaque(boolean) -> b
    void setFont(geogebra.common.awt.GFont) -> a
    void setForeground(geogebra.common.awt.GColor) -> a
    void setBackground(geogebra.common.awt.GColor) -> b
geogebra.javax.swing.GOptionPaneD -> geogebra.g.a.d:
    int showConfirmDialog(java.lang.Object,java.lang.String,java.lang.String,int,int) -> a
geogebra.javax.swing.GPopupMenuD -> geogebra.g.a.e:
    javax.swing.JPopupMenu impl -> a
    javax.swing.JPopupMenu getImpl(geogebra.common.javax.swing.GPopupMenu) -> a
geogebra.javax.swing.GTextComponentD -> geogebra.g.a.f:
    javax.swing.text.JTextComponent impl -> a
    void replaceSelection(java.lang.String) -> a
    geogebra.javax.swing.GTextComponentD wrap(javax.swing.text.JTextComponent) -> a
    javax.swing.text.JTextComponent getImpl() -> a
geogebra.kernel.AnimationManagerD -> geogebra.h.a:
    javax.swing.Timer timer -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean isRunning() -> c
    void setTimerDelay(int) -> a
    void stopTimer() -> f
    void startTimer() -> g
geogebra.kernel.EvalCommandQueue -> geogebra.h.b:
    geogebra.common.plugin.GgbAPI ggbAPI -> a
    java.util.ArrayList queue -> a
    javax.swing.Timer timer -> a
    void addCommand(java.lang.String) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.kernel.UndoManagerD -> geogebra.h.c:
    boolean useHashMap -> a
    java.util.HashMap hashMap -> a
    void storeUndoInfoAfterPasteOrAdd() -> g
    void storeUndoInfo(boolean) -> a
    void doStoreUndoInfo(java.lang.StringBuilder) -> a
    java.io.File createTempFile(java.lang.StringBuilder) -> a
    void loadUndoInfo(geogebra.common.kernel.UndoManager$AppState) -> a
    void processXML(java.lang.String) -> a
geogebra.kernel.UndoManagerD$1 -> geogebra.h.d:
    geogebra.kernel.UndoManagerD this$0 -> a
    java.lang.StringBuilder val$currentUndoXML -> a
    void run() -> run
geogebra.kernel.UndoManagerD$2 -> geogebra.h.e:
    geogebra.kernel.UndoManagerD this$0 -> a
    java.lang.StringBuilder val$currentUndoXML -> a
    boolean val$refresh -> a
    void run() -> run
geogebra.kernel.UndoManagerD$AppStateApplet -> geogebra.h.c$a:
    java.lang.String key -> a
    geogebra.kernel.UndoManagerD this$0 -> a
    void initHashMap() -> b
    java.lang.String getXML() -> a
    void delete() -> a
geogebra.kernel.UndoManagerD$AppStateDesktop -> geogebra.h.c$b:
    java.io.File f -> a
    geogebra.kernel.UndoManagerD this$0 -> a
    java.io.File getFile() -> a
    void delete() -> a
geogebra.kernel.geos.GeoElementGraphicsAdapterDesktop -> geogebra.h.a.a:
    geogebra.main.AppD app -> a
    geogebra.common.awt.GBufferedImage getFillImage() -> b
    void setImageFileName(java.lang.String) -> b
geogebra.main.AppD -> geogebra.i.a:
    java.lang.String[] GEOGEBRA_JAR_ALT -> b
    java.lang.String[] JAR_FILES -> c
    java.awt.Color COLOR_SELECTION -> a
    java.io.File currentPath -> a
    java.io.File currentImagePath -> b
    java.io.File currentFile -> c
    java.awt.Dimension preferredSize -> a
    javax.swing.JFrame frame -> a
    geogebra.main.AppletImplementation appletImpl -> a
    geogebra.main.FontManagerD fontManager -> a
    geogebra.common.gui.GuiManager guiManager -> a
    java.awt.Component mainComp -> a
    boolean isApplet -> E
    geogebra.main.GlobalKeyDispatcherD globalKeyDispatcher -> a
    java.util.ResourceBundle rbcommandEnglish -> a
    java.util.ResourceBundle rbmenuEnglish -> b
    java.util.ResourceBundle rbsettings -> c
    geogebra.main.LocalizationD loc -> a
    geogebra.util.ImageManager imageManager -> a
    int maxIconSize -> h
    boolean showAlgebraView -> x
    boolean showConsProtNavigation -> y
    boolean printScaleString -> F
    boolean allowToolTips -> G
    boolean isErrorDialogsActive -> H
    boolean isErrorDialogShowing -> z
    java.util.LinkedList fileList -> a
    geogebra.plugin.GgbAPID ggbapi -> a
    geogebra.plugin.PluginManager pluginmanager -> a
    javax.swing.JPanel centerPanel -> a
    javax.swing.JPanel northPanel -> b
    javax.swing.JPanel southPanel -> c
    javax.swing.JPanel eastPanel -> d
    javax.swing.JPanel westPanel -> e
    int toolbarPosition -> i
    javax.swing.JSplitPane applicationSplitPane -> a
    geogebra.main.DockBarInterface dockBar -> a
    boolean showDockBar -> I
    boolean isDockBarEast -> J
    geogebra.main.SpreadsheetTableModelD tableModel -> a
    geogebra.CommandLineArguments args -> a
    java.lang.String regressionFileName -> a
    boolean versionCheckAllowed -> K
    java.lang.StringBuilder testCharacters -> b
    boolean showConstProtNavigationNeedsUpdate -> L
    boolean dontShowDockBarPopup -> M
    java.net.URL codebase -> a
    boolean runningFromJar -> N
    geogebra.main.GlassPaneListener glassPaneListener -> a
    boolean controlDown -> O
    boolean shiftDown -> P
    boolean fakeRightClick -> Q
    java.lang.Runtime runtime -> a
    java.awt.Rectangle screenSize -> a
    java.awt.Cursor transparentCursor -> a
    java.awt.Cursor eraserCursor -> b
    boolean virtualKeyboardActive -> R
    java.util.logging.LogManager logManager -> a
    java.lang.StringBuilder logFile -> c
    geogebra.sound.SoundManager soundManager -> a
    geogebra.euclidian.DrawEquationD drawEquation -> a
    java.lang.String uniqueId -> b
    geogebra.common.main.DialogManager dialogManager -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation constProtocolNavigation -> a
    java.lang.String OS -> c
    boolean MAC_OS -> A
    boolean WINDOWS -> B
    boolean LINUX -> C
    boolean WINDOWS_VISTA_OR_LATER -> D
    geogebra.main.DockBarInterface getDockBar() -> a
    boolean isShowDockBar() -> R
    boolean isDockBarEast() -> S
    void setDockBarEast(boolean) -> x
    void setShowDockBar(boolean) -> y
    void setShowDockBar(boolean,boolean) -> e
    void initFactories() -> ak
    void handleHelpVersionArgs(geogebra.CommandLineArguments) -> a
    geogebra.euclidian.EuclidianControllerD newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.euclidian.EuclidianView newEuclidianView(boolean[],boolean) -> a
    void initImageManager(java.awt.Component) -> a
    boolean isUsingFullGui() -> c
    void initGuiManager() -> r
    geogebra.common.gui.GuiManager newGuiManager() -> b
    geogebra.common.gui.GuiManager getGuiManager() -> a
    javax.swing.JApplet getJApplet() -> a
    java.awt.Font getBoldFont() -> a
    java.awt.Font getItalicFont() -> b
    java.awt.Font getPlainFont() -> c
    geogebra.common.awt.GFont getPlainFontCommon() -> a
    java.awt.Font getSmallFont() -> d
    java.awt.Font getFont(boolean,int,int) -> a
    geogebra.main.FontManagerD getFontManager() -> a
    void setSaved() -> T
    void setUnsaved() -> u
    void fileNew() -> U
    boolean getAllowToolTips() -> T
    void updateContentPane() -> V
    void updateContentPane(boolean) -> G
    void updateComponentTreeUI() -> W
    javax.swing.JPanel buildApplicationPanel() -> a
    void setShowInputHelpPanel(boolean) -> z
    void updateDockBar() -> X
    void updateApplicationLayout() -> M
    void createRegressionFile() -> Y
    boolean addMacroXML(java.lang.String) -> c
    void updateCenterPanel(boolean) -> A
    javax.swing.JPanel getCenterPanel() -> b
    void validateComponent() -> Z
    void handleOptionArgs(geogebra.CommandLineArguments) -> b
    void setVersionCheckAllowed(java.lang.String) -> r
    boolean getVersionCheckAllowed() -> U
    void handleOptionArgsEarly(geogebra.CommandLineArguments) -> c
    boolean isLoadingTool(geogebra.CommandLineArguments) -> a
    boolean handleFileArg(geogebra.CommandLineArguments) -> b
    boolean loadBase64File(java.io.File) -> a
    boolean loadFromHtml(java.net.URL) -> a
    java.lang.String getAttributeValue(java.lang.String,java.lang.String,java.lang.String) -> b
    java.lang.String getAttributeValue(java.lang.String,int,char[]) -> a
    boolean isMarker(char[],char) -> a
    java.lang.String fetchPage(java.net.URL) -> a
    void setApplet(geogebra.main.AppletImplementation) -> a
    geogebra.main.AppletImplementation getApplet() -> a
    void reset() -> K
    void setFrame(javax.swing.JFrame) -> a
    boolean isApplet() -> b
    javax.swing.JFrame getFrame() -> a
    java.awt.Component getMainComponent() -> a
    java.awt.Dimension getPreferredSize() -> a
    void setPreferredSize(geogebra.common.awt.GDimension) -> a
    boolean isJustEuclidianVisible() -> am
    geogebra.euclidian.EuclidianViewD getEuclidianView1() -> a
    geogebra.common.gui.view.algebra.AlgebraView getAlgebraView() -> a
    geogebra.euclidian.EuclidianViewD getEuclidianView2() -> b
    boolean hasEuclidianView2() -> v
    boolean hasEuclidianView2EitherShowingOrNot() -> q
    boolean isShowingEuclidianView2() -> r
    geogebra.euclidianND.EuclidianViewND getActiveEuclidianView() -> a
    java.awt.image.BufferedImage getExportImage(double,double) -> a
    void setShowAxesSelected(javax.swing.JCheckBoxMenuItem) -> a
    void setShowGridSelected(javax.swing.JCheckBoxMenuItem) -> b
    void setMaxIconSize(int) -> j
    javax.swing.ImageIcon getImageIcon(java.lang.String) -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String,java.awt.Color) -> a
    java.lang.String getFlagName(boolean) -> c
    javax.swing.ImageIcon getFlagIcon(java.lang.String) -> b
    javax.swing.ImageIcon getToolBarImage(java.lang.String,java.awt.Color) -> b
    javax.swing.ImageIcon getToolIcon(java.awt.Color) -> a
    javax.swing.ImageIcon getEmptyIcon() -> a
    java.awt.Image getInternalImage(java.lang.String) -> a
    java.awt.Image getRefreshViewImage() -> a
    java.awt.Image getPlayImage() -> b
    java.awt.Image getPauseImage() -> c
    java.awt.image.BufferedImage getExternalImage(java.lang.String) -> a
    geogebra.common.awt.GBufferedImage getExternalImageAdapter(java.lang.String) -> a
    void addExternalImage(java.lang.String,java.awt.image.BufferedImage) -> a
    java.util.Locale getLocale(java.lang.String) -> a
    int getTooltipTimeout() -> f
    void setLanguage(java.util.Locale) -> a
    void setLocale(java.util.Locale) -> b
    java.util.Locale getLocale() -> a
    java.lang.String getEnglishCommand(java.lang.String) -> m
    java.lang.String getEnglishMenu(java.lang.String) -> n
    java.lang.String getSyntaxString() -> d
    java.lang.String getCommandSyntaxCAS(java.lang.String) -> o
    java.lang.String getSetting(java.lang.String) -> p
    boolean propertiesFilesPresent() -> V
    void showHelp(java.lang.String) -> p
    void showError(java.lang.String) -> c
    void showError(java.lang.String,java.lang.String) -> a
    void showError(geogebra.common.main.MyError) -> a
    void showErrorDialog(java.lang.String) -> d
    boolean isErrorDialogShowing() -> W
    void showMessage(java.lang.String) -> q
    void setWaitCursor() -> A
    void setDefaultCursor() -> z
    java.io.File getCurrentFile() -> a
    java.io.File getCurrentPath() -> b
    void setCurrentPath(java.io.File) -> a
    void setCurrentFile(java.io.File) -> b
    void addToFileList(java.io.File) -> c
    java.io.File getFromFileList(int) -> a
    int getFileListSize() -> n
    void updateTitle() -> aa
    void updateUI() -> H
    void setLabels() -> al
    java.lang.String getToolTooltipHTML(int) -> g
    javax.swing.ImageIcon getModeIcon(int) -> a
    boolean onlyGraphicsViewShowing() -> X
    boolean showAlgebraInput() -> C
    void setShowAlgebraInput(boolean,boolean) -> d
    void setToolbarPosition(int,boolean) -> b
    int getToolbarPosition() -> o
    boolean showToolBarHelp() -> Y
    void updateToolBarLayout() -> ab
    boolean showMenuBar() -> Z
    boolean getShowCPNavNeedsUpdate() -> aa
    void setShowConstructionProtocolNavigation(boolean) -> k
    void toggleShowConstructionProtocolNavigation() -> ac
    boolean showConsProtNavigation() -> ab
    void setShowAuxiliaryObjects(boolean) -> g
    void updateToolBar() -> ad
    void updateMenubar() -> G
    void updateStyleBars() -> B
    void updateMenuWindow() -> ae
    boolean clearConstruction() -> ac
    void exit() -> af
    void exitAll() -> P
    boolean saveCurrentFile() -> ad
    geogebra.common.euclidian.EuclidianView createEuclidianView() -> b
    boolean loadFile(java.io.File,boolean) -> a
    boolean loadXML(java.io.File,boolean) -> b
    boolean loadXML(java.net.URL,boolean) -> a
    boolean loadXML(byte[]) -> a
    boolean loadXML(java.lang.String) -> b
    boolean loadXML(java.io.InputStream,boolean) -> a
    void hideDockBarPopup() -> am
    void setActiveView(int) -> c
    boolean saveGeoGebraFile(java.io.File) -> b
    boolean saveMacroFile(java.io.File,java.util.ArrayList) -> a
    void setXML(java.lang.String,boolean) -> a
    byte[] getMacroFileAsByteArray() -> a
    void loadMacroFileFromByteArray(byte[],boolean) -> a
    geogebra.io.MyXMLio getXMLio() -> a
    geogebra.io.MyXMLio createXMLio(geogebra.common.kernel.Construction) -> a
    boolean isSaved() -> ae
    void storeUndoInfo() -> h
    void getWindowLayoutXML(java.lang.StringBuilder,boolean) -> b
    java.net.URL getCodeBase() -> a
    void initCodeBase() -> an
    boolean isWebstart() -> af
    boolean isWebstartDebug() -> ag
    boolean hasFullPermissions() -> ah
    void startDispatchingEventsTo(javax.swing.JComponent) -> a
    void stopDispatchingEvents() -> ag
    java.awt.Component getGlassPane() -> b
    void setGlassPane(java.awt.Component) -> b
    java.awt.Container getContentPane() -> a
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
    void handleShiftEvent(boolean) -> B
    geogebra.main.GlobalKeyDispatcherD getGlobalKeyDispatcher() -> a
    geogebra.main.GlobalKeyDispatcherD newGlobalKeyDispatcher() -> b
    boolean isPrintScaleString() -> ai
    void setPrintScaleString(boolean) -> C
    java.io.File getCurrentImagePath() -> c
    void setCurrentImagePath(java.io.File) -> d
    java.lang.String loadTextFile(java.lang.String) -> q
    void setErrorDialogsActive(boolean) -> D
    geogebra.plugin.GgbAPID getGgbApi() -> a
    geogebra.plugin.ScriptManagerD getScriptManager() -> a
    geogebra.plugin.PluginManager getPluginManager() -> a
    void printStacktrace(java.lang.String) -> e
    void setEmptyIcon(javax.swing.JCheckBoxMenuItem) -> c
    boolean isAltDown(java.awt.event.InputEvent) -> a
    boolean getControlDown() -> aj
    boolean getShiftDown() -> ak
    boolean isControlDown(java.awt.event.InputEvent) -> b
    boolean isMiddleClick(java.awt.event.MouseEvent) -> a
    boolean isRightClick(java.awt.event.MouseEvent) -> b
    boolean isRightClickForceMetaDown(java.awt.event.MouseEvent) -> c
    java.lang.String createImage(java.awt.image.BufferedImage,java.lang.String) -> a
    java.lang.String getExtension(java.io.File) -> a
    java.lang.String getExtension(java.lang.String) -> r
    java.io.File addExtension(java.io.File,java.lang.String) -> a
    java.io.File removeExtension(java.io.File) -> a
    java.lang.String removeExtension(java.lang.String) -> s
    boolean freeMemoryIsCritical() -> k
    long freeMemory() -> a
    long getHeapSize() -> b
    void copyGraphicsViewToClipboard() -> N
    void copyGraphicsViewToClipboard(geogebra.euclidian.EuclidianViewD) -> a
    void simpleExportToClipboard(geogebra.euclidian.EuclidianViewD) -> b
    java.awt.Rectangle getScreenSize() -> a
    java.awt.Cursor getTransparentCursor() -> a
    boolean isVirtualKeyboardActive() -> al
    void setVirtualKeyboardActive(boolean) -> E
    void removeTraversableKeys(javax.swing.JPanel) -> a
    void setUpLogging() -> ao
    java.lang.String getCodeBaseFolder() -> m
    void exportToLMS(boolean) -> v
    java.lang.String getStringFromClipboard() -> n
    geogebra.util.ImageManager getImageManager() -> a
    geogebra.sound.SoundManager getSoundManager() -> a
    void setScrollToShow(boolean) -> f
    geogebra.euclidian.DrawEquationD getDrawEquation() -> a
    java.lang.String getUniqueId() -> g
    void setUniqueId(java.lang.String) -> n
    void resetUniqueId() -> ah
    void callAppletJavaScript(java.lang.String,java.lang.Object[]) -> a
    boolean showView(int) -> b
    void evalJavaScript(geogebra.common.main.App,java.lang.String,java.lang.String) -> a
    int getMD5folderLength(java.lang.String) -> a
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    void setTooltipTimeout(int) -> e
    double getWidth() -> a
    double getHeight() -> b
    geogebra.common.awt.GFont getFontCommon(boolean,int,int) -> a
    geogebra.common.awt.GFont getBoldFontCommon() -> b
    void repaintSpreadsheet() -> y
    geogebra.kernel.UndoManagerD getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter newGeoElementGraphicsAdapter() -> a
    geogebra.common.kernel.AnimationManager newAnimationManager(geogebra.common.kernel.Kernel) -> a
    geogebra.common.main.SpreadsheetTableModel getSpreadsheetTableModel() -> a
    boolean isRightClick(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean isControlDown(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean isMiddleClick(geogebra.common.euclidian.event.AbstractEvent) -> c
    java.awt.Font getFontCanDisplayAwt(java.lang.String,boolean,int,int) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String,int) -> a
    boolean isMacOS() -> s
    boolean isWindows() -> t
    boolean isHTML5Applet() -> H
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getFormulaRenderingType() -> a
    geogebra.common.main.DialogManager getDialogManager() -> a
    java.lang.String getLocaleStr() -> h
    void showURLinBrowser(java.lang.String) -> o
    void uploadToGeoGebraTube() -> L
    geogebra.common.util.LowerCaseDictionary newLowerCaseDictionary() -> a
    geogebra.CommandLineArguments getCommandLineArgs() -> a
    void resetPen() -> ai
    java.lang.String getCountryFromGeoIP() -> i
    java.lang.String borderEast() -> o
    java.lang.String borderWest() -> p
    int flowLeft() -> p
    int flowRight() -> q
    void repaintEuclidianViews(java.awt.Component) -> c
    void addMenuItem(geogebra.common.gui.menubar.MenuInterface,java.lang.String,java.lang.String,boolean,geogebra.common.gui.menubar.MenuInterface) -> a
    java.lang.String getJavaVersion() -> q
    java.lang.StringBuilder appendJavaVersion(java.lang.StringBuilder) -> a
    geogebra.common.util.NormalizerMinimal getNormalizer() -> a
    void runScripts(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    geogebra.common.factories.CASFactory getCASFactory() -> a
    geogebra.common.factories.SwingFactory getSwingFactory() -> a
    geogebra.common.factories.Factory getFactory() -> a
    void setLAF(boolean) -> F
    void toggleCrossPlatformLAF() -> aj
    void setComponentOrientation(java.awt.Component) -> d
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation getConstructionProtocolNavigation() -> a
    void setFlowLayoutOrientation(javax.swing.JPanel) -> b
    geogebra.main.LocalizationD getLocalization() -> a
    void setTooltipLanguage(java.lang.String) -> b
    geogebra.common.sound.SoundManager getSoundManager() -> a
    geogebra.common.main.Localization getLocalization() -> a
    java.lang.Object getMainComponent() -> a
    geogebra.common.euclidian.EuclidianView getEuclidianView2() -> c
    geogebra.common.kernel.UndoManager getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.util.AbstractImageManager getImageManager() -> a
    geogebra.common.euclidian.DrawEquationInterface getDrawEquation() -> a
    geogebra.common.euclidian.EuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.io.MyXMLio createXMLio(geogebra.common.kernel.Construction) -> a
    geogebra.common.main.GlobalKeyDispatcher getGlobalKeyDispatcher() -> a
    geogebra.common.plugin.ScriptManager getScriptManager() -> a
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getActiveEuclidianView() -> a
    geogebra.common.main.FontManager getFontManager() -> a
    geogebra.common.euclidian.EuclidianView getEuclidianView1() -> a
    geogebra.common.plugin.GgbAPI getGgbApi() -> a
    geogebra.common.io.MyXMLio getXMLio() -> a
geogebra.main.AppD$1 -> geogebra.i.b:
    geogebra.main.AppD this$0 -> a
    java.lang.String val$fileArgument -> a
    void run() -> run
geogebra.main.AppD$2 -> geogebra.i.c:
    geogebra.main.AppD this$0 -> a
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
geogebra.main.AppD$3 -> geogebra.i.d:
    geogebra.main.AppD this$0 -> a
    java.lang.String val$msg -> a
    void run() -> run
geogebra.main.AppD$4 -> geogebra.i.e:
    geogebra.main.AppD this$0 -> a
    java.lang.String val$message -> a
    void run() -> run
geogebra.main.AppD$5 -> geogebra.i.f:
    geogebra.main.AppD this$0 -> a
    geogebra.euclidian.EuclidianViewD val$ev -> a
    void run() -> run
geogebra.main.AppD$6 -> geogebra.i.g:
    geogebra.main.AppD this$0 -> a
    geogebra.common.kernel.geos.GeoElement val$geo1 -> a
    java.lang.String val$string -> a
    void run() -> run
geogebra.main.AppD2 -> geogebra.i.h:
    void initToolbar(geogebra.main.AppD,int,boolean,javax.swing.JPanel,javax.swing.JPanel,javax.swing.JPanel,javax.swing.JPanel) -> a
    void initInputBar(geogebra.main.AppD,boolean,javax.swing.JPanel,javax.swing.JPanel) -> a
    javax.swing.JPanel getMenuBarPanel(geogebra.main.AppD,javax.swing.JPanel) -> a
    geogebra.common.gui.GuiManager newGuiManager(geogebra.main.AppD) -> a
    void loadFile(geogebra.main.AppD,java.io.File,boolean) -> a
    void setActiveView(geogebra.main.AppD,int) -> a
    boolean inExternalWindow(geogebra.main.AppD,java.awt.Component) -> a
    java.awt.Component getRootComponent(geogebra.main.AppD) -> a
    void newLayout(geogebra.main.AppD) -> a
    geogebra.main.DockBarInterface newDockBar(geogebra.main.AppD) -> a
geogebra.main.AppletImplementation -> geogebra.i.i:
    javax.swing.JApplet applet -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.euclidian.EuclidianViewD ev -> a
    boolean undoActive -> a
    boolean showToolBar -> b
    boolean showToolBarHelp -> c
    boolean showAlgebraInput -> d
    boolean allowStyleBar -> e
    boolean enableRightClick -> f
    boolean useBrowserForJavaScript -> g
    boolean enableChooserPopups -> h
    boolean errorDialogsActive -> i
    boolean enableLabelDrags -> j
    boolean enableShiftDragZoom -> k
    boolean allowRescaling -> l
    boolean showMenuBar -> m
    boolean showResetIcon -> n
    java.awt.Color bgColor -> a
    java.awt.Color borderColor -> b
    java.lang.String fileStr -> b
    java.lang.String customToolBar -> c
    int maxIconSize -> c
    javax.swing.JFrame wnd -> a
    netscape.javascript.JSObject browserWindow -> a
    int width -> a
    int height -> b
    geogebra.plugin.GgbAPID ggbApi -> a
    java.lang.String ggbOnInitParam -> a
    int originalWidth -> d
    int originalHeight -> e
    void dispose() -> a
    void initInBackground() -> b
    void init() -> e
    geogebra.main.AppD buildApplication(geogebra.CommandLineArguments,boolean) -> a
    boolean needsGui() -> a
    void initGUI() -> c
    void setInitialScaling() -> f
    javax.swing.JPanel createGeoGebraAppletPanel() -> a
    void showApplet() -> d
    void reinitGUI() -> g
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getXML() -> getXML
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    boolean evalCommand(java.lang.String,boolean) -> a
    void debug(java.lang.String) -> debug
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void reset() -> reset
    void refreshViews() -> refreshViews
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
    void openFile(java.lang.String) -> openFile
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    boolean getVisible(java.lang.String,int) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setColor(java.lang.String,int,int,int) -> setColor
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void setLineThickness(java.lang.String,int) -> setLineThickness
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setPointSize(java.lang.String,int) -> setPointSize
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    java.lang.String getColor(java.lang.String) -> getColor
    double getFilling(java.lang.String) -> getFilling
    int getLineStyle(java.lang.String) -> getLineStyle
    int getLineThickness(java.lang.String) -> getLineThickness
    int getPointStyle(java.lang.String) -> getPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    void deleteObject(java.lang.String) -> deleteObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    boolean exists(java.lang.String) -> exists
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    void setMode(int) -> setMode
    void initJavaScript(boolean) -> a
    boolean sessionStorageSetItem(java.lang.String,java.lang.String) -> a
    java.lang.String sessionStorageGetItem(java.lang.String) -> a
    java.lang.String sessionStorageRemoveItem(java.lang.String) -> b
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
    javax.swing.JApplet getJApplet() -> a
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    boolean isMoveable(java.lang.String) -> isMoveable
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    void setListValue(java.lang.String,int,double) -> setListValue
    double getListValue(java.lang.String,int) -> getListValue
    javax.swing.JFrame access$2(geogebra.main.AppletImplementation) -> a
    void access$3(geogebra.main.AppletImplementation) -> a
    geogebra.plugin.GgbAPID access$4(geogebra.main.AppletImplementation) -> a
    java.lang.String access$5(geogebra.main.AppletImplementation) -> a
geogebra.main.AppletImplementation$1 -> geogebra.i.j:
    geogebra.main.AppletImplementation this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.main.AppletImplementation$10 -> geogebra.i.k:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$algorithm -> a
    java.lang.String val$format -> b
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$11 -> geogebra.i.l:
    geogebra.main.AppletImplementation this$0 -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.lang.String run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$12 -> geogebra.i.m:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$filename -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.lang.Boolean run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$2 -> geogebra.i.n:
    geogebra.main.AppletImplementation this$0 -> a
    void run() -> run
geogebra.main.AppletImplementation$4 -> geogebra.i.o:
    geogebra.main.AppletImplementation this$0 -> a
    void run() -> run
geogebra.main.AppletImplementation$5 -> geogebra.i.p:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$base64 -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$6 -> geogebra.i.q:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$cmdString -> a
    boolean val$waitForResult -> a
    geogebra.common.kernel.arithmetic.MyBoolean run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$8 -> geogebra.i.r:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$9 -> geogebra.i.s:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$strURL -> a
    java.lang.Object run() -> run
geogebra.main.DialogManagerMinimal -> geogebra.i.t:
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    boolean confirm(java.lang.String) -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showPropertiesDialog(geogebra.common.main.OptionType,java.util.ArrayList) -> a
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.GPoint,geogebra.common.kernel.geos.GeoBoolean) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.EuclidianView) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    void closeAll() -> a
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showPropertiesDialog() -> b
    void showToolbarConfigDialog() -> c
    void openToolHelp() -> d
    void showDataSourceDialog(int,boolean) -> a
geogebra.main.DockBarInterface -> geogebra.i.u:
    boolean isEastOrientation() -> c
    void update() -> f
    void setLabels() -> a
    void showPopup() -> c
    boolean isShowButtonBar() -> b
    void setEastOrientation(boolean) -> d
    void setShowButtonBar(boolean) -> c
    void hidePopup() -> d
geogebra.main.FontManagerD -> geogebra.i.v:
    java.awt.Font boldFont -> a
    java.awt.Font italicFont -> b
    java.awt.Font plainFont -> c
    java.awt.Font smallFont -> d
    java.awt.Font serifFont -> e
    java.awt.Font serifFontBold -> f
    java.awt.Font javaSans -> g
    java.awt.Font javaSerif -> h
    int fontSize -> a
    java.lang.String sansName -> a
    java.lang.String serifName -> b
    java.util.HashMap fontMap -> a
    java.lang.StringBuilder key -> a
    java.lang.String[] FONT_NAMES_SANSSERIF -> a
    java.lang.String[] FONT_NAMES_SERIF -> b
    void setLanguage(java.util.Locale) -> a
    void setFontSize(int) -> a
    void updateDefaultFonts(int,java.lang.String,java.lang.String) -> a
    java.awt.Font getFont(boolean,int,int) -> a
    java.awt.Font getFont(java.lang.String,int,int) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String,boolean,int,int) -> a
    java.lang.String getFontCanDisplay(java.util.LinkedList,java.lang.String) -> a
    java.awt.Font getBoldFont() -> a
    java.awt.Font getItalicFont() -> b
    java.awt.Font getPlainFont() -> c
    java.awt.Font getSmallFont() -> d
    java.awt.Font getSerifFont() -> e
    void setLAFFont(java.awt.Font) -> a
    geogebra.common.awt.GFont getFontCanDisplay(java.lang.String,boolean,int,int) -> a
geogebra.main.GeoGebraPortablePreferences -> geogebra.i.w:
    java.util.Properties properties -> a
    geogebra.main.GeoGebraPortablePreferences singleton -> a
    geogebra.main.GeoGebraPreferencesD getPref() -> a
    void loadPreferences() -> d
    void storePreferences() -> e
    java.lang.String loadPreference(java.lang.String,java.lang.String) -> a
    void savePreference(java.lang.String,java.lang.String) -> a
    java.io.File getDefaultFilePath() -> a
    java.io.File getDefaultImagePath() -> b
    void saveDefaultImagePath(java.io.File) -> a
    java.util.Locale getDefaultLocale() -> a
    void saveDefaultLocale(java.util.Locale) -> a
    void loadFileList() -> a
    void saveFileList() -> b
    void saveXMLPreferences(geogebra.main.AppD) -> a
    void loadXMLPreferences(geogebra.main.AppD) -> b
    void clearPreferences() -> c
    java.lang.String get(java.lang.String,java.lang.String) -> b
    void set(java.lang.String,java.lang.String) -> b
    java.lang.String getB64(geogebra.main.AppD) -> a
    void debug(java.lang.String) -> c
geogebra.main.GeoGebraPreferencesD -> geogebra.i.x:
    java.util.prefs.Preferences ggbPrefs -> a
    java.util.prefs.Preferences ggbPrefsSystem -> b
    java.lang.String factoryDefaultXml -> a
    java.lang.String XML_FACTORY_DEFAULT -> b
    java.lang.String TOOLS_FILE_GGT -> c
    java.lang.String APP_LOCALE -> d
    java.lang.String APP_CURRENT_IMAGE_PATH -> e
    java.lang.String APP_FILE_ -> f
    java.lang.String PROPERTY_FILEPATH -> g
    geogebra.main.GeoGebraPreferencesD singleton -> a
    void setPropertyFileName(java.lang.String) -> a
    geogebra.main.GeoGebraPreferencesD getPref() -> a
    java.lang.String loadPreference(java.lang.String,java.lang.String) -> a
    void savePreference(java.lang.String,java.lang.String) -> a
    boolean loadVersionCheckAllow(java.lang.String) -> a
    void saveVersionCheckAllow(java.lang.String) -> b
    java.io.File getDefaultFilePath() -> a
    java.io.File getDefaultImagePath() -> b
    void saveDefaultImagePath(java.io.File) -> a
    java.util.Locale getDefaultLocale() -> a
    void saveDefaultLocale(java.util.Locale) -> a
    void loadFileList() -> a
    void saveFileList() -> b
    void initDefaultXML(geogebra.main.AppD) -> c
    void saveXMLPreferences(geogebra.main.AppD) -> a
    void putByteArray(java.util.prefs.Preferences,java.lang.String,byte[]) -> a
    byte[] getByteArray(java.util.prefs.Preferences,java.lang.String,byte[]) -> a
    java.lang.String getXMLPreferences() -> a
    void loadXMLPreferences(geogebra.main.AppD) -> b
    void clearPreferences() -> c
    java.lang.String getDefaultPreferences() -> b
geogebra.main.GlassPaneListener -> geogebra.i.y:
    java.awt.Component glassPane -> a
    java.awt.Component destComp -> b
    java.awt.Container contentPane -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void redispatchMouseEvent(java.awt.event.MouseEvent) -> a
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
geogebra.main.GlobalKeyDispatcherD -> geogebra.i.z:
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
    boolean handleKeyPressed(java.awt.event.KeyEvent) -> a
    boolean handleKeyTyped(java.awt.event.KeyEvent) -> c
    boolean handleGeneralKeys(java.awt.event.KeyEvent) -> b
    boolean handleSelectedGeosKeys(java.awt.event.KeyEvent,java.util.ArrayList) -> a
    void handleFunctionKeyForAlgebraInput(int,geogebra.common.kernel.geos.GeoElement) -> a
    boolean handleEnter() -> a
    boolean handleTab(boolean,boolean) -> a
    void handleCtrlC() -> c
    void handleCtrlV() -> b
    boolean handleCtrlShiftN(boolean) -> a
    void copyDefinitionsToInputBarAsList(java.util.ArrayList) -> a
    void createNewWindow() -> a
    void showPrintPreview(geogebra.common.main.App) -> a
geogebra.main.LocalizationD -> geogebra.i.A:
    java.util.ResourceBundle rbmenu -> a
    java.util.ResourceBundle rbmenuTT -> b
    java.util.ResourceBundle rbcommand -> c
    java.util.ResourceBundle rbcommandOld -> d
    java.util.ResourceBundle rberror -> e
    java.util.ResourceBundle rbcolors -> f
    java.util.ResourceBundle rbplain -> g
    java.util.ResourceBundle rbplainTT -> h
    java.util.ResourceBundle rbsymbol -> i
    java.util.Locale currentLocale -> a
    java.util.Locale tooltipLocale -> b
    geogebra.common.main.App app -> a
    java.util.ArrayList supportedLocales -> a
    void setTooltipFlag() -> b
    java.lang.String getCommand(java.lang.String) -> a
    java.lang.String getPlain(java.lang.String) -> b
    java.lang.String getPlainTooltip(java.lang.String) -> j
    void initPlainTTResourceBundle() -> d
    java.lang.String getMenu(java.lang.String) -> c
    java.lang.String getMenuTooltip(java.lang.String) -> i
    java.lang.String getError(java.lang.String) -> d
    java.lang.String getSymbol(int) -> a
    java.lang.String getLanguage() -> a
    java.lang.String getSymbolTooltip(int) -> d
    void initPlainResourceBundle() -> e
    void initSymbolResourceBundle() -> f
    void initCommand() -> a
    void initColorsResourceBundle() -> g
    void updateResourceBundles() -> h
    java.util.Locale getClosestSupportedLocale(java.util.Locale) -> a
    java.util.ArrayList getSupportedLocales() -> a
    java.util.ArrayList getSupportedLocales(boolean) -> a
    java.util.Locale getLocale() -> a
    void setLocale(java.util.Locale) -> a
    boolean propertiesFilesPresent() -> g
    boolean setTooltipLanguage(java.lang.String) -> c
    java.util.Locale getTooltipLocale() -> b
    java.lang.String getTooltipLanguageString() -> b
    java.lang.String getColor(java.lang.String) -> f
    java.lang.String reverseGetColor(java.lang.String) -> e
    boolean isCommandChanged() -> e
    void setCommandChanged(boolean) -> b
    boolean isCommandNull() -> f
geogebra.main.LoggingOutputStream -> geogebra.i.B:
    java.lang.String lineSeparator -> a
    java.util.logging.Logger logger -> a
    java.util.logging.Level level -> a
    void flush() -> flush
geogebra.main.MyResourceBundle -> geogebra.i.C:
    java.util.ResourceBundle createBundle(java.lang.String,java.util.Locale) -> a
    geogebra.main.MyResourceBundle loadSingleBundleFile(java.lang.String) -> a
geogebra.main.SpreadsheetTableModelD -> geogebra.i.D:
    javax.swing.table.DefaultTableModel defaultTableModel -> a
    javax.swing.table.DefaultTableModel getDefaultTableModel() -> a
    int getRowCount() -> b
    int getColumnCount() -> c
    void setRowCount(int) -> a
    void setColumnCount(int) -> b
    java.lang.Object getValueAt(int,int) -> a
    void setValueAt(java.lang.Object,int,int) -> a
    boolean hasFocus() -> hasFocus
    void repaint() -> repaint
    boolean isShowing() -> isShowing
geogebra.main.StdOutErrLevel -> geogebra.i.E:
    java.util.logging.Level STDOUT -> a
    java.util.logging.Level STDERR -> b
geogebra.plugin.CallJavaScript -> geogebra.j.a:
    void evalScript(geogebra.common.main.App,java.lang.String,java.lang.String) -> a
geogebra.plugin.ClassPathManipulator -> geogebra.j.b:
    boolean addURL(java.net.URL,java.lang.ClassLoader) -> a
geogebra.plugin.GeoGebraGlobal -> geogebra.j.c:
    geogebra.main.AppD app -> a
    java.lang.StringBuilder sb -> a
    int[] linep -> a
    java.lang.Object FTAG -> a
    void init(geogebra.main.AppD,org.mozilla.javascript.Scriptable,boolean) -> a
    java.lang.Object execIdCall(org.mozilla.javascript.IdFunctionObject,org.mozilla.javascript.Context,org.mozilla.javascript.Scriptable,org.mozilla.javascript.Scriptable,java.lang.Object[]) -> execIdCall
    java.lang.String argError(java.lang.Object,java.lang.String) -> a
    java.lang.String argNumError(int,java.lang.String) -> a
    void initStandardObjects(geogebra.main.AppD,org.mozilla.javascript.Scriptable,java.lang.String,boolean) -> a
geogebra.plugin.GgbAPID -> geogebra.j.d:
    geogebra.kernel.EvalCommandQueue evq -> a
    java.security.MessageDigest messageDigestMD5 -> a
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getBase64(boolean) -> getBase64
    void setBase64(java.lang.String) -> setBase64
    boolean evalCommand(java.lang.String,boolean) -> a
    geogebra.kernel.EvalCommandQueue getEvalCommandQueue() -> a
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void reset() -> reset
    void refreshViews() -> refreshViews
    void openFile(java.lang.String) -> openFile
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    java.security.MessageDigest getMessageDigestMD5() -> a
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    java.lang.String prompt(java.lang.Object,java.lang.Object) -> a
    void alert(java.lang.String) -> a
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
geogebra.plugin.GgbAPID$1 -> geogebra.j.e:
    geogebra.plugin.GgbAPID this$0 -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.io.File val$file -> a
    java.lang.Boolean run() -> a
    java.lang.Object run() -> run
geogebra.plugin.PlugLetIF -> geogebra.j.f:
    java.lang.String getMenuText() -> a
    void init(geogebra.plugin.GgbAPID,java.lang.String) -> a
    void execute() -> a
geogebra.plugin.PluginManager -> geogebra.j.g:
    java.util.Hashtable plugintable -> a
    geogebra.main.AppD app -> a
    javax.swing.JMenu pluginmenu -> a
    java.util.ArrayList lines -> a
    geogebra.plugin.ClassPathManipulator cpm -> a
    javax.swing.JMenu getPluginMenu() -> a
    void addPlugin(java.lang.String,java.lang.String) -> a
    void installPlugins() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void addPaths(java.util.ArrayList) -> a
    geogebra.plugin.PlugLetIF getPluginInstance(java.lang.String) -> a
    void loadProperties() -> b
    void debug(java.lang.String) -> a
    java.net.URL addPathToJar(java.lang.String) -> a
geogebra.plugin.ScriptManagerD -> geogebra.j.h:
    void ggbOnInit() -> f
    void initJavaScript() -> g
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
geogebra.sound.FunctionSound -> geogebra.k.a:
    geogebra.main.AppD app -> a
    geogebra.sound.FunctionSound$SoundThread soundThread -> a
    javax.sound.sampled.AudioFormat af -> a
    javax.sound.sampled.SourceDataLine sdl -> a
    int bitDepth -> a
    int sampleRate -> b
    int maxVolume -> c
    geogebra.common.kernel.geos.GeoFunction f -> a
    double min -> a
    double max -> b
    double t -> c
    boolean initStreamingAudio(int,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
    void pause(boolean) -> a
    void update(javax.sound.sampled.LineEvent) -> update
    int access$0(geogebra.sound.FunctionSound) -> a
    int access$1(geogebra.sound.FunctionSound) -> b
    javax.sound.sampled.SourceDataLine access$2() -> a
    javax.sound.sampled.AudioFormat access$3() -> a
    double access$4(geogebra.sound.FunctionSound) -> a
    void access$5(geogebra.sound.FunctionSound,double) -> a
    double access$6(geogebra.sound.FunctionSound) -> b
    double access$7(geogebra.sound.FunctionSound) -> c
    geogebra.common.kernel.geos.GeoFunction access$8(geogebra.sound.FunctionSound) -> a
    int access$9(geogebra.sound.FunctionSound) -> c
geogebra.sound.FunctionSound$SoundThread -> geogebra.k.a$a:
    boolean stopped -> a
    double samplePeriod -> a
    byte[] buf -> a
    geogebra.sound.FunctionSound this$0 -> a
    void run() -> run
    void generateFunctionSound() -> b
    void loadBuffer8(double) -> a
    void loadBuffer16(double) -> b
    void doFade(short,boolean) -> a
    void stopSound() -> a
geogebra.sound.MidiSound -> geogebra.k.b:
    geogebra.main.AppD app -> a
    javax.sound.midi.Synthesizer synthesizer -> a
    javax.sound.midi.Instrument[] instruments -> a
    javax.sound.midi.MidiChannel[] channels -> a
    javax.sound.midi.Sequencer sequencer -> a
    javax.sound.midi.Sequence sequence -> a
    long tickPosition -> a
    org.jfugue.Player player -> a
    boolean initialize() -> a
    void playSequence(javax.sound.midi.Sequence,long) -> a
    void playSequence(javax.sound.midi.Sequence,int,long) -> a
    void pause(boolean) -> a
    void stop() -> a
    void closeMidiSound() -> b
    void meta(javax.sound.midi.MetaMessage) -> meta
    void playSequenceNote(int,double,int,int) -> a
    void playMidiFile(java.lang.String) -> a
    void loadSoundBank(java.io.File,java.net.URL) -> b
    void playSequenceFromJFugueString(java.lang.String,int) -> a
    void playJFugueFromFile(java.io.File,java.net.URL) -> a
geogebra.sound.MidiSound$PlayerThread -> geogebra.k.b$a:
    org.jfugue.Pattern pattern -> a
    org.jfugue.Player player -> a
    geogebra.sound.MidiSound this$0 -> a
    void run() -> run
geogebra.sound.SoundManager -> geogebra.k.c:
    geogebra.main.AppD app -> a
    geogebra.sound.MidiSound midiSound -> a
    geogebra.sound.FunctionSound functionSound -> a
    int currentSoundType -> a
    boolean isRunning -> a
    boolean isPaused -> b
    geogebra.sound.MidiSound getMidiSound() -> a
    geogebra.sound.FunctionSound getFunctionSound() -> a
    void playSequenceNote(int,double,int,int) -> a
    void playMidiFile(java.lang.String) -> a
    void playSequenceFromString(java.lang.String,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void stopCurrentSound() -> a
    void pauseResumeSound(boolean) -> a
geogebra.util.AlgebraViewTransferHandler -> geogebra.l.a:
    geogebra.main.AppD app -> a
    java.awt.datatransfer.DataFlavor algebraViewFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.util.ArrayList geoLabelList -> a
    int getSourceActions(javax.swing.JComponent) -> getSourceActions
    boolean canImport(javax.swing.JComponent,java.awt.datatransfer.DataFlavor[]) -> canImport
    java.awt.datatransfer.Transferable createTransferable(javax.swing.JComponent) -> createTransferable
    boolean importData(javax.swing.JComponent,java.awt.datatransfer.Transferable) -> importData
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
geogebra.util.CASDragGestureListener -> geogebra.l.b:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.App app -> a
    geogebra.cas.view.CASTableD table -> a
    java.awt.dnd.DragSource ds -> a
    java.util.ArrayList geoLabelList -> a
    java.awt.dnd.DragGestureRecognizer dgr -> a
    void enableDnD() -> a
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
geogebra.util.CASDragGestureListener$TransferableCAS -> geogebra.l.b$a:
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.util.ArrayList geoLabels -> a
    int tableRef -> a
    boolean isAssignment -> a
    geogebra.util.CASDragGestureListener this$0 -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
    void setIsAssignment(boolean) -> a
geogebra.util.CASDropTargetListener -> geogebra.l.c:
    geogebra.cas.view.CASTableD table -> a
    geogebra.main.AppD app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.cas.view.CASView view -> a
    java.awt.dnd.DropTarget dropTarget -> a
    void enableDnD() -> a
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
geogebra.util.CASTransferHandler -> geogebra.l.d:
    java.awt.datatransfer.DataFlavor casTableFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    void setSupportedFlavours() -> a
    boolean canImport(javax.swing.JComponent,java.awt.datatransfer.DataFlavor[]) -> canImport
    java.awt.datatransfer.Transferable createTransferable(javax.swing.JComponent) -> createTransferable
    int getSourceActions(javax.swing.JComponent) -> getSourceActions
    void exportDone(javax.swing.JComponent,java.awt.datatransfer.Transferable,int) -> exportDone
geogebra.util.DisposeDialogAction -> geogebra.l.e:
    javax.swing.JDialog dialog -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.util.DownloadManager -> geogebra.l.f:
    java.lang.String tempDir -> a
    java.lang.String getTempDir() -> a
geogebra.util.GeoGebraLogger -> geogebra.l.g:
    java.io.File logFile -> a
    java.io.FileWriter logFileWriter -> a
    java.lang.String getTimeInfo() -> a
    void setLogFile(java.lang.String) -> b
    void print(java.lang.String,geogebra.common.util.GeoGebraLogger$Level) -> a
geogebra.util.GeoLaTeXCache -> geogebra.l.h:
    java.lang.Object keyLaTeX -> a
    java.lang.Object getCachedLaTeXKey(java.lang.String,int,int,geogebra.common.awt.GColor) -> a
    void remove() -> a
geogebra.util.HttpRequest -> geogebra.l.i:
    java.lang.String answer -> b
    void sendRequest(java.lang.String) -> a
    java.lang.String sendRequestGetResponseSync(java.lang.String) -> a
geogebra.util.ImageManager -> geogebra.l.j:
    java.util.Hashtable iconTable -> a
    java.util.Hashtable internalImageTable -> b
    java.util.Hashtable externalImageTable -> c
    java.awt.Toolkit toolKit -> a
    java.awt.MediaTracker tracker -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String) -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String,java.awt.Color) -> a
    java.awt.Image addBorder(java.awt.Image,java.awt.Color) -> a
    java.awt.Image getInternalImage(java.lang.String) -> a
    void addExternalImage(java.lang.String,java.awt.image.BufferedImage) -> a
    java.awt.image.BufferedImage getExternalImage(java.lang.String) -> a
    java.awt.Image getImageResourceGeoGebra(java.lang.String) -> b
    java.awt.Image getImageResource(java.lang.String) -> c
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image) -> a
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image,int) -> a
    boolean hasAlpha(java.awt.Image) -> a
    javax.swing.ImageIcon getScaledIcon(javax.swing.ImageIcon,int,int) -> a
    java.awt.Image getScaledImage(java.awt.Image,int,int) -> a
    java.lang.String createImage(java.lang.String,geogebra.common.main.App) -> a
geogebra.util.Normalizer -> geogebra.l.k:
    geogebra.common.util.NormalizerMinimal INSTANCE -> a
    geogebra.common.util.NormalizerMinimal getInstance() -> a
    geogebra.common.util.NormalizerMinimal getNormalizerClass() -> b
geogebra.util.Normalizer6 -> geogebra.l.l:
    java.lang.reflect.Method normalize -> a
    java.lang.Object NFD -> a
    java.lang.String transform(java.lang.String) -> a
geogebra.util.NumberFormatDesktop -> geogebra.l.m:
geogebra.util.ScientificFormat -> geogebra.l.n:
    int sigDigit -> a
    int maxWidth -> b
    boolean sciNote -> a
    java.text.DecimalFormat decimalFormat -> a
    double k -> a
    java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition) -> format
    java.lang.Object parseObject(java.lang.String,java.text.ParsePosition) -> parseObject
    int getSigDigits() -> a
    void setSigDigits(int) -> a
    void setMaxWidth(int) -> b
    void setScientificNotationStyle(boolean) -> a
    double Log10(double) -> a
    int resolveErrorSigDigit(double,double) -> a
    java.text.DecimalFormat getDecimalFormat(int) -> a
    java.lang.String format(double) -> a
    java.lang.String format(double,int) -> a
geogebra.util.StringUtil -> geogebra.l.o:
    boolean isRightToLeftChar(char) -> a
    java.lang.String toLower(java.lang.String) -> d
    java.lang.String toUpper(java.lang.String) -> e
geogebra.util.Util -> geogebra.l.p:
    char[] hexChar -> a
    java.lang.StringBuilder hexSB -> a
    java.util.Comparator comparator -> a
    double getJavaVersion() -> a
    void addKeyListenerToAll(java.awt.Container,java.awt.event.KeyListener) -> a
    byte[] loadIntoMemory(java.io.InputStream) -> a
    java.lang.String loadIntoString(java.io.InputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void registerForDisposeOnEscape(javax.swing.JDialog) -> a
    java.lang.String keepOnlyLettersAndDigits(java.lang.String) -> a
    java.lang.String processFilename(java.lang.String) -> b
    java.util.Comparator getFileComparator() -> a
    java.lang.String getIPAddress() -> a
    java.lang.String getHostname() -> b
geogebra.util.Util$1 -> geogebra.l.q:
    int compare(java.io.File,java.io.File) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.util.Util$2 -> geogebra.l.r:
    java.lang.Object run() -> run
geogebra.util.Util$3 -> geogebra.l.s:
    java.lang.String run() -> a
    java.lang.Object run() -> run
geogebra.util.Validation -> geogebra.l.t:
    geogebra.util.Validation validation -> a
    double validateDouble(javax.swing.JTextField,double) -> a
    double validateDoublePositive(javax.swing.JTextField,double) -> b
geogebra.util.Validation$1 -> geogebra.l.u:
    boolean checkInterval(double) -> a
geogebra.util.Validation$DoubleValidator -> geogebra.l.t$a:
    geogebra.util.Validation this$0 -> a
    double validateDouble(javax.swing.JTextField,double) -> a
    boolean checkInterval(double) -> a
    double access$1(geogebra.util.Validation$DoubleValidator,javax.swing.JTextField,double) -> a
org.apache.commons.collections15.IteratorUtils -> org.a.a.a.a:
    org.apache.commons.collections15.ResettableIterator EMPTY_ITERATOR -> a
    org.apache.commons.collections15.ResettableListIterator EMPTY_LIST_ITERATOR -> a
    org.apache.commons.collections15.OrderedIterator EMPTY_ORDERED_ITERATOR -> a
    org.apache.commons.collections15.MapIterator EMPTY_MAP_ITERATOR -> a
    org.apache.commons.collections15.OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR -> a
    java.util.Iterator unmodifiableIterator(java.util.Iterator) -> a
org.apache.commons.collections15.MapIterator -> org.a.a.a.b:
org.apache.commons.collections15.OrderedIterator -> org.a.a.a.c:
org.apache.commons.collections15.OrderedMapIterator -> org.a.a.a.d:
org.apache.commons.collections15.ResettableIterator -> org.a.a.a.e:
org.apache.commons.collections15.ResettableListIterator -> org.a.a.a.f:
org.apache.commons.collections15.Transformer -> org.a.a.a.g:
    java.lang.Object transform(java.lang.Object) -> a
org.apache.commons.collections15.Unmodifiable -> org.a.a.a.h:
org.apache.commons.collections15.functors.ConstantTransformer -> org.a.a.a.a.a:
    org.apache.commons.collections15.Transformer NULL_INSTANCE -> a
    java.lang.Object iConstant -> a
    java.lang.Object transform(java.lang.Object) -> a
org.apache.commons.collections15.iterators.AbstractEmptyIterator -> org.a.a.a.b.a:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    boolean hasPrevious() -> hasPrevious
    java.lang.Object previous() -> previous
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    void add(java.lang.Object) -> add
    void set(java.lang.Object) -> set
    void remove() -> remove
org.apache.commons.collections15.iterators.EmptyIterator -> org.a.a.a.b.b:
    org.apache.commons.collections15.ResettableIterator RESETTABLE_INSTANCE -> a
    java.util.Iterator INSTANCE -> a
org.apache.commons.collections15.iterators.EmptyListIterator -> org.a.a.a.b.c:
    org.apache.commons.collections15.ResettableListIterator RESETTABLE_INSTANCE -> a
    java.util.ListIterator INSTANCE -> a
org.apache.commons.collections15.iterators.EmptyMapIterator -> org.a.a.a.b.d:
    org.apache.commons.collections15.MapIterator INSTANCE -> a
org.apache.commons.collections15.iterators.EmptyOrderedIterator -> org.a.a.a.b.e:
    org.apache.commons.collections15.OrderedIterator INSTANCE -> a
org.apache.commons.collections15.iterators.EmptyOrderedMapIterator -> org.a.a.a.b.f:
    org.apache.commons.collections15.OrderedMapIterator INSTANCE -> a
org.apache.commons.collections15.iterators.UnmodifiableIterator -> org.a.a.a.b.g:
    java.util.Iterator iterator -> a
    java.util.Iterator decorate(java.util.Iterator) -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
org.apache.commons.math.ConvergenceException -> org.a.a.b.a:
org.apache.commons.math.ConvergingAlgorithm -> org.a.a.b.b:
    void setAbsoluteAccuracy(double) -> a
org.apache.commons.math.ConvergingAlgorithmImpl -> org.a.a.b.c:
    double absoluteAccuracy -> a
    double relativeAccuracy -> b
    int maximalIterationCount -> a
    double defaultAbsoluteAccuracy -> c
    double defaultRelativeAccuracy -> d
    int defaultMaximalIterationCount -> b
    int iterationCount -> c
    void setAbsoluteAccuracy(double) -> a
    void setMaximalIterationCount(int) -> a
    void setRelativeAccuracy(double) -> b
org.apache.commons.math.FunctionEvaluationException -> org.a.a.b.d:
    double[] argument -> a
org.apache.commons.math.MathException -> org.a.a.b.e:
    org.apache.commons.math.exception.util.Localizable pattern -> a
    java.lang.Object[] arguments -> a
    org.apache.commons.math.exception.util.Localizable getSpecificPattern() -> a
    org.apache.commons.math.exception.util.Localizable getGeneralPattern() -> b
    java.lang.Object[] getArguments() -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    void printStackTrace() -> printStackTrace
    void printStackTrace(java.io.PrintStream) -> printStackTrace
org.apache.commons.math.MathRuntimeException -> org.a.a.b.f:
    org.apache.commons.math.exception.util.Localizable pattern -> a
    java.lang.Object[] arguments -> a
    java.lang.String buildMessage(java.util.Locale,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> b
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    void printStackTrace() -> printStackTrace
    void printStackTrace(java.io.PrintStream) -> printStackTrace
    java.lang.ArithmeticException createArithmeticException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.IllegalArgumentException createIllegalArgumentException(java.lang.String,java.lang.Object[]) -> a
    java.lang.IllegalArgumentException createIllegalArgumentException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.IllegalStateException createIllegalStateException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.UnsupportedOperationException createUnsupportedOperationException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.String access$0(java.util.Locale,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
org.apache.commons.math.MathRuntimeException$1 -> org.a.a.b.g:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$4 -> org.a.a.b.h:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$5 -> org.a.a.b.i:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$8 -> org.a.a.b.j:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MaxEvaluationsExceededException -> org.a.a.b.k:
    int maxEvaluations -> a
org.apache.commons.math.MaxIterationsExceededException -> org.a.a.b.l:
    int maxIterations -> a
org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction -> org.a.a.b.a.a:
    org.apache.commons.math.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction -> org.a.a.b.a.b:
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
org.apache.commons.math.analysis.MultivariateMatrixFunction -> org.a.a.b.a.c:
    double[][] value(double[]) -> a
org.apache.commons.math.analysis.MultivariateVectorialFunction -> org.a.a.b.a.d:
    double[] value(double[]) -> a
org.apache.commons.math.analysis.UnivariateRealFunction -> org.a.a.b.a.e:
    double value(double) -> a
org.apache.commons.math.analysis.integration.LegendreGaussIntegrator -> org.a.a.b.a.a.a:
    double[] ABSCISSAS_2 -> a
    double[] WEIGHTS_2 -> b
    double[] ABSCISSAS_3 -> c
    double[] WEIGHTS_3 -> d
    double[] ABSCISSAS_4 -> e
    double[] WEIGHTS_4 -> f
    double[] ABSCISSAS_5 -> g
    double[] WEIGHTS_5 -> h
    double[] abscissas -> i
    double[] weights -> j
    double integrate(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double stage(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,int) -> a
org.apache.commons.math.analysis.integration.UnivariateRealIntegrator -> org.a.a.b.a.a.b:
org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl -> org.a.a.b.a.a.c:
    int minimalIterationCount -> d
    int defaultMinimalIterationCount -> e
    boolean resultComputed -> a
    double result -> e
    void setResult(double,int) -> a
    void clearResult() -> a
    void verifyInterval(double,double) -> a
    void verifyIterationCount() -> b
org.apache.commons.math.analysis.polynomials.PolynomialFunction -> org.a.a.b.a.b.a:
    double[] coefficients -> a
    double value(double) -> a
    int degree() -> a
    double[] getCoefficients() -> a
    double evaluate(double[],double) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction add(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction subtract(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> b
    org.apache.commons.math.analysis.polynomials.PolynomialFunction multiply(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> c
    double[] differentiate(double[]) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction polynomialDerivative() -> a
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math.analysis.solvers.BrentSolver -> org.a.a.b.a.c.a:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double,double,double,double) -> a
org.apache.commons.math.analysis.solvers.LaguerreSolver -> org.a.a.b.a.c.b:
    org.apache.commons.math.analysis.polynomials.PolynomialFunction p -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    boolean isRootOK(double,double,org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex[] solveAll(double[],double) -> a
    org.apache.commons.math.complex.Complex[] solveAll(org.apache.commons.math.complex.Complex[],org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex solve(org.apache.commons.math.complex.Complex[],org.apache.commons.math.complex.Complex) -> a
org.apache.commons.math.analysis.solvers.NewtonSolver -> org.a.a.b.a.c.c:
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolver -> org.a.a.b.a.c.d:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory -> org.a.a.b.a.c.e:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory newInstance() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newDefaultSolver() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newBrentSolver() -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newNewtonSolver() -> c
org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImpl -> org.a.a.b.a.c.f:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newDefaultSolver() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newBrentSolver() -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newNewtonSolver() -> c
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl -> org.a.a.b.a.c.g:
    double functionValueAccuracy -> e
    double defaultFunctionValueAccuracy -> f
    boolean resultComputed -> a
    double result -> g
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    void setResult(double,int) -> a
    void clearResult() -> a
    boolean isBracketing(double,double,org.apache.commons.math.analysis.UnivariateRealFunction) -> a
    boolean isSequence(double,double,double) -> a
    void verifyInterval(double,double) -> a
    void verifySequence(double,double,double) -> a
    void verifyBracketing(double,double,org.apache.commons.math.analysis.UnivariateRealFunction) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils -> org.a.a.b.a.c.h:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double[] bracket(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double[] bracket(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double,int) -> a
    double midpoint(double,double) -> a
    void setup(org.apache.commons.math.analysis.UnivariateRealFunction) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils$LazyHolder -> org.a.a.b.a.c.h$a:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory FACTORY -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory access$0() -> a
org.apache.commons.math.complex.Complex -> org.a.a.b.b.a:
    org.apache.commons.math.complex.Complex I -> a
    org.apache.commons.math.complex.Complex NaN -> b
    org.apache.commons.math.complex.Complex INF -> c
    org.apache.commons.math.complex.Complex ONE -> d
    org.apache.commons.math.complex.Complex ZERO -> e
    double imaginary -> a
    double real -> b
    boolean isNaN -> a
    boolean isInfinite -> b
    double abs() -> a
    org.apache.commons.math.complex.Complex add(org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex conjugate() -> a
    org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    double getImaginary() -> b
    double getReal() -> c
    boolean isNaN() -> a
    boolean isInfinite() -> b
    org.apache.commons.math.complex.Complex multiply(org.apache.commons.math.complex.Complex) -> c
    org.apache.commons.math.complex.Complex multiply(double) -> a
    org.apache.commons.math.complex.Complex subtract(org.apache.commons.math.complex.Complex) -> d
    org.apache.commons.math.complex.Complex exp() -> b
    org.apache.commons.math.complex.Complex log() -> c
    org.apache.commons.math.complex.Complex pow(org.apache.commons.math.complex.Complex) -> e
    org.apache.commons.math.complex.Complex sqrt() -> d
    org.apache.commons.math.complex.Complex createComplex(double,double) -> a
org.apache.commons.math.distribution.AbstractContinuousDistribution -> org.a.a.b.c.a:
    org.apache.commons.math.random.RandomDataImpl randomData -> a
    double solverAbsoluteAccuracy -> a
    double inverseCumulativeProbability(double) -> a_
    double getInitialDomain(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.AbstractContinuousDistribution$1 -> org.a.a.b.c.b:
    org.apache.commons.math.distribution.AbstractContinuousDistribution this$0 -> a
    double val$p -> a
    double value(double) -> a
org.apache.commons.math.distribution.AbstractDistribution -> org.a.a.b.c.c:
org.apache.commons.math.distribution.AbstractIntegerDistribution -> org.a.a.b.c.d:
    org.apache.commons.math.random.RandomDataImpl randomData -> a
    double cumulativeProbability(double) -> a
    double cumulativeProbability(int) -> a
    double probability(double) -> b
    int inverseCumulativeProbability(double) -> a
    double checkedCumulativeProbability(int) -> c
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
org.apache.commons.math.distribution.BinomialDistribution -> org.a.a.b.c.e:
    int getNumberOfTrials() -> a
    double getProbabilityOfSuccess() -> a
org.apache.commons.math.distribution.BinomialDistributionImpl -> org.a.a.b.c.f:
    int numberOfTrials -> a
    double probabilityOfSuccess -> a
    int getNumberOfTrials() -> a
    double getProbabilityOfSuccess() -> a
    void setNumberOfTrialsInternal(int) -> a
    void setProbabilityOfSuccessInternal(double) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double cumulativeProbability(int) -> a
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.CauchyDistribution -> org.a.a.b.c.g:
    double getMedian() -> b
    double getScale() -> c
org.apache.commons.math.distribution.CauchyDistributionImpl -> org.a.a.b.c.h:
    double median -> a
    double scale -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double getMedian() -> b
    double getScale() -> c
    double inverseCumulativeProbability(double) -> a_
    void setMedianInternal(double) -> a
    void setScaleInternal(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ChiSquaredDistribution -> org.a.a.b.c.i:
    double getDegreesOfFreedom() -> b
org.apache.commons.math.distribution.ChiSquaredDistributionImpl -> org.a.a.b.c.j:
    org.apache.commons.math.distribution.GammaDistribution gamma -> a
    double solverAbsoluteAccuracy -> a
    void setDegreesOfFreedomInternal(double) -> a
    double getDegreesOfFreedom() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    void setGammaInternal(org.apache.commons.math.distribution.GammaDistribution) -> a
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ContinuousDistribution -> org.a.a.b.c.k:
    double inverseCumulativeProbability(double) -> a_
org.apache.commons.math.distribution.DiscreteDistribution -> org.a.a.b.c.l:
    double probability(double) -> b
org.apache.commons.math.distribution.Distribution -> org.a.a.b.c.m:
    double cumulativeProbability(double) -> a
org.apache.commons.math.distribution.ExponentialDistribution -> org.a.a.b.c.n:
    double getMean() -> b
org.apache.commons.math.distribution.ExponentialDistributionImpl -> org.a.a.b.c.o:
    double mean -> a
    double solverAbsoluteAccuracy -> b
    void setMeanInternal(double) -> a
    double getMean() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.FDistribution -> org.a.a.b.c.p:
    double getNumeratorDegreesOfFreedom() -> b
    double getDenominatorDegreesOfFreedom() -> c
org.apache.commons.math.distribution.FDistributionImpl -> org.a.a.b.c.q:
    double numeratorDegreesOfFreedom -> a
    double denominatorDegreesOfFreedom -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    void setNumeratorDegreesOfFreedomInternal(double) -> a
    double getNumeratorDegreesOfFreedom() -> b
    void setDenominatorDegreesOfFreedomInternal(double) -> b
    double getDenominatorDegreesOfFreedom() -> c
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.GammaDistribution -> org.a.a.b.c.r:
    void setAlpha(double) -> a
    double getAlpha() -> b
    double getBeta() -> c
org.apache.commons.math.distribution.GammaDistributionImpl -> org.a.a.b.c.s:
    double alpha -> a
    double beta -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    void setAlpha(double) -> a
    void setAlphaInternal(double) -> b
    double getAlpha() -> b
    void setBetaInternal(double) -> c
    double getBeta() -> c
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.HypergeometricDistribution -> org.a.a.b.c.t:
    int getNumberOfSuccesses() -> a
    int getPopulationSize() -> b
    int getSampleSize() -> c
org.apache.commons.math.distribution.HypergeometricDistributionImpl -> org.a.a.b.c.u:
    int numberOfSuccesses -> a
    int populationSize -> b
    int sampleSize -> c
    double cumulativeProbability(int) -> a
    int[] getDomain(int,int,int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    int getLowerDomain(int,int,int) -> a
    int getNumberOfSuccesses() -> a
    int getPopulationSize() -> b
    int getSampleSize() -> c
    int getUpperDomain(int,int) -> a
    double probability(int) -> b
    double probability(int,int,int,int) -> a
    void setNumberOfSuccessesInternal(int) -> a
    void setPopulationSizeInternal(int) -> b
    void setSampleSizeInternal(int) -> c
    double innerCumulativeProbability(int,int,int,int,int,int) -> a
org.apache.commons.math.distribution.IntegerDistribution -> org.a.a.b.c.v:
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.NormalDistribution -> org.a.a.b.c.w:
    double getMean() -> b
    void setMean(double) -> a
    double getStandardDeviation() -> c
    void setStandardDeviation(double) -> b
org.apache.commons.math.distribution.NormalDistributionImpl -> org.a.a.b.c.x:
    double SQRT2PI -> a
    double mean -> b
    double standardDeviation -> c
    double solverAbsoluteAccuracy -> d
    double getMean() -> b
    void setMean(double) -> a
    void setMeanInternal(double) -> c
    double getStandardDeviation() -> c
    void setStandardDeviation(double) -> b
    void setStandardDeviationInternal(double) -> d
    double cumulativeProbability(double) -> a
    double getSolverAbsoluteAccuracy() -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
org.apache.commons.math.distribution.PascalDistribution -> org.a.a.b.c.y:
    int getNumberOfSuccesses() -> a
    double getProbabilityOfSuccess() -> a
org.apache.commons.math.distribution.PascalDistributionImpl -> org.a.a.b.c.z:
    int numberOfSuccesses -> a
    double probabilityOfSuccess -> a
    int getNumberOfSuccesses() -> a
    double getProbabilityOfSuccess() -> a
    void setNumberOfSuccessesInternal(int) -> a
    void setProbabilityOfSuccessInternal(double) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double cumulativeProbability(int) -> a
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.PoissonDistribution -> org.a.a.b.c.A:
    double getMean() -> a
org.apache.commons.math.distribution.PoissonDistributionImpl -> org.a.a.b.c.B:
    org.apache.commons.math.distribution.NormalDistribution normal -> a
    double mean -> a
    int maxIterations -> a
    double epsilon -> b
    double getMean() -> a
    void setNormalAndMeanInternal(org.apache.commons.math.distribution.NormalDistribution,double) -> a
    double probability(int) -> b
    double cumulativeProbability(int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
org.apache.commons.math.distribution.SaddlePointExpansion -> org.a.a.b.c.C:
    double HALF_LOG_2_PI -> a
    double[] EXACT_STIRLING_ERRORS -> a
    double getStirlingError(double) -> a
    double getDeviancePart(double,double) -> a
    double logBinomialProbability(int,int,double,double) -> a
org.apache.commons.math.distribution.TDistribution -> org.a.a.b.c.D:
    void setDegreesOfFreedom(double) -> a
    double getDegreesOfFreedom() -> b
org.apache.commons.math.distribution.TDistributionImpl -> org.a.a.b.c.E:
    double degreesOfFreedom -> a
    double solverAbsoluteAccuracy -> b
    void setDegreesOfFreedom(double) -> a
    void setDegreesOfFreedomInternal(double) -> b
    double getDegreesOfFreedom() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.WeibullDistribution -> org.a.a.b.c.F:
    double getShape() -> b
    double getScale() -> c
org.apache.commons.math.distribution.WeibullDistributionImpl -> org.a.a.b.c.G:
    double shape -> a
    double scale -> b
    double solverAbsoluteAccuracy -> c
    double numericalMean -> d
    boolean numericalMeanIsCalculated -> a
    double numericalVariance -> e
    boolean numericalVarianceIsCalculated -> b
    double cumulativeProbability(double) -> a
    double getShape() -> b
    double getScale() -> c
    double inverseCumulativeProbability(double) -> a_
    void setShapeInternal(double) -> a
    void setScaleInternal(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ZipfDistribution -> org.a.a.b.c.H:
    int getNumberOfElements() -> a
    double getExponent() -> a
org.apache.commons.math.distribution.ZipfDistributionImpl -> org.a.a.b.c.I:
    int numberOfElements -> a
    double exponent -> a
    int getNumberOfElements() -> a
    void setNumberOfElementsInternal(int) -> a
    double getExponent() -> a
    void setExponentInternal(double) -> a
    double probability(int) -> b
    double cumulativeProbability(int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double generalizedHarmonic(int,double) -> a
org.apache.commons.math.exception.DimensionMismatchException -> org.a.a.b.d.a:
    int dimension -> a
org.apache.commons.math.exception.MathIllegalArgumentException -> org.a.a.b.d.b:
    org.apache.commons.math.exception.util.Localizable specific -> a
    org.apache.commons.math.exception.util.Localizable general -> b
    java.lang.Object[] arguments -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.exception.MathIllegalNumberException -> org.a.a.b.d.c:
    java.lang.Number argument -> a
org.apache.commons.math.exception.MathIllegalStateException -> org.a.a.b.d.d:
    org.apache.commons.math.exception.util.Localizable specific -> a
    org.apache.commons.math.exception.util.Localizable general -> b
    java.lang.Object[] arguments -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.exception.MathInternalError -> org.a.a.b.d.e:
org.apache.commons.math.exception.NoDataException -> org.a.a.b.d.f:
org.apache.commons.math.exception.NotPositiveException -> org.a.a.b.d.g:
org.apache.commons.math.exception.NullArgumentException -> org.a.a.b.d.h:
org.apache.commons.math.exception.NumberIsTooLargeException -> org.a.a.b.d.i:
    java.lang.Number max -> a
    boolean boundIsAllowed -> a
org.apache.commons.math.exception.NumberIsTooSmallException -> org.a.a.b.d.j:
    java.lang.Number min -> a
    boolean boundIsAllowed -> a
org.apache.commons.math.exception.util.ArgUtils -> org.a.a.b.d.a.a:
    java.lang.Object[] flatten(java.lang.Object[]) -> a
org.apache.commons.math.exception.util.DummyLocalizable -> org.a.a.b.d.a.b:
    java.lang.String source -> a
    java.lang.String getLocalizedString(java.util.Locale) -> a
    java.lang.String toString() -> toString
org.apache.commons.math.exception.util.Localizable -> org.a.a.b.d.a.c:
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math.exception.util.LocalizedFormats -> org.a.a.b.d.a.d:
    org.apache.commons.math.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> a
    org.apache.commons.math.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> b
    org.apache.commons.math.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> c
    org.apache.commons.math.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> d
    org.apache.commons.math.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> e
    org.apache.commons.math.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> f
    org.apache.commons.math.exception.util.LocalizedFormats BANDWIDTH_OUT_OF_INTERVAL -> g
    org.apache.commons.math.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> h
    org.apache.commons.math.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> i
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> j
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> k
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> l
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> m
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> n
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_CONVERT_OBJECT_TO_FRACTION -> o
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> p
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> q
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> r
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> s
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> t
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> u
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> v
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> w
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> x
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> y
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> z
    org.apache.commons.math.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> A
    org.apache.commons.math.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> B
    org.apache.commons.math.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> C
    org.apache.commons.math.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> D
    org.apache.commons.math.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> E
    org.apache.commons.math.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> F
    org.apache.commons.math.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> G
    org.apache.commons.math.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> H
    org.apache.commons.math.exception.util.LocalizedFormats CONVERGENCE_FAILED -> I
    org.apache.commons.math.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> J
    org.apache.commons.math.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> K
    org.apache.commons.math.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> L
    org.apache.commons.math.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> M
    org.apache.commons.math.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> N
    org.apache.commons.math.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> O
    org.apache.commons.math.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> P
    org.apache.commons.math.exception.util.LocalizedFormats DUPLICATED_ABSCISSA -> Q
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> R
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> S
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> T
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> U
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> V
    org.apache.commons.math.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> W
    org.apache.commons.math.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> X
    org.apache.commons.math.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> Y
    org.apache.commons.math.exception.util.LocalizedFormats EVALUATION_FAILED -> Z
    org.apache.commons.math.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> aa
    org.apache.commons.math.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> ab
    org.apache.commons.math.exception.util.LocalizedFormats FAILED_BRACKETING -> ac
    org.apache.commons.math.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> ad
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> ae
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> af
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> ag
    org.apache.commons.math.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> ah
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> ai
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> aj
    org.apache.commons.math.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> ak
    org.apache.commons.math.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> al
    org.apache.commons.math.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> am
    org.apache.commons.math.exception.util.LocalizedFormats IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO -> an
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> ao
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> ap
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> aq
    org.apache.commons.math.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> ar
    org.apache.commons.math.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> as
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> at
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> au
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> av
    org.apache.commons.math.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> aw
    org.apache.commons.math.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> ax
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> ay
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> az
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> aA
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> aB
    org.apache.commons.math.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT -> aC
    org.apache.commons.math.exception.util.LocalizedFormats INTERNAL_ERROR -> aD
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> aE
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> aF
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> aG
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> aH
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> aI
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> aJ
    org.apache.commons.math.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> aK
    org.apache.commons.math.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> aL
    org.apache.commons.math.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> aM
    org.apache.commons.math.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> aN
    org.apache.commons.math.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> aO
    org.apache.commons.math.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> aP
    org.apache.commons.math.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> aQ
    org.apache.commons.math.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> aR
    org.apache.commons.math.exception.util.LocalizedFormats MAX_EVALUATIONS_EXCEEDED -> aS
    org.apache.commons.math.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> aT
    org.apache.commons.math.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> aU
    org.apache.commons.math.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> aV
    org.apache.commons.math.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> aW
    org.apache.commons.math.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> aX
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> aY
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> aZ
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> ba
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> bb
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> bc
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> bd
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ROBUSTNESS_ITERATIONS -> be
    org.apache.commons.math.exception.util.LocalizedFormats START_POSITION -> bf
    org.apache.commons.math.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> bg
    org.apache.commons.math.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> bh
    org.apache.commons.math.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> bi
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> bj
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> bk
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> bl
    org.apache.commons.math.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> bm
    org.apache.commons.math.exception.util.LocalizedFormats NORMALIZE_INFINITE -> bn
    org.apache.commons.math.exception.util.LocalizedFormats NORMALIZE_NAN -> bo
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> bp
    org.apache.commons.math.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> bq
    org.apache.commons.math.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> br
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> bs
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> bt
    org.apache.commons.math.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> bu
    org.apache.commons.math.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> bv
    org.apache.commons.math.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> bw
    org.apache.commons.math.exception.util.LocalizedFormats NOT_OVERRIDEN -> bx
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ALPHA -> by
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_BETA -> bz
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_COLUMNDIMENSION -> bA
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> bB
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> bC
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> bD
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> bE
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> bF
    org.apache.commons.math.exception.util.LocalizedFormats LENGTH -> bG
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> bH
    org.apache.commons.math.exception.util.LocalizedFormats MEAN -> bI
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> bJ
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> bK
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> bL
    org.apache.commons.math.exception.util.LocalizedFormats PERMUTATION_SIZE -> bM
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> bN
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> bO
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> bP
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> bQ
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> bR
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> bS
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> bT
    org.apache.commons.math.exception.util.LocalizedFormats STANDARD_DEVIATION -> bU
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> bV
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> bW
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> bX
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> bY
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> bZ
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> ca
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> cb
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> cc
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> cd
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> ce
    org.apache.commons.math.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> cf
    org.apache.commons.math.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> cg
    org.apache.commons.math.exception.util.LocalizedFormats NO_BIN_SELECTED -> ch
    org.apache.commons.math.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> ci
    org.apache.commons.math.exception.util.LocalizedFormats NO_DATA -> cj
    org.apache.commons.math.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> ck
    org.apache.commons.math.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> cl
    org.apache.commons.math.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> cm
    org.apache.commons.math.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> cn
    org.apache.commons.math.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> co
    org.apache.commons.math.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> cp
    org.apache.commons.math.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> cq
    org.apache.commons.math.exception.util.LocalizedFormats COVARIANCE_MATRIX -> cr
    org.apache.commons.math.exception.util.LocalizedFormats DENOMINATOR -> cs
    org.apache.commons.math.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> ct
    org.apache.commons.math.exception.util.LocalizedFormats FRACTION -> cu
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION -> cv
    org.apache.commons.math.exception.util.LocalizedFormats IMAGINARY_FORMAT -> cw
    org.apache.commons.math.exception.util.LocalizedFormats INPUT_ARRAY -> cx
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR -> cy
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR_FORMAT -> cz
    org.apache.commons.math.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> cA
    org.apache.commons.math.exception.util.LocalizedFormats REAL_FORMAT -> cB
    org.apache.commons.math.exception.util.LocalizedFormats WHOLE_FORMAT -> cC
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> cD
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> cE
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> cF
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> cG
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> cH
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> cI
    org.apache.commons.math.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> cJ
    org.apache.commons.math.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> cK
    org.apache.commons.math.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> cL
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> cM
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> cN
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> cO
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> cP
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> cQ
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> cR
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> cS
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> cT
    org.apache.commons.math.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> cU
    org.apache.commons.math.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> cV
    org.apache.commons.math.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> cW
    org.apache.commons.math.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> cX
    org.apache.commons.math.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> cY
    org.apache.commons.math.exception.util.LocalizedFormats POSITION_SIZE_MISMATCH_INPUT_ARRAY -> cZ
    org.apache.commons.math.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> da
    org.apache.commons.math.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> db
    org.apache.commons.math.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> dc
    org.apache.commons.math.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> dd
    org.apache.commons.math.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> de
    org.apache.commons.math.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> df
    org.apache.commons.math.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> dg
    org.apache.commons.math.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> dh
    org.apache.commons.math.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> di
    org.apache.commons.math.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> dj
    org.apache.commons.math.exception.util.LocalizedFormats SIMPLE_MESSAGE -> dk
    org.apache.commons.math.exception.util.LocalizedFormats SINGULAR_MATRIX -> dl
    org.apache.commons.math.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> dm
    org.apache.commons.math.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> dn
    org.apache.commons.math.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> do
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_BANDWIDTH -> dp
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> dq
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> dr
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> ds
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> dt
    org.apache.commons.math.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> du
    org.apache.commons.math.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> dv
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> dw
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> dx
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> dy
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> dz
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> dA
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> dB
    org.apache.commons.math.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> dC
    org.apache.commons.math.exception.util.LocalizedFormats UNKNOWN_MODE -> dD
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> dE
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> dF
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_FRACTION_NUMBER -> dG
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> dH
    org.apache.commons.math.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> dI
    org.apache.commons.math.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> dJ
    org.apache.commons.math.exception.util.LocalizedFormats USER_EXCEPTION -> dK
    org.apache.commons.math.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> dL
    org.apache.commons.math.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> dM
    org.apache.commons.math.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> dN
    org.apache.commons.math.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> dO
    org.apache.commons.math.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> dP
    org.apache.commons.math.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> dQ
    org.apache.commons.math.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> dR
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_POINTS -> dS
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_DENOMINATOR -> dT
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> dU
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> dV
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM -> dW
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> dX
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> dY
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> dZ
    java.lang.String sourceFormat -> a
    org.apache.commons.math.exception.util.LocalizedFormats[] ENUM$VALUES -> a
    java.lang.String getLocalizedString(java.util.Locale) -> a
    org.apache.commons.math.exception.util.LocalizedFormats[] values() -> values
    org.apache.commons.math.exception.util.LocalizedFormats valueOf(java.lang.String) -> valueOf
org.apache.commons.math.exception.util.MessageFactory -> org.a.a.b.d.a.e:
    java.lang.String buildMessage(java.util.Locale,org.apache.commons.math.exception.util.Localizable,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
org.apache.commons.math.linear.AbstractRealMatrix -> org.a.a.b.e.a:
    org.apache.commons.math.linear.DecompositionSolver lu -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
    double[][] getData() -> a
    void copySubMatrix(int,int,int,int,double[][]) -> a
    void setSubMatrix(double[][],int,int) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math.linear.RealMatrix transpose() -> a
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> b
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.linear.AbstractRealMatrix$4 -> org.a.a.b.e.b:
    int startRow -> a
    int startColumn -> b
    org.apache.commons.math.linear.AbstractRealMatrix this$0 -> a
    double[][] val$destination -> a
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
org.apache.commons.math.linear.AbstractRealMatrix$5 -> org.a.a.b.e.c:
    org.apache.commons.math.linear.AbstractRealMatrix this$0 -> a
    org.apache.commons.math.linear.RealMatrix val$out -> a
    void visit(int,int,double) -> a
org.apache.commons.math.linear.AnyMatrix -> org.a.a.b.e.d:
    boolean isSquare() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
org.apache.commons.math.linear.Array2DRowRealMatrix -> org.a.a.b.e.e:
    double[][] data -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double[][] copyOut() -> b
    void copyIn(double[][]) -> a
org.apache.commons.math.linear.BlockRealMatrix -> org.a.a.b.e.f:
    double[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    double[][] createBlocksLayout(int,int) -> a
    org.apache.commons.math.linear.BlockRealMatrix createMatrix(int,int) -> a
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math.linear.BlockRealMatrix transpose() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> b
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> b
    int blockHeight(int) -> a
    int blockWidth(int) -> b
    org.apache.commons.math.linear.RealMatrix transpose() -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
org.apache.commons.math.linear.DecompositionSolver -> org.a.a.b.e.g:
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    boolean isNonSingular() -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor -> org.a.a.b.e.h:
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math.linear.InvalidMatrixException -> org.a.a.b.e.i:
org.apache.commons.math.linear.LUDecompositionImpl -> org.a.a.b.e.j:
    double[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    org.apache.commons.math.linear.RealMatrix cachedL -> a
    org.apache.commons.math.linear.RealMatrix cachedU -> b
    org.apache.commons.math.linear.RealMatrix cachedP -> c
    double getDeterminant() -> a
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.LUDecompositionImpl$Solver -> org.a.a.b.e.j$a:
    double[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.MatrixIndexException -> org.a.a.b.e.k:
org.apache.commons.math.linear.MatrixUtils -> org.a.a.b.e.l:
    org.apache.commons.math.linear.RealMatrix createRealMatrix(int,int) -> a
    org.apache.commons.math.linear.RealMatrix createRealIdentityMatrix(int) -> a
    void checkRowIndex(org.apache.commons.math.linear.AnyMatrix,int) -> a
    void checkColumnIndex(org.apache.commons.math.linear.AnyMatrix,int) -> b
    void checkSubMatrixIndex(org.apache.commons.math.linear.AnyMatrix,int,int,int,int) -> a
org.apache.commons.math.linear.MatrixVisitorException -> org.a.a.b.e.m:
org.apache.commons.math.linear.NonSquareMatrixException -> org.a.a.b.e.n:
org.apache.commons.math.linear.QRDecompositionImpl -> org.a.a.b.e.o:
    double[][] qrt -> a
    double[] rDiag -> a
    org.apache.commons.math.linear.RealMatrix cachedQ -> a
    org.apache.commons.math.linear.RealMatrix cachedQT -> b
    org.apache.commons.math.linear.RealMatrix cachedR -> c
    org.apache.commons.math.linear.RealMatrix cachedH -> d
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.QRDecompositionImpl$Solver -> org.a.a.b.e.o$a:
    double[][] qrt -> a
    double[] rDiag -> a
    boolean isNonSingular() -> a
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.RealMatrix -> org.a.a.b.e.p:
    double[][] getData() -> a
    void copySubMatrix(int,int,int,int,double[][]) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math.linear.RealMatrix transpose() -> a
org.apache.commons.math.linear.RealMatrixPreservingVisitor -> org.a.a.b.e.q:
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math.linear.SingularMatrixException -> org.a.a.b.e.r:
org.apache.commons.math.ode.AbstractIntegrator -> org.a.a.b.f.a:
    java.util.Collection stepHandlers -> a
    double stepStart -> a
    double stepSize -> b
    boolean isLastStep -> a
    boolean resetOccurred -> b
    java.util.Collection eventsStates -> b
    boolean statesInitialized -> c
    java.lang.String name -> a
    int maxEvaluations -> a
    int evaluations -> b
    org.apache.commons.math.ode.FirstOrderDifferentialEquations equations -> a
    void addStepHandler(org.apache.commons.math.ode.sampling.StepHandler) -> a
    boolean requiresDenseOutput() -> a
    void setMaxEvaluations(int) -> a
    void resetEvaluations() -> a
    void setEquations(org.apache.commons.math.ode.FirstOrderDifferentialEquations) -> a
    void computeDerivatives(double,double[],double[]) -> a
    void setStateInitialized(boolean) -> a
    double acceptStep(org.apache.commons.math.ode.sampling.AbstractStepInterpolator,double[],double[],double) -> a
    void sanityChecks(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.AbstractIntegrator$1 -> org.a.a.b.f.b:
    org.apache.commons.math.ode.AbstractIntegrator this$0 -> a
    int val$orderingSign -> a
    int compare(org.apache.commons.math.ode.events.EventState,org.apache.commons.math.ode.events.EventState) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.apache.commons.math.ode.DerivativeException -> org.a.a.b.f.c:
org.apache.commons.math.ode.FirstOrderDifferentialEquations -> org.a.a.b.f.d:
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
org.apache.commons.math.ode.FirstOrderIntegrator -> org.a.a.b.f.e:
    double integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.IntegratorException -> org.a.a.b.f.f:
org.apache.commons.math.ode.ODEIntegrator -> org.a.a.b.f.g:
    void addStepHandler(org.apache.commons.math.ode.sampling.StepHandler) -> a
org.apache.commons.math.ode.events.EventException -> org.a.a.b.f.a.a:
org.apache.commons.math.ode.events.EventHandler -> org.a.a.b.f.a.b:
    double g(double,double[]) -> a
    int eventOccurred(double,double[],boolean) -> a
    void resetState(double,double[]) -> a
org.apache.commons.math.ode.events.EventState -> org.a.a.b.f.a.c:
    org.apache.commons.math.ode.events.EventHandler handler -> a
    double maxCheckInterval -> a
    double convergence -> b
    int maxIterationCount -> a
    double t0 -> c
    double g0 -> d
    boolean g0Positive -> a
    boolean pendingEvent -> b
    double pendingEventTime -> e
    double previousEventTime -> f
    boolean forward -> c
    boolean increasing -> d
    int nextAction -> b
    double getConvergence() -> a
    void reinitializeBegin(org.apache.commons.math.ode.sampling.StepInterpolator) -> a
    boolean evaluateStep(org.apache.commons.math.ode.sampling.StepInterpolator) -> a
    double getEventTime() -> b
    void stepAccepted(double,double[]) -> a
    boolean stop() -> a
    boolean reset(double,double[]) -> a
    org.apache.commons.math.ode.events.EventHandler access$0(org.apache.commons.math.ode.events.EventState) -> a
org.apache.commons.math.ode.events.EventState$1 -> org.a.a.b.f.a.d:
    org.apache.commons.math.ode.events.EventState this$0 -> a
    org.apache.commons.math.ode.sampling.StepInterpolator val$interpolator -> a
    double value(double) -> a
org.apache.commons.math.ode.events.EventState$EmbeddedDerivativeException -> org.a.a.b.f.a.c$a:
    org.apache.commons.math.ode.DerivativeException derivativeException -> a
    org.apache.commons.math.ode.DerivativeException getDerivativeException() -> a
org.apache.commons.math.ode.events.EventState$EmbeddedEventException -> org.a.a.b.f.a.c$b:
    org.apache.commons.math.ode.events.EventException eventException -> a
    org.apache.commons.math.ode.events.EventException getEventException() -> a
org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator -> org.a.a.b.f.b.a:
    double[] STATIC_C -> a
    double[][] STATIC_A -> a
    double[] STATIC_B -> b
org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolator -> org.a.a.b.f.b.b:
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator -> org.a.a.b.f.b.c:
    double[] c -> a
    double[][] a -> a
    double[] b -> b
    org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator prototype -> a
    double step -> c
    double integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator -> org.a.a.b.f.b.d:
    double[][] yDotK -> a
    org.apache.commons.math.ode.AbstractIntegrator integrator -> a
    void reinitialize(org.apache.commons.math.ode.AbstractIntegrator,double[],double[][],boolean) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
org.apache.commons.math.ode.sampling.AbstractStepInterpolator -> org.a.a.b.f.c.a:
    double h -> a
    double[] currentState -> a
    double interpolatedTime -> b
    double[] interpolatedState -> b
    double[] interpolatedDerivatives -> c
    double globalPreviousTime -> c
    double globalCurrentTime -> d
    double softPreviousTime -> e
    double softCurrentTime -> f
    boolean finalized -> a
    boolean forward -> b
    boolean dirtyState -> c
    void reinitialize(double[],boolean) -> a
    org.apache.commons.math.ode.sampling.StepInterpolator copy() -> b
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void shift() -> a
    void storeTime(double) -> a
    void setSoftPreviousTime(double) -> b
    void setSoftCurrentTime(double) -> c
    double getGlobalPreviousTime() -> a
    double getGlobalCurrentTime() -> b
    double getPreviousTime() -> c
    double getCurrentTime() -> d
    void setInterpolatedTime(double) -> d
    boolean isForward() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
    double[] getInterpolatedState() -> a
    void finalizeStep() -> b
    void doFinalize() -> c
    void writeBaseExternal(java.io.ObjectOutput) -> a
    double readBaseExternal(java.io.ObjectInput) -> a
org.apache.commons.math.ode.sampling.DummyStepInterpolator -> org.a.a.b.f.c.b:
    double[] currentDerivative -> d
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
org.apache.commons.math.ode.sampling.StepHandler -> org.a.a.b.f.c.c:
    boolean requiresDenseOutput() -> a
    void reset() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
org.apache.commons.math.ode.sampling.StepInterpolator -> org.a.a.b.f.c.d:
    double getPreviousTime() -> c
    double getCurrentTime() -> d
    void setInterpolatedTime(double) -> d
    double[] getInterpolatedState() -> a
    boolean isForward() -> a
org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer -> org.a.a.b.g.a:
    org.apache.commons.math.optimization.VectorialPointValuePair optimize(org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction,double[],double[],double[]) -> a
org.apache.commons.math.optimization.OptimizationException -> org.a.a.b.g.b:
org.apache.commons.math.optimization.SimpleVectorialValueChecker -> org.a.a.b.g.c:
    double relativeThreshold -> a
    double absoluteThreshold -> b
    boolean converged(int,org.apache.commons.math.optimization.VectorialPointValuePair,org.apache.commons.math.optimization.VectorialPointValuePair) -> a
org.apache.commons.math.optimization.VectorialConvergenceChecker -> org.a.a.b.g.d:
    boolean converged(int,org.apache.commons.math.optimization.VectorialPointValuePair,org.apache.commons.math.optimization.VectorialPointValuePair) -> a
org.apache.commons.math.optimization.VectorialPointValuePair -> org.a.a.b.g.e:
    double[] point -> a
    double[] value -> b
    double[] getPointRef() -> a
    double[] getValueRef() -> b
org.apache.commons.math.optimization.fitting.CurveFitter -> org.a.a.b.g.a.a:
    org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer optimizer -> a
    java.util.List observations -> a
    void addObservedPoint(double,double,double) -> a
    void clearObservations() -> a
    double[] fit(org.apache.commons.math.optimization.fitting.ParametricRealFunction,double[]) -> a
    java.util.List access$0(org.apache.commons.math.optimization.fitting.CurveFitter) -> a
org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction -> org.a.a.b.g.a.a$a:
    org.apache.commons.math.optimization.fitting.ParametricRealFunction f -> a
    org.apache.commons.math.optimization.fitting.CurveFitter this$0 -> a
    org.apache.commons.math.analysis.MultivariateMatrixFunction jacobian() -> a
    double[] value(double[]) -> a
    org.apache.commons.math.optimization.fitting.ParametricRealFunction access$0(org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction) -> a
    org.apache.commons.math.optimization.fitting.CurveFitter access$1(org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction) -> a
org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction$1 -> org.a.a.b.g.a.b:
    org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction this$1 -> a
    double[][] value(double[]) -> a
org.apache.commons.math.optimization.fitting.ParametricRealFunction -> org.a.a.b.g.a.c:
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
org.apache.commons.math.optimization.fitting.WeightedObservedPoint -> org.a.a.b.g.a.d:
    double weight -> a
    double x -> b
    double y -> c
    double getWeight() -> a
    double getX() -> b
    double getY() -> c
org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer -> org.a.a.b.g.b.a:
    org.apache.commons.math.optimization.VectorialConvergenceChecker checker -> a
    double[][] jacobian -> a
    int cols -> a
    int rows -> b
    double[] targetValues -> a
    double[] residualsWeights -> b
    double[] point -> c
    double[] objective -> d
    double[] residuals -> e
    double[][] wjacobian -> b
    double[] wresiduals -> f
    double cost -> a
    int maxIterations -> c
    int iterations -> d
    int maxEvaluations -> e
    int objectiveEvaluations -> f
    int jacobianEvaluations -> g
    org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function -> a
    org.apache.commons.math.analysis.MultivariateMatrixFunction jF -> a
    void setMaxIterations(int) -> a
    int getIterations() -> a
    void setMaxEvaluations(int) -> b
    void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker) -> a
    void incrementIterationsCounter() -> a
    void updateJacobian() -> b
    void updateResidualsAndCost() -> c
    org.apache.commons.math.optimization.VectorialPointValuePair optimize(org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction,double[],double[],double[]) -> a
    org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() -> a
org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer -> org.a.a.b.g.b.b:
    int solvedCols -> c
    double[] diagR -> g
    double[] jacNorm -> h
    double[] beta -> i
    int[] permutation -> a
    int rank -> d
    double lmPar -> b
    double[] lmDir -> j
    double initialStepBoundFactor -> c
    double costRelativeTolerance -> d
    double parRelativeTolerance -> e
    double orthoTolerance -> f
    double qrRankingThreshold -> g
    void setInitialStepBoundFactor(double) -> a
    void setCostRelativeTolerance(double) -> b
    void setParRelativeTolerance(double) -> c
    void setOrthoTolerance(double) -> d
    void setQRRankingThreshold(double) -> e
    org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() -> a
    void determineLMParameter(double[],double,double[],double[],double[],double[]) -> a
    void determineLMDirection(double[],double[],double[],double[]) -> a
    void qrDecomposition() -> d
    void qTy(double[]) -> a
org.apache.commons.math.random.JDKRandomGenerator -> org.a.a.b.h.a:
org.apache.commons.math.random.RandomData -> org.a.a.b.h.b:
    long nextLong(long,long) -> a
org.apache.commons.math.random.RandomDataImpl -> org.a.a.b.h.c:
    org.apache.commons.math.random.RandomGenerator rand -> a
    java.security.SecureRandom secRand -> a
    long nextLong(long,long) -> a
    org.apache.commons.math.random.RandomGenerator getRan() -> a
org.apache.commons.math.random.RandomGenerator -> org.a.a.b.h.d:
    void setSeed(long) -> setSeed
    double nextDouble() -> nextDouble
org.apache.commons.math.special.Beta -> org.a.a.b.i.a:
    double regularizedBeta(double,double,double) -> a
    double regularizedBeta(double,double,double,double,int) -> a
    double logBeta(double,double) -> a
    double logBeta(double,double,double,int) -> a
org.apache.commons.math.special.Beta$1 -> org.a.a.b.i.b:
    double val$b -> a
    double val$a -> b
    double getB(int,double) -> a
    double getA(int,double) -> b
org.apache.commons.math.special.Erf -> org.a.a.b.i.c:
    double erf(double) -> a
org.apache.commons.math.special.Gamma -> org.a.a.b.i.d:
    double[] LANCZOS -> a
    double HALF_LOG_2_PI -> a
    double logGamma(double) -> a
    double regularizedGammaP(double,double) -> a
    double regularizedGammaP(double,double,double,int) -> a
    double regularizedGammaQ(double,double,double,int) -> b
    double digamma(double) -> b
    double trigamma(double) -> c
org.apache.commons.math.special.Gamma$1 -> org.a.a.b.i.e:
    double val$a -> a
    double getA(int,double) -> b
    double getB(int,double) -> a
org.apache.commons.math.stat.Frequency -> org.a.a.b.j.a:
    java.util.TreeMap freqTable -> a
    java.lang.String toString() -> toString
    void addValue(java.lang.Comparable) -> a
    void clear() -> a
    java.util.Iterator valuesIterator() -> a
    long getSumFreq() -> a
    long getCount(java.lang.Comparable) -> a
    long getCount(long) -> a
    double getPct(java.lang.Comparable) -> a
    long getCumFreq(java.lang.Comparable) -> b
    long getCumFreq(long) -> b
    double getCumPct(java.lang.Comparable) -> b
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math.stat.Frequency$NaturalComparator -> org.a.a.b.j.a$a:
    int compare(java.lang.Comparable,java.lang.Comparable) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.apache.commons.math.stat.StatUtils -> org.a.a.b.j.b:
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM -> a
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM_OF_SQUARES -> b
    org.apache.commons.math.stat.descriptive.UnivariateStatistic PRODUCT -> c
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM_OF_LOGS -> d
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MIN -> e
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MAX -> f
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MEAN -> g
    org.apache.commons.math.stat.descriptive.moment.Variance VARIANCE -> a
    org.apache.commons.math.stat.descriptive.rank.Percentile PERCENTILE -> a
    org.apache.commons.math.stat.descriptive.moment.GeometricMean GEOMETRIC_MEAN -> a
    double mean(double[]) -> a
    double variance(double[]) -> b
    double sumDifference(double[],double[]) -> a
    double meanDifference(double[],double[]) -> b
    double varianceDifference(double[],double[],double) -> a
org.apache.commons.math.stat.correlation.PearsonsCorrelation -> org.a.a.b.j.a.a:
    org.apache.commons.math.linear.RealMatrix correlationMatrix -> a
    int nObs -> a
    double correlation(double[],double[]) -> a
org.apache.commons.math.stat.correlation.SpearmansCorrelation -> org.a.a.b.j.a.b:
    org.apache.commons.math.linear.RealMatrix data -> a
    org.apache.commons.math.stat.ranking.RankingAlgorithm rankingAlgorithm -> a
    org.apache.commons.math.stat.correlation.PearsonsCorrelation rankCorrelation -> a
    double correlation(double[],double[]) -> a
org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic -> org.a.a.b.j.b.a:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    void clear() -> a
    double getResult() -> a
    void increment(double) -> a
    void incrementAll(double[],int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic -> org.a.a.b.j.b.b:
    double[] storedData -> a
    void setData(double[]) -> a
    double[] getDataRef() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    boolean test(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.StatisticalSummary -> org.a.a.b.j.b.c:
    double getMean() -> a
    double getVariance() -> b
    long getN() -> a
org.apache.commons.math.stat.descriptive.StatisticalSummaryValues -> org.a.a.b.j.b.d:
    double mean -> a
    double variance -> b
    long n -> a
    double max -> c
    double min -> d
    double sum -> e
    double getMax() -> c
    double getMean() -> a
    double getMin() -> d
    long getN() -> a
    double getSum() -> e
    double getStandardDeviation() -> f
    double getVariance() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic -> org.a.a.b.j.b.e:
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
org.apache.commons.math.stat.descriptive.SummaryStatistics -> org.a.a.b.j.b.f:
    long n -> a
    org.apache.commons.math.stat.descriptive.moment.SecondMoment secondMoment -> a
    org.apache.commons.math.stat.descriptive.summary.Sum sum -> a
    org.apache.commons.math.stat.descriptive.summary.SumOfSquares sumsq -> a
    org.apache.commons.math.stat.descriptive.rank.Min min -> a
    org.apache.commons.math.stat.descriptive.rank.Max max -> a
    org.apache.commons.math.stat.descriptive.summary.SumOfLogs sumLog -> a
    org.apache.commons.math.stat.descriptive.moment.GeometricMean geoMean -> a
    org.apache.commons.math.stat.descriptive.moment.Mean mean -> a
    org.apache.commons.math.stat.descriptive.moment.Variance variance -> a
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumImpl -> a
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumsqImpl -> b
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic minImpl -> c
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic maxImpl -> d
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumLogImpl -> e
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic geoMeanImpl -> f
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic meanImpl -> g
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic varianceImpl -> h
    void addValue(double) -> a
    long getN() -> a
    double getSum() -> c
    double getSumsq() -> d
    double getMean() -> a
    double getStandardDeviation() -> e
    double getVariance() -> b
    double getMax() -> f
    double getMin() -> g
    double getGeometricMean() -> h
    double getSumOfLogs() -> i
    java.lang.String toString() -> toString
    void clear() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.stat.descriptive.UnivariateStatistic -> org.a.a.b.j.b.g:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.moment.FirstMoment -> org.a.a.b.j.b.a.a:
    long n -> a
    double m1 -> a
    double dev -> b
    double nDev -> c
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math.stat.descriptive.moment.GeometricMean -> org.a.a.b.j.b.a.b:
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumOfLogs -> a
    void increment(double) -> a
    double getResult() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
    long getN() -> a
org.apache.commons.math.stat.descriptive.moment.Mean -> org.a.a.b.j.b.a.c:
    org.apache.commons.math.stat.descriptive.moment.FirstMoment moment -> a
    boolean incMoment -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.moment.SecondMoment -> org.a.a.b.j.b.a.d:
    double m2 -> d
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
org.apache.commons.math.stat.descriptive.moment.Variance -> org.a.a.b.j.b.a.e:
    org.apache.commons.math.stat.descriptive.moment.SecondMoment moment -> a
    boolean incMoment -> a
    boolean isBiasCorrected -> b
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    double evaluate(double[],double,int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Max -> org.a.a.b.j.b.b.a:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Min -> org.a.a.b.j.b.b.b:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Percentile -> org.a.a.b.j.b.b.c:
    double quantile -> a
    int[] cachedPivots -> a
    void setData(double[]) -> a
    double evaluate(double) -> a
    double evaluate(double[],double) -> a
    double evaluate(double[],int,int) -> a
    double evaluate(double[],int,int,double) -> a
    double select(double[],int[],int) -> a
    int medianOf3(double[],int,int) -> a
    int partition(double[],int,int,int) -> a
    void insertionSort(double[],int,int) -> a
    void setQuantile(double) -> a
org.apache.commons.math.stat.descriptive.summary.Product -> org.a.a.b.j.b.c.a:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.Sum -> org.a.a.b.j.b.c.b:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.SumOfLogs -> org.a.a.b.j.b.c.c:
    int n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.SumOfSquares -> org.a.a.b.j.b.c.d:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.inference.OneWayAnovaImpl -> org.a.a.b.j.c.a:
    double anovaFValue(java.util.Collection) -> a
    double anovaPValue(java.util.Collection) -> b
    org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats anovaStats(java.util.Collection) -> a
org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats -> org.a.a.b.j.c.a$a:
    int dfbg -> a
    int dfwg -> b
    double F -> a
    double access$0(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> a
    int access$1(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> a
    int access$2(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> b
org.apache.commons.math.stat.inference.TTestImpl -> org.a.a.b.j.c.b:
    org.apache.commons.math.distribution.TDistribution distribution -> a
    double pairedT(double[],double[]) -> a
    double pairedTTest(double[],double[]) -> b
    double t(double,double[]) -> a
    double t(double,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
    double homoscedasticT(double[],double[]) -> c
    double t(double[],double[]) -> d
    double t(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
    double homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> b
    double tTest(double,double[]) -> b
    double tTest(double,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> b
    double tTest(double[],double[]) -> e
    double homoscedasticTTest(double[],double[]) -> f
    double tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> c
    double homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> d
    double df(double,double,double,double) -> a
    double t(double,double,double,double) -> b
    double t(double,double,double,double,double,double) -> a
    double homoscedasticT(double,double,double,double,double,double) -> b
    double tTest(double,double,double,double) -> c
    double tTest(double,double,double,double,double,double) -> c
    double homoscedasticTTest(double,double,double,double,double,double) -> d
    void setDistribution(org.apache.commons.math.distribution.TDistribution) -> a
    void checkSampleData(double[]) -> a
    void checkSampleData(org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
org.apache.commons.math.stat.ranking.NaNStrategy -> org.a.a.b.j.d.a:
    org.apache.commons.math.stat.ranking.NaNStrategy MINIMAL -> a
    org.apache.commons.math.stat.ranking.NaNStrategy MAXIMAL -> b
    org.apache.commons.math.stat.ranking.NaNStrategy REMOVED -> c
    org.apache.commons.math.stat.ranking.NaNStrategy FIXED -> d
    org.apache.commons.math.stat.ranking.NaNStrategy[] ENUM$VALUES -> a
    org.apache.commons.math.stat.ranking.NaNStrategy[] values() -> values
    org.apache.commons.math.stat.ranking.NaNStrategy valueOf(java.lang.String) -> valueOf
org.apache.commons.math.stat.ranking.NaturalRanking -> org.a.a.b.j.d.b:
    org.apache.commons.math.stat.ranking.NaNStrategy DEFAULT_NAN_STRATEGY -> a
    org.apache.commons.math.stat.ranking.TiesStrategy DEFAULT_TIES_STRATEGY -> a
    org.apache.commons.math.stat.ranking.NaNStrategy nanStrategy -> b
    org.apache.commons.math.stat.ranking.TiesStrategy tiesStrategy -> b
    org.apache.commons.math.random.RandomData randomData -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$NaNStrategy -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$TiesStrategy -> b
    double[] rank(double[]) -> a
    org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[] removeNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    void recodeNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[],double) -> a
    boolean containsNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    void resolveTie(double[],java.util.List) -> a
    void fill(double[],java.util.List,double) -> a
    void restoreNaNs(double[],java.util.List) -> b
    java.util.List getNanPositions(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$NaNStrategy() -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$TiesStrategy() -> b
org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair -> org.a.a.b.j.d.b$a:
    double value -> a
    int position -> a
    int compareTo(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair) -> a
    double getValue() -> a
    int getPosition() -> a
    int compareTo(java.lang.Object) -> compareTo
org.apache.commons.math.stat.ranking.RankingAlgorithm -> org.a.a.b.j.d.c:
    double[] rank(double[]) -> a
org.apache.commons.math.stat.ranking.TiesStrategy -> org.a.a.b.j.d.d:
    org.apache.commons.math.stat.ranking.TiesStrategy SEQUENTIAL -> a
    org.apache.commons.math.stat.ranking.TiesStrategy MINIMUM -> b
    org.apache.commons.math.stat.ranking.TiesStrategy MAXIMUM -> c
    org.apache.commons.math.stat.ranking.TiesStrategy AVERAGE -> d
    org.apache.commons.math.stat.ranking.TiesStrategy RANDOM -> e
    org.apache.commons.math.stat.ranking.TiesStrategy[] ENUM$VALUES -> a
    org.apache.commons.math.stat.ranking.TiesStrategy[] values() -> values
    org.apache.commons.math.stat.ranking.TiesStrategy valueOf(java.lang.String) -> valueOf
org.apache.commons.math.stat.regression.SimpleRegression -> org.a.a.b.j.e.a:
    org.apache.commons.math.distribution.TDistribution distribution -> a
    double sumX -> a
    double sumXX -> b
    double sumY -> c
    double sumYY -> d
    double sumXY -> e
    long n -> a
    double xbar -> f
    double ybar -> g
    void addData(double,double) -> a
    double getSlope() -> a
    double getSumSquaredErrors() -> b
    double getTotalSumSquares() -> c
    double getR() -> d
    double getRSquare() -> e
    void setDistribution(org.apache.commons.math.distribution.TDistribution) -> a
org.apache.commons.math.util.ContinuedFraction -> org.a.a.b.k.a:
    double getA(int,double) -> b
    double getB(int,double) -> a
    double evaluate(double,double,int) -> a
org.apache.commons.math.util.FastMath -> org.a.a.b.k.b:
    double[] EXP_INT_TABLE_A -> a
    double[] EXP_INT_TABLE_B -> b
    double[] EXP_FRAC_TABLE_A -> c
    double[] EXP_FRAC_TABLE_B -> d
    double[] FACT -> e
    double[][] LN_MANT -> a
    double[][] LN_SPLIT_COEF -> b
    double[][] LN_QUICK_COEF -> c
    double[][] LN_HI_PREC_COEF -> d
    double[] SINE_TABLE_A -> f
    double[] SINE_TABLE_B -> g
    double[] COSINE_TABLE_A -> h
    double[] COSINE_TABLE_B -> i
    double[] TANGENT_TABLE_A -> j
    double[] TANGENT_TABLE_B -> k
    long[] RECIP_2PI -> a
    long[] PI_O_4_BITS -> b
    double[] EIGHTHS -> l
    double[] CBRTTWO -> m
    double doubleHighPart(double) -> k
    double sqrt(double) -> a
    double exp(double) -> b
    double exp(double,double,double[]) -> a
    double slowexp(double,double[]) -> a
    void split(double,double[]) -> a
    void resplit(double[]) -> a
    void splitMult(double[],double[],double[]) -> a
    void splitAdd(double[],double[],double[]) -> b
    void splitReciprocal(double[],double[]) -> a
    void quadMult(double[],double[],double[]) -> c
    double expint(int,double[]) -> a
    double log(double) -> c
    double log(double,double[]) -> b
    double pow(double,double) -> a
    double[] slowLog(double) -> a
    double slowSin(double,double[]) -> c
    double slowCos(double,double[]) -> d
    void buildSinCosTables() -> a
    double polySine(double) -> l
    double polyCosine(double) -> m
    double sinQ(double,double) -> f
    double cosQ(double,double) -> g
    double tanQ(double,double,boolean) -> a
    void reducePayneHanek(double,double[]) -> b
    double sin(double) -> d
    double cos(double) -> e
    double tan(double) -> f
    double atan(double) -> g
    double atan(double,double,boolean) -> b
    double atan2(double,double) -> b
    int abs(int) -> a
    long abs(long) -> a
    double abs(double) -> h
    double floor(double) -> i
    double ceil(double) -> j
    long round(double) -> a
    int min(int,int) -> a
    double min(double,double) -> c
    int max(int,int) -> b
    double max(double,double) -> d
    double copySign(double,double) -> e
org.apache.commons.math.util.MathUtils -> org.a.a.b.k.c:
    long[] FACTORIALS -> a
    boolean $assertionsDisabled -> a
    long binomialCoefficient(int,int) -> a
    double binomialCoefficientDouble(int,int) -> a
    double binomialCoefficientLog(int,int) -> b
    void checkBinomial(int,int) -> a
    boolean equalsIncludingNaN(float,float) -> a
    boolean equals(float,float,int) -> a
    boolean equalsIncludingNaN(double,double) -> a
    boolean equals(double,double,int) -> a
    int gcd(int,int) -> a
    int hash(double) -> a
    double indicator(double) -> a
    long mulAndCheck(long,long) -> a
org.freehep.graphics2d.AbstractVectorGraphics -> org.freehep.a.a:
    org.freehep.util.UserProperties properties -> a
    java.lang.String creator -> a
    boolean isDeviceIndependent -> a
    org.freehep.graphics2d.SymbolShape cachedShape -> a
    int colorMode -> a
    java.awt.Color backgroundColor -> a
    java.awt.Color currentColor -> b
    java.awt.Paint currentPaint -> a
    java.awt.Font currentFont -> a
    void initProperties(java.util.Properties) -> a
    java.util.Properties getProperties() -> a
    java.lang.String getProperty(java.lang.String) -> a
    java.awt.Color getPropertyColor(java.lang.String) -> a
    java.awt.Insets getPropertyInsets(java.lang.String) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String) -> a
    boolean isProperty(java.lang.String) -> a
    java.lang.String getCreator() -> a
    boolean isDeviceIndependent() -> a
    java.awt.Font getFont() -> getFont
    void setFont(java.awt.Font) -> setFont
    void clearRect(int,int,int,int) -> clearRect
    void drawLine(int,int,int,int) -> drawLine
    void drawRect(int,int,int,int) -> drawRect
    void fillRect(int,int,int,int) -> fillRect
    void drawArc(int,int,int,int,int,int) -> drawArc
    void fillArc(int,int,int,int,int,int) -> fillArc
    void drawOval(int,int,int,int) -> drawOval
    void fillOval(int,int,int,int) -> fillOval
    void drawRoundRect(int,int,int,int,int,int) -> drawRoundRect
    void fillRoundRect(int,int,int,int,int,int) -> fillRoundRect
    void translate(int,int) -> translate
    void setLineWidth(double) -> a
    void drawString(java.lang.String,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    java.awt.geom.Point2D drawFrameAndBanner(java.awt.font.TextLayout,double,double,int,int,boolean,java.awt.Color,double,boolean,java.awt.Color) -> a
    void drawString(org.freehep.graphics2d.TagString,double,double,int,int,boolean,java.awt.Color,double,boolean,java.awt.Color) -> a
    void drawString(org.freehep.graphics2d.TagString,double,double,int,int) -> a
    java.awt.Color getBackground() -> getBackground
    void setBackground(java.awt.Color) -> setBackground
    void setColor(java.awt.Color) -> setColor
    java.awt.Color getColor() -> getColor
    void setPaint(java.awt.Paint) -> setPaint
    java.awt.Paint getPaint() -> getPaint
    java.awt.Color getPrintColor(java.awt.Color) -> a
    void rotate(double,double,double) -> rotate
    void drawArc(double,double,double,double,double,double) -> a
    void drawLine(double,double,double,double) -> a
    void drawOval(double,double,double,double) -> b
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawRect(double,double,double,double) -> c
    void drawRoundRect(double,double,double,double,double,double) -> b
    void fillArc(double,double,double,double,double,double) -> c
    void fillOval(double,double,double,double) -> d
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillRect(double,double,double,double) -> e
    void fillRoundRect(double,double,double,double,double,double) -> d
    java.awt.Shape createShape(int[],int[],int,boolean,boolean) -> a
org.freehep.graphics2d.GenericTagHandler -> org.freehep.a.b:
    java.lang.Integer UNDERLINE_OVERLINE -> a
    java.awt.Graphics2D graphics -> a
    java.lang.StringBuffer clearedText -> a
    java.util.Vector attributes -> a
    java.util.Hashtable tags -> a
    java.util.Stack fontFamilyStack -> a
    double superscriptCorrection -> a
    void print(org.freehep.graphics2d.TagString,double,double,double) -> a
    java.awt.font.TextLayout createTextLayout(org.freehep.graphics2d.TagString,double) -> a
    java.lang.String openTag(java.lang.String) -> a
    java.lang.String closeTag(java.lang.String) -> b
    java.lang.String text(java.lang.String) -> c
org.freehep.graphics2d.GenericTagHandler$AttributeEntry -> org.freehep.a.b$a:
    int begin -> a
    int end -> b
    java.awt.font.TextAttribute textAttribute -> a
    java.lang.Object value -> a
    org.freehep.graphics2d.GenericTagHandler this$0 -> a
    void apply(java.text.AttributedString) -> a
org.freehep.graphics2d.PixelGraphics2D -> org.freehep.a.c:
    java.awt.RenderingHints$Key KEY_SYMBOL_BLIT -> a
    java.lang.Object VALUE_SYMBOL_BLIT_ON -> a
    java.lang.Object VALUE_SYMBOL_BLIT_OFF -> b
    java.awt.Graphics2D hostGraphics -> a
    double lineWidth -> a
    int resolution -> a
    org.freehep.graphics2d.GenericTagHandler tagHandler -> a
    java.util.Map symbols -> a
    org.freehep.graphics2d.WebColor webColor -> a
    boolean displayX11 -> a
    boolean displayLocal -> b
    void setHostGraphics(java.awt.Graphics) -> a
    void startExport() -> a
    void endExport() -> b
    void clearRect(int,int,int,int) -> clearRect
    void clipRect(int,int,int,int) -> clipRect
    void copyArea(int,int,int,int,int,int) -> copyArea
    java.awt.Graphics create() -> create
    void dispose() -> dispose
    void drawArc(int,int,int,int,int,int) -> drawArc
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    void drawLine(int,int,int,int) -> drawLine
    void drawOval(int,int,int,int) -> drawOval
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawPolygon(java.awt.Polygon) -> drawPolygon
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawRect(int,int,int,int) -> drawRect
    void drawString(java.lang.String,int,int) -> drawString
    void fillArc(int,int,int,int,int,int) -> fillArc
    void fillOval(int,int,int,int) -> fillOval
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillPolygon(java.awt.Polygon) -> fillPolygon
    void fillRect(int,int,int,int) -> fillRect
    void setLineWidth(double) -> a
    java.awt.Shape getClip() -> getClip
    java.awt.Rectangle getClipBounds() -> getClipBounds
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    void setClip(int,int,int,int) -> setClip
    void setClip(java.awt.Shape) -> setClip
    void setFont(java.awt.Font) -> setFont
    void setColor(java.awt.Color) -> setColor
    void setPaint(java.awt.Paint) -> setPaint
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void translate(int,int) -> translate
    void addRenderingHints(java.util.Map) -> addRenderingHints
    void clip(java.awt.Shape) -> clip
    void draw(java.awt.Shape) -> draw
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void fill(java.awt.Shape) -> fill
    java.awt.Composite getComposite() -> getComposite
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    java.awt.Stroke getStroke() -> getStroke
    java.awt.geom.AffineTransform getTransform() -> getTransform
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    void rotate(double) -> rotate
    void rotate(double,double,double) -> rotate
    void scale(double,double) -> scale
    void setBackground(java.awt.Color) -> setBackground
    void setComposite(java.awt.Composite) -> setComposite
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    void setRenderingHints(java.util.Map) -> setRenderingHints
    void setStroke(java.awt.Stroke) -> setStroke
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    void shear(double,double) -> shear
    void transform(java.awt.geom.AffineTransform) -> transform
    void translate(double,double) -> translate
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    java.lang.String toString() -> toString
org.freehep.graphics2d.PixelGraphics2D$SymbolBlitKey -> org.freehep.a.c$a:
    boolean isCompatibleValue(java.lang.Object) -> isCompatibleValue
    java.lang.String toString() -> toString
org.freehep.graphics2d.PrintColor -> org.freehep.a.d:
    java.awt.Color[] defaultColors -> a
    float asGray -> a
    boolean asBlack -> a
    void testColorValueRange(float) -> a
    float getAsGray() -> a
    boolean getAsBlack() -> a
    org.freehep.graphics2d.PrintColor getColor(int) -> a
    org.freehep.graphics2d.PrintColor createPrintColor(java.awt.Color) -> a
    java.awt.Color mixColor(java.awt.Color,java.awt.Color) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    org.freehep.graphics2d.PrintColor invert(java.awt.Color) -> b
org.freehep.graphics2d.SymbolShape -> org.freehep.a.e:
    double SQRT_2 -> a
    double SQRT_3 -> b
    double[] points -> a
    int[] type -> a
    org.freehep.graphics2d.SymbolShape$ArrayPathIterator pathIterator -> a
    double x -> c
    double y -> d
    double size -> e
    int symbol -> a
    boolean contains(double,double) -> contains
    boolean contains(double,double,double,double) -> contains
    boolean contains(java.awt.geom.Point2D) -> contains
    boolean contains(java.awt.geom.Rectangle2D) -> contains
    boolean intersects(double,double,double,double) -> intersects
    boolean intersects(java.awt.geom.Rectangle2D) -> intersects
    java.awt.geom.PathIterator getPathIterator(java.awt.geom.AffineTransform,double) -> getPathIterator
    java.awt.geom.Rectangle2D getBounds2D() -> getBounds2D
    java.awt.Rectangle getBounds() -> getBounds
    java.awt.geom.PathIterator getPathIterator(java.awt.geom.AffineTransform) -> getPathIterator
    java.lang.String toString() -> toString
    void ensureNumberOfPoints(int) -> a
org.freehep.graphics2d.SymbolShape$ArrayPathIterator -> org.freehep.a.e$a:
    int currentPoint -> a
    double[] points -> a
    int[] type -> a
    int numberOfPoints -> b
    org.freehep.graphics2d.SymbolShape this$0 -> a
    boolean isDone() -> isDone
    void next() -> next
    int currentSegment(double[]) -> currentSegment
    int currentSegment(float[]) -> currentSegment
    int getWindingRule() -> getWindingRule
    void reset() -> a
    double[] access$1(org.freehep.graphics2d.SymbolShape$ArrayPathIterator) -> a
    void access$2(org.freehep.graphics2d.SymbolShape$ArrayPathIterator) -> a
org.freehep.graphics2d.TagHandler -> org.freehep.a.f:
    java.lang.String parse(org.freehep.graphics2d.TagString) -> a
    java.lang.String defaultEntity(java.lang.String) -> d
    java.lang.String entity(java.lang.String) -> e
    java.lang.String openTag(java.lang.String) -> a
    java.lang.String closeTag(java.lang.String) -> b
    java.lang.String text(java.lang.String) -> c
org.freehep.graphics2d.TagString -> org.freehep.a.g:
    java.lang.String string -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
org.freehep.graphics2d.VectorGraphics -> org.freehep.a.h:
    java.util.Hashtable symbols -> a
    java.util.Hashtable alignments -> b
    java.awt.Graphics create(int,int,int,int) -> create
    void draw(java.awt.Shape) -> draw
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void fill(java.awt.Shape) -> fill
    java.awt.Stroke getStroke() -> getStroke
    void rotate(double) -> rotate
    void setStroke(java.awt.Stroke) -> setStroke
    void translate(double,double) -> translate
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    void endExport() -> b
    void startExport() -> a
org.freehep.graphics2d.WebColor -> org.freehep.a.i:
    org.freehep.graphics2d.WebColor white -> a
    org.freehep.graphics2d.WebColor WHITE -> b
    org.freehep.graphics2d.WebColor lightGray -> c
    org.freehep.graphics2d.WebColor LIGHT_GRAY -> d
    org.freehep.graphics2d.WebColor gray -> e
    org.freehep.graphics2d.WebColor GRAY -> f
    org.freehep.graphics2d.WebColor darkGray -> g
    org.freehep.graphics2d.WebColor DARK_GRAY -> h
    org.freehep.graphics2d.WebColor black -> i
    org.freehep.graphics2d.WebColor BLACK -> j
    org.freehep.graphics2d.WebColor red -> k
    org.freehep.graphics2d.WebColor RED -> l
    org.freehep.graphics2d.WebColor pink -> m
    org.freehep.graphics2d.WebColor PINK -> n
    org.freehep.graphics2d.WebColor orange -> o
    org.freehep.graphics2d.WebColor ORANGE -> p
    org.freehep.graphics2d.WebColor yellow -> q
    org.freehep.graphics2d.WebColor YELLOW -> r
    org.freehep.graphics2d.WebColor green -> s
    org.freehep.graphics2d.WebColor GREEN -> t
    org.freehep.graphics2d.WebColor magenta -> u
    org.freehep.graphics2d.WebColor MAGENTA -> v
    org.freehep.graphics2d.WebColor cyan -> w
    org.freehep.graphics2d.WebColor CYAN -> x
    org.freehep.graphics2d.WebColor blue -> y
    org.freehep.graphics2d.WebColor BLUE -> z
    org.freehep.graphics2d.WebColor create(java.awt.Color) -> a
org.freehep.graphics2d.font.AbstractCharTable -> org.freehep.a.a.a:
    int toEncoding(char) -> a
    java.lang.String toName(char) -> a
org.freehep.graphics2d.font.CharTable -> org.freehep.a.a.b:
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    int toEncoding(char) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Expert -> org.freehep.a.a.c:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.FontEncoder -> org.freehep.a.a.d:
    java.lang.String getEncodedString(java.lang.String,java.lang.String) -> a
    java.lang.String getEncodedString(java.lang.String,org.freehep.graphics2d.font.CharTable) -> a
org.freehep.graphics2d.font.ISOLatin -> org.freehep.a.a.e:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Lookup -> org.freehep.a.a.f:
    org.freehep.graphics2d.font.Lookup instance -> a
    org.freehep.graphics2d.font.CharTable[] tables -> a
    int ntables -> a
    org.freehep.graphics2d.font.Lookup getInstance() -> a
    org.freehep.graphics2d.font.CharTable getTable(java.lang.String) -> a
org.freehep.graphics2d.font.MACLatin -> org.freehep.a.a.g:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.PDFLatin -> org.freehep.a.a.h:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.STDLatin -> org.freehep.a.a.i:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Symbol -> org.freehep.a.a.j:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.WINLatin -> org.freehep.a.a.k:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Zapfdingbats -> org.freehep.a.a.l:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphicsio.AbstractPathConstructor -> org.freehep.graphicsio.a:
    double currentX -> a
    double currentY -> b
    void flush() -> a
    boolean addPath(java.awt.Shape) -> a
    boolean addPath(java.awt.Shape,java.awt.geom.AffineTransform) -> a
    boolean addPath(org.freehep.graphicsio.PathConstructor,java.awt.Shape,java.awt.geom.AffineTransform) -> a
    boolean isEvenOdd(java.awt.Shape) -> b
org.freehep.graphicsio.AbstractVectorGraphicsIO -> org.freehep.graphicsio.b:
    java.lang.String rootKey -> e
    java.lang.String EMIT_WARNINGS -> a
    java.lang.String TEXT_AS_SHAPES -> b
    java.lang.String EMIT_ERRORS -> c
    java.lang.String CLIP -> d
    java.awt.Dimension size -> a
    java.awt.Component component -> a
    boolean doRestoreOnDispose -> a
    java.awt.Rectangle deviceClip -> a
    java.awt.geom.Area userClip -> a
    java.awt.geom.AffineTransform currentTransform -> a
    java.awt.geom.AffineTransform oldTransform -> b
    java.awt.Composite currentComposite -> a
    java.awt.Stroke currentStroke -> a
    java.awt.RenderingHints hints -> a
    java.awt.Dimension getSize() -> a
    java.awt.Component getComponent() -> a
    void startExport() -> a
    void endExport() -> b
    void writeHeader() -> c
    void writeGraphicsState() -> d
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    void resetClip(java.awt.Rectangle) -> a
    void dispose() -> dispose
    void writeGraphicsRestore() -> h
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    void writeString(java.lang.String,double,double) -> b
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    java.awt.geom.AffineTransform getTransform() -> getTransform
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    void transform(java.awt.geom.AffineTransform) -> transform
    void translate(double,double) -> translate
    void rotate(double) -> rotate
    void scale(double,double) -> scale
    void shear(double,double) -> shear
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    java.awt.Shape getClip() -> getClip
    java.awt.Rectangle getClipBounds() -> getClipBounds
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    void clipRect(int,int,int,int) -> clipRect
    void setClip(int,int,int,int) -> setClip
    void setClip(java.awt.Shape) -> setClip
    void clip(java.awt.Shape) -> clip
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    java.awt.Stroke getStroke() -> getStroke
    void setStroke(java.awt.Stroke) -> setStroke
    void writeStroke(java.awt.Stroke) -> a
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void writeDash(double[],double) -> a
    void setColor(java.awt.Color) -> setColor
    void setPaint(java.awt.Paint) -> setPaint
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    void addRenderingHints(java.util.Map) -> addRenderingHints
    void setRenderingHints(java.util.Map) -> setRenderingHints
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    void setFont(java.awt.Font) -> setFont
    void writeFont(java.awt.Font) -> a
    java.awt.Composite getComposite() -> getComposite
    void setComposite(java.awt.Composite) -> setComposite
    void handleException(java.lang.Exception) -> a
    void writeWarning(java.lang.Exception) -> b
    void writeWarning(java.lang.String) -> c
    void writeError(java.lang.Exception) -> c
    java.awt.Shape transformShape(java.awt.geom.AffineTransform,java.awt.Shape) -> a
    java.awt.Shape transformShape(java.awt.Shape) -> a
    java.awt.Shape untransformShape(java.awt.Shape) -> b
org.freehep.graphicsio.ImageGraphics2D -> org.freehep.graphicsio.c:
    java.lang.String[] alwaysCompressedFormats -> a
    java.lang.String[] nonTransparentFormats -> b
    java.util.Map defaultProperties -> a
    java.io.OutputStream os -> a
    java.awt.image.BufferedImage image -> a
    java.lang.String format -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    void setHintsOnGraphics() -> e
    java.awt.Graphics create() -> create
    void startExport() -> a
    void endExport() -> b
    void write() -> c
    void closeStream() -> d
    void handleException(java.lang.Exception) -> a
    java.awt.image.BufferedImage generateThumbnail(java.awt.Component,java.awt.Dimension) -> a
    void writeImage(java.awt.image.RenderedImage,java.lang.String,java.util.Properties,java.io.OutputStream) -> a
    javax.imageio.ImageWriter getPreferredImageWriter(java.lang.String) -> a
    java.util.SortedSet getImageWriters(java.util.Iterator) -> a
    boolean canWriteUncompressed(java.lang.String) -> b
org.freehep.graphicsio.ImageGraphics2D$1 -> org.freehep.graphicsio.d:
    int order(java.lang.Object) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.freehep.graphicsio.ImageParamConverter -> org.freehep.graphicsio.e:
    javax.imageio.ImageWriteParam getWriteParam(java.util.Properties) -> a
org.freehep.graphicsio.MultiPageDocument -> org.freehep.graphicsio.f:
org.freehep.graphicsio.PageConstants -> org.freehep.graphicsio.g:
    java.util.Map sizeTable -> a
    java.util.Map marginTable -> b
    java.awt.Dimension getSize(java.lang.String,java.lang.String) -> a
    java.awt.Insets getMargins(java.lang.String) -> a
    java.awt.Insets getMargins(java.awt.Insets,java.lang.String) -> a
org.freehep.graphicsio.PathConstructor -> org.freehep.graphicsio.h:
    void move(double,double) -> a
    void line(double,double) -> b
    void quad(double,double,double,double) -> a
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void flush() -> a
org.freehep.graphicsio.QuadToCubicPathConstructor -> org.freehep.graphicsio.i:
    void move(double,double) -> a
    void line(double,double) -> b
    void quad(double,double,double,double) -> a
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
org.freehep.graphicsio.VectorGraphicsIO -> org.freehep.graphicsio.j:
org.freehep.graphicsio.emf.EMFGraphics2D -> org.freehep.graphicsio.a.a:
    org.freehep.graphicsio.emf.EMFHandleManager handleManager -> a
    int penHandle -> a
    int brushHandle -> b
    java.awt.Rectangle imageBounds -> a
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Color textColor -> b
    java.awt.Color penColor -> c
    java.awt.Color brushColor -> d
    java.util.Map fontTable -> a
    java.util.Map unitFontTable -> b
    org.freehep.graphicsio.emf.EMFPathConstructor pathConstructor -> a
    boolean evenOdd -> a
    java.awt.Rectangle dummy -> b
    java.lang.String rootKey -> h
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    org.freehep.util.UserProperties defaultProperties -> a
    java.awt.Point[] points -> a
    java.awt.Color invisible -> a
    java.util.Properties replaceFonts -> a
    void init(java.io.OutputStream) -> a
    void writeHeader() -> c
    void writeGraphicsState() -> d
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> i
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeSetClip(java.awt.Shape) -> b
    void writeClip(java.awt.Shape) -> a
    void writeStroke(java.awt.Stroke) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    boolean writePath(java.awt.Shape) -> a
    void writePen(java.awt.BasicStroke,java.awt.Color) -> a
    void writeBrush(java.awt.Color) -> b
    int toUnit(double) -> a
org.freehep.graphicsio.emf.EMFHandleManager -> org.freehep.graphicsio.a.b:
    java.util.BitSet handles -> a
    int maxHandle -> a
    int getHandle() -> a
    int freeHandle(int) -> a
    int nextClearBit() -> d
    int highestHandleInUse() -> b
    int maxHandlesUsed() -> c
org.freehep.graphicsio.emf.EMFHeader -> org.freehep.graphicsio.a.c:
    java.awt.Dimension screenMM -> a
    int type -> a
    java.awt.Rectangle bounds -> a
    java.awt.Rectangle frame -> b
    java.lang.String signature -> a
    int versionMajor -> b
    int versionMinor -> c
    int bytes -> d
    int records -> e
    int handles -> f
    java.lang.String description -> b
    int palEntries -> g
    java.awt.Dimension device -> b
    java.awt.Dimension millimeters -> c
    java.awt.Dimension micrometers -> d
    boolean openGL -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int size() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFInputStream -> org.freehep.graphicsio.a.d:
    int DEFAULT_VERSION -> a
    int readDWORD() -> a
    int[] readDWORD(int) -> a
    int readWORD() -> b
    int readLONG() -> c
    float readFLOAT() -> a
    int readUINT() -> d
    int readULONG() -> e
    java.awt.Color readCOLORREF() -> a
    java.awt.Color readCOLOR16() -> b
    java.awt.Color readCOLOR() -> c
    java.awt.geom.AffineTransform readXFORM() -> a
    java.awt.Rectangle readRECTL() -> a
    java.awt.Point readPOINTL() -> a
    java.awt.Point[] readPOINTL(int) -> a
    java.awt.Point readPOINTS() -> b
    java.awt.Point[] readPOINTS(int) -> b
    java.awt.Dimension readSIZEL() -> a
    int readBYTE() -> f
    byte[] readBYTE(int) -> a
    boolean readBOOLEAN() -> a
    java.lang.String readWCHAR(int) -> a
    org.freehep.util.io.TagHeader readTagHeader() -> a
org.freehep.graphicsio.emf.EMFOutputStream -> org.freehep.graphicsio.a.e:
    java.lang.String application -> a
    java.lang.String name -> b
    int recordCount -> b
    java.awt.Rectangle imageBounds -> a
    int version -> c
    org.freehep.graphicsio.emf.EMFHandleManager handles -> a
    java.awt.Dimension device -> a
    void close() -> close
    void writeDWORD(int) -> a
    void writeDWORD(int[]) -> a
    void writeWORD(int) -> b
    void writeFLOAT(float) -> a
    void writeCOLORREF(java.awt.Color) -> a
    void writeCOLOR16(java.awt.Color) -> b
    void writeCOLOR(java.awt.Color) -> c
    void writeXFORM(java.awt.geom.AffineTransform) -> a
    void writePOINTS(java.awt.Point[]) -> a
    void writePOINTS(int,java.awt.Point[]) -> a
    void writePOINTS(java.awt.Point) -> a
    void writePOINTL(java.awt.Point[]) -> b
    void writePOINTL(int,java.awt.Point[]) -> b
    void writePOINTL(java.awt.Point) -> b
    void writeRECTL(java.awt.Rectangle) -> a
    void writeSIZEL(java.awt.Dimension) -> a
    void writeUINT(int) -> c
    void writeULONG(int) -> d
    void writeLONG(int) -> e
    void writeSHORT(short) -> a
    void writeBYTE(byte[]) -> a
    void writeBYTE(int) -> f
    void writeBYTE(boolean) -> a
    void writeDWORD(boolean) -> b
    void writeWCHAR(java.lang.String) -> a
    void writeWCHAR(java.lang.String,int) -> a
    int getTagAlignment() -> a
    org.freehep.util.io.TagHeader createTagHeader(org.freehep.util.io.Tag,long) -> a
    void writeTagHeader(org.freehep.util.io.TagHeader) -> a
    void writeTag(org.freehep.util.io.Tag) -> a
    void writeTag(org.freehep.util.io.Tag,boolean) -> a
    void writeHeader(org.freehep.graphicsio.emf.EMFHeader) -> a
    int getVersion() -> b
org.freehep.graphicsio.emf.EMFPathConstructor -> org.freehep.graphicsio.a.f:
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Rectangle imageBounds -> a
    boolean curved -> a
    int pointIndex -> a
    boolean wide -> b
    java.awt.Point[] points -> a
    void move(double,double) -> a
    void addPoint(int,double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void flush() -> a
    int toUnit(double) -> a
org.freehep.graphicsio.emf.EMFPlusGraphics2D -> org.freehep.graphicsio.a.g:
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Rectangle imageBounds -> a
    org.freehep.graphicsio.emf.EMFHandleManager handleManager -> a
    org.freehep.util.Value containerIndex -> a
    java.awt.Paint restorePaint -> a
    java.lang.String rootKey -> h
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    org.freehep.util.UserProperties defaultProperties -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    void init(java.io.OutputStream) -> a
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> i
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    void writeWarning(java.lang.String) -> c
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFTag -> org.freehep.graphicsio.a.h:
    int flags -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int getFlags() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFTagHeader -> org.freehep.graphicsio.a.i:
    int flags -> b
    int getFlags() -> a
org.freehep.graphicsio.emf.EMFTagSet -> org.freehep.graphicsio.a.j:
org.freehep.graphicsio.emf.gdi.AbortPath -> org.freehep.graphicsio.a.a.a:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.AlphaBlend -> org.freehep.graphicsio.a.a.b:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    org.freehep.graphicsio.emf.gdi.BlendFunction dwROP -> a
    int xSrc -> f
    int ySrc -> g
    java.awt.geom.AffineTransform transform -> a
    java.awt.Color bkg -> a
    int usage -> h
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.AngleArc -> org.freehep.graphicsio.a.a.c:
    java.awt.Point center -> a
    int radius -> b
    float startAngle -> a
    float sweepAngle -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Arc -> org.freehep.graphicsio.a.a.d:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ArcTo -> org.freehep.graphicsio.a.a.e:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BeginPath -> org.freehep.graphicsio.a.a.f:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.BitBlt -> org.freehep.graphicsio.a.a.g:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    int dwROP -> f
    int xSrc -> g
    int ySrc -> h
    java.awt.geom.AffineTransform transform -> a
    java.awt.Color bkg -> a
    int usage -> i
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BitmapInfo -> org.freehep.graphicsio.a.a.h:
    org.freehep.graphicsio.emf.gdi.BitmapInfoHeader header -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BitmapInfoHeader -> org.freehep.graphicsio.a.a.i:
    int width -> a
    int height -> b
    int planes -> c
    int bitCount -> d
    int compression -> e
    int sizeImage -> f
    int xPelsPerMeter -> g
    int yPelsPerMeter -> h
    int clrUsed -> i
    int clrImportant -> j
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BlendFunction -> org.freehep.graphicsio.a.a.j:
    int blendOp -> a
    int blendFlags -> b
    int sourceConstantAlpha -> c
    int alphaFormat -> d
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Chord -> org.freehep.graphicsio.a.a.k:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.CloseFigure -> org.freehep.graphicsio.a.a.l:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.CreateBrushIndirect -> org.freehep.graphicsio.a.a.m:
    int index -> b
    org.freehep.graphicsio.emf.gdi.LogBrush32 brush -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.CreatePen -> org.freehep.graphicsio.a.a.n:
    int index -> b
    org.freehep.graphicsio.emf.gdi.LogPen pen -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.DeleteObject -> org.freehep.graphicsio.a.a.o:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EMFPolygon -> org.freehep.graphicsio.a.a.p:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EMFRectangle -> org.freehep.graphicsio.a.a.q:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EOF -> org.freehep.graphicsio.a.a.r:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdi.Ellipse -> org.freehep.graphicsio.a.a.s:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EndPath -> org.freehep.graphicsio.a.a.t:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.ExcludeClipRect -> org.freehep.graphicsio.a.a.u:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtCreateFontIndirectW -> org.freehep.graphicsio.a.a.v:
    int index -> b
    org.freehep.graphicsio.emf.gdi.ExtLogFontW font -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtCreatePen -> org.freehep.graphicsio.a.a.w:
    int index -> b
    org.freehep.graphicsio.emf.gdi.ExtLogPen pen -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtFloodFill -> org.freehep.graphicsio.a.a.x:
    java.awt.Point start -> a
    java.awt.Color color -> a
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtLogFontW -> org.freehep.graphicsio.a.a.y:
    org.freehep.graphicsio.emf.gdi.LogFontW font -> a
    java.lang.String fullName -> a
    java.lang.String style -> b
    int version -> a
    int styleSize -> b
    int match -> c
    byte[] vendorID -> a
    int culture -> d
    org.freehep.graphicsio.emf.gdi.Panose panose -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtLogPen -> org.freehep.graphicsio.a.a.z:
    int penStyle -> a
    int width -> b
    int brushStyle -> c
    java.awt.Color color -> a
    int hatch -> d
    int[] style -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtSelectClipRgn -> org.freehep.graphicsio.a.a.A:
    int mode -> b
    org.freehep.graphicsio.emf.gdi.Region rgn -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtTextOutA -> org.freehep.graphicsio.a.a.B:
    java.awt.Rectangle bounds -> a
    int mode -> b
    float xScale -> a
    float yScale -> b
    org.freehep.graphicsio.emf.gdi.Text text -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtTextOutW -> org.freehep.graphicsio.a.a.C:
    java.awt.Rectangle bounds -> a
    int mode -> b
    float xScale -> a
    float yScale -> b
    org.freehep.graphicsio.emf.gdi.TextW text -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.FillPath -> org.freehep.graphicsio.a.a.D:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.FlattenPath -> org.freehep.graphicsio.a.a.E:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.GDIComment -> org.freehep.graphicsio.a.a.F:
    byte[] bytes -> a
    org.freehep.graphicsio.emf.EMFTag tag -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Gradient -> org.freehep.graphicsio.a.a.G:
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdi.GradientFill -> org.freehep.graphicsio.a.a.H:
    java.awt.Rectangle bounds -> a
    int mode -> b
    org.freehep.graphicsio.emf.gdi.TriVertex[] vertices -> a
    org.freehep.graphicsio.emf.gdi.Gradient[] gradients -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.GradientRectangle -> org.freehep.graphicsio.a.a.I:
    int upperLeft -> a
    int lowerRight -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.GradientTriangle -> org.freehep.graphicsio.a.a.J:
    int vertex1 -> a
    int vertex2 -> b
    int vertex3 -> c
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.IntersectClipRect -> org.freehep.graphicsio.a.a.K:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LineTo -> org.freehep.graphicsio.a.a.L:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogBrush32 -> org.freehep.graphicsio.a.a.M:
    int style -> a
    java.awt.Color color -> a
    int hatch -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogFontW -> org.freehep.graphicsio.a.a.N:
    int height -> a
    int width -> b
    int escapement -> c
    int orientation -> d
    int weight -> e
    boolean italic -> a
    boolean underline -> b
    boolean strikeout -> c
    int charSet -> f
    int outPrecision -> g
    int clipPrecision -> h
    int quality -> i
    int pitchAndFamily -> j
    java.lang.String faceFamily -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogPen -> org.freehep.graphicsio.a.a.O:
    int penStyle -> a
    int width -> b
    java.awt.Color color -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ModifyWorldTransform -> org.freehep.graphicsio.a.a.P:
    java.awt.geom.AffineTransform transform -> a
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.MoveToEx -> org.freehep.graphicsio.a.a.Q:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.OffsetClipRgn -> org.freehep.graphicsio.a.a.R:
    java.awt.Point offset -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Panose -> org.freehep.graphicsio.a.a.S:
    int familyType -> a
    int serifStyle -> b
    int weight -> c
    int proportion -> d
    int contrast -> e
    int strokeVariation -> f
    int armStyle -> g
    int letterForm -> h
    int midLine -> i
    int xHeight -> j
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Pie -> org.freehep.graphicsio.a.a.T:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezier -> org.freehep.graphicsio.a.a.U:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezier16 -> org.freehep.graphicsio.a.a.V:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezierTo -> org.freehep.graphicsio.a.a.W:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezierTo16 -> org.freehep.graphicsio.a.a.X:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyDraw -> org.freehep.graphicsio.a.a.Y:
    java.awt.Rectangle bounds -> a
    java.awt.Point[] points -> a
    byte[] types -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyDraw16 -> org.freehep.graphicsio.a.a.Z:
    java.awt.Rectangle bounds -> a
    java.awt.Point[] points -> a
    byte[] types -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolygon -> org.freehep.graphicsio.a.a.aa:
    java.awt.Rectangle bounds -> a
    int start -> b
    int end -> c
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolygon16 -> org.freehep.graphicsio.a.a.ab:
    java.awt.Rectangle bounds -> a
    int numberOfPolys -> b
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolyline -> org.freehep.graphicsio.a.a.ac:
    java.awt.Rectangle bounds -> a
    int start -> b
    int end -> c
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolyline16 -> org.freehep.graphicsio.a.a.ad:
    java.awt.Rectangle bounds -> a
    int numberOfPolys -> b
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polygon16 -> org.freehep.graphicsio.a.a.ae:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polyline -> org.freehep.graphicsio.a.a.af:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polyline16 -> org.freehep.graphicsio.a.a.ag:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolylineTo -> org.freehep.graphicsio.a.a.ah:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolylineTo16 -> org.freehep.graphicsio.a.a.ai:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RealizePalette -> org.freehep.graphicsio.a.a.aj:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.Region -> org.freehep.graphicsio.a.a.ak:
    java.awt.Rectangle bounds -> a
    java.awt.Rectangle region -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int length() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ResizePalette -> org.freehep.graphicsio.a.a.al:
    int index -> b
    int entries -> c
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RestoreDC -> org.freehep.graphicsio.a.a.am:
    int savedDC -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RoundRect -> org.freehep.graphicsio.a.a.an:
    java.awt.Rectangle bounds -> a
    java.awt.Dimension corner -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SaveDC -> org.freehep.graphicsio.a.a.ao:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.ScaleViewportExtEx -> org.freehep.graphicsio.a.a.ap:
    int xNum -> b
    int xDenom -> c
    int yNum -> d
    int yDenom -> e
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ScaleWindowExtEx -> org.freehep.graphicsio.a.a.aq:
    int xNum -> b
    int xDenom -> c
    int yNum -> d
    int yDenom -> e
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectClipPath -> org.freehep.graphicsio.a.a.ar:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectObject -> org.freehep.graphicsio.a.a.as:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectPalette -> org.freehep.graphicsio.a.a.at:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetArcDirection -> org.freehep.graphicsio.a.a.au:
    int direction -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBkColor -> org.freehep.graphicsio.a.a.av:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBkMode -> org.freehep.graphicsio.a.a.aw:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBrushOrgEx -> org.freehep.graphicsio.a.a.ax:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetICMMode -> org.freehep.graphicsio.a.a.ay:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMapMode -> org.freehep.graphicsio.a.a.az:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMapperFlags -> org.freehep.graphicsio.a.a.aA:
    int flags -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMetaRgn -> org.freehep.graphicsio.a.a.aB:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.SetMiterLimit -> org.freehep.graphicsio.a.a.aC:
    int limit -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetPixelV -> org.freehep.graphicsio.a.a.aD:
    java.awt.Point point -> a
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetPolyFillMode -> org.freehep.graphicsio.a.a.aE:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetROP2 -> org.freehep.graphicsio.a.a.aF:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetStretchBltMode -> org.freehep.graphicsio.a.a.aG:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetTextAlign -> org.freehep.graphicsio.a.a.aH:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetTextColor -> org.freehep.graphicsio.a.a.aI:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetViewportExtEx -> org.freehep.graphicsio.a.a.aJ:
    java.awt.Dimension size -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetViewportOrgEx -> org.freehep.graphicsio.a.a.aK:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWindowExtEx -> org.freehep.graphicsio.a.a.aL:
    java.awt.Dimension size -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWindowOrgEx -> org.freehep.graphicsio.a.a.aM:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWorldTransform -> org.freehep.graphicsio.a.a.aN:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StretchDIBits -> org.freehep.graphicsio.a.a.aO:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    int xSrc -> f
    int ySrc -> g
    int widthSrc -> h
    int heightSrc -> i
    int usage -> j
    int dwROP -> k
    java.awt.Color bkg -> a
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StrokeAndFillPath -> org.freehep.graphicsio.a.a.aP:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StrokePath -> org.freehep.graphicsio.a.a.aQ:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Text -> org.freehep.graphicsio.a.a.aR:
    java.awt.Point pos -> a
    java.lang.String string -> a
    int options -> a
    int[] widths -> a
    java.awt.Rectangle bounds -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.TextW -> org.freehep.graphicsio.a.a.aS:
    java.awt.Point pos -> a
    java.lang.String string -> a
    int options -> a
    int[] widths -> a
    java.awt.Rectangle bounds -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.TriVertex -> org.freehep.graphicsio.a.a.aT:
    int x -> a
    int y -> b
    java.awt.Color color -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.WidenPath -> org.freehep.graphicsio.a.a.aU:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdiplus.Clear -> org.freehep.graphicsio.a.b.a:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.DrawEllipse -> org.freehep.graphicsio.a.b.b:
    float x -> a
    float y -> b
    float w -> c
    float h -> d
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.DrawImage -> org.freehep.graphicsio.a.b.c:
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.DrawLines -> org.freehep.graphicsio.a.b.d:
    float[] x -> a
    float[] y -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.DrawPath -> org.freehep.graphicsio.a.b.e:
    int penIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.EMFPlusPathConstructor -> org.freehep.graphicsio.a.b.f:
    java.util.List path -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void reset() -> b
    org.freehep.graphicsio.emf.gdiplus.PathPoint[] getPath() -> a
org.freehep.graphicsio.emf.gdiplus.EMFPlusTag -> org.freehep.graphicsio.a.b.g:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.EndOfFile -> org.freehep.graphicsio.a.b.h:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.FillEllipse -> org.freehep.graphicsio.a.b.i:
    int brushIndex -> b
    java.awt.Color brushColor -> a
    float x -> a
    float y -> b
    float w -> c
    float h -> d
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.FillPath -> org.freehep.graphicsio.a.b.j:
    java.awt.Color brushColor -> a
    int brushIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.GDIPlusObject -> org.freehep.graphicsio.a.b.k:
    java.awt.Paint brush -> a
    java.awt.BasicStroke stroke -> a
    org.freehep.graphicsio.emf.gdiplus.PathPoint[] path -> a
    int pathFillMode -> b
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
    java.awt.Paint readBrush(org.freehep.graphicsio.emf.EMFInputStream) -> a
    void writeBrush(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.Paint) -> a
    void writeTransform(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.geom.AffineTransform) -> a
    void writeImage(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.image.RenderedImage) -> a
org.freehep.graphicsio.emf.gdiplus.Header -> org.freehep.graphicsio.a.b.l:
    int hDpi -> b
    int vDpi -> c
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.MultiplyWorldTransform -> org.freehep.graphicsio.a.b.m:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.PathPoint -> org.freehep.graphicsio.a.b.n:
    float x -> a
    float y -> b
    int type -> a
    void setType(int) -> a
    int getType() -> a
    void setX(float) -> a
    float getX() -> a
    void setY(float) -> b
    float getY() -> b
org.freehep.graphicsio.emf.gdiplus.ResetClip -> org.freehep.graphicsio.a.b.o:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.Restore -> org.freehep.graphicsio.a.b.p:
    int containerIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.Save -> org.freehep.graphicsio.a.b.q:
    int containerIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.SetAntiAliasMode -> org.freehep.graphicsio.a.b.r:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.SetClipPath -> org.freehep.graphicsio.a.b.s:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.SetWorldTransform -> org.freehep.graphicsio.a.b.t:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.font.CharstringEncoder -> org.freehep.graphicsio.b.a:
    java.io.OutputStream out -> a
    int currentX -> a
    int currentY -> b
    int writeNumber(double) -> a
    void writeNumber(int) -> b
    void writeCommand(int) -> a
    void writePoint(double,double) -> e
    void writeX(double) -> a
    void writeY(double) -> b
    void startChar(double,double) -> d
    void endchar() -> b
    int to(double,double) -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void drawPath(java.awt.Shape) -> a
org.freehep.graphicsio.font.FontEmbedder -> org.freehep.graphicsio.b.b:
    double[] widths -> a
    java.awt.font.GlyphVector glyphs -> a
    java.awt.Font font -> a
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
    void writeWidths(double[]) -> a
    void openGlyphs() -> a
    void closeGlyphs() -> b
    void closeEmbedFont() -> c
    double[] getAdvanceWidths() -> a
    java.awt.Shape getGlyph(int) -> a
    java.awt.font.GlyphMetrics getGlyphMetrics(int) -> a
    void includeFont(java.awt.Font,org.freehep.graphics2d.font.CharTable,java.lang.String) -> a
    java.awt.Shape createUndefined() -> a
org.freehep.graphicsio.font.FontEmbedderType1 -> org.freehep.graphicsio.b.c:
    java.io.PrintStream fontFile -> a
    java.io.PrintStream encrypted -> b
    org.freehep.util.io.CountedByteOutputStream byteCounter -> a
    int asciiEnd -> a
    int encEnd -> b
    boolean addZeros -> a
    void writeWidths(double[]) -> a
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    void openIncludeFont() -> d
    void closeIncludeFont() -> e
    void openGlyphs() -> a
    void closeGlyphs() -> b
    void closeEmbedFont() -> c
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
    int getAsciiLength() -> a
    int getEncryptedLength() -> b
org.freehep.graphicsio.font.FontIncluder -> org.freehep.graphicsio.b.d:
    java.awt.font.FontRenderContext context -> a
    java.awt.geom.Rectangle2D fontBBox -> a
    java.awt.Font font -> a
    java.lang.String fontName -> a
    org.freehep.graphics2d.font.CharTable charTable -> a
    char[] unicode -> a
    java.lang.String[] charName -> a
    int noDefinedChars -> a
    void openIncludeFont() -> d
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    void closeIncludeFont() -> e
    java.awt.font.FontRenderContext getContext() -> a
    java.lang.String getFontName() -> a
    java.awt.Font getFont() -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    java.awt.geom.Rectangle2D getFontBBox() -> a
    java.lang.String getCharName(int) -> a
    char getUnicode(int) -> a
    char[] getUnicode() -> a
    int getNODefinedChars() -> c
    void includeFont(java.awt.Font,org.freehep.graphics2d.font.CharTable,java.lang.String) -> a
    double getUndefinedWidth() -> a
org.freehep.graphicsio.font.FontTable -> org.freehep.graphicsio.b.e:
    java.util.Hashtable table -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    void firstRequest(org.freehep.graphicsio.font.FontTable$Entry,boolean,java.lang.String) -> a
    java.lang.String createFontReference(java.awt.Font) -> a
    java.awt.Font substituteFont(java.awt.Font) -> a
    java.lang.String fontReference(java.awt.Font,boolean,java.lang.String) -> a
    java.lang.String getKey(java.awt.Font) -> b
    void normalize(java.util.Map) -> a
    java.util.Collection getEntries() -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable(java.awt.Font) -> a
org.freehep.graphicsio.font.FontTable$Entry -> org.freehep.graphicsio.b.e$a:
    java.awt.Font font -> a
    java.lang.String ref -> a
    org.freehep.graphics2d.font.CharTable encoding -> a
    boolean written -> a
    org.freehep.graphicsio.font.FontTable this$0 -> a
    java.awt.Font getFont() -> a
    java.lang.String getReference() -> a
    org.freehep.graphics2d.font.CharTable getEncoding() -> a
    void setWritten(boolean) -> a
    boolean isWritten() -> a
    java.lang.String toString() -> toString
    java.lang.String access$1(org.freehep.graphicsio.font.FontTable$Entry) -> a
org.freehep.graphicsio.font.FontUtilities -> org.freehep.graphicsio.b.f:
    java.util.Properties windowsFonts -> a
    org.freehep.graphics2d.font.CharTable[] STANDARD_CHAR_TABLES -> a
    java.awt.Font[] STANDARD_FONT -> a
    java.lang.String getWindowsFontName(java.lang.String) -> a
    void showString(java.awt.Font,java.lang.String,org.freehep.graphics2d.font.CharTable,org.freehep.graphicsio.font.FontUtilities$ShowString) -> a
org.freehep.graphicsio.font.FontUtilities$ShowString -> org.freehep.graphicsio.b.f$a:
    void showString(java.awt.Font,java.lang.String) -> a
org.freehep.graphicsio.pdf.PDF -> org.freehep.graphicsio.c.a:
    int generationNumber -> a
    java.util.Hashtable refsByName -> a
    java.util.Vector refsByNumber -> a
    java.util.Vector xrefsByNumber -> b
    int startXref -> b
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    org.freehep.graphicsio.pdf.PDFName name(java.lang.String) -> a
    org.freehep.graphicsio.pdf.PDFRef ref(java.lang.String) -> a
    void setXRef(int,int) -> a
    void xref() -> a
    void trailer(java.lang.String,java.lang.String) -> a
    void startxref() -> b
org.freehep.graphicsio.pdf.PDFByteWriter -> org.freehep.graphicsio.c.b:
    int indent -> a
    java.lang.String indentString -> b
    void write(java.lang.String) -> a
    void close() -> close
    void print(java.lang.String) -> b
    void printPlain(java.lang.String) -> c
    void println() -> a
    void indent() -> b
    void outdent() -> c
    void println(java.lang.String) -> d
    void print(int) -> a
    void println(int) -> b
    void printPlain(java.lang.Object) -> a
org.freehep.graphicsio.pdf.PDFCatalog -> org.freehep.graphicsio.c.c:
    void setViewerPreferences(java.lang.String) -> a
    void setPageMode(java.lang.String) -> b
    void setOutlines(java.lang.String) -> c
    void setOpenAction(java.lang.Object[]) -> a
org.freehep.graphicsio.pdf.PDFCharTableWriter -> org.freehep.graphicsio.c.d:
    org.freehep.graphicsio.pdf.PDFCharTableWriter ctw -> a
    org.freehep.graphicsio.pdf.PDFCharTableWriter getInstance() -> a
    void writeObject(java.lang.Object,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFWriter) -> a
org.freehep.graphicsio.pdf.PDFConstants -> org.freehep.graphicsio.c.e:
    java.lang.String EOL -> a
    java.text.SimpleDateFormat dateFormat -> a
org.freehep.graphicsio.pdf.PDFDictionary -> org.freehep.graphicsio.c.f:
    java.lang.String open -> b
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    boolean ok -> a
    org.freehep.graphicsio.pdf.PDFObject object -> a
    org.freehep.graphicsio.pdf.PDF pdf -> a
    void close() -> a
    void entry(java.lang.String,java.lang.String) -> a
    void entry(java.lang.String,org.freehep.graphicsio.pdf.PDFName) -> a
    void entry(java.lang.String,int) -> a
    void entry(java.lang.String,double) -> a
    void entry(java.lang.String,boolean) -> a
    void entry(java.lang.String,org.freehep.graphicsio.pdf.PDFRef) -> a
    void entry(java.lang.String,java.util.Calendar) -> a
    void entry(java.lang.String,java.lang.Object[]) -> a
    void entry(java.lang.String,double[]) -> a
    void entry(java.lang.String,boolean[]) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDictionary) -> a
org.freehep.graphicsio.pdf.PDFDocInfo -> org.freehep.graphicsio.c.g:
    void setTitle(java.lang.String) -> a
    void setAuthor(java.lang.String) -> b
    void setSubject(java.lang.String) -> c
    void setKeywords(java.lang.String) -> d
    void setCreator(java.lang.String) -> e
    void setProducer(java.lang.String) -> f
    void setCreationDate(java.util.Calendar) -> a
    void setModificationDate(java.util.Calendar) -> b
    void setTrapped(java.lang.String) -> g
org.freehep.graphicsio.pdf.PDFFontEmbedder -> org.freehep.graphicsio.c.h:
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFDictionary fontDict -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    java.lang.String getSubtype() -> b
    void addAdditionalEntries(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    void addAdditionalInitDicts() -> f
    java.lang.String getReference() -> c
    void openIncludeFont() -> d
    void closeEmbedFont() -> c
    void writeWidths(double[]) -> a
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    java.lang.String createCharacterReference(java.lang.String) -> a
org.freehep.graphicsio.pdf.PDFFontEmbedderType1 -> org.freehep.graphicsio.c.i:
    java.io.ByteArrayOutputStream byteBuffer -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFStream fontFile -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    org.freehep.graphicsio.pdf.PDFFontEmbedderType1 create(java.awt.font.FontRenderContext,org.freehep.graphicsio.pdf.PDFWriter,java.lang.String,org.freehep.graphicsio.pdf.PDFRedundanceTracker) -> a
    java.lang.String getReference() -> b
    void openIncludeFont() -> d
    void writeWidths(double[]) -> a
    void openGlyphs() -> a
    void closeEmbedFont() -> c
org.freehep.graphicsio.pdf.PDFFontEmbedderType3 -> org.freehep.graphicsio.c.j:
    java.lang.String getSubtype() -> b
    void addAdditionalEntries(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    void addAdditionalInitDicts() -> f
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
org.freehep.graphicsio.pdf.PDFFontIncluder -> org.freehep.graphicsio.c.k:
    java.lang.String[][] STANDARD_FONT -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    void openIncludeFont() -> d
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    boolean isStandardFont(java.awt.Font) -> a
    int getFontBaseIndex(java.awt.Font) -> a
    int getFontStyle(java.awt.Font) -> b
org.freehep.graphicsio.pdf.PDFFontTable -> org.freehep.graphicsio.c.l:
    int currentFontIndex -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker tracker -> a
    java.util.Properties replaceFonts -> a
    int addFontDictionary() -> a
    void embedAll(java.awt.font.FontRenderContext,boolean,java.lang.String) -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    void firstRequest(org.freehep.graphicsio.font.FontTable$Entry,boolean,java.lang.String) -> a
    java.awt.Font substituteFont(java.awt.Font) -> a
    java.lang.String createFontReference(java.awt.Font) -> a
org.freehep.graphicsio.pdf.PDFGraphics2D -> org.freehep.graphicsio.c.m:
    java.lang.String rootKey -> w
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    java.lang.String PAGE_SIZE -> h
    java.lang.String PAGE_MARGINS -> i
    java.lang.String ORIENTATION -> j
    java.lang.String FIT_TO_PAGE -> k
    java.lang.String EMBED_FONTS -> l
    java.lang.String EMBED_FONTS_AS -> m
    java.lang.String THUMBNAILS -> n
    java.lang.String THUMBNAIL_SIZE -> o
    java.lang.String COMPRESS -> p
    java.lang.String VERSION -> q
    java.lang.String WRITE_IMAGES_AS -> r
    java.lang.String AUTHOR -> s
    java.lang.String TITLE -> t
    java.lang.String SUBJECT -> u
    java.lang.String KEYWORDS -> v
    org.freehep.util.UserProperties defaultProperties -> a
    java.lang.String[] COMPRESS_FILTERS -> a
    java.lang.String[] NO_FILTERS -> b
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.pdf.PDFWriter os -> a
    org.freehep.graphicsio.pdf.PDFStream pageStream -> a
    org.freehep.graphicsio.pdf.PDFFontTable fontTable -> a
    org.freehep.graphicsio.pdf.PDFImageDelayQueue delayImageQueue -> a
    org.freehep.graphicsio.pdf.PDFPaintDelayQueue delayPaintQueue -> a
    int currentPage -> b
    boolean multiPage -> a
    org.freehep.graphics2d.TagString[] headerText -> a
    int headerUnderline -> c
    java.awt.Font headerFont -> a
    org.freehep.graphics2d.TagString[] footerText -> b
    int footerUnderline -> d
    java.awt.Font footerFont -> b
    java.util.List titles -> a
    int alphaIndex -> a
    java.util.Map extGStates -> a
    java.awt.Dimension pageSize -> a
    java.util.Properties getDefaultProperties() -> b
    void setDefaultProperties(java.util.Properties) -> b
    void init(java.io.OutputStream) -> a
    boolean isMultiPage() -> b
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    void processDelayed() -> k
    void openPage(java.awt.Dimension,java.lang.String,java.awt.Component) -> a
    void closePage() -> i
    void writeHeadline(java.awt.geom.AffineTransform) -> c
    void writeFootline(java.awt.geom.AffineTransform) -> d
    void writeLine(java.awt.geom.AffineTransform,java.awt.Font,org.freehep.graphics2d.TagString[],double,int,double,int) -> a
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> j
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeClip(java.awt.Shape) -> a
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    void showString(java.awt.Font,java.lang.String) -> a
    void showCharacterCodes(java.lang.String) -> a
    double getWidth() -> a
    double getHeight() -> b
    java.awt.Dimension getSize(java.lang.String,java.lang.String) -> a
    void setPageSize(java.awt.Dimension) -> a
org.freehep.graphicsio.pdf.PDFImageDelayQueue -> org.freehep.graphicsio.c.n:
    int currentNumber -> a
    java.util.Map imageMap -> a
    java.util.List imageList -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFName delayImage(java.awt.image.RenderedImage,java.awt.Color,java.lang.String) -> a
    void processAll() -> a
    int addXObjects() -> a
    int access$0(org.freehep.graphicsio.pdf.PDFImageDelayQueue) -> a
    void access$1(org.freehep.graphicsio.pdf.PDFImageDelayQueue,int) -> a
org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry -> org.freehep.graphicsio.c.n$a:
    java.awt.image.RenderedImage image -> a
    java.lang.String name -> a
    java.lang.String maskName -> b
    java.awt.Color bkg -> a
    java.lang.String writeAs -> c
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFImageDelayQueue this$0 -> a
    java.lang.String access$1(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    void access$3(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry,boolean) -> a
    java.lang.String access$4(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> b
    java.lang.String access$5(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> c
    java.awt.image.RenderedImage access$6(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    java.awt.Color access$7(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
org.freehep.graphicsio.pdf.PDFName -> org.freehep.graphicsio.c.o:
    java.lang.String name -> b
    java.lang.String toString() -> toString
org.freehep.graphicsio.pdf.PDFObject -> org.freehep.graphicsio.c.p:
    org.freehep.graphicsio.pdf.PDF pdf -> a
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    java.lang.String open -> b
    boolean ok -> a
    void close() -> a
    void entry(int) -> a
    void entry(java.lang.Object[]) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary() -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String,java.lang.String[]) -> a
    org.freehep.graphicsio.pdf.PDFDocInfo openDocInfo(org.freehep.graphicsio.pdf.PDF) -> a
    org.freehep.graphicsio.pdf.PDFCatalog openCatalog(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFPageTree openPageTree(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFPage openPage(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFViewerPreferences openViewerPreferences(org.freehep.graphicsio.pdf.PDF) -> a
    org.freehep.graphicsio.pdf.PDFOutlineList openOutlineList(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFOutline openOutline(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef,java.lang.String,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFRef) -> a
org.freehep.graphicsio.pdf.PDFOutline -> org.freehep.graphicsio.c.q:
    void setDest(java.lang.Object[]) -> a
org.freehep.graphicsio.pdf.PDFOutlineList -> org.freehep.graphicsio.c.r:
org.freehep.graphicsio.pdf.PDFPage -> org.freehep.graphicsio.c.s:
    void setContents(java.lang.String) -> a
    void setThumb(java.lang.String) -> b
org.freehep.graphicsio.pdf.PDFPageBase -> org.freehep.graphicsio.c.t:
    void setResources(java.lang.String) -> c
    void setMediaBox(double,double,double,double) -> a
org.freehep.graphicsio.pdf.PDFPageTree -> org.freehep.graphicsio.c.u:
    java.util.Vector pages -> a
    void addPage(java.lang.String) -> a
    void close() -> a
org.freehep.graphicsio.pdf.PDFPaintDelayQueue -> org.freehep.graphicsio.c.v:
    int currentNumber -> a
    java.util.List paintList -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.awt.geom.AffineTransform pageMatrix -> a
    void setPageMatrix(java.awt.geom.AffineTransform) -> a
    org.freehep.graphicsio.pdf.PDFName delayPaint(java.awt.Paint,java.awt.geom.AffineTransform,java.lang.String) -> a
    void processAll() -> a
    int addPatterns() -> a
    void addGradientPaint(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    void addLinearFunction(java.lang.String,double[],double[],double[]) -> a
    void addTexturePaint(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> b
    void setMatrix(org.freehep.graphicsio.pdf.PDFDictionary,org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry,double,double) -> a
    int access$0() -> b
    void access$1(int) -> a
org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry -> org.freehep.graphicsio.c.v$a:
    java.awt.Paint paint -> a
    java.lang.String name -> a
    java.awt.geom.AffineTransform trafo -> a
    java.lang.String writeAs -> b
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFPaintDelayQueue this$0 -> a
    java.lang.String access$1(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    void access$3(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry,boolean) -> a
    java.awt.Paint access$4(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    java.lang.String access$5(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> b
    java.awt.geom.AffineTransform access$6(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
org.freehep.graphicsio.pdf.PDFPathConstructor -> org.freehep.graphicsio.c.w:
    org.freehep.graphicsio.pdf.PDFStream stream -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
org.freehep.graphicsio.pdf.PDFRedundanceTracker -> org.freehep.graphicsio.c.x:
    int refCount -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.util.Map objects -> a
    java.util.Vector orderedObjects -> a
    org.freehep.graphicsio.pdf.PDFRef getReference(java.lang.Object,java.lang.Object,org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer) -> a
    org.freehep.graphicsio.pdf.PDFRef getReference(java.lang.Object,org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer) -> a
    void writeAll() -> a
    org.freehep.graphicsio.pdf.PDFWriter access$0(org.freehep.graphicsio.pdf.PDFRedundanceTracker) -> a
    int access$1() -> a
    void access$2(int) -> a
org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry -> org.freehep.graphicsio.c.x$a:
    java.lang.Object object -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer writer -> a
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFRef reference -> a
    java.lang.Object groupID -> b
    org.freehep.graphicsio.pdf.PDFRedundanceTracker this$0 -> a
    org.freehep.graphicsio.pdf.PDFRef access$0(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer access$3(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    java.lang.Object access$4(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    void access$5(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry,boolean) -> a
org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer -> org.freehep.graphicsio.c.x$b:
    void writeObject(java.lang.Object,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFWriter) -> a
org.freehep.graphicsio.pdf.PDFRef -> org.freehep.graphicsio.c.y:
    java.lang.String name -> b
    int objectNumber -> a
    int generationNumber -> b
    java.lang.String getName() -> a
    int getObjectNumber() -> a
    int getGenerationNumber() -> b
    java.lang.String toString() -> toString
org.freehep.graphicsio.pdf.PDFStream -> org.freehep.graphicsio.c.z:
    java.lang.String name -> b
    org.freehep.graphicsio.pdf.PDFObject object -> a
    boolean dictionaryOpen -> a
    java.io.OutputStream[] stream -> a
    org.freehep.util.io.CountedByteOutputStream byteCountStream -> a
    java.lang.String[] encode -> a
    int gStates -> a
    boolean textOpen -> b
    boolean fontWasSet -> c
    boolean compatibilityOpen -> d
    void startStream() -> m
    void startStream(java.lang.String[]) -> a
    void write(int) -> c
    void write(byte[]) -> a
    org.freehep.graphicsio.pdf.PDFName[] decodeFilters(java.lang.String[]) -> a
    java.io.OutputStream[] openFilters(java.io.OutputStream,java.lang.String[]) -> a
    void closeFilters(java.io.OutputStream[]) -> a
    void write(java.lang.String) -> d
    void close() -> a
    java.lang.String getName() -> a
    int getLength() -> a
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void save() -> b
    void restore() -> c
    void matrix(java.awt.geom.AffineTransform) -> a
    void matrix(double,double,double,double,double,double) -> a
    void width(double) -> a
    void cap(int) -> a
    void join(int) -> b
    void mitterLimit(double) -> b
    void dash(float[],double) -> a
    void state(org.freehep.graphicsio.pdf.PDFName) -> a
    void cubic(double,double,double,double,double,double) -> b
    void move(double,double) -> a
    void line(double,double) -> b
    void closePath() -> d
    void stroke() -> e
    void fill() -> f
    void fillEvenOdd() -> g
    void endPath() -> h
    void clip() -> i
    void clipEvenOdd() -> j
    void beginText() -> k
    void endText() -> l
    void font(org.freehep.graphicsio.pdf.PDFName,double) -> a
    void text(double,double) -> c
    void show(java.lang.String) -> c
    void glyph(double,double,double,double,double,double) -> c
    void colorSpace(org.freehep.graphicsio.pdf.PDFName) -> b
    void colorSpaceStroke(org.freehep.graphicsio.pdf.PDFName) -> c
    void colorSpace(double[],org.freehep.graphicsio.pdf.PDFName) -> a
    void colorSpaceStroke(double[],org.freehep.graphicsio.pdf.PDFName) -> b
    void colorSpace(double,double,double) -> a
    void colorSpaceStroke(double,double,double) -> b
    void image(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> a
    void imageMask(java.awt.image.RenderedImage,java.lang.String[]) -> a
    void inlineImage(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> b
    byte[] imageToBytes(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> a
    void imageInfo(java.lang.String,int) -> b
    void imageInfo(java.lang.String,org.freehep.graphicsio.pdf.PDFName) -> b
    void imageInfo(java.lang.String,java.lang.Object[]) -> b
    boolean drawPath(java.awt.Shape) -> a
    void xObject(org.freehep.graphicsio.pdf.PDFName) -> d
org.freehep.graphicsio.pdf.PDFUtil -> org.freehep.graphicsio.c.A:
    geogebra.util.ScientificFormat scientific -> a
    java.lang.String escape(java.lang.String) -> a
    java.lang.String date(java.util.Calendar) -> a
    java.lang.String fixedPrecision(double) -> a
org.freehep.graphicsio.pdf.PDFViewerPreferences -> org.freehep.graphicsio.c.B:
    void setFitWindow(boolean) -> a
    void setCenterWindow(boolean) -> b
org.freehep.graphicsio.pdf.PDFWriter -> org.freehep.graphicsio.c.C:
    java.lang.String open -> b
    java.lang.String catalogName -> c
    java.lang.String docInfoName -> d
    void close(java.lang.String,java.lang.String) -> b
    void object(java.lang.String,java.lang.Object[]) -> a
    void object(java.lang.String,int) -> a
    org.freehep.graphicsio.pdf.PDFObject openObject(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFObject) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String) -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String,java.lang.String[]) -> a
    void close(org.freehep.graphicsio.pdf.PDFStream) -> a
    void close() -> c
    org.freehep.graphicsio.pdf.PDFDocInfo openDocInfo(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDocInfo) -> a
    org.freehep.graphicsio.pdf.PDFCatalog openCatalog(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFCatalog) -> a
    org.freehep.graphicsio.pdf.PDFPageTree openPageTree(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFPageTree) -> a
    org.freehep.graphicsio.pdf.PDFPage openPage(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFPage) -> a
    org.freehep.graphicsio.pdf.PDFViewerPreferences openViewerPreferences(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFViewerPreferences) -> a
    org.freehep.graphicsio.pdf.PDFOutlineList openOutlineList(java.lang.String,java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFOutlineList) -> a
    org.freehep.graphicsio.pdf.PDFOutline openOutline(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFOutline) -> a
org.freehep.graphicsio.raw.RawImageWriteParam -> org.freehep.graphicsio.raw.a:
    java.lang.String rootKey -> d
    java.lang.String BACKGROUND -> a
    java.lang.String CODE -> b
    java.lang.String PAD -> c
    java.awt.Color bkg -> a
    java.lang.String code -> e
    int pad -> a
    javax.imageio.ImageWriteParam getWriteParam(java.util.Properties) -> a
    java.awt.Color getBackground() -> a
    void setBackground(java.awt.Color) -> a
    java.lang.String getCode() -> a
    void setCode(java.lang.String) -> a
    int getPad() -> a
    void setPad(int) -> a
org.freehep.graphicsio.raw.RawImageWriter -> org.freehep.graphicsio.raw.b:
    void write(javax.imageio.metadata.IIOMetadata,javax.imageio.IIOImage,javax.imageio.ImageWriteParam) -> write
    javax.imageio.metadata.IIOMetadata convertStreamMetadata(javax.imageio.metadata.IIOMetadata,javax.imageio.ImageWriteParam) -> convertStreamMetadata
    javax.imageio.metadata.IIOMetadata convertImageMetadata(javax.imageio.metadata.IIOMetadata,javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam) -> convertImageMetadata
    javax.imageio.metadata.IIOMetadata getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam) -> getDefaultImageMetadata
    javax.imageio.metadata.IIOMetadata getDefaultStreamMetadata(javax.imageio.ImageWriteParam) -> getDefaultStreamMetadata
    javax.imageio.ImageWriteParam getDefaultWriteParam() -> getDefaultWriteParam
org.freehep.graphicsio.raw.RawImageWriterSpi -> org.freehep.graphicsio.raw.RawImageWriterSpi:
    java.lang.String getDescription(java.util.Locale) -> getDescription
    javax.imageio.ImageWriter createWriterInstance(java.lang.Object) -> createWriterInstance
    boolean canEncodeImage(javax.imageio.ImageTypeSpecifier) -> canEncodeImage
org.freehep.graphicsio.svg.SVGFontTable -> org.freehep.graphicsio.d.a:
    java.util.Hashtable glyphs -> a
    java.util.Properties replaceFonts -> a
    org.freehep.graphicsio.svg.SVGGlyph addGlyph(int,java.awt.Font) -> a
    org.freehep.graphicsio.svg.SVGGlyph createGlyph(int,java.awt.Font) -> b
    void addGlyphs(java.lang.String,java.awt.Font) -> a
    java.util.Hashtable getGlyphs(java.awt.Font) -> a
    java.lang.String toString() -> toString
    java.awt.Font untransform(java.awt.Font) -> a
    void normalize(java.util.Map) -> a
org.freehep.graphicsio.svg.SVGGlyph -> org.freehep.graphicsio.d.b:
    int FONT_SIZE -> a
    int UNITS_PER_EM -> b
    java.awt.Shape glyph -> a
    int unicode -> c
    java.awt.font.GlyphMetrics glyphMetrics -> a
    java.awt.geom.AffineTransform defaultTransform -> a
    java.lang.String toString() -> toString
    java.lang.String getPathString() -> a
    java.lang.String getHorizontalAdvanceXString() -> b
    java.lang.String getHorizontalAdvanceYString() -> c
org.freehep.graphicsio.svg.SVGGraphics2D -> org.freehep.graphicsio.d.c:
    java.lang.String rootKey -> r
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    java.lang.String VERSION -> h
    java.lang.String COMPRESS -> i
    java.lang.String STYLABLE -> j
    java.lang.String IMAGE_SIZE -> k
    java.lang.String EXPORT_IMAGES -> l
    java.lang.String EXPORT_SUFFIX -> m
    java.lang.String WRITE_IMAGES_AS -> n
    java.lang.String FOR -> o
    java.lang.String TITLE -> p
    java.awt.BasicStroke defaultStroke -> a
    java.lang.String EMBED_FONTS -> q
    org.freehep.graphicsio.svg.SVGFontTable fontTable -> a
    org.freehep.util.UserProperties defaultProperties -> a
    java.lang.String filename -> s
    int bbx -> a
    int bby -> b
    int bbw -> c
    int bbh -> d
    java.io.OutputStream ros -> a
    java.io.PrintWriter os -> a
    java.util.Hashtable gradients -> a
    java.util.Hashtable textures -> b
    java.util.Stack closeTags -> a
    int imageNumber -> e
    org.freehep.util.Value clipNumber -> a
    int width -> f
    int height -> g
    geogebra.util.ScientificFormat scientific -> a
    java.util.Properties getDefaultProperties() -> b
    void setDefaultProperties(java.util.Properties) -> b
    void init(java.io.OutputStream) -> a
    void setBoundingBox() -> i
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> j
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void writePathIterator(java.awt.geom.PathIterator,java.util.Properties) -> a
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    java.util.Properties getFontProperties(java.awt.Font) -> a
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    java.util.Properties getStrokeProperties(java.awt.Stroke,boolean) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    java.lang.String getTransformedString(java.awt.geom.AffineTransform,java.lang.String) -> a
    java.lang.String getClippedString(java.lang.String) -> b
    float alphaColor(java.awt.Paint) -> a
    java.lang.String hexColor(java.awt.Paint) -> a
    java.lang.String hexColor(java.awt.Color) -> a
    java.lang.String hexColor(java.awt.GradientPaint) -> a
    java.lang.String hexColor(java.awt.TexturePaint) -> a
    java.lang.String getPathContent(java.awt.geom.PathIterator) -> a
    java.lang.String getPath(java.awt.geom.PathIterator) -> b
    java.lang.String style(java.util.Properties) -> a
    java.lang.String fixedPrecision(double) -> a
org.freehep.util.UserProperties -> org.freehep.b.a:
    java.util.Properties altDefaults -> a
    java.util.Enumeration propertyNames() -> propertyNames
    void setProperties(java.util.Properties) -> a
    java.lang.Object setProperty(java.lang.String,java.lang.String) -> setProperty
    java.lang.Object setProperty(java.lang.String,java.awt.Color) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Color) -> a
    java.lang.Object setProperty(java.lang.String,java.awt.Insets) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Insets) -> a
    java.lang.Object setProperty(java.lang.String,java.awt.Dimension) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Dimension) -> a
    java.lang.Object setProperty(java.lang.String,int) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,int) -> a
    java.lang.Object setProperty(java.lang.String,boolean) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,boolean) -> a
    java.lang.String getProperty(java.lang.String) -> getProperty
    java.lang.String getProperty(java.lang.String,java.lang.String) -> getProperty
    java.awt.Color getPropertyColor(java.lang.String) -> a
    java.awt.Color getPropertyColor(java.lang.String,java.awt.Color) -> a
    java.awt.Insets getPropertyInsets(java.lang.String) -> a
    java.awt.Insets getPropertyInsets(java.lang.String,java.awt.Insets) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String,java.awt.Dimension) -> a
    int getPropertyInt(java.lang.String,int) -> a
    float getPropertyFloat(java.lang.String) -> a
    float getPropertyFloat(java.lang.String,float) -> a
    boolean isProperty(java.lang.String) -> a
    boolean isProperty(java.lang.String,boolean) -> a
org.freehep.util.Value -> org.freehep.b.b:
    int intValue -> a
    short shortValue -> a
    long longValue -> a
    float floatValue -> a
    double doubleValue -> a
    boolean boolValue -> a
    byte byteValue -> a
    char charValue -> a
    java.lang.Object obj -> a
    java.lang.Class type -> k
    java.lang.Class TYPE_INTEGER -> a
    java.lang.Class TYPE_SHORT -> b
    java.lang.Class TYPE_LONG -> c
    java.lang.Class TYPE_FLOAT -> d
    java.lang.Class TYPE_DOUBLE -> e
    java.lang.Class TYPE_BOOLEAN -> f
    java.lang.Class TYPE_BYTE -> g
    java.lang.Class TYPE_CHAR -> h
    java.lang.Class TYPE_STRING -> i
    java.lang.Class TYPE_DATE -> j
    org.freehep.util.Value set(int) -> a
    int getInt() -> a
    java.lang.String getString() -> a
    java.lang.String toString() -> toString
org.freehep.util.images.ImageUtilities -> org.freehep.b.a.a:
    java.awt.image.RenderedImage createRenderedImage(java.awt.Image,java.awt.image.ImageObserver,java.awt.Color) -> a
    byte[] getBytes(java.awt.image.RenderedImage,java.awt.Color,java.lang.String,int) -> a
org.freehep.util.io.ASCII85OutputStream -> org.freehep.b.b.a:
    boolean end -> a
    int characters -> a
    int[] b -> a
    int bIndex -> b
    int[] c -> b
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeTuple() -> a
    void writeEOD() -> b
    void writeChar(int) -> a
    void writeNewLine() -> c
org.freehep.util.io.ASCIIHexOutputStream -> org.freehep.b.b.b:
    int characters -> a
    boolean end -> a
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeChar(int) -> a
    void writeNewLine() -> a
org.freehep.util.io.Action -> org.freehep.b.b.c:
    int code -> a
    java.lang.String name -> a
    int getCode() -> a
    java.lang.String getName() -> a
    java.lang.String toString() -> toString
org.freehep.util.io.Action$Unknown -> org.freehep.b.b.c$a:
    int[] data -> a
    java.lang.String toString() -> toString
org.freehep.util.io.ActionSet -> org.freehep.b.b.d:
    java.util.Map actions -> a
    org.freehep.util.io.Action defaultAction -> a
org.freehep.util.io.Base64OutputStream -> org.freehep.b.b.e:
    int MAX_LINE_LENGTH -> a
    int position -> b
    byte[] buffer -> a
    int lineLength -> c
    char[] intToBase64 -> a
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeTuple() -> a
    void writeNewLine() -> b
org.freehep.util.io.BitInputStream -> org.freehep.b.b.f:
    int[] BIT_MASK -> a
    int[] FIELD_MASK -> b
    int bits -> a
    int validBits -> b
    void byteAlign() -> a
org.freehep.util.io.BitOutputStream -> org.freehep.b.b.g:
    int bits -> a
    int bitPos -> b
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void flushByte() -> a
    void byteAlign() -> b
org.freehep.util.io.ByteCountInputStream -> org.freehep.b.b.h:
    int index -> a
    int[] size -> c
    long len -> a
    int read() -> read
    void pushBuffer(int) -> a
    byte[] popBuffer() -> a
org.freehep.util.io.ByteCountOutputStream -> org.freehep.b.b.i:
    int currentBuffer -> b
    java.util.List bufferList -> a
    void write(int) -> write
    void pushBuffer() -> c
    int popBuffer() -> c
    int getBufferLength() -> d
    void append() -> d
    void close() -> close
org.freehep.util.io.ByteCountOutputStream$Buffer -> org.freehep.b.b.i$a:
    byte[] buffer -> a
    int len -> a
    void add(byte) -> a
    void add(org.freehep.util.io.ByteCountOutputStream$Buffer) -> a
    int getLength() -> a
    byte[] getBytes() -> a
org.freehep.util.io.ByteOrderInputStream -> org.freehep.b.b.j:
    boolean little -> a
    void readFully(byte[]) -> readFully
    void readFully(byte[],int,int) -> readFully
    int skipBytes(int) -> skipBytes
    boolean readBoolean() -> readBoolean
    char readChar() -> readChar
    byte readByte() -> readByte
    byte[] readByte(int) -> b
    int readUnsignedByte() -> readUnsignedByte
    int[] readUnsignedByte(int) -> b
    short readShort() -> readShort
    int readUnsignedShort() -> readUnsignedShort
    int readInt() -> readInt
    long readUnsignedInt() -> a
    long readLong() -> readLong
    float readFloat() -> readFloat
    double readDouble() -> readDouble
    java.lang.String readLine() -> readLine
    java.lang.String readUTF() -> readUTF
org.freehep.util.io.ByteOrderOutputStream -> org.freehep.b.b.k:
    boolean little -> a
    int written -> a
    void write(int) -> write
    void writeBoolean(boolean) -> writeBoolean
    void writeChar(int) -> writeChar
    void writeByte(int) -> writeByte
    void writeByte(byte[]) -> b
    void writeUnsignedByte(int) -> g
    void writeUnsignedByte(int[]) -> b
    void writeShort(int) -> writeShort
    void writeUnsignedShort(int) -> h
    void writeInt(int) -> writeInt
    void writeUnsignedInt(long) -> a
    void writeLong(long) -> writeLong
    void writeFloat(float) -> writeFloat
    void writeDouble(double) -> writeDouble
    void writeBytes(java.lang.String) -> writeBytes
    void writeChars(java.lang.String) -> writeChars
    void writeUTF(java.lang.String) -> writeUTF
    void writeUTF(java.lang.String,java.io.DataOutput) -> a
org.freehep.util.io.CompressableOutputStream -> org.freehep.b.b.l:
    boolean compress -> a
    java.util.zip.DeflaterOutputStream dos -> a
    void write(int) -> write
    void write(byte[],int,int) -> write
    void finish() -> finish
    void close() -> close
org.freehep.util.io.CountedByteOutputStream -> org.freehep.b.b.m:
    int count -> a
    void write(int) -> write
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    int getCount() -> a
org.freehep.util.io.DecompressableInputStream -> org.freehep.b.b.n:
    boolean decompress -> a
    java.util.zip.InflaterInputStream iis -> a
    java.io.InputStream in -> a
    int read() -> read
    long skip(long) -> skip
org.freehep.util.io.EEXECEncryption -> org.freehep.b.b.o:
    int n -> a
    int c1 -> b
    int c2 -> c
    int r -> d
    java.io.OutputStream out -> a
    boolean first -> a
    int encrypt(int) -> a
    void write(int) -> write
    void flush() -> flush
    void close() -> close
org.freehep.util.io.FinishableOutputStream -> org.freehep.b.b.p:
    void finish() -> finish
org.freehep.util.io.FlateOutputStream -> org.freehep.b.b.q:
    void finish() -> finish
org.freehep.util.io.IncompleteTagException -> org.freehep.b.b.r:
    org.freehep.util.io.Tag tag -> a
    byte[] rest -> a
org.freehep.util.io.NoCloseOutputStream -> org.freehep.b.b.s:
    void close() -> close
org.freehep.util.io.Tag -> org.freehep.b.b.t:
    int tagID -> a
    java.lang.String name -> a
    int version -> b
    int getTag() -> b
    java.lang.String getName() -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
org.freehep.util.io.TagHeader -> org.freehep.b.b.u:
    int tagID -> a
    long length -> a
    int getTag() -> b
    long getLength() -> a
org.freehep.util.io.TagSet -> org.freehep.b.b.v:
    java.util.Map tags -> a
    org.freehep.util.io.Tag defaultTag -> a
    void addTag(org.freehep.util.io.Tag) -> a
    org.freehep.util.io.Tag get(int) -> a
    boolean exists(int) -> a
org.freehep.util.io.TaggedInputStream -> org.freehep.b.b.w:
    org.freehep.util.io.TagSet tagSet -> a
    org.freehep.util.io.ActionSet actionSet -> a
    org.freehep.util.io.TagHeader tagHeader -> a
    org.freehep.util.io.TagHeader readTagHeader() -> a
    org.freehep.util.io.Tag readTag() -> a
    org.freehep.util.io.TagHeader getTagHeader() -> b
org.freehep.util.io.TaggedOutputStream -> org.freehep.b.b.x:
    org.freehep.util.io.TagSet tagSet -> a
    org.freehep.util.io.ActionSet actionSet -> a
    void writeTagHeader(org.freehep.util.io.TagHeader) -> a
    int getTagAlignment() -> a
    void writeTag(org.freehep.util.io.Tag) -> a
    org.freehep.util.io.TagHeader createTagHeader(org.freehep.util.io.Tag,long) -> a
org.freehep.util.io.UndefinedTag -> org.freehep.b.b.y:
    int[] bytes -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.util.io.UndefinedTagException -> org.freehep.b.b.z:
org.freehep.util.io.WriterOutputStream -> org.freehep.b.b.A:
    java.io.Writer writer -> a
    void write(int) -> write
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    void close() -> close
    void flush() -> flush
org.freehep.xml.util.XMLWriter -> org.freehep.c.a.a:
    java.lang.String normalizeText(java.lang.String) -> a
org.jfugue.ChannelPressure -> org.b.a:
    byte pressure -> a
    void setPressure(byte) -> a
    byte getPressure() -> a
org.jfugue.Controller -> org.b.b:
    byte index -> a
    byte value -> b
    byte getIndex() -> a
    byte getValue() -> b
org.jfugue.Instrument -> org.b.c:
    byte instrument -> a
    java.lang.String[] INSTRUMENT_NAME -> a
    void setInstrument(byte) -> a
    byte getInstrument() -> a
org.jfugue.JFugueDefinitions -> org.b.d:
    void populateDictionary(java.util.Map) -> a
org.jfugue.JFugueElement -> org.b.e:
org.jfugue.JFugueException -> org.b.f:
org.jfugue.KeySignature -> org.b.g:
    byte keySig -> a
    byte scale -> b
    java.lang.String[] majorSigs -> a
    java.lang.String[] minorSigs -> b
    void setKeySig(byte) -> a
    void setScale(byte) -> b
    byte getKeySig() -> a
    byte getScale() -> b
org.jfugue.Layer -> org.b.h:
    byte layer -> a
    void setLayer(byte) -> a
    byte getLayer() -> a
org.jfugue.Measure -> org.b.i:
org.jfugue.MidiEventManager -> org.b.j:
    int CHANNELS -> a
    int LAYERS -> b
    byte currentTrack -> a
    byte[] currentLayer -> a
    long[][] time -> a
    javax.sound.midi.Sequence sequence -> a
    javax.sound.midi.Track[] track -> a
    void setCurrentTrack(byte) -> a
    void setCurrentLayer(byte) -> b
    void advanceTrackTimer(long) -> a
    void setTrackTimer(long) -> b
    long getTrackTimer() -> a
    void addMetaMessage(int,byte[]) -> a
    void addEvent(int,int) -> a
    void addEvent(int,int,int) -> a
    void addNoteEvent(int,int,int,long,boolean,boolean) -> a
    javax.sound.midi.Sequence getSequence() -> a
org.jfugue.MidiRenderer -> org.b.k:
    org.jfugue.MidiEventManager eventManager -> a
    long initialNoteTime -> a
    float sequenceTiming -> a
    int resolution -> a
    void reset(float,int) -> a
    void reset() -> a
    javax.sound.midi.Sequence getSequence() -> a
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void timeEvent(org.jfugue.Time) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.MusicStringParser -> org.b.l:
    java.util.Map dictionaryMap -> a
    byte keySig -> a
    void parse(org.jfugue.Pattern) -> a
    void parseToken(java.lang.String) -> a
    void parseVoiceElement(java.lang.String) -> b
    void parseTempoElement(java.lang.String) -> c
    void parseInstrumentElement(java.lang.String) -> d
    void parseLayerElement(java.lang.String) -> e
    void parseTimeElement(java.lang.String) -> f
    void parseKeySignatureElement(java.lang.String) -> g
    void parseMeasureElement(java.lang.String) -> h
    void parseControllerElement(java.lang.String) -> i
    void parseChannelPressureElement(java.lang.String) -> j
    void parsePolyPressureElement(java.lang.String) -> k
    void parsePitchBendElement(java.lang.String) -> l
    void parseDictionaryElement(java.lang.String) -> m
    void parseNoteElement(java.lang.String) -> n
    void decideSequentialOrParallel(org.jfugue.MusicStringParser$NoteContext) -> a
    int parseNoteRoot(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> a
    int parseNumericNote(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> b
    int parseRest(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> c
    int parseLetterNote(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> d
    int parseNoteOctave(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> e
    int parseNoteChord(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> f
    void computeNoteValue(org.jfugue.MusicStringParser$NoteContext) -> b
    int parseNoteChordInversion(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> g
    int parseNoteDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> h
    int parseLetterDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> i
    int parseNumericDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> j
    int parseTuplet(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> k
    int parseNoteVelocity(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> l
    java.lang.String parseNoteConnector(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> a
    void fireNoteEvents(org.jfugue.MusicStringParser$NoteContext) -> c
    java.lang.String dictionaryLookup(java.lang.String) -> a
    byte getByteFromDictionary(java.lang.String) -> a
    long getLongFromDictionary(java.lang.String) -> a
    int getIntFromDictionary(java.lang.String) -> a
    double getDoubleFromDictionary(java.lang.String) -> a
org.jfugue.MusicStringParser$NoteContext -> org.b.l$a:
    boolean isRest -> a
    boolean isNumericNote -> b
    boolean isChord -> c
    boolean isFirstNote -> d
    boolean isSequentialNote -> e
    boolean isParallelNote -> f
    boolean isNatural -> g
    boolean existAnotherNote -> h
    boolean anotherNoteIsSequential -> i
    boolean anotherNoteIsParallel -> j
    boolean isStartOfTie -> k
    boolean isEndOfTie -> l
    byte[] halfsteps -> a
    byte numHalfsteps -> a
    byte noteNumber -> b
    int octaveNumber -> a
    double decimalDuration -> a
    long duration -> a
    byte attackVelocity -> c
    byte decayVelocity -> d
    org.jfugue.MusicStringParser this$0 -> a
org.jfugue.Note -> org.b.m:
    byte value -> a
    long duration -> a
    double decimalDuration -> a
    boolean isStartOfTie -> a
    boolean isEndOfTie -> b
    byte attackVelocity -> b
    byte decayVelocity -> c
    boolean rest -> c
    byte type -> d
    boolean accompanyingNotes -> d
    java.lang.String[] NOTES -> a
    void setRest(boolean) -> a
    boolean isRest() -> a
    void setValue(byte) -> a
    byte getValue() -> a
    void setDuration(long) -> a
    long getDuration() -> a
    void setDecimalDuration(double) -> a
    void setStartOfTie(boolean) -> b
    boolean isStartOfTie() -> b
    void setEndOfTie(boolean) -> c
    boolean isEndOfTie() -> c
    void setAttackVelocity(byte) -> b
    byte getAttackVelocity() -> b
    void setDecayVelocity(byte) -> c
    byte getDecayVelocity() -> c
    void setHasAccompanyingNotes(boolean) -> d
    void setType(byte) -> d
org.jfugue.Parser -> org.b.n:
    int tracing -> a
    javax.swing.event.EventListenerList progressListenerList -> a
    javax.swing.event.EventListenerList listenerList -> b
    int getTracing() -> a
    void trace(java.lang.Object[]) -> a
    void fireProgressReported(java.lang.String,long,long) -> a
    void addParserListener(org.jfugue.ParserListener) -> a
    void fireVoiceEvent(org.jfugue.Voice) -> a
    void fireTempoEvent(org.jfugue.Tempo) -> a
    void fireInstrumentEvent(org.jfugue.Instrument) -> a
    void fireLayerEvent(org.jfugue.Layer) -> a
    void fireTimeEvent(org.jfugue.Time) -> a
    void fireKeySignatureEvent(org.jfugue.KeySignature) -> a
    void fireMeasureEvent(org.jfugue.Measure) -> a
    void fireControllerEvent(org.jfugue.Controller) -> a
    void fireChannelPressureEvent(org.jfugue.ChannelPressure) -> a
    void firePolyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void firePitchBendEvent(org.jfugue.PitchBend) -> a
    void fireNoteEvent(org.jfugue.Note) -> a
    void fireSequentialNoteEvent(org.jfugue.Note) -> b
    void fireParallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserListener -> org.b.o:
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void timeEvent(org.jfugue.Time) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserListenerAdapter -> org.b.p:
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void timeEvent(org.jfugue.Time) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserProgressListener -> org.b.q:
    void progressReported(java.lang.String,long,long) -> a
org.jfugue.Pattern -> org.b.r:
    java.lang.StringBuilder musicString -> a
    java.util.Map properties -> a
    javax.swing.event.EventListenerList listenerList -> a
    void setMusicString(java.lang.String) -> a
    java.lang.String getMusicString() -> a
    java.lang.String[] getTokens() -> a
    java.lang.String toString() -> toString
org.jfugue.PitchBend -> org.b.s:
    byte lsb -> a
    byte msb -> b
    void setPitchBend(byte,byte) -> a
    byte[] getBend() -> a
org.jfugue.Player -> org.b.t:
    javax.sound.midi.Sequencer sequencer -> a
    org.jfugue.MusicStringParser parser -> a
    org.jfugue.MidiRenderer renderer -> a
    float sequenceTiming -> a
    int resolution -> a
    boolean paused -> a
    boolean started -> b
    boolean finished -> c
    void initParser() -> b
    void initSequencer() -> c
    void openSequencer() -> d
    void play(org.jfugue.Pattern) -> a
    void play(javax.sound.midi.Sequence) -> a
    void close() -> a
    void setStarted(boolean) -> a
    void setFinished(boolean) -> b
    boolean isPlaying() -> a
    boolean isPaused() -> b
    javax.sound.midi.Sequencer getSequencer() -> a
    void setSequencer(javax.sound.midi.Sequencer) -> a
    javax.sound.midi.Sequence getSequence(org.jfugue.Pattern) -> a
org.jfugue.Player$1 -> org.b.u:
    org.jfugue.Player this$0 -> a
    void meta(javax.sound.midi.MetaMessage) -> meta
org.jfugue.PolyphonicPressure -> org.b.v:
    byte key -> a
    byte pressure -> b
    void setKey(byte) -> a
    void setPressure(byte) -> b
    byte getKey() -> a
    byte getPressure() -> b
org.jfugue.Tempo -> org.b.w:
    int tempo -> a
    void setTempo(int) -> a
    int getTempo() -> a
org.jfugue.Time -> org.b.x:
    long time -> a
    void setTime(long) -> a
    long getTime() -> a
org.jfugue.TimeFactor -> org.b.y:
    double DEFAULT_BPM -> a
    int QUARTER_DURATIONS_IN_WHOLE -> a
    byte[] convertToThreeTempoBytes(int) -> a
    double convertBPMToMicrosecondsPerBeat(int) -> a
org.jfugue.Voice -> org.b.z:
    byte voice -> a
    void setVoice(byte) -> a
    byte getVoice() -> a
org.mathpiper.mpreduce.Environment -> org.c.a.a:
    org.mathpiper.mpreduce.symbols.Symbol nil -> a
    org.mathpiper.mpreduce.symbols.Symbol lispTrue -> b
    org.mathpiper.mpreduce.LispObject[] lit -> a
    java.math.BigInteger bigModulus -> a
    int modulus -> a
    int printprec -> b
    boolean descendSymbols -> a
    boolean specialNil -> b
    org.mathpiper.mpreduce.functions.builtin.Fns1 fns1 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns2 fns2 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns3 fns3 -> a
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions mpreduceFunctions -> a
    org.mathpiper.mpreduce.special.Specfn specfn -> a
org.mathpiper.mpreduce.FlushOutputThread -> org.c.a.b:
    void run() -> run
org.mathpiper.mpreduce.Interpreter2 -> org.c.a.c:
    org.mathpiper.mpreduce.Jlisp jlisp -> a
    org.mathpiper.mpreduce.Interpreter2 JlispCASInstance -> a
    java.lang.String startMessage -> a
    java.lang.Thread reduceThread -> a
    java.lang.String sendString -> b
    java.lang.StringBuffer inputBuffer -> a
    java.lang.Object inputLock -> a
    java.lang.Object outputLock -> b
    java.io.Reader in -> a
    java.io.PrintWriter out -> a
    java.lang.String getStartMessage() -> a
    void initialize() -> a
    java.lang.String evaluate(java.lang.String) -> a
    java.lang.String evaluate(java.lang.String,long) -> a
    void interruptEvaluation() -> b
    void access$0(org.mathpiper.mpreduce.Interpreter2,java.lang.String) -> a
    java.lang.String access$1(org.mathpiper.mpreduce.Interpreter2) -> a
    java.lang.Object access$2(org.mathpiper.mpreduce.Interpreter2) -> a
    java.lang.Object access$3(org.mathpiper.mpreduce.Interpreter2) -> b
    java.lang.StringBuffer access$4(org.mathpiper.mpreduce.Interpreter2) -> a
org.mathpiper.mpreduce.Interpreter2$1 -> org.c.a.d:
    org.mathpiper.mpreduce.Interpreter2 this$0 -> a
    java.lang.String[] val$args -> a
    void run() -> run
org.mathpiper.mpreduce.Interpreter2$InterpreterReader -> org.c.a.c$a:
    org.mathpiper.mpreduce.Interpreter2 interpreter -> a
    int pos -> a
    java.lang.String tmp -> a
    org.mathpiper.mpreduce.Interpreter2 this$0 -> b
    void close() -> close
    boolean markSupported() -> markSupported
    int read() -> read
    int read(char[]) -> read
    int read(char[],int,int) -> read
org.mathpiper.mpreduce.Interpreter2$InterpreterWriter -> org.c.a.c$b:
    org.mathpiper.mpreduce.Interpreter2 this$0 -> a
    void close() -> close
    void flush() -> flush
org.mathpiper.mpreduce.Jlisp -> org.c.a.e:
    java.lang.String version -> d
    org.mathpiper.mpreduce.io.streams.LispStream lispIO -> a
    org.mathpiper.mpreduce.io.streams.LispStream lispErr -> b
    boolean interactivep -> c
    boolean debugFlag -> d
    boolean headline -> e
    boolean backtrace -> f
    org.mathpiper.mpreduce.LispObject errorCode -> a
    int verbosFlag -> c
    boolean trapExceptions -> g
    java.io.Writer transcript -> a
    boolean interruptEvaluation -> h
    org.mathpiper.mpreduce.packagedatastore.PDS[] images -> a
    int outputImagePos -> d
    int imageCount -> e
    java.lang.String[] imageFile -> a
    java.io.Reader in -> a
    java.io.PrintWriter out -> a
    boolean standAlone -> i
    java.util.Vector openOutputFiles -> a
    boolean restarting -> j
    java.lang.String restartModule -> a
    java.lang.String restartFn -> b
    java.lang.String restartArg -> c
    boolean finishingUp -> k
    java.io.OutputStream odump -> a
    java.io.InputStream idump -> a
    java.util.HashMap builtinFunctions -> a
    java.util.HashMap builtinSpecials -> b
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void println() -> a
    void errprint(java.lang.String) -> c
    void errprintln(java.lang.String) -> d
    void errprintln() -> b
    void traceprint(java.lang.String) -> e
    void traceprintln(java.lang.String) -> f
    void traceprintln() -> c
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String,org.mathpiper.mpreduce.LispObject) -> a
    void startup(java.lang.String[],java.io.Reader,java.io.PrintWriter,boolean) -> a
    void startup1(java.lang.String[]) -> a
    void standardStreams() -> d
    void preserve(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    void initfns(java.lang.Object[][]) -> a
    void initSymbols() -> e
    void readEvalPrintLoop(boolean) -> a
    void checkExit(java.lang.String) -> g
org.mathpiper.mpreduce.LispEqualObject -> org.c.a.f:
    org.mathpiper.mpreduce.LispObject value -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.mathpiper.mpreduce.LispObject -> org.c.a.g:
    boolean atom -> a
    org.mathpiper.mpreduce.LispObject car -> a
    org.mathpiper.mpreduce.LispObject cdr -> b
    org.mathpiper.mpreduce.io.streams.LispStream currentOutput -> a
    int currentFlags -> a
    void print() -> a
    void print(int) -> a
    void iprint() -> b
    void blankprint() -> c
    void errPrint() -> d
    void tracePrint() -> e
    void scan() -> f
    void dump() -> g
    void putSharedRef(java.lang.Object) -> a
    void putPrefix2(int,int,int) -> a
    void putPrefix(int,int) -> a
    boolean lispequals(java.lang.Object) -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    org.mathpiper.mpreduce.LispObject copy() -> b
    int lisphashCode() -> a
    double doubleValue() -> a
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject modMinus() -> y
    org.mathpiper.mpreduce.LispObject modRecip() -> z
    org.mathpiper.mpreduce.LispObject safeModRecip() -> A
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    org.mathpiper.mpreduce.LispObject modAdd(org.mathpiper.mpreduce.LispObject) -> p
    org.mathpiper.mpreduce.LispObject modSubtract(org.mathpiper.mpreduce.LispObject) -> q
    org.mathpiper.mpreduce.LispObject modMultiply(org.mathpiper.mpreduce.LispObject) -> r
    org.mathpiper.mpreduce.LispObject modDivide(org.mathpiper.mpreduce.LispObject) -> s
    org.mathpiper.mpreduce.LispObject modExpt(int) -> d
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    org.mathpiper.mpreduce.LispObject modAddSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> p
    org.mathpiper.mpreduce.LispObject modSubtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> q
    org.mathpiper.mpreduce.LispObject modMultiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> r
    org.mathpiper.mpreduce.LispObject modDivideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> s
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    java.lang.String toString() -> toString
org.mathpiper.mpreduce.LispReader -> org.c.a.h:
    int istacklimit -> a
    int[] istack -> a
    int sharedIndex -> b
    java.util.Stack stack -> a
    int sharedSize -> c
    org.mathpiper.mpreduce.LispObject[] shared -> a
    int oblistSize -> d
    int oblistCount -> e
    org.mathpiper.mpreduce.symbols.Symbol[] oblist -> a
    org.mathpiper.mpreduce.datatypes.LispVector obvector -> a
    org.mathpiper.mpreduce.symbols.Symbol[] chars -> b
    org.mathpiper.mpreduce.LispObject[] spine -> b
    int inputType -> f
    java.util.HashSet objects -> a
    java.util.HashMap repeatedObjects -> a
    org.mathpiper.mpreduce.io.streams.LispStream readIn -> a
    org.mathpiper.mpreduce.LispObject readObject() -> a
    org.mathpiper.mpreduce.LispObject read() -> b
    org.mathpiper.mpreduce.LispObject readTail() -> c
    org.mathpiper.mpreduce.LispObject expandBackquote(org.mathpiper.mpreduce.LispObject) -> a
    void preRestore() -> a
    void postRestore() -> b
    void restore(java.io.InputStream) -> a
    boolean isPrime(int) -> a
    void reHashOblist() -> c
    void scanObject(org.mathpiper.mpreduce.LispObject) -> a
    void writeObject(org.mathpiper.mpreduce.LispObject) -> b
    void preserve(java.io.OutputStream) -> a
    void dumpTree(org.mathpiper.mpreduce.LispObject,java.io.OutputStream) -> a
org.mathpiper.mpreduce.Lit -> org.c.a.i:
    java.lang.String[] names -> a
org.mathpiper.mpreduce.Spid -> org.c.a.j:
    int tag -> b
    int data -> c
    org.mathpiper.mpreduce.Spid fbind -> a
    org.mathpiper.mpreduce.Spid noarg -> b
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.Cons -> org.c.a.a.a:
    int consCount -> b
    int consCountDown -> c
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject copy() -> b
    boolean lispequals(java.lang.Object) -> a
    int lisphashCode() -> a
    int lisphashCode(org.mathpiper.mpreduce.LispObject,int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispEqualHash -> org.c.a.a.b:
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object remove(java.lang.Object) -> remove
org.mathpiper.mpreduce.datatypes.LispHash -> org.c.a.a.c:
    java.util.HashMap hash -> a
    int flavour -> b
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispString -> org.c.a.a.d:
    int stringCount -> b
    java.lang.String string -> a
    java.lang.StringBuffer sb -> a
    void iprint() -> b
    java.lang.String escapedPrint() -> a
    void blankprint() -> c
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispVector -> org.c.a.a.e:
    org.mathpiper.mpreduce.LispObject[] vec -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    boolean lispequals(java.lang.Object) -> a
    int lisphashCode() -> a
    int lisphashCode(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.exceptions.EOFException -> org.c.a.b.a:
org.mathpiper.mpreduce.exceptions.LispException -> org.c.a.b.b:
    org.mathpiper.mpreduce.LispObject details -> a
    java.lang.String message -> a
org.mathpiper.mpreduce.exceptions.ProgEvent -> org.c.a.b.c:
    org.mathpiper.mpreduce.LispObject details -> b
    org.mathpiper.mpreduce.LispObject extras -> c
    java.lang.String message -> b
    int type -> a
org.mathpiper.mpreduce.exceptions.ResourceException -> org.c.a.b.d:
    int time_base -> a
    int space_base -> b
    int io_base -> c
    int errors_base -> d
    int time_now -> e
    int space_now -> f
    int io_now -> g
    int errors_now -> h
    int time_limit -> i
    int space_limit -> j
    int io_limit -> k
    int errors_limit -> l
org.mathpiper.mpreduce.functions.builtin.BuiltinFunction -> org.c.a.c.a.a:
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.builtin.Fns -> org.c.a.c.a.b:
    java.lang.String prompt -> a
    org.mathpiper.mpreduce.LispObject[] args -> a
    org.mathpiper.mpreduce.LispObject put(org.mathpiper.mpreduce.symbols.Symbol,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    void fluid(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject get(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject remprop(org.mathpiper.mpreduce.symbols.Symbol,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject reversip(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject lessp(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject apply0(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject apply1(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject apply2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject apply3(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject applyn(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject applyInner(org.mathpiper.mpreduce.LispObject,int) -> a
    java.lang.String explodeToString(org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1 -> org.c.a.c.a.c:
    java.lang.Object[][] builtins -> a
    org.mathpiper.mpreduce.LispObject lispZero -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AconsFn -> org.c.a.c.a.c$a:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AppendFn -> org.c.a.c.a.c$b:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply0Fn -> org.c.a.c.a.c$c:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply1Fn -> org.c.a.c.a.c$d:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply2Fn -> org.c.a.c.a.c$e:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply3Fn -> org.c.a.c.a.c$f:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ApplyFn -> org.c.a.c.a.c$g:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject applySub(org.mathpiper.mpreduce.LispObject,int,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AssocFn -> org.c.a.c.a.c$h:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AssocStarStarFn -> org.c.a.c.a.c$i:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AtomFn -> org.c.a.c.a.c$j:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$AtsocFn -> org.c.a.c.a.c$k:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$BatchpFn -> org.c.a.c.a.c$l:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_close_inputFn -> org.c.a.c.a.c$m:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_close_outputFn -> org.c.a.c.a.c$n:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_open_inputFn -> org.c.a.c.a.c$o:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_open_outputFn -> org.c.a.c.a.c$p:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin1Fn -> org.c.a.c.a.c$q:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin2Fn -> org.c.a.c.a.c$r:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin3Fn -> org.c.a.c.a.c$s:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prinbyteFn -> org.c.a.c.a.c$t:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_princFn -> org.c.a.c.a.c$u:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prinfloatFn -> org.c.a.c.a.c$v:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read2Fn -> org.c.a.c.a.c$w:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read3Fn -> org.c.a.c.a.c$x:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read4Fn -> org.c.a.c.a.c$y:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_readbyteFn -> org.c.a.c.a.c$z:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_readfloatFn -> org.c.a.c.a.c$A:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_select_inputFn -> org.c.a.c.a.c$B:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_terpriFn -> org.c.a.c.a.c$C:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BinopenFn -> org.c.a.c.a.c$D:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BoundpFn -> org.c.a.c.a.c$E:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_getvFn -> org.c.a.c.a.c$F:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_putvFn -> org.c.a.c.a.c$G:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_upbvFn -> org.c.a.c.a.c$H:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BpspFn -> org.c.a.c.a.c$I:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Break_loopFn -> org.c.a.c.a.c$J:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Byte_getvFn -> org.c.a.c.a.c$K:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$BytecountsFn -> org.c.a.c.a.c$L:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$C_outFn -> org.c.a.c.a.c$M:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaaarFn -> org.c.a.c.a.c$N:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaadrFn -> org.c.a.c.a.c$O:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaarFn -> org.c.a.c.a.c$P:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaadarFn -> org.c.a.c.a.c$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaddrFn -> org.c.a.c.a.c$R:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaadrFn -> org.c.a.c.a.c$S:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaarFn -> org.c.a.c.a.c$T:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadaarFn -> org.c.a.c.a.c$U:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadadrFn -> org.c.a.c.a.c$V:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadarFn -> org.c.a.c.a.c$W:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaddarFn -> org.c.a.c.a.c$X:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadddrFn -> org.c.a.c.a.c$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaddrFn -> org.c.a.c.a.c$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadrFn -> org.c.a.c.a.c$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarFn -> org.c.a.c.a.c$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarStarFn -> org.c.a.c.a.c$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarcheckFn -> org.c.a.c.a.c$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CatchFn -> org.c.a.c.a.c$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CbrtFn -> org.c.a.c.a.c$af:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaaarFn -> org.c.a.c.a.c$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaadrFn -> org.c.a.c.a.c$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaarFn -> org.c.a.c.a.c$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdadarFn -> org.c.a.c.a.c$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaddrFn -> org.c.a.c.a.c$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdadrFn -> org.c.a.c.a.c$al:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdarFn -> org.c.a.c.a.c$am:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddaarFn -> org.c.a.c.a.c$an:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddadrFn -> org.c.a.c.a.c$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddarFn -> org.c.a.c.a.c$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdddarFn -> org.c.a.c.a.c$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddddrFn -> org.c.a.c.a.c$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdddrFn -> org.c.a.c.a.c$as:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddrFn -> org.c.a.c.a.c$at:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdrFn -> org.c.a.c.a.c$au:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_codeFn -> org.c.a.c.a.c$av:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_downcaseFn -> org.c.a.c.a.c$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_upcaseFn -> org.c.a.c.a.c$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ChdirFn -> org.c.a.c.a.c$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CheckpointFn -> org.c.a.c.a.c$az:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Cl_equalFn -> org.c.a.c.a.c$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CloseFn -> org.c.a.c.a.c$aB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Close_libraryFn -> org.c.a.c.a.c$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ClrhashFn -> org.c.a.c.a.c$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Code_charFn -> org.c.a.c.a.c$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CodepFn -> org.c.a.c.a.c$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CompressFn -> org.c.a.c.a.c$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ConsFn -> org.c.a.c.a.c$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ConspFn -> org.c.a.c.a.c$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ConstantpFn -> org.c.a.c.a.c$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ContainedFn -> org.c.a.c.a.c$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Convert_to_evectorFn -> org.c.a.c.a.c$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CopyFn -> org.c.a.c.a.c$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Copy_moduleFn -> org.c.a.c.a.c$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Create_directoryFn -> org.c.a.c.a.c$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DateFn -> org.c.a.c.a.c$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Dated_nameFn -> org.c.a.c.a.c$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DatelesspFn -> org.c.a.c.a.c$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$DatestampFn -> org.c.a.c.a.c$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Define_in_moduleFn -> org.c.a.c.a.c$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DeflistFn -> org.c.a.c.a.c$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DeleqFn -> org.c.a.c.a.c$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$DeleteFn -> org.c.a.c.a.c$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Delete_fileFn -> org.c.a.c.a.c$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Delete_moduleFn -> org.c.a.c.a.c$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Demo_modeFn -> org.c.a.c.a.c$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$DigitFn -> org.c.a.c.a.c$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DirectorypFn -> org.c.a.c.a.c$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DmFn -> org.c.a.c.a.c$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DoFn -> org.c.a.c.a.c$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DoStarFn -> org.c.a.c.a.c$be:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DolistFn -> org.c.a.c.a.c$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DotimesFn -> org.c.a.c.a.c$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Double_executeFn -> org.c.a.c.a.c$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EgetvFn -> org.c.a.c.a.c$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EjectFn -> org.c.a.c.a.c$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Enable_backtraceFn -> org.c.a.c.a.c$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Enable_errorsetFn -> org.c.a.c.a.c$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EndpFn -> org.c.a.c.a.c$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EputvFn -> org.c.a.c.a.c$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqFn -> org.c.a.c.a.c$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqcarFn -> org.c.a.c.a.c$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqlFn -> org.c.a.c.a.c$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqlhashFn -> org.c.a.c.a.c$br:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualFn -> org.c.a.c.a.c$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualcarFn -> org.c.a.c.a.c$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualpFn -> org.c.a.c.a.c$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Error1Fn -> org.c.a.c.a.c$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ErrorFn -> org.c.a.c.a.c$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ErrorsetFn -> org.c.a.c.a.c$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EupbvFn -> org.c.a.c.a.c$by:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvalFn -> org.c.a.c.a.c$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Eval_whenFn -> org.c.a.c.a.c$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvectorpFn -> org.c.a.c.a.c$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvlisFn -> org.c.a.c.a.c$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExpandFn -> org.c.a.c.a.c$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2Fn -> org.c.a.c.a.c$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2lcFn -> org.c.a.c.a.c$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2lcnFn -> org.c.a.c.a.c$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2nFn -> org.c.a.c.a.c$bH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2ucFn -> org.c.a.c.a.c$bI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2ucnFn -> org.c.a.c.a.c$bJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodeFn -> org.c.a.c.a.c$bK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodebinaryFn -> org.c.a.c.a.c$bL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodecFn -> org.c.a.c.a.c$bM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodecnFn -> org.c.a.c.a.c$bN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodehexFn -> org.c.a.c.a.c$bO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodenFn -> org.c.a.c.a.c$bP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodeoctalFn -> org.c.a.c.a.c$bQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodetostringFn -> org.c.a.c.a.c$bR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fetch_urlFn -> org.c.a.c.a.c$bS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fgetv32Fn -> org.c.a.c.a.c$bT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fgetv64Fn -> org.c.a.c.a.c$bU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$File_readablepFn -> org.c.a.c.a.c$bV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$File_writeablepFn -> org.c.a.c.a.c$bW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FiledateFn -> org.c.a.c.a.c$bX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FilepFn -> org.c.a.c.a.c$bY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagFn -> org.c.a.c.a.c$bZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpFn -> org.c.a.c.a.c$ca:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpStarStarFn -> org.c.a.c.a.c$cb:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpcarFn -> org.c.a.c.a.c$cc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FluidFn -> org.c.a.c.a.c$cd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FluidpFn -> org.c.a.c.a.c$ce:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FlushFn -> org.c.a.c.a.c$cf:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FormatFn -> org.c.a.c.a.c$cg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fp_evaluateFn -> org.c.a.c.a.c$ch:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fputv32Fn -> org.c.a.c.a.c$ci:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fputv64Fn -> org.c.a.c.a.c$cj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FuncallFn -> org.c.a.c.a.c$ck:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GctimeFn -> org.c.a.c.a.c$cl:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Gensym1Fn -> org.c.a.c.a.c$cm:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Gensym2Fn -> org.c.a.c.a.c$cn:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GensymFn -> org.c.a.c.a.c$co:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$GensympFn -> org.c.a.c.a.c$cp:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetFn -> org.c.a.c.a.c$cq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GetStarFn -> org.c.a.c.a.c$cr:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Get_current_directoryFn -> org.c.a.c.a.c$cs:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Get_lisp_directoryFn -> org.c.a.c.a.c$ct:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetdFn -> org.c.a.c.a.c$cu:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetenvFn -> org.c.a.c.a.c$cv:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GethashFn -> org.c.a.c.a.c$cw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv16Fn -> org.c.a.c.a.c$cx:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv32Fn -> org.c.a.c.a.c$cy:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv8Fn -> org.c.a.c.a.c$cz:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetvFn -> org.c.a.c.a.c$cA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GlobalFn -> org.c.a.c.a.c$cB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GlobalpFn -> org.c.a.c.a.c$cC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Hash_table_pFn -> org.c.a.c.a.c$cD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$HashcontentsFn -> org.c.a.c.a.c$cE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Hashtagged_nameFn -> org.c.a.c.a.c$cF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$HelpFn -> org.c.a.c.a.c$cG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IdpFn -> org.c.a.c.a.c$cH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IndirectFn -> org.c.a.c.a.c$cI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$InormFn -> org.c.a.c.a.c$cJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Input_librariesFn -> org.c.a.c.a.c$cK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$InternFn -> org.c.a.c.a.c$cL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IntersectionFn -> org.c.a.c.a.c$cM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Is_consoleFn -> org.c.a.c.a.c$cN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastFn -> org.c.a.c.a.c$cO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastcarFn -> org.c.a.c.a.c$cP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastpairFn -> org.c.a.c.a.c$cQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LengthFn -> org.c.a.c.a.c$cR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LengthcFn -> org.c.a.c.a.c$cS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Library_membersFn -> org.c.a.c.a.c$cT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Library_nameFn -> org.c.a.c.a.c$cU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LinelengthFn -> org.c.a.c.a.c$cV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List2Fn -> org.c.a.c.a.c$cW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List2StarFn -> org.c.a.c.a.c$cX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List3Fn -> org.c.a.c.a.c$cY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ListFn -> org.c.a.c.a.c$cZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ListStarFn -> org.c.a.c.a.c$da:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List_directoryFn -> org.c.a.c.a.c$db:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_modulesFn -> org.c.a.c.a.c$dc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_stringFn -> org.c.a.c.a.c$dd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_symbolFn -> org.c.a.c.a.c$de:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_vectorFn -> org.c.a.c.a.c$df:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ResourceExceededFn -> org.c.a.c.a.c$dg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$ResourceLimitFn -> org.c.a.c.a.c$dh:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$TimeofdayFn -> org.c.a.c.a.c$di:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns2 -> org.c.a.c.a.d:
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AbsFn -> org.c.a.c.a.d$a:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcosFn -> org.c.a.c.a.d$b:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcosdFn -> org.c.a.c.a.d$c:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcoshFn -> org.c.a.c.a.d$d:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcotFn -> org.c.a.c.a.d$e:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcotdFn -> org.c.a.c.a.d$f:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcothFn -> org.c.a.c.a.d$g:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcscFn -> org.c.a.c.a.d$h:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcscdFn -> org.c.a.c.a.d$i:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcschFn -> org.c.a.c.a.d$j:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Add1Fn -> org.c.a.c.a.d$k:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsecFn -> org.c.a.c.a.d$l:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsecdFn -> org.c.a.c.a.d$m:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsechFn -> org.c.a.c.a.d$n:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Ash1Fn -> org.c.a.c.a.d$o:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AshFn -> org.c.a.c.a.d$p:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AsinFn -> org.c.a.c.a.d$q:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsindFn -> org.c.a.c.a.d$r:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsinhFn -> org.c.a.c.a.d$s:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Atan2Fn -> org.c.a.c.a.d$t:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Atan2dFn -> org.c.a.c.a.d$u:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AtanFn -> org.c.a.c.a.d$v:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AtandFn -> org.c.a.c.a.d$w:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AtanhFn -> org.c.a.c.a.d$x:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CeilingFn -> org.c.a.c.a.d$y:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CosFn -> org.c.a.c.a.d$z:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CosdFn -> org.c.a.c.a.d$A:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CoshFn -> org.c.a.c.a.d$B:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CotFn -> org.c.a.c.a.d$C:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CotdFn -> org.c.a.c.a.d$D:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CothFn -> org.c.a.c.a.d$E:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CscFn -> org.c.a.c.a.d$F:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CscdFn -> org.c.a.c.a.d$G:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CschFn -> org.c.a.c.a.d$H:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$DifferenceFn -> org.c.a.c.a.d$I:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$DivideFn -> org.c.a.c.a.d$J:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$EqSafeFn -> org.c.a.c.a.d$K:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$EqnFn -> org.c.a.c.a.d$L:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$EvenpFn -> org.c.a.c.a.d$M:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ExpFn -> org.c.a.c.a.d$N:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ExptFn -> org.c.a.c.a.d$O:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$FixFn -> org.c.a.c.a.d$P:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FixpFn -> org.c.a.c.a.d$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloatFn -> org.c.a.c.a.d$R:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloatpFn -> org.c.a.c.a.d$S:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloorFn -> org.c.a.c.a.d$T:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FrexpFn -> org.c.a.c.a.d$U:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$GcdnFn -> org.c.a.c.a.d$V:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$GeqFn -> org.c.a.c.a.d$W:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$GreaterpFn -> org.c.a.c.a.d$X:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$HypotFn -> org.c.a.c.a.d$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Iadd1Fn -> org.c.a.c.a.d$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IdifferenceFn -> org.c.a.c.a.d$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IgeqFn -> org.c.a.c.a.d$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IgreaterpFn -> org.c.a.c.a.d$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IleqFn -> org.c.a.c.a.d$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlesspFn -> org.c.a.c.a.d$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogandFn -> org.c.a.c.a.d$af:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogorFn -> org.c.a.c.a.d$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogxorFn -> org.c.a.c.a.d$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ImaxFn -> org.c.a.c.a.d$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IminFn -> org.c.a.c.a.d$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IminusFn -> org.c.a.c.a.d$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IminuspFn -> org.c.a.c.a.d$al:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IntegerpFn -> org.c.a.c.a.d$am:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IonepFn -> org.c.a.c.a.d$an:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Iplus2Fn -> org.c.a.c.a.d$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IplusFn -> org.c.a.c.a.d$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IquotientFn -> org.c.a.c.a.d$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IremainderFn -> org.c.a.c.a.d$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IrightshiftFn -> org.c.a.c.a.d$as:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Isub1Fn -> org.c.a.c.a.d$at:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Itimes2Fn -> org.c.a.c.a.d$au:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ItimesFn -> org.c.a.c.a.d$av:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IzeropFn -> org.c.a.c.a.d$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LcmnFn -> org.c.a.c.a.d$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LeqFn -> org.c.a.c.a.d$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LesspFn -> org.c.a.c.a.d$az:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LnFn -> org.c.a.c.a.d$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Log10Fn -> org.c.a.c.a.d$aB:
    double log10 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LogFn -> org.c.a.c.a.d$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogandFn -> org.c.a.c.a.d$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogbFn -> org.c.a.c.a.d$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogeqvFn -> org.c.a.c.a.d$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LognotFn -> org.c.a.c.a.d$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LogorFn -> org.c.a.c.a.d$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogxorFn -> org.c.a.c.a.d$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Lose_precisionFn -> org.c.a.c.a.d$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LsdFn -> org.c.a.c.a.d$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Max2Fn -> org.c.a.c.a.d$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MaxFn -> org.c.a.c.a.d$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Min2Fn -> org.c.a.c.a.d$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MinFn -> org.c.a.c.a.d$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MinusFn -> org.c.a.c.a.d$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$MinuspFn -> org.c.a.c.a.d$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ModFn -> org.c.a.c.a.d$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_differenceFn -> org.c.a.c.a.d$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_exptFn -> org.c.a.c.a.d$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_minusFn -> org.c.a.c.a.d$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_numberFn -> org.c.a.c.a.d$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_plusFn -> org.c.a.c.a.d$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_quotientFn -> org.c.a.c.a.d$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_reciprocalFn -> org.c.a.c.a.d$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_timesFn -> org.c.a.c.a.d$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MsdFn -> org.c.a.c.a.d$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$NumberpFn -> org.c.a.c.a.d$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$OddpFn -> org.c.a.c.a.d$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$OnepFn -> org.c.a.c.a.d$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Plus2Fn -> org.c.a.c.a.d$be:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$PlusFn -> org.c.a.c.a.d$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$PluspFn -> org.c.a.c.a.d$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$QuotientFn -> org.c.a.c.a.d$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Random_fixnumFn -> org.c.a.c.a.d$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Random_numberFn -> org.c.a.c.a.d$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$RationalFn -> org.c.a.c.a.d$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$RemainderFn -> org.c.a.c.a.d$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$RoundFn -> org.c.a.c.a.d$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_plusFn -> org.c.a.c.a.d$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_quotFn -> org.c.a.c.a.d$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_timesFn -> org.c.a.c.a.d$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_modular_reciprocalFn -> org.c.a.c.a.d$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SecFn -> org.c.a.c.a.d$br:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SecdFn -> org.c.a.c.a.d$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SechFn -> org.c.a.c.a.d$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Set_small_modulusFn -> org.c.a.c.a.d$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SinFn -> org.c.a.c.a.d$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SindFn -> org.c.a.c.a.d$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SinhFn -> org.c.a.c.a.d$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SqrtFn -> org.c.a.c.a.d$by:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Sub1Fn -> org.c.a.c.a.d$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TanFn -> org.c.a.c.a.d$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TandFn -> org.c.a.c.a.d$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TanhFn -> org.c.a.c.a.d$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Times2Fn -> org.c.a.c.a.d$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$TimesFn -> org.c.a.c.a.d$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$TruncateFn -> org.c.a.c.a.d$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ZeropFn -> org.c.a.c.a.d$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3 -> org.c.a.c.a.e:
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Get_print_precisionFn -> org.c.a.c.a.e$a:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$InternalOpenFn -> org.c.a.c.a.e$b:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject openPipe(java.lang.String,int) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$LiterFn -> org.c.a.c.a.e$c:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Load_moduleFn -> org.c.a.c.a.e$d:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$LposnFn -> org.c.a.c.a.e$e:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Macro_functionFn -> org.c.a.c.a.e$f:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MacroexpandFn -> org.c.a.c.a.e$g:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Macroexpand_1Fn -> org.c.a.c.a.e$h:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_bpsFn -> org.c.a.c.a.e$i:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_function_streamFn -> org.c.a.c.a.e$j:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_globalFn -> org.c.a.c.a.e$k:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_nativeFn -> org.c.a.c.a.e$l:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_random_stateFn -> org.c.a.c.a.e$m:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_simple_stringFn -> org.c.a.c.a.e$n:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_specialFn -> org.c.a.c.a.e$o:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapFn -> org.c.a.c.a.e$p:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcFn -> org.c.a.c.a.e$q:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcanFn -> org.c.a.c.a.e$r:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcarFn -> org.c.a.c.a.e$s:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapconFn -> org.c.a.c.a.e$t:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MaphashFn -> org.c.a.c.a.e$u:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MaplistFn -> org.c.a.c.a.e$v:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapstoreFn -> org.c.a.c.a.e$w:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Md5Fn -> org.c.a.c.a.e$x:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Md60Fn -> org.c.a.c.a.e$y:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MemberFn -> org.c.a.c.a.e$z:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MemberStarStarFn -> org.c.a.c.a.e$A:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MemqFn -> org.c.a.c.a.e$B:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MkevectFn -> org.c.a.c.a.e$C:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkfvect32Fn -> org.c.a.c.a.e$D:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkfvect64Fn -> org.c.a.c.a.e$E:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkhashFn -> org.c.a.c.a.e$F:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MkquoteFn -> org.c.a.c.a.e$G:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect16Fn -> org.c.a.c.a.e$H:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect32Fn -> org.c.a.c.a.e$I:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect8Fn -> org.c.a.c.a.e$J:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkvectFn -> org.c.a.c.a.e$K:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkxvectFn -> org.c.a.c.a.e$L:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ModulepFn -> org.c.a.c.a.e$M:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_addressFn -> org.c.a.c.a.e$N:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_getvFn -> org.c.a.c.a.e$O:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_putvFn -> org.c.a.c.a.e$P:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_typeFn -> org.c.a.c.a.e$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NconcFn -> org.c.a.c.a.e$R:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$NconsFn -> org.c.a.c.a.e$S:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NeqFn -> org.c.a.c.a.e$T:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Noisy_setqFn -> org.c.a.c.a.e$U:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NotFn -> org.c.a.c.a.e$V:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NullFn -> org.c.a.c.a.e$W:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OblistFn -> org.c.a.c.a.e$X:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$Oem_supervisorFn -> org.c.a.c.a.e$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OpenFn -> org.c.a.c.a.e$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Open_libraryFn -> org.c.a.c.a.e$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Open_urlFn -> org.c.a.c.a.e$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OrderpFn -> org.c.a.c.a.e$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    boolean ordp(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    boolean ordv(org.mathpiper.mpreduce.datatypes.LispVector,org.mathpiper.mpreduce.datatypes.LispVector) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Output_libraryFn -> org.c.a.c.a.e$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PagelengthFn -> org.c.a.c.a.e$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PairFn -> org.c.a.c.a.e$af:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PairpFn -> org.c.a.c.a.e$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PeekchFn -> org.c.a.c.a.e$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Pipe_openFn -> org.c.a.c.a.e$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PlistFn -> org.c.a.c.a.e$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PosnFn -> org.c.a.c.a.e$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$PreserveFn -> org.c.a.c.a.e$al:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin1Fn -> org.c.a.c.a.e$am:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin2Fn -> org.c.a.c.a.e$an:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin2aFn -> org.c.a.c.a.e$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinFn -> org.c.a.c.a.e$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinbinaryFn -> org.c.a.c.a.e$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrincFn -> org.c.a.c.a.e$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Princ_downcaseFn -> org.c.a.c.a.e$as:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Princ_upcaseFn -> org.c.a.c.a.e$at:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinhexFn -> org.c.a.c.a.e$au:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinoctalFn -> org.c.a.c.a.e$av:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintFn -> org.c.a.c.a.e$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintcFn -> org.c.a.c.a.e$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintpromptFn -> org.c.a.c.a.e$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prog1Fn -> org.c.a.c.a.e$az:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Prog2Fn -> org.c.a.c.a.e$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PrognFn -> org.c.a.c.a.e$aB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PutFn -> org.c.a.c.a.e$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PuthashFn -> org.c.a.c.a.e$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv16Fn -> org.c.a.c.a.e$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv32Fn -> org.c.a.c.a.e$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv8Fn -> org.c.a.c.a.e$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PutvFn -> org.c.a.c.a.e$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv_charFn -> org.c.a.c.a.e$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$QcaarFn -> org.c.a.c.a.e$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcadrFn -> org.c.a.c.a.e$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcarFn -> org.c.a.c.a.e$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcdarFn -> org.c.a.c.a.e$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcddrFn -> org.c.a.c.a.e$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcdrFn -> org.c.a.c.a.e$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QgetvFn -> org.c.a.c.a.e$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$QputvFn -> org.c.a.c.a.e$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RassocFn -> org.c.a.c.a.e$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RdfFn -> org.c.a.c.a.e$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RdsFn -> org.c.a.c.a.e$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadFn -> org.c.a.c.a.e$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadchFn -> org.c.a.c.a.e$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadlineFn -> org.c.a.c.a.e$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReclaimFn -> org.c.a.c.a.e$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RemdFn -> org.c.a.c.a.e$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RemflagFn -> org.c.a.c.a.e$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RemhashFn -> org.c.a.c.a.e$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RemobFn -> org.c.a.c.a.e$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RempropFn -> org.c.a.c.a.e$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Rename_fileFn -> org.c.a.c.a.e$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RepresentationFn -> org.c.a.c.a.e$be:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RestartFn -> org.c.a.c.a.e$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RestoreObjectFn -> org.c.a.c.a.e$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$ReturnFn -> org.c.a.c.a.e$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReverseFn -> org.c.a.c.a.e$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReversipFn -> org.c.a.c.a.e$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacaFn -> org.c.a.c.a.e$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacdFn -> org.c.a.c.a.e$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacwFn -> org.c.a.c.a.e$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RseekFn -> org.c.a.c.a.e$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RtellFn -> org.c.a.c.a.e$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SampleFn -> org.c.a.c.a.e$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SassocFn -> org.c.a.c.a.e$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SaveObjectFn -> org.c.a.c.a.e$br:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$ScharFn -> org.c.a.c.a.e$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SeprpFn -> org.c.a.c.a.e$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SetFn -> org.c.a.c.a.e$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_autoloadFn -> org.c.a.c.a.e$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_help_fileFn -> org.c.a.c.a.e$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_print_precisionFn -> org.c.a.c.a.e$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SetpcharFn -> org.c.a.c.a.e$by:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Simple_string_pFn -> org.c.a.c.a.e$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Simple_vector_pFn -> org.c.a.c.a.e$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SmemqFn -> org.c.a.c.a.e$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SpacesFn -> org.c.a.c.a.e$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Special_charFn -> org.c.a.c.a.e$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Special_form_pFn -> org.c.a.c.a.e$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SpoolFn -> org.c.a.c.a.e$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Start_moduleFn -> org.c.a.c.a.e$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Startup_bannerFn -> org.c.a.c.a.e$bH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StopFn -> org.c.a.c.a.e$bI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StreampFn -> org.c.a.c.a.e$bJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StringpFn -> org.c.a.c.a.e$bK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Stub1Fn -> org.c.a.c.a.e$bL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Stub2Fn -> org.c.a.c.a.e$bM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SublaFn -> org.c.a.c.a.e$bN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SublisFn -> org.c.a.c.a.e$bO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SubstFn -> org.c.a.c.a.e$bP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject subst(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SubstqFn -> org.c.a.c.a.e$bQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject substq(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SxhashFn -> org.c.a.c.a.e$bR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_argcountFn -> org.c.a.c.a.e$bS:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_envFn -> org.c.a.c.a.e$bT:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_fastgetsFn -> org.c.a.c.a.e$bU:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_fn_cellFn -> org.c.a.c.a.e$bV:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_functionFn -> org.c.a.c.a.e$bW:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_make_fastgetFn -> org.c.a.c.a.e$bX:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_nameFn -> org.c.a.c.a.e$bY:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_protectFn -> org.c.a.c.a.e$bZ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_definitionFn -> org.c.a.c.a.e$ca:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_envFn -> org.c.a.c.a.e$cb:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_nativeFn -> org.c.a.c.a.e$cc:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_valueFn -> org.c.a.c.a.e$cd:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SymbolpFn -> org.c.a.c.a.e$ce:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SymerrFn -> org.c.a.c.a.e$cf:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SystemFn -> org.c.a.c.a.e$cg:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TagbodyFn -> org.c.a.c.a.e$ch:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TerpriFn -> org.c.a.c.a.e$ci:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ThreevectorpFn -> org.c.a.c.a.e$cj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ThrowFn -> org.c.a.c.a.e$ck:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TimeFn -> org.c.a.c.a.e$cl:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$TmpnamFn -> org.c.a.c.a.e$cm:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TraceFn -> org.c.a.c.a.e$cn:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Traceset1Fn -> org.c.a.c.a.e$co:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TracesetFn -> org.c.a.c.a.e$cp:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TtabFn -> org.c.a.c.a.e$cq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TyiFn -> org.c.a.c.a.e$cr:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TyoFn -> org.c.a.c.a.e$cs:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Undouble_executeFn -> org.c.a.c.a.e$ct:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnfluidFn -> org.c.a.c.a.e$cu:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnglobalFn -> org.c.a.c.a.e$cv:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnionFn -> org.c.a.c.a.e$cw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Unmake_globalFn -> org.c.a.c.a.e$cx:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Unmake_specialFn -> org.c.a.c.a.e$cy:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnreadchFn -> org.c.a.c.a.e$cz:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UntraceFn -> org.c.a.c.a.e$cA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Untraceset1Fn -> org.c.a.c.a.e$cB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UntracesetFn -> org.c.a.c.a.e$cC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Unwind_protectFn -> org.c.a.c.a.e$cD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UpbvFn -> org.c.a.c.a.e$cE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$User_homedir_pathnameFn -> org.c.a.c.a.e$cF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$VectorpFn -> org.c.a.c.a.e$cG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$VerbosFn -> org.c.a.c.a.e$cH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Where_was_thatFn -> org.c.a.c.a.e$cI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$Window_headingFn -> org.c.a.c.a.e$cJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Writable_librarypFn -> org.c.a.c.a.e$cK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Write_help_moduleFn -> org.c.a.c.a.e$cL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Write_moduleFn -> org.c.a.c.a.e$cM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$WrsFn -> org.c.a.c.a.e$cN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XassocFn -> org.c.a.c.a.e$cO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XconsFn -> org.c.a.c.a.e$cP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$XdifferenceFn -> org.c.a.c.a.e$cQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XtabFn -> org.c.a.c.a.e$cR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions -> org.c.a.c.a.f:
    boolean inEvaluationMode -> a
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions$EvaluatingClearFn -> org.c.a.c.a.f$a:
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions$EvaluatingSetFn -> org.c.a.c.a.f$b:
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.MyMath -> org.c.a.c.a.g:
    double acosh(double) -> a
    double acoth(double) -> b
    double acsch(double) -> c
    double asech(double) -> d
    double asinh(double) -> e
    double atanh(double) -> f
    double cosh(double) -> g
    double coth(double) -> h
    double csch(double) -> i
    double sech(double) -> j
    double sinh(double) -> k
    double tanh(double) -> l
org.mathpiper.mpreduce.functions.functionwithenvironment.ByteOpt -> org.c.a.c.b.a:
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.functionwithenvironment.Bytecode -> org.c.a.c.b.b:
    java.lang.StringBuffer sb -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin0 -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin1 -> b
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin2 -> c
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin3 -> d
    int BIbatchp -> b
    int BIdate -> c
    int BIeject -> d
    int BIerror1 -> e
    int BIgctime -> f
    int BIgensym -> g
    int BIlposn -> h
    int BIposn -> i
    int BIread -> j
    int BIreadch -> k
    int BIterpri -> l
    int BItime -> m
    int BIabs -> n
    int BIadd1 -> o
    int BIatan -> p
    int BIapply0 -> q
    int BIatom -> r
    int BIboundp -> s
    int BIchar_code -> t
    int BIclose -> u
    int BIcodep -> v
    int BIcompress -> w
    int BIconstantp -> x
    int BIdigit -> y
    int BIendp -> z
    int BIeval -> A
    int BIevenp -> B
    int BIevlis -> C
    int BIexplode -> D
    int BIexplode2lc -> E
    int BIexplode2 -> F
    int BIexplodec -> G
    int BIfixp -> H
    int BIfloat -> I
    int BIfloatp -> J
    int BIgensym1 -> K
    int BIgetenv -> L
    int BIiadd1 -> M
    int BIsymbolp -> N
    int BIiminus -> O
    int BIiminusp -> P
    int BIindirect -> Q
    int BIintegerp -> R
    int BIintern -> S
    int BIisub1 -> T
    int BIlength -> U
    int BIlengthc -> V
    int BIlinelength -> W
    int BIliter -> X
    int BIload_module -> Y
    int BIlognot -> Z
    int BImacroexpand -> aa
    int BImacroexpand_1 -> ab
    int BImacro_function -> ac
    int BImake_bps -> ad
    int BImake_global -> ae
    int BImake_simple_string -> af
    int BImake_special -> ag
    int BIminus -> ah
    int BIminusp -> ai
    int BImkvect -> aj
    int BImodular_minus -> ak
    int BImodular_number -> al
    int BImodular_reciprocal -> am
    int BInull -> an
    int BIoddp -> ao
    int BIonep -> ap
    int BIpagelength -> aq
    int BIpairp -> ar
    int BIplist -> as
    int BIplusp -> at
    int BIprin -> au
    int BIprinc -> av
    int BIprint -> aw
    int BIprintc -> ax
    int BIrational -> ay
    int BIrds -> az
    int BIremd -> aA
    int BIreverse -> aB
    int BIreversip -> aC
    int BIreversip2 -> aD
    int BIseprp -> aE
    int BIset_small_modulus -> aF
    int BIspaces -> aG
    int BIxtab -> aH
    int BIspecial_char -> aI
    int BIspecial_form_p -> aJ
    int BIspool -> aK
    int BIstop -> aL
    int BIstringp -> aM
    int BIsub1 -> aN
    int BIsymbol_env -> aO
    int BIsymbol_function -> aP
    int BIsymbol_name -> aQ
    int BIsymbol_value -> aR
    int BIsystem -> aS
    int BIfix -> aT
    int BIttab -> aU
    int BItyo -> aV
    int BIremob -> aW
    int BIunmake_global -> aX
    int BIunmake_special -> aY
    int BIupbv -> aZ
    int BIvectorp -> ba
    int BIverbos -> bb
    int BIwrs -> bc
    int BIzerop -> bd
    int BIcar -> be
    int BIcdr -> bf
    int BIcaar -> bg
    int BIcadr -> bh
    int BIcdar -> bi
    int BIcddr -> bj
    int BIqcar -> bk
    int BIqcdr -> bl
    int BIqcaar -> bm
    int BIqcadr -> bn
    int BIqcdar -> bo
    int BIqcddr -> bp
    int BIncons -> bq
    int BInumberp -> br
    int BIappend -> bs
    int BIash -> bt
    int BIassoc -> bu
    int BIatsoc -> bv
    int BIdeleq -> bw
    int BIdelete -> bx
    int BIdivide -> by
    int BIeqcar -> bz
    int BIeql -> bA
    int BIeqn -> bB
    int BIexpt -> bC
    int BIflag -> bD
    int BIflagpcar -> bE
    int BIgcdn -> bF
    int BIgeq -> bG
    int BIgetv -> bH
    int BIgreaterp -> bI
    int BIidifference -> bJ
    int BIigreaterp -> bK
    int BIilessp -> bL
    int BIimax -> bM
    int BIimin -> bN
    int BIiplus2 -> bO
    int BIiquotient -> bP
    int BIiremainder -> bQ
    int BIirightshift -> bR
    int BIitimes2 -> bS
    int BIleq -> bT
    int BIlessp -> bU
    int BImake_random_state -> bV
    int BImax2 -> bW
    int BImember -> bX
    int BImemq -> bY
    int BImin2 -> bZ
    int BImod -> ca
    int BImodular_difference -> cb
    int BImodular_expt -> cc
    int BImodular_plus -> cd
    int BImodular_quotient -> ce
    int BImodular_times -> cf
    int BInconc -> cg
    int BIneq -> ch
    int BIorderp -> ci
    int BIordp -> cj
    int BIquotient -> ck
    int BIremainder -> cl
    int BIremflag -> cm
    int BIremprop -> cn
    int BIrplaca -> co
    int BIrplacd -> cp
    int BIschar -> cq
    int BIset -> cr
    int BIsmemq -> cs
    int BIsubla -> ct
    int BIsublis -> cu
    int BIsymbol_set_definition -> cv
    int BIsymbol_set_env -> cw
    int BIxcons -> cx
    int BIequal -> cy
    int BIeq -> cz
    int BIcons -> cA
    int BIlist2 -> cB
    int BIget -> cC
    int BIqgetv -> cD
    int BIflagp -> cE
    int BIapply1 -> cF
    int BIdifference -> cG
    int BIplus2 -> cH
    int BItimes2 -> cI
    int BIequalcar -> cJ
    int BIiequal -> cK
    int BIbps_putv -> cL
    int BIerrorset -> cM
    int BIlist2STAR -> cN
    int BIlist3 -> cO
    int BIputv -> cP
    int BIputv_char -> cQ
    int BIsubst -> cR
    int BIapply2 -> cS
    int BIacons -> cT
    int stack_size -> cU
    org.mathpiper.mpreduce.LispObject[] stack -> a
    int sp -> cV
    int poll_time_countdown -> cW
    long last_clock -> a
    void handleInterrupt() -> i
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction lookupBuiltin(java.lang.String) -> a
    void setupBuiltins() -> h
    org.mathpiper.mpreduce.LispObject interpret(int) -> e
org.mathpiper.mpreduce.functions.functionwithenvironment.FnWithEnv -> org.c.a.c.b.c:
    int nargs -> cX
    byte[] bytecodes -> a
    org.mathpiper.mpreduce.LispObject[] env -> b
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.AutoLoad -> org.c.a.c.c.a:
    org.mathpiper.mpreduce.symbols.Symbol name -> a
    org.mathpiper.mpreduce.LispObject data -> c
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void print() -> a
    void print(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.CallAs -> org.c.a.c.c.b:
    org.mathpiper.mpreduce.LispObject body -> c
    int nargs -> b
    void print() -> a
    void print(int) -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.Interpreted -> org.c.a.c.c.c:
    org.mathpiper.mpreduce.LispObject body -> c
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.lisp.LispFunction -> org.c.a.c.c.d:
    java.lang.String name -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String,org.mathpiper.mpreduce.LispObject) -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
org.mathpiper.mpreduce.functions.lisp.Macro -> org.c.a.c.c.e:
    org.mathpiper.mpreduce.LispObject body -> c
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.lisp.TracedFunction -> org.c.a.c.c.f:
    org.mathpiper.mpreduce.symbols.Symbol name -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction fn -> a
    int traceDepth -> b
    void indent() -> h
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void print() -> a
    void print(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.Undefined -> org.c.a.c.c.g:
    void dump() -> g
org.mathpiper.mpreduce.io.Fasl -> org.c.a.d.a:
    java.io.OutputStream writer -> a
    java.io.InputStream reader -> a
    org.mathpiper.mpreduce.LispObject[] recent -> a
    int recentp -> a
    int recentn -> b
    java.lang.String moduleName -> a
    java.lang.String name -> b
    org.mathpiper.mpreduce.LispObject startModule(org.mathpiper.mpreduce.LispObject) -> a
    void defineInModule(int) -> a
    void faslWrite(org.mathpiper.mpreduce.LispObject) -> a
    boolean openModule(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject loadModule(org.mathpiper.mpreduce.LispObject) -> b
    void readByteDef(int,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject faslRead() -> a
org.mathpiper.mpreduce.io.streams.DoubleWriter -> org.c.a.d.a.a:
    java.io.Writer log -> a
    boolean closeMe -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispCounter -> org.c.a.d.a.b:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispDigester -> org.c.a.d.a.c:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispExploder -> org.c.a.d.a.d:
    boolean asSymbols -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispOutputStream -> org.c.a.d.a.e:
    boolean closeMe -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispOutputString -> org.c.a.d.a.f:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    java.lang.String toString() -> toString
org.mathpiper.mpreduce.io.streams.LispStream -> org.c.a.d.a.g:
    java.lang.String name -> a
    int lineLength -> b
    int column -> c
    java.lang.String eol -> b
    org.mathpiper.mpreduce.LispObject exploded -> c
    java.lang.StringBuffer sb -> a
    java.security.MessageDigest md -> a
    java.io.Writer wr -> b
    boolean inputValid -> c
    org.mathpiper.mpreduce.LispObject inputData -> d
    java.lang.String stringData -> c
    java.io.Reader reader -> a
    org.mathpiper.mpreduce.LispObject value -> e
    int nextChar -> d
    int prevChar -> e
    java.lang.StringBuffer s -> b
    boolean needsPrompt -> d
    boolean escaped -> e
    boolean allowOctal -> f
    java.math.BigInteger[] digits -> a
    java.text.SimpleDateFormat dFormat -> a
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void println() -> j
    void flush() -> h
    void close() -> i
    void setReader(java.lang.String,java.io.Reader,boolean,boolean) -> a
    void prompt() -> k
    int read() -> c
    void getNext() -> l
    int readChar() -> d
    int nextToken() -> e
    void tidyup(org.mathpiper.mpreduce.LispObject) -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String nameConvert(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject fileDate(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject fileDelete(java.lang.String) -> b
    org.mathpiper.mpreduce.LispObject fileRename(java.lang.String,java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject listDirectory(java.lang.String) -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.io.streams.LispStringReader -> org.c.a.d.a.h:
    int pos -> f
    int read() -> c
    void close() -> i
org.mathpiper.mpreduce.io.streams.ListReader -> org.c.a.d.a.i:
    int read() -> c
    void close() -> i
org.mathpiper.mpreduce.io.streams.WriterToLisp -> org.c.a.d.a.j:
    org.mathpiper.mpreduce.io.streams.LispStream stream -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
org.mathpiper.mpreduce.numbers.LispBigInteger -> org.c.a.e.a:
    java.math.BigInteger value -> a
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    java.math.BigInteger biglcm(java.math.BigInteger,java.math.BigInteger) -> a
org.mathpiper.mpreduce.numbers.LispFloat -> org.c.a.e.b:
    double value -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    java.lang.String trimTo(int) -> a
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
org.mathpiper.mpreduce.numbers.LispInteger -> org.c.a.e.c:
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(int) -> a
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(long) -> a
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(java.math.BigInteger) -> a
org.mathpiper.mpreduce.numbers.LispNumber -> org.c.a.e.d:
org.mathpiper.mpreduce.numbers.LispSmallInteger -> org.c.a.e.e:
    int value -> b
    org.mathpiper.mpreduce.numbers.LispSmallInteger[] preAllocated -> a
    void preAllocate() -> h
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject modMinus() -> y
    org.mathpiper.mpreduce.LispObject modRecip() -> z
    org.mathpiper.mpreduce.LispObject safeModRecip() -> A
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    org.mathpiper.mpreduce.LispObject modAdd(org.mathpiper.mpreduce.LispObject) -> p
    org.mathpiper.mpreduce.LispObject modSubtract(org.mathpiper.mpreduce.LispObject) -> q
    org.mathpiper.mpreduce.LispObject modMultiply(org.mathpiper.mpreduce.LispObject) -> r
    org.mathpiper.mpreduce.LispObject modDivide(org.mathpiper.mpreduce.LispObject) -> s
    org.mathpiper.mpreduce.LispObject modExpt(int) -> d
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    org.mathpiper.mpreduce.LispObject modAddSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> p
    org.mathpiper.mpreduce.LispObject modSubtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> q
    org.mathpiper.mpreduce.LispObject modMultiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> r
    org.mathpiper.mpreduce.LispObject modDivideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> s
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
org.mathpiper.mpreduce.packagedatastore.PDS -> org.c.a.f.a:
    java.lang.String name -> a
    boolean writeable -> a
    boolean untidy -> b
    java.io.RandomAccessFile f -> a
    java.util.Vector data -> a
    java.util.HashMap directory -> a
    byte[] buffer -> a
    long bufferPos -> a
    long pos -> b
    boolean bufferValid -> c
    int readCount -> a
    int memberData -> b
    int memberStart -> c
    void seek(long) -> a
    int read() -> a
    int read(byte[],int,int) -> a
    long getFilePointer() -> a
    long length() -> b
    void print() -> a
    org.mathpiper.mpreduce.LispObject members() -> a
    void readDirectory() -> b
    void addToDirectory(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject modulep(java.lang.String) -> a
org.mathpiper.mpreduce.packagedatastore.PDSEntry -> org.c.a.f.b:
    java.lang.String name -> a
    int loc -> a
    int len -> b
    long date -> a
    int ordering -> c
    int compareTo(java.lang.Object) -> compareTo
org.mathpiper.mpreduce.packagedatastore.PDSInputStream -> org.c.a.f.c:
    org.mathpiper.mpreduce.packagedatastore.PDS pds -> a
    long savedPosition -> a
    int left -> a
    int available() -> available
    void close() -> close
    boolean markSupported() -> markSupported
    int read() -> read
    int read(byte[]) -> read
    int read(byte[],int,int) -> read
org.mathpiper.mpreduce.packagedatastore.PDSOutputStream -> org.c.a.f.d:
    org.mathpiper.mpreduce.packagedatastore.PDS pds -> a
    java.lang.String member -> a
    int length -> a
    long savedPosition -> a
    void close() -> close
    void write(int) -> write
org.mathpiper.mpreduce.special.Specfn -> org.c.a.g.a:
    int progEvent -> a
    org.mathpiper.mpreduce.LispObject progData -> a
    java.lang.Object[][] specials -> a
org.mathpiper.mpreduce.special.Specfn$AndSpecial -> org.c.a.g.a$a:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$BlockSpecial -> org.c.a.g.a$b:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$CondSpecial -> org.c.a.g.a$c:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DeclareSpecial -> org.c.a.g.a$d:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DefunSpecial -> org.c.a.g.a$e:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DmSpecial -> org.c.a.g.a$f:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$FunctionSpecial -> org.c.a.g.a$g:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$GoSpecial -> org.c.a.g.a$h:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$IfSpecial -> org.c.a.g.a$i:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LambdaSpecial -> org.c.a.g.a$j:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LetSpecial -> org.c.a.g.a$k:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LetStarSpecial -> org.c.a.g.a$l:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ListSpecial -> org.c.a.g.a$m:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ListStarSpecial -> org.c.a.g.a$n:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$OrSpecial -> org.c.a.g.a$o:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$PlusSpecial -> org.c.a.g.a$p:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ProgSpecial -> org.c.a.g.a$q:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$QuoteSpecial -> org.c.a.g.a$r:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$SetqSpecial -> org.c.a.g.a$s:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$TimesSpecial -> org.c.a.g.a$t:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$UnlessSpecial -> org.c.a.g.a$u:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$WhenSpecial -> org.c.a.g.a$v:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.SpecialFunction -> org.c.a.g.b:
    java.lang.String name -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.symbols.Gensym -> org.c.a.h.a:
    java.lang.String nameBase -> a
    int gensymCounter -> b
    int myNumber -> c
    void completeName() -> h
    void dump() -> g
org.mathpiper.mpreduce.symbols.Symbol -> org.c.a.h.b:
    int symbolCount -> d
    java.lang.String pname -> b
    int cacheFlags -> e
    java.lang.String cacheString -> c
    org.mathpiper.mpreduce.functions.lisp.LispFunction fn -> a
    org.mathpiper.mpreduce.special.SpecialFunction special -> a
    java.lang.StringBuffer cache -> a
    void completeName() -> h
    org.mathpiper.mpreduce.symbols.Symbol intern(java.lang.String,org.mathpiper.mpreduce.functions.lisp.LispFunction,org.mathpiper.mpreduce.special.SpecialFunction) -> a
    void remob(org.mathpiper.mpreduce.symbols.Symbol) -> a
    org.mathpiper.mpreduce.symbols.Symbol intern(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String toPrint() -> a
    void iprint() -> b
    void blankprint() -> c
    int lisphashCode() -> a
    void scan() -> f
    void dump() -> g
org.scilab.forge.jlatexmath.AccentedAtom -> org.scilab.forge.jlatexmath.AccentedAtom:
    org.scilab.forge.jlatexmath.SymbolAtom accent -> a
    boolean acc -> a
    boolean changeSize -> b
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom underbase -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.AlphabetRegistration -> org.scilab.forge.jlatexmath.AlphabetRegistration:
    java.lang.Character$UnicodeBlock[] JLM_GREEK -> a
    java.lang.Character$UnicodeBlock[] JLM_CYRILLIC -> b
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.AlphabetRegistrationException -> org.scilab.forge.jlatexmath.AlphabetRegistrationException:
org.scilab.forge.jlatexmath.ArrayOfAtoms -> org.scilab.forge.jlatexmath.ArrayOfAtoms:
    java.util.LinkedList array -> a
    int col -> a
    int row -> b
    void addCol() -> addCol
    void addCol(int) -> addCol
    void addRow() -> addRow
    int getRows() -> getRows
    int getCols() -> getCols
    org.scilab.forge.jlatexmath.VRowAtom getAsVRow() -> getAsVRow
    void checkDimensions() -> checkDimensions
org.scilab.forge.jlatexmath.Atom -> org.scilab.forge.jlatexmath.Atom:
    int type -> a
    int type_limits -> b
    int alignment -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Atom clone() -> clone
    java.lang.Object clone() -> clone
org.scilab.forge.jlatexmath.BigDelimiterAtom -> org.scilab.forge.jlatexmath.BigDelimiterAtom:
    org.scilab.forge.jlatexmath.SymbolAtom delim -> a
    int size -> d
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.BigOperatorAtom -> org.scilab.forge.jlatexmath.BigOperatorAtom:
    org.scilab.forge.jlatexmath.Atom under -> b
    org.scilab.forge.jlatexmath.Atom over -> c
    org.scilab.forge.jlatexmath.Atom base -> a
    boolean limitsSet -> a
    boolean limits -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box changeWidth(org.scilab.forge.jlatexmath.Box,float) -> changeWidth
org.scilab.forge.jlatexmath.BoldAtom -> org.scilab.forge.jlatexmath.BoldAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Box -> org.scilab.forge.jlatexmath.Box:
    boolean DEBUG -> a
    java.awt.Color foreground -> a
    java.awt.Color background -> b
    java.awt.Color prevColor -> d
    float width -> a
    float height -> b
    float depth -> c
    float shift -> d
    int type -> a
    java.util.LinkedList children -> a
    org.scilab.forge.jlatexmath.Box parent -> a
    org.scilab.forge.jlatexmath.Box elderParent -> b
    java.awt.Color markForDEBUG -> c
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void setParent(org.scilab.forge.jlatexmath.Box) -> setParent
    org.scilab.forge.jlatexmath.Box getParent() -> getParent
    void setElderParent(org.scilab.forge.jlatexmath.Box) -> setElderParent
    org.scilab.forge.jlatexmath.Box getElderParent() -> getElderParent
    float getWidth() -> getWidth
    void negWidth() -> negWidth
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    float getShift() -> getShift
    void setWidth(float) -> setWidth
    void setDepth(float) -> setDepth
    void setHeight(float) -> setHeight
    void setShift(float) -> setShift
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
    void startDraw(java.awt.Graphics2D,float,float) -> startDraw
    void drawDebug(java.awt.Graphics2D,float,float,boolean) -> drawDebug
    void drawDebug(java.awt.Graphics2D,float,float) -> drawDebug
    void endDraw(java.awt.Graphics2D) -> endDraw
org.scilab.forge.jlatexmath.BreakFormula -> org.scilab.forge.jlatexmath.BreakFormula:
    org.scilab.forge.jlatexmath.Box split(org.scilab.forge.jlatexmath.Box,float,float) -> split
    org.scilab.forge.jlatexmath.Box split(org.scilab.forge.jlatexmath.HorizontalBox,float,float) -> split
    org.scilab.forge.jlatexmath.Box split(org.scilab.forge.jlatexmath.VerticalBox,float,float) -> split
    float canBreak(java.util.Stack,org.scilab.forge.jlatexmath.HorizontalBox,float) -> canBreak
    int getBreakPosition(org.scilab.forge.jlatexmath.HorizontalBox,int) -> getBreakPosition
org.scilab.forge.jlatexmath.BreakFormula$Position -> org.scilab.forge.jlatexmath.BreakFormula$Position:
    int index -> a
    org.scilab.forge.jlatexmath.HorizontalBox hbox -> a
org.scilab.forge.jlatexmath.BreakMarkAtom -> org.scilab.forge.jlatexmath.BreakMarkAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.CedillaAtom -> org.scilab.forge.jlatexmath.CedillaAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Char -> org.scilab.forge.jlatexmath.Char:
    char c -> a
    java.awt.Font font -> a
    org.scilab.forge.jlatexmath.Metrics m -> a
    int fontCode -> a
    org.scilab.forge.jlatexmath.CharFont getCharFont() -> getCharFont
    char getChar() -> getChar
    java.awt.Font getFont() -> getFont
    int getFontCode() -> getFontCode
    float getWidth() -> getWidth
    float getItalic() -> getItalic
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    org.scilab.forge.jlatexmath.Metrics getMetrics() -> getMetrics
org.scilab.forge.jlatexmath.CharAtom -> org.scilab.forge.jlatexmath.CharAtom:
    char c -> a
    java.lang.String textStyle -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    char getCharacter() -> getCharacter
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.TeXFont,int,boolean) -> getChar
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
    java.lang.String toString() -> toString
org.scilab.forge.jlatexmath.CharBox -> org.scilab.forge.jlatexmath.CharBox:
    org.scilab.forge.jlatexmath.CharFont cf -> a
    float size -> e
    char[] arr -> a
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
    java.lang.String toString() -> toString
org.scilab.forge.jlatexmath.CharFont -> org.scilab.forge.jlatexmath.CharFont:
    char c -> a
    int fontId -> a
    int boldFontId -> b
org.scilab.forge.jlatexmath.CharSymbol -> org.scilab.forge.jlatexmath.CharSymbol:
    boolean textSymbol -> a
    void markAsTextSymbol() -> markAsTextSymbol
    void removeMark() -> removeMark
    boolean isMarkedAsTextSymbol() -> isMarkedAsTextSymbol
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
org.scilab.forge.jlatexmath.ColorAtom -> org.scilab.forge.jlatexmath.ColorAtom:
    java.util.Map Colors -> a
    java.awt.Color background -> a
    java.awt.Color color -> b
    org.scilab.forge.jlatexmath.RowAtom elements -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
    java.awt.Color getColor(java.lang.String) -> getColor
    void initColors() -> initColors
    java.awt.Color convColor(float,float,float,float) -> convColor
org.scilab.forge.jlatexmath.CumulativeScriptsAtom -> org.scilab.forge.jlatexmath.CumulativeScriptsAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.RowAtom sup -> a
    org.scilab.forge.jlatexmath.RowAtom sub -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.DdotsAtom -> org.scilab.forge.jlatexmath.DdotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.DefaultTeXFont -> org.scilab.forge.jlatexmath.DefaultTeXFont:
    java.lang.String[] defaultTextStyleMappings -> a
    java.util.Map textStyleMappings -> b
    java.util.Map symbolMappings -> c
    org.scilab.forge.jlatexmath.FontInfo[] fontInfo -> a
    java.util.Map parameters -> d
    java.util.Map generalSettings -> e
    boolean magnificationEnable -> f
    java.util.List loadedAlphabets -> a
    java.util.Map registeredAlphabets -> a
    float factor -> a
    boolean isBold -> a
    boolean isRoman -> b
    boolean isSs -> c
    boolean isTt -> d
    boolean isIt -> e
    float size -> b
    void addTeXFontDescription(java.lang.String) -> addTeXFontDescription
    void addTeXFontDescription(java.io.InputStream,java.lang.String) -> addTeXFontDescription
    void addTeXFontDescription(java.lang.Object,java.io.InputStream,java.lang.String) -> addTeXFontDescription
    void addAlphabet(java.lang.Character$UnicodeBlock,java.io.InputStream,java.lang.String,java.io.InputStream,java.lang.String,java.io.InputStream,java.lang.String) -> addAlphabet
    void addAlphabet(java.lang.Object,java.lang.Character$UnicodeBlock[],java.lang.String) -> addAlphabet
    void addAlphabet(java.lang.Character$UnicodeBlock,java.lang.String) -> addAlphabet
    void addAlphabet(org.scilab.forge.jlatexmath.AlphabetRegistration) -> addAlphabet
    void registerAlphabet(org.scilab.forge.jlatexmath.AlphabetRegistration) -> registerAlphabet
    org.scilab.forge.jlatexmath.TeXFont copy() -> copy
    org.scilab.forge.jlatexmath.TeXFont deriveFont(float) -> deriveFont
    org.scilab.forge.jlatexmath.TeXFont scaleFont(float) -> scaleFont
    float getScaleFactor() -> getScaleFactor
    float getAxisHeight(int) -> getAxisHeight
    float getBigOpSpacing1(int) -> getBigOpSpacing1
    float getBigOpSpacing2(int) -> getBigOpSpacing2
    float getBigOpSpacing3(int) -> getBigOpSpacing3
    float getBigOpSpacing4(int) -> getBigOpSpacing4
    float getBigOpSpacing5(int) -> getBigOpSpacing5
    org.scilab.forge.jlatexmath.Char getChar(char,org.scilab.forge.jlatexmath.CharFont[],int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(char,java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.CharFont,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getDefaultChar(char,int) -> getDefaultChar
    float getDefaultRuleThickness(int) -> getDefaultRuleThickness
    float getDenom1(int) -> getDenom1
    float getDenom2(int) -> getDenom2
    org.scilab.forge.jlatexmath.Extension getExtension(org.scilab.forge.jlatexmath.Char,int) -> getExtension
    float getKern(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont,int) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont) -> getLigature
    org.scilab.forge.jlatexmath.Metrics getMetrics(org.scilab.forge.jlatexmath.CharFont,float) -> getMetrics
    int getMuFontId() -> getMuFontId
    org.scilab.forge.jlatexmath.Char getNextLarger(org.scilab.forge.jlatexmath.Char,int) -> getNextLarger
    float getNum1(int) -> getNum1
    float getNum2(int) -> getNum2
    float getNum3(int) -> getNum3
    float getQuad(int,int) -> getQuad
    float getSize() -> getSize
    float getSkew(org.scilab.forge.jlatexmath.CharFont,int) -> getSkew
    float getSpace(int) -> getSpace
    float getSub1(int) -> getSub1
    float getSub2(int) -> getSub2
    float getSubDrop(int) -> getSubDrop
    float getSup1(int) -> getSup1
    float getSup2(int) -> getSup2
    float getSup3(int) -> getSup3
    float getSupDrop(int) -> getSupDrop
    float getXHeight(int,int) -> getXHeight
    float getEM(int) -> getEM
    boolean hasNextLarger(org.scilab.forge.jlatexmath.Char) -> hasNextLarger
    void setBold(boolean) -> setBold
    boolean getBold() -> getBold
    void setRoman(boolean) -> setRoman
    boolean getRoman() -> getRoman
    void setTt(boolean) -> setTt
    boolean getTt() -> getTt
    void setIt(boolean) -> setIt
    boolean getIt() -> getIt
    void setSs(boolean) -> setSs
    boolean getSs() -> getSs
    boolean hasSpace(int) -> hasSpace
    boolean isExtensionChar(org.scilab.forge.jlatexmath.Char) -> isExtensionChar
    void setMathSizes(float,float,float,float) -> setMathSizes
    void setMagnification(float) -> setMagnification
    void enableMagnification(boolean) -> enableMagnification
    float getParameter(java.lang.String) -> getParameter
    float getSizeFactor(int) -> getSizeFactor
org.scilab.forge.jlatexmath.DefaultTeXFontParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser:
    boolean registerFontExceptionDisplayed -> a
    boolean shouldRegisterFonts -> b
    javax.xml.parsers.DocumentBuilderFactory factory -> a
    java.util.ArrayList Font_ID -> a
    java.util.Map rangeTypeMappings -> a
    java.util.Map charChildParsers -> b
    java.util.Map parsedTextStyles -> c
    org.w3c.dom.Element root -> a
    java.lang.Object base -> a
    void setCharChildParsers() -> setCharChildParsers
    org.scilab.forge.jlatexmath.FontInfo[] parseFontDescriptions(org.scilab.forge.jlatexmath.FontInfo[],java.io.InputStream,java.lang.String) -> parseFontDescriptions
    org.scilab.forge.jlatexmath.FontInfo[] parseFontDescriptions(org.scilab.forge.jlatexmath.FontInfo[]) -> parseFontDescriptions
    void parseExtraPath() -> parseExtraPath
    void processCharElement(org.w3c.dom.Element,org.scilab.forge.jlatexmath.FontInfo) -> processCharElement
    void registerFonts(boolean) -> registerFonts
    java.awt.Font createFont(java.lang.String) -> createFont
    java.awt.Font createFont(java.io.InputStream,java.lang.String) -> createFont
    java.util.Map parseSymbolMappings() -> parseSymbolMappings
    java.lang.String[] parseDefaultTextStyleMappings() -> parseDefaultTextStyleMappings
    java.util.Map parseParameters() -> parseParameters
    java.util.Map parseGeneralSettings() -> parseGeneralSettings
    java.util.Map parseTextStyleMappings() -> parseTextStyleMappings
    java.util.Map parseStyleMappings() -> parseStyleMappings
    void setRangeTypeMappings() -> setRangeTypeMappings
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
    float getFloatAndCheck(java.lang.String,org.w3c.dom.Element) -> getFloatAndCheck
    int getIntAndCheck(java.lang.String,org.w3c.dom.Element) -> getIntAndCheck
    int getOptionalInt(java.lang.String,org.w3c.dom.Element,int) -> getOptionalInt
    float getOptionalFloat(java.lang.String,org.w3c.dom.Element,float) -> getOptionalFloat
    java.lang.String access$000(java.lang.String,org.w3c.dom.Element) -> access$000
org.scilab.forge.jlatexmath.DefaultTeXFontParser$CharChildParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$CharChildParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$ExtensionParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$ExtensionParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$KernParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$KernParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$LigParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$LigParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$NextLargerParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$NextLargerParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DelimiterFactory -> org.scilab.forge.jlatexmath.DelimiterFactory:
    org.scilab.forge.jlatexmath.Box create(org.scilab.forge.jlatexmath.SymbolAtom,org.scilab.forge.jlatexmath.TeXEnvironment,int) -> create
    org.scilab.forge.jlatexmath.Box create(java.lang.String,org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
org.scilab.forge.jlatexmath.DelimiterMappingNotFoundException -> org.scilab.forge.jlatexmath.DelimiterMappingNotFoundException:
org.scilab.forge.jlatexmath.DoubleFramedAtom -> org.scilab.forge.jlatexmath.DoubleFramedAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Dummy -> org.scilab.forge.jlatexmath.Dummy:
    org.scilab.forge.jlatexmath.Atom el -> a
    boolean textSymbol -> a
    int type -> a
    void setType(int) -> setType
    int getType() -> getType
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    boolean isCharSymbol() -> isCharSymbol
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
    void changeAtom(org.scilab.forge.jlatexmath.FixedCharAtom) -> changeAtom
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    void markAsTextSymbol() -> markAsTextSymbol
    boolean isKern() -> isKern
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.EmptyAtom -> org.scilab.forge.jlatexmath.EmptyAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.EmptyFormulaException -> org.scilab.forge.jlatexmath.EmptyFormulaException:
org.scilab.forge.jlatexmath.Extension -> org.scilab.forge.jlatexmath.Extension:
    org.scilab.forge.jlatexmath.Char top -> a
    org.scilab.forge.jlatexmath.Char middle -> b
    org.scilab.forge.jlatexmath.Char bottom -> c
    org.scilab.forge.jlatexmath.Char repeat -> d
    boolean hasTop() -> hasTop
    boolean hasMiddle() -> hasMiddle
    boolean hasBottom() -> hasBottom
    org.scilab.forge.jlatexmath.Char getTop() -> getTop
    org.scilab.forge.jlatexmath.Char getMiddle() -> getMiddle
    org.scilab.forge.jlatexmath.Char getRepeat() -> getRepeat
    org.scilab.forge.jlatexmath.Char getBottom() -> getBottom
org.scilab.forge.jlatexmath.FBoxAtom -> org.scilab.forge.jlatexmath.FBoxAtom:
    float INTERSPACE -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    java.awt.Color bg -> a
    java.awt.Color line -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FencedAtom -> org.scilab.forge.jlatexmath.FencedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.SymbolAtom left -> a
    org.scilab.forge.jlatexmath.SymbolAtom right -> b
    java.util.List middle -> a
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void center(org.scilab.forge.jlatexmath.Box,float) -> center
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FixedCharAtom -> org.scilab.forge.jlatexmath.FixedCharAtom:
    org.scilab.forge.jlatexmath.CharFont cf -> a
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FontAlreadyLoadedException -> org.scilab.forge.jlatexmath.FontAlreadyLoadedException:
org.scilab.forge.jlatexmath.FontInfo -> org.scilab.forge.jlatexmath.FontInfo:
    java.util.Map fonts -> a
    int fontId -> a
    java.awt.Font font -> a
    java.lang.Object base -> a
    java.lang.String path -> f
    java.lang.String fontName -> g
    java.util.Map lig -> b
    java.util.Map kern -> c
    float[][] metrics -> a
    org.scilab.forge.jlatexmath.CharFont[] nextLarger -> a
    int[][] extensions -> a
    java.util.HashMap unicode -> a
    char skewChar -> a
    float xHeight -> a
    float space -> b
    float quad -> c
    int boldId -> b
    int romanId -> c
    int ssId -> d
    int ttId -> e
    int itId -> f
    java.lang.String boldVersion -> a
    java.lang.String romanVersion -> b
    java.lang.String ssVersion -> c
    java.lang.String ttVersion -> d
    java.lang.String itVersion -> e
    void addKern(char,char,float) -> addKern
    void addLigature(char,char,char) -> addLigature
    int[] getExtension(char) -> getExtension
    float getKern(char,char,float) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(char,char) -> getLigature
    float[] getMetrics(char) -> getMetrics
    org.scilab.forge.jlatexmath.CharFont getNextLarger(char) -> getNextLarger
    float getQuad(float) -> getQuad
    char getSkewChar() -> getSkewChar
    float getSpace(float) -> getSpace
    float getXHeight(float) -> getXHeight
    boolean hasSpace() -> hasSpace
    void setExtension(char,int[]) -> setExtension
    void setMetrics(char,float[]) -> setMetrics
    void setNextLarger(char,char,int) -> setNextLarger
    void setSkewChar(char) -> setSkewChar
    int getId() -> getId
    int getBoldId() -> getBoldId
    int getRomanId() -> getRomanId
    int getTtId() -> getTtId
    int getItId() -> getItId
    int getSsId() -> getSsId
    void setSsId(int) -> setSsId
    void setTtId(int) -> setTtId
    void setItId(int) -> setItId
    void setRomanId(int) -> setRomanId
    void setBoldId(int) -> setBoldId
    java.awt.Font getFont() -> getFont
    java.awt.Font getFont(int) -> getFont
org.scilab.forge.jlatexmath.FontInfo$CharCouple -> org.scilab.forge.jlatexmath.FontInfo$CharCouple:
    char left -> a
    char right -> b
    org.scilab.forge.jlatexmath.FontInfo this$0 -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.scilab.forge.jlatexmath.FormulaNotFoundException -> org.scilab.forge.jlatexmath.FormulaNotFoundException:
org.scilab.forge.jlatexmath.FractionAtom -> org.scilab.forge.jlatexmath.FractionAtom:
    boolean noDefault -> a
    int unit -> d
    int numAlign -> e
    int denomAlign -> f
    org.scilab.forge.jlatexmath.Atom numerator -> a
    org.scilab.forge.jlatexmath.Atom denominator -> b
    float thickness -> a
    float defFactor -> b
    boolean defFactorSet -> b
    int checkAlignment(int) -> checkAlignment
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FramedBox -> org.scilab.forge.jlatexmath.FramedBox:
    org.scilab.forge.jlatexmath.Box box -> c
    float thickness -> e
    float space -> f
    java.awt.Color line -> d
    java.awt.Color bg -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.GeoGebraLogoAtom -> org.scilab.forge.jlatexmath.GeoGebraLogoAtom:
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GeoGebraLogoBox -> org.scilab.forge.jlatexmath.GeoGebraLogoBox:
    java.awt.Color gray -> d
    java.awt.Color blue -> e
    java.awt.BasicStroke st -> a
    java.awt.BasicStroke stC -> b
    void draw(java.awt.Graphics2D,float,float) -> draw
    void drawCircle(java.awt.Graphics2D,float,float) -> drawCircle
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.Glue -> org.scilab.forge.jlatexmath.Glue:
    float space -> a
    float stretch -> b
    float shrink -> c
    java.lang.String name -> a
    org.scilab.forge.jlatexmath.Glue[] glueTypes -> a
    int[][][] glueTable -> a
    java.lang.String getName() -> getName
    org.scilab.forge.jlatexmath.Box get(int,int,org.scilab.forge.jlatexmath.TeXEnvironment) -> get
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GlueBox -> org.scilab.forge.jlatexmath.GlueBox:
    float stretch -> e
    float shrink -> f
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.GlueSettingsParser -> org.scilab.forge.jlatexmath.GlueSettingsParser:
    java.util.Map typeMappings -> a
    java.util.Map glueTypeMappings -> b
    org.scilab.forge.jlatexmath.Glue[] glueTypes -> a
    java.util.Map styleMappings -> c
    org.w3c.dom.Element root -> a
    void setStyleMappings() -> setStyleMappings
    void parseGlueTypes() -> parseGlueTypes
    org.scilab.forge.jlatexmath.Glue createGlue(org.w3c.dom.Element,java.lang.String) -> createGlue
    void setTypeMappings() -> setTypeMappings
    org.scilab.forge.jlatexmath.Glue[] getGlueTypes() -> getGlueTypes
    int[][][] createGlueTable() -> createGlueTable
    void checkMapping(java.lang.Object,java.lang.String,java.lang.String,java.lang.String) -> checkMapping
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.GraphicsAtom -> org.scilab.forge.jlatexmath.GraphicsAtom:
    java.awt.Image image -> a
    java.awt.image.BufferedImage bimage -> a
    java.awt.Label c -> a
    int w -> d
    int h -> e
    org.scilab.forge.jlatexmath.Atom base -> a
    boolean first -> a
    int interp -> f
    void buildAtom(java.lang.String) -> buildAtom
    void draw() -> draw
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GraphicsBox -> org.scilab.forge.jlatexmath.GraphicsBox:
    java.awt.image.BufferedImage image -> a
    float scl -> e
    java.lang.Object interp -> a
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.HdotsforAtom -> org.scilab.forge.jlatexmath.HdotsforAtom:
    org.scilab.forge.jlatexmath.Atom ldotp -> b
    org.scilab.forge.jlatexmath.Atom thin -> c
    float coeff -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.HlineAtom -> org.scilab.forge.jlatexmath.HlineAtom:
    float width -> a
    float shift -> b
    void setWidth(float) -> setWidth
    void setShift(float) -> setShift
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.HorizontalBox -> org.scilab.forge.jlatexmath.HorizontalBox:
    float curPos -> e
    java.util.List breakPositions -> a
    org.scilab.forge.jlatexmath.HorizontalBox cloneBox() -> cloneBox
    void draw(java.awt.Graphics2D,float,float) -> draw
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void recalculate(org.scilab.forge.jlatexmath.Box) -> recalculate
    int getLastFontId() -> getLastFontId
    void addBreakPosition(int) -> addBreakPosition
    org.scilab.forge.jlatexmath.HorizontalBox[] split(int) -> split
    org.scilab.forge.jlatexmath.HorizontalBox[] splitRemove(int) -> splitRemove
    org.scilab.forge.jlatexmath.HorizontalBox[] split(int,int) -> split
org.scilab.forge.jlatexmath.HorizontalRule -> org.scilab.forge.jlatexmath.HorizontalRule:
    java.awt.Color color -> d
    float speShift -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.IJAtom -> org.scilab.forge.jlatexmath.IJAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.IddotsAtom -> org.scilab.forge.jlatexmath.IddotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.InvalidAtomTypeException -> org.scilab.forge.jlatexmath.InvalidAtomTypeException:
org.scilab.forge.jlatexmath.InvalidDelimiterException -> org.scilab.forge.jlatexmath.InvalidDelimiterException:
org.scilab.forge.jlatexmath.InvalidDelimiterTypeException -> org.scilab.forge.jlatexmath.InvalidDelimiterTypeException:
org.scilab.forge.jlatexmath.InvalidMatrixException -> org.scilab.forge.jlatexmath.InvalidMatrixException:
org.scilab.forge.jlatexmath.InvalidSymbolTypeException -> org.scilab.forge.jlatexmath.InvalidSymbolTypeException:
org.scilab.forge.jlatexmath.InvalidTeXFormulaException -> org.scilab.forge.jlatexmath.InvalidTeXFormulaException:
org.scilab.forge.jlatexmath.InvalidUnitException -> org.scilab.forge.jlatexmath.InvalidUnitException:
org.scilab.forge.jlatexmath.ItAtom -> org.scilab.forge.jlatexmath.ItAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.JMathTeXException -> org.scilab.forge.jlatexmath.JMathTeXException:
org.scilab.forge.jlatexmath.JavaFontRenderingAtom -> org.scilab.forge.jlatexmath.JavaFontRenderingAtom:
    java.lang.String str -> a
    int type -> d
    org.scilab.forge.jlatexmath.TeXFormula$FontInfos fontInfos -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.JavaFontRenderingBox -> org.scilab.forge.jlatexmath.JavaFontRenderingBox:
    java.awt.Graphics2D TEMPGRAPHIC -> a
    java.awt.Font font -> a
    java.lang.String str -> a
    java.awt.font.TextLayout text -> a
    float size -> e
    java.awt.font.TextAttribute KERNING -> a
    java.lang.Integer KERNING_ON -> a
    java.awt.font.TextAttribute LIGATURES -> b
    java.lang.Integer LIGATURES_ON -> b
    void setFont(java.lang.String) -> setFont
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.LCaronAtom -> org.scilab.forge.jlatexmath.LCaronAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.LaTeXAtom -> org.scilab.forge.jlatexmath.LaTeXAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.LapedAtom -> org.scilab.forge.jlatexmath.LapedAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    char type -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MacroInfo -> org.scilab.forge.jlatexmath.MacroInfo:
    java.util.HashMap Commands -> a
    java.util.HashMap Packages -> b
    java.lang.Object pack -> a
    java.lang.reflect.Method macro -> a
    int nbArgs -> a
    boolean hasOptions -> a
    int posOpts -> b
    java.lang.Object invoke(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invoke
org.scilab.forge.jlatexmath.MathAtom -> org.scilab.forge.jlatexmath.MathAtom:
    int style -> d
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MatrixAtom -> org.scilab.forge.jlatexmath.MatrixAtom:
    org.scilab.forge.jlatexmath.SpaceAtom hsep -> a
    org.scilab.forge.jlatexmath.SpaceAtom semihsep -> b
    org.scilab.forge.jlatexmath.SpaceAtom vsep_in -> c
    org.scilab.forge.jlatexmath.SpaceAtom vsep_ext_top -> d
    org.scilab.forge.jlatexmath.SpaceAtom vsep_ext_bot -> e
    org.scilab.forge.jlatexmath.Box nullBox -> a
    org.scilab.forge.jlatexmath.ArrayOfAtoms matrix -> a
    int[] position -> a
    java.util.Map vlines -> a
    int type -> d
    boolean isPartial -> a
    boolean spaceAround -> b
    org.scilab.forge.jlatexmath.SpaceAtom align -> f
    void parsePositions(java.lang.StringBuffer) -> parsePositions
    org.scilab.forge.jlatexmath.Box[] getColumnSep(org.scilab.forge.jlatexmath.TeXEnvironment,float) -> getColumnSep
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box generateMulticolumn(org.scilab.forge.jlatexmath.TeXEnvironment,org.scilab.forge.jlatexmath.Box[],float[],int,int) -> generateMulticolumn
org.scilab.forge.jlatexmath.Metrics -> org.scilab.forge.jlatexmath.Metrics:
    float w -> a
    float h -> b
    float d -> c
    float i -> d
    float s -> e
    float getWidth() -> getWidth
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    float getItalic() -> getItalic
    float getSize() -> getSize
org.scilab.forge.jlatexmath.MiddleAtom -> org.scilab.forge.jlatexmath.MiddleAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box box -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MonoScaleAtom -> org.scilab.forge.jlatexmath.MonoScaleAtom:
    float factor -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MulticolumnAtom -> org.scilab.forge.jlatexmath.MulticolumnAtom:
    int n -> d
    int align -> e
    float w -> a
    org.scilab.forge.jlatexmath.Atom cols -> a
    int beforeVlines -> f
    int afterVlines -> g
    int row -> h
    int col -> i
    void setWidth(float) -> setWidth
    int getSkipped() -> getSkipped
    boolean hasRightVline() -> hasRightVline
    void setRowColumn(int,int) -> setRowColumn
    int getRow() -> getRow
    int getCol() -> getCol
    int parseAlign(java.lang.String) -> parseAlign
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MultlineAtom -> org.scilab.forge.jlatexmath.MultlineAtom:
    org.scilab.forge.jlatexmath.SpaceAtom vsep_in -> a
    org.scilab.forge.jlatexmath.ArrayOfAtoms column -> a
    int type -> d
    boolean isPartial -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.NewCommandMacro -> org.scilab.forge.jlatexmath.NewCommandMacro:
    java.util.HashMap macrocode -> a
    java.util.HashMap macroreplacement -> b
    void addNewCommand(java.lang.String,java.lang.String,int) -> addNewCommand
    void addNewCommand(java.lang.String,java.lang.String,int,java.lang.String) -> addNewCommand
    boolean isMacro(java.lang.String) -> isMacro
    void addReNewCommand(java.lang.String,java.lang.String,int) -> addReNewCommand
    java.lang.String executeMacro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> executeMacro
org.scilab.forge.jlatexmath.NewEnvironmentMacro -> org.scilab.forge.jlatexmath.NewEnvironmentMacro:
    void addNewEnvironment(java.lang.String,java.lang.String,java.lang.String,int) -> addNewEnvironment
    void addReNewEnvironment(java.lang.String,java.lang.String,java.lang.String,int) -> addReNewEnvironment
org.scilab.forge.jlatexmath.NthRoot -> org.scilab.forge.jlatexmath.NthRoot:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom root -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OgonekAtom -> org.scilab.forge.jlatexmath.OgonekAtom:
    org.scilab.forge.jlatexmath.SymbolAtom ogonek -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OvalAtom -> org.scilab.forge.jlatexmath.OvalAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OvalBox -> org.scilab.forge.jlatexmath.OvalBox:
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.OverBar -> org.scilab.forge.jlatexmath.OverBar:
org.scilab.forge.jlatexmath.OverUnderBox -> org.scilab.forge.jlatexmath.OverUnderBox:
    org.scilab.forge.jlatexmath.Box base -> c
    org.scilab.forge.jlatexmath.Box del -> d
    org.scilab.forge.jlatexmath.Box script -> e
    float kern -> e
    boolean over -> b
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.OverUnderDelimiter -> org.scilab.forge.jlatexmath.OverUnderDelimiter:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom script -> b
    org.scilab.forge.jlatexmath.SymbolAtom symbol -> a
    org.scilab.forge.jlatexmath.SpaceAtom kern -> a
    boolean over -> a
    void addScript(org.scilab.forge.jlatexmath.Atom) -> addScript
    boolean isOver() -> isOver
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    float getMaxWidth(org.scilab.forge.jlatexmath.Box,org.scilab.forge.jlatexmath.Box,org.scilab.forge.jlatexmath.Box) -> getMaxWidth
org.scilab.forge.jlatexmath.OverlinedAtom -> org.scilab.forge.jlatexmath.OverlinedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ParseException -> org.scilab.forge.jlatexmath.ParseException:
org.scilab.forge.jlatexmath.ParseOption -> org.scilab.forge.jlatexmath.ParseOption:
    java.util.Map parseMap(java.lang.String) -> parseMap
org.scilab.forge.jlatexmath.PhantomAtom -> org.scilab.forge.jlatexmath.PhantomAtom:
    org.scilab.forge.jlatexmath.RowAtom elements -> a
    boolean w -> a
    boolean h -> b
    boolean d -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.PredefMacroInfo -> org.scilab.forge.jlatexmath.PredefMacroInfo:
    int id -> c
    java.lang.Object invoke(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invoke
    java.lang.Object invokeID(int,org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invokeID
org.scilab.forge.jlatexmath.PredefMacros -> org.scilab.forge.jlatexmath.PredefMacros:
    org.scilab.forge.jlatexmath.Atom Braket_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Braket_macro
    org.scilab.forge.jlatexmath.Atom Set_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Set_macro
    org.scilab.forge.jlatexmath.Atom spATbreve_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> spATbreve_macro
    org.scilab.forge.jlatexmath.Atom spAThat_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> spAThat_macro
    org.scilab.forge.jlatexmath.Atom hvspace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hvspace_macro
    org.scilab.forge.jlatexmath.Atom clrlap_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> clrlap_macro
    org.scilab.forge.jlatexmath.Atom mathclrlap_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathclrlap_macro
    org.scilab.forge.jlatexmath.Atom includegraphics_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> includegraphics_macro
    org.scilab.forge.jlatexmath.Atom rule_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rule_macro
    org.scilab.forge.jlatexmath.Atom cfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cfrac_macro
    org.scilab.forge.jlatexmath.Atom frac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> frac_macro
    org.scilab.forge.jlatexmath.Atom sfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sfrac_macro
    org.scilab.forge.jlatexmath.Atom genfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> genfrac_macro
    org.scilab.forge.jlatexmath.Atom over_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> over_macro
    org.scilab.forge.jlatexmath.Atom overwithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overwithdelims_macro
    org.scilab.forge.jlatexmath.Atom atop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> atop_macro
    org.scilab.forge.jlatexmath.Atom atopwithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> atopwithdelims_macro
    org.scilab.forge.jlatexmath.Atom choose_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> choose_macro
    org.scilab.forge.jlatexmath.Atom binom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> binom_macro
    org.scilab.forge.jlatexmath.Atom above_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> above_macro
    org.scilab.forge.jlatexmath.Atom abovewithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> abovewithdelims_macro
    org.scilab.forge.jlatexmath.Atom textstyle_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textstyle_macros
    org.scilab.forge.jlatexmath.Atom mbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mbox_macro
    org.scilab.forge.jlatexmath.Atom text_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> text_macro
    org.scilab.forge.jlatexmath.Atom underscore_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underscore_macro
    org.scilab.forge.jlatexmath.Atom accent_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accent_macros
    org.scilab.forge.jlatexmath.Atom grkaccent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> grkaccent_macro
    org.scilab.forge.jlatexmath.Atom accent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accent_macro
    org.scilab.forge.jlatexmath.Atom accentbis_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accentbis_macros
    org.scilab.forge.jlatexmath.Atom cedilla_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cedilla_macro
    org.scilab.forge.jlatexmath.Atom IJ_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> IJ_macro
    org.scilab.forge.jlatexmath.Atom TStroke_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> TStroke_macro
    org.scilab.forge.jlatexmath.Atom LCaron_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> LCaron_macro
    org.scilab.forge.jlatexmath.Atom tcaron_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> tcaron_macro
    org.scilab.forge.jlatexmath.Atom ogonek_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ogonek_macro
    org.scilab.forge.jlatexmath.Atom nbsp_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> nbsp_macro
    org.scilab.forge.jlatexmath.Atom sqrt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sqrt_macro
    org.scilab.forge.jlatexmath.Atom overrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overrightarrow_macro
    org.scilab.forge.jlatexmath.Atom overleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overleftarrow_macro
    org.scilab.forge.jlatexmath.Atom overleftrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overleftrightarrow_macro
    org.scilab.forge.jlatexmath.Atom underrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underrightarrow_macro
    org.scilab.forge.jlatexmath.Atom underleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underleftarrow_macro
    org.scilab.forge.jlatexmath.Atom underleftrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underleftrightarrow_macro
    org.scilab.forge.jlatexmath.Atom xleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> xleftarrow_macro
    org.scilab.forge.jlatexmath.Atom xrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> xrightarrow_macro
    org.scilab.forge.jlatexmath.Atom sideset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sideset_macro
    org.scilab.forge.jlatexmath.Atom prescript_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> prescript_macro
    org.scilab.forge.jlatexmath.Atom underbrace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underbrace_macro
    org.scilab.forge.jlatexmath.Atom overbrace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overbrace_macro
    org.scilab.forge.jlatexmath.Atom underbrack_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underbrack_macro
    org.scilab.forge.jlatexmath.Atom overbrack_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overbrack_macro
    org.scilab.forge.jlatexmath.Atom underparen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underparen_macro
    org.scilab.forge.jlatexmath.Atom overparen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overparen_macro
    org.scilab.forge.jlatexmath.Atom overline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overline_macro
    org.scilab.forge.jlatexmath.Atom underline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underline_macro
    org.scilab.forge.jlatexmath.Atom mathop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathop_macro
    org.scilab.forge.jlatexmath.Atom mathpunct_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathpunct_macro
    org.scilab.forge.jlatexmath.Atom mathord_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathord_macro
    org.scilab.forge.jlatexmath.Atom mathrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathrel_macro
    org.scilab.forge.jlatexmath.Atom mathinner_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathinner_macro
    org.scilab.forge.jlatexmath.Atom mathbin_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathbin_macro
    org.scilab.forge.jlatexmath.Atom mathopen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathopen_macro
    org.scilab.forge.jlatexmath.Atom mathclose_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathclose_macro
    org.scilab.forge.jlatexmath.Atom joinrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> joinrel_macro
    org.scilab.forge.jlatexmath.Atom smash_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smash_macro
    org.scilab.forge.jlatexmath.Atom vdots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> vdots_macro
    org.scilab.forge.jlatexmath.Atom ddots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ddots_macro
    org.scilab.forge.jlatexmath.Atom iddots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iddots_macro
    org.scilab.forge.jlatexmath.Atom nolimits_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> nolimits_macro
    org.scilab.forge.jlatexmath.Atom limits_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> limits_macro
    org.scilab.forge.jlatexmath.Atom normal_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> normal_macro
    org.scilab.forge.jlatexmath.Atom left_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> left_macro
    org.scilab.forge.jlatexmath.Atom leftparenthesis_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> leftparenthesis_macro
    org.scilab.forge.jlatexmath.Atom leftbracket_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> leftbracket_macro
    org.scilab.forge.jlatexmath.Atom middle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> middle_macro
    org.scilab.forge.jlatexmath.Atom cr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cr_macro
    org.scilab.forge.jlatexmath.Atom backslashcr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> backslashcr_macro
    org.scilab.forge.jlatexmath.Atom intertext_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> intertext_macro
    org.scilab.forge.jlatexmath.Atom smallmatrixATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smallmatrixATATenv_macro
    org.scilab.forge.jlatexmath.Atom matrixATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> matrixATATenv_macro
    org.scilab.forge.jlatexmath.Atom multicolumn_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> multicolumn_macro
    org.scilab.forge.jlatexmath.Atom hdotsfor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hdotsfor_macro
    org.scilab.forge.jlatexmath.Atom arrayATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> arrayATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignATATenv_macro
    org.scilab.forge.jlatexmath.Atom flalignATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> flalignATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignatATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignatATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignedATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignedATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignedatATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignedatATATenv_macro
    org.scilab.forge.jlatexmath.Atom multlineATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> multlineATATenv_macro
    org.scilab.forge.jlatexmath.Atom gatherATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> gatherATATenv_macro
    org.scilab.forge.jlatexmath.Atom gatheredATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> gatheredATATenv_macro
    org.scilab.forge.jlatexmath.Atom shoveright_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shoveright_macro
    org.scilab.forge.jlatexmath.Atom shoveleft_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shoveleft_macro
    org.scilab.forge.jlatexmath.Atom newcommand_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> newcommand_macro
    org.scilab.forge.jlatexmath.Atom renewcommand_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> renewcommand_macro
    org.scilab.forge.jlatexmath.Atom makeatletter_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> makeatletter_macro
    org.scilab.forge.jlatexmath.Atom makeatother_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> makeatother_macro
    org.scilab.forge.jlatexmath.Atom newenvironment_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> newenvironment_macro
    org.scilab.forge.jlatexmath.Atom renewenvironment_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> renewenvironment_macro
    org.scilab.forge.jlatexmath.Atom fbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fbox_macro
    org.scilab.forge.jlatexmath.Atom stackrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> stackrel_macro
    org.scilab.forge.jlatexmath.Atom stackbin_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> stackbin_macro
    org.scilab.forge.jlatexmath.Atom overset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overset_macro
    org.scilab.forge.jlatexmath.Atom underset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underset_macro
    org.scilab.forge.jlatexmath.Atom accentset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accentset_macro
    org.scilab.forge.jlatexmath.Atom underaccent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underaccent_macro
    org.scilab.forge.jlatexmath.Atom undertilde_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> undertilde_macro
    org.scilab.forge.jlatexmath.Atom boldsymbol_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> boldsymbol_macro
    org.scilab.forge.jlatexmath.Atom mathrm_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathrm_macro
    org.scilab.forge.jlatexmath.Atom rm_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rm_macro
    org.scilab.forge.jlatexmath.Atom mathbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathbf_macro
    org.scilab.forge.jlatexmath.Atom bf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bf_macro
    org.scilab.forge.jlatexmath.Atom mathtt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathtt_macro
    org.scilab.forge.jlatexmath.Atom tt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> tt_macro
    org.scilab.forge.jlatexmath.Atom mathit_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathit_macro
    org.scilab.forge.jlatexmath.Atom it_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> it_macro
    org.scilab.forge.jlatexmath.Atom mathsf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathsf_macro
    org.scilab.forge.jlatexmath.Atom sf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sf_macro
    org.scilab.forge.jlatexmath.Atom LaTeX_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> LaTeX_macro
    org.scilab.forge.jlatexmath.Atom GeoGebra_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> GeoGebra_macro
    org.scilab.forge.jlatexmath.Atom hphantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hphantom_macro
    org.scilab.forge.jlatexmath.Atom vphantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> vphantom_macro
    org.scilab.forge.jlatexmath.Atom phantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> phantom_macro
    org.scilab.forge.jlatexmath.Atom big_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> big_macro
    org.scilab.forge.jlatexmath.Atom Big_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Big_macro
    org.scilab.forge.jlatexmath.Atom bigg_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigg_macro
    org.scilab.forge.jlatexmath.Atom Bigg_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigg_macro
    org.scilab.forge.jlatexmath.Atom bigl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigl_macro
    org.scilab.forge.jlatexmath.Atom Bigl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigl_macro
    org.scilab.forge.jlatexmath.Atom biggl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> biggl_macro
    org.scilab.forge.jlatexmath.Atom Biggl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Biggl_macro
    org.scilab.forge.jlatexmath.Atom bigr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigr_macro
    org.scilab.forge.jlatexmath.Atom Bigr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigr_macro
    org.scilab.forge.jlatexmath.Atom biggr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> biggr_macro
    org.scilab.forge.jlatexmath.Atom Biggr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Biggr_macro
    org.scilab.forge.jlatexmath.Atom displaystyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> displaystyle_macro
    org.scilab.forge.jlatexmath.Atom scriptstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scriptstyle_macro
    org.scilab.forge.jlatexmath.Atom textstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textstyle_macro
    org.scilab.forge.jlatexmath.Atom scriptscriptstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scriptscriptstyle_macro
    org.scilab.forge.jlatexmath.Atom rotatebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rotatebox_macro
    org.scilab.forge.jlatexmath.Atom reflectbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> reflectbox_macro
    org.scilab.forge.jlatexmath.Atom scalebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scalebox_macro
    org.scilab.forge.jlatexmath.Atom resizebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> resizebox_macro
    org.scilab.forge.jlatexmath.Atom raisebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> raisebox_macro
    org.scilab.forge.jlatexmath.Atom shadowbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shadowbox_macro
    org.scilab.forge.jlatexmath.Atom ovalbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ovalbox_macro
    org.scilab.forge.jlatexmath.Atom doublebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> doublebox_macro
    org.scilab.forge.jlatexmath.Atom definecolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> definecolor_macro
    org.scilab.forge.jlatexmath.Atom fgcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fgcolor_macro
    org.scilab.forge.jlatexmath.Atom bgcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bgcolor_macro
    org.scilab.forge.jlatexmath.Atom textcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textcolor_macro
    org.scilab.forge.jlatexmath.Atom colorbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colorbox_macro
    org.scilab.forge.jlatexmath.Atom fcolorbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fcolorbox_macro
    org.scilab.forge.jlatexmath.Atom cong_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cong_macro
    org.scilab.forge.jlatexmath.Atom doteq_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> doteq_macro
    org.scilab.forge.jlatexmath.Atom jlmDynamic_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmDynamic_macro
    org.scilab.forge.jlatexmath.Atom jlmExternalFont_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmExternalFont_macro
    org.scilab.forge.jlatexmath.Atom jlmText_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmText_macro
    org.scilab.forge.jlatexmath.Atom jlmTextit_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextit_macro
    org.scilab.forge.jlatexmath.Atom jlmTextbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextbf_macro
    org.scilab.forge.jlatexmath.Atom jlmTextitbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextitbf_macro
    org.scilab.forge.jlatexmath.Atom DeclareMathSizes_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> DeclareMathSizes_macro
    org.scilab.forge.jlatexmath.Atom magnification_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> magnification_macro
    org.scilab.forge.jlatexmath.Atom hline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hline_macro
    org.scilab.forge.jlatexmath.Atom size_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> size_macros
    org.scilab.forge.jlatexmath.Atom jlatexmathcumsup_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlatexmathcumsup_macro
    org.scilab.forge.jlatexmath.Atom jlatexmathcumsub_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlatexmathcumsub_macro
    org.scilab.forge.jlatexmath.Atom dotminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> dotminus_macro
    org.scilab.forge.jlatexmath.Atom ratio_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ratio_macro
    org.scilab.forge.jlatexmath.Atom geoprop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> geoprop_macro
    org.scilab.forge.jlatexmath.Atom minuscolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> minuscolon_macro
    org.scilab.forge.jlatexmath.Atom minuscoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> minuscoloncolon_macro
    org.scilab.forge.jlatexmath.Atom simcolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> simcolon_macro
    org.scilab.forge.jlatexmath.Atom simcoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> simcoloncolon_macro
    org.scilab.forge.jlatexmath.Atom approxcolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> approxcolon_macro
    org.scilab.forge.jlatexmath.Atom approxcoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> approxcoloncolon_macro
    org.scilab.forge.jlatexmath.Atom equalscolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> equalscolon_macro
    org.scilab.forge.jlatexmath.Atom equalscoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> equalscoloncolon_macro
    org.scilab.forge.jlatexmath.Atom colonminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonminus_macro
    org.scilab.forge.jlatexmath.Atom coloncolonminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonminus_macro
    org.scilab.forge.jlatexmath.Atom colonequals_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonequals_macro
    org.scilab.forge.jlatexmath.Atom coloncolonequals_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonequals_macro
    org.scilab.forge.jlatexmath.Atom coloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolon_macro
    org.scilab.forge.jlatexmath.Atom colonsim_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonsim_macro
    org.scilab.forge.jlatexmath.Atom coloncolonsim_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonsim_macro
    org.scilab.forge.jlatexmath.Atom colonapprox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonapprox_macro
    org.scilab.forge.jlatexmath.Atom coloncolonapprox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonapprox_macro
    org.scilab.forge.jlatexmath.Atom smallfrowneq_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smallfrowneq_macro
    org.scilab.forge.jlatexmath.Atom hstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hstrok_macro
    org.scilab.forge.jlatexmath.Atom Hstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Hstrok_macro
    org.scilab.forge.jlatexmath.Atom dstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> dstrok_macro
    org.scilab.forge.jlatexmath.Atom Dstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Dstrok_macro
    org.scilab.forge.jlatexmath.Atom kern_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> kern_macro
    org.scilab.forge.jlatexmath.Atom char_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> char_macro
    org.scilab.forge.jlatexmath.Atom T_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> T_macro
    org.scilab.forge.jlatexmath.Atom romannumeral_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> romannumeral_macro
    org.scilab.forge.jlatexmath.Atom textcircled_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textcircled_macro
    org.scilab.forge.jlatexmath.Atom textsc_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textsc_macro
    org.scilab.forge.jlatexmath.Atom sc_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sc_macro
    org.scilab.forge.jlatexmath.Atom quad_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> quad_macro
    org.scilab.forge.jlatexmath.Atom muskip_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> muskip_macros
    org.scilab.forge.jlatexmath.Atom surd_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> surd_macro
    org.scilab.forge.jlatexmath.Atom int_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> int_macro
    org.scilab.forge.jlatexmath.Atom oint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> oint_macro
    org.scilab.forge.jlatexmath.Atom iint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iint_macro
    org.scilab.forge.jlatexmath.Atom iiint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iiint_macro
    org.scilab.forge.jlatexmath.Atom iiiint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iiiint_macro
    org.scilab.forge.jlatexmath.Atom idotsint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> idotsint_macro
    org.scilab.forge.jlatexmath.Atom lmoustache_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> lmoustache_macro
    org.scilab.forge.jlatexmath.Atom rmoustache_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rmoustache_macro
    org.scilab.forge.jlatexmath.Atom insertBreakMark_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> insertBreakMark_macro
    org.scilab.forge.jlatexmath.Atom jlmXML_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmXML_macro
org.scilab.forge.jlatexmath.PredefinedCommands -> org.scilab.forge.jlatexmath.PredefinedCommands:
org.scilab.forge.jlatexmath.PredefinedTeXFormulaParser -> org.scilab.forge.jlatexmath.PredefinedTeXFormulaParser:
    org.w3c.dom.Element root -> a
    java.lang.String type -> a
    void parse(java.util.Map) -> parse
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.PredefinedTeXFormulas -> org.scilab.forge.jlatexmath.PredefinedTeXFormulas:
org.scilab.forge.jlatexmath.RaiseAtom -> org.scilab.forge.jlatexmath.RaiseAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    int runit -> d
    int hunit -> e
    int dunit -> f
    float r -> a
    float h -> b
    float d -> c
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ReflectAtom -> org.scilab.forge.jlatexmath.ReflectAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ReflectBox -> org.scilab.forge.jlatexmath.ReflectBox:
    org.scilab.forge.jlatexmath.Box box -> c
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.ResizeAtom -> org.scilab.forge.jlatexmath.ResizeAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    int wunit -> d
    int hunit -> e
    float w -> a
    float h -> b
    boolean keepaspectratio -> a
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ResourceParseException -> org.scilab.forge.jlatexmath.ResourceParseException:
org.scilab.forge.jlatexmath.RomanAtom -> org.scilab.forge.jlatexmath.RomanAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.RotateAtom -> org.scilab.forge.jlatexmath.RotateAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    double angle -> a
    int option -> d
    int xunit -> e
    int yunit -> f
    float x -> a
    float y -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.RotateBox -> org.scilab.forge.jlatexmath.RotateBox:
    double angle -> a
    org.scilab.forge.jlatexmath.Box box -> c
    float xmax -> e
    float xmin -> f
    float ymax -> g
    float ymin -> h
    float shiftX -> i
    float shiftY -> j
    int getOrigin(java.lang.String) -> getOrigin
    java.awt.geom.Point2D$Float calculateShift(org.scilab.forge.jlatexmath.Box,int) -> calculateShift
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.Row -> org.scilab.forge.jlatexmath.Row:
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.RowAtom -> org.scilab.forge.jlatexmath.RowAtom:
    java.util.LinkedList elements -> a
    boolean lookAtLastAtom -> a
    org.scilab.forge.jlatexmath.Dummy previousAtom -> a
    java.util.BitSet binSet -> a
    java.util.BitSet ligKernSet -> b
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    void add(org.scilab.forge.jlatexmath.Atom) -> add
    void changeToOrd(org.scilab.forge.jlatexmath.Dummy,org.scilab.forge.jlatexmath.Dummy,org.scilab.forge.jlatexmath.Atom) -> changeToOrd
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.RuleAtom -> org.scilab.forge.jlatexmath.RuleAtom:
    int wunit -> d
    int hunit -> e
    int runit -> f
    float w -> a
    float h -> b
    float r -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ScaleAtom -> org.scilab.forge.jlatexmath.ScaleAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    double xscl -> a
    double yscl -> b
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ScaleBox -> org.scilab.forge.jlatexmath.ScaleBox:
    org.scilab.forge.jlatexmath.Box box -> c
    double xscl -> a
    double yscl -> b
    float factor -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.ScriptsAtom -> org.scilab.forge.jlatexmath.ScriptsAtom:
    org.scilab.forge.jlatexmath.SpaceAtom SCRIPT_SPACE -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom subscript -> b
    org.scilab.forge.jlatexmath.Atom superscript -> c
    int align -> d
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.ShadowAtom -> org.scilab.forge.jlatexmath.ShadowAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ShadowBox -> org.scilab.forge.jlatexmath.ShadowBox:
    float shadowRule -> g
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.SmallCapAtom -> org.scilab.forge.jlatexmath.SmallCapAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SmashedAtom -> org.scilab.forge.jlatexmath.SmashedAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    boolean h -> a
    boolean d -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SpaceAtom -> org.scilab.forge.jlatexmath.SpaceAtom:
    java.util.Map units -> a
    org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion[] unitConversions -> a
    boolean blankSpace -> a
    int blankType -> d
    float width -> a
    float height -> b
    float depth -> c
    int wUnit -> e
    int hUnit -> f
    int dUnit -> g
    void checkUnit(int) -> checkUnit
    int getUnit(java.lang.String) -> getUnit
    float[] getLength(java.lang.String) -> getLength
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    float getFactor(int,org.scilab.forge.jlatexmath.TeXEnvironment) -> getFactor
org.scilab.forge.jlatexmath.SpaceAtom$1 -> org.scilab.forge.jlatexmath.SpaceAtom$1:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$10 -> org.scilab.forge.jlatexmath.SpaceAtom$10:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$11 -> org.scilab.forge.jlatexmath.SpaceAtom$11:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$12 -> org.scilab.forge.jlatexmath.SpaceAtom$12:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$13 -> org.scilab.forge.jlatexmath.SpaceAtom$13:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$2 -> org.scilab.forge.jlatexmath.SpaceAtom$2:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$3 -> org.scilab.forge.jlatexmath.SpaceAtom$3:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$4 -> org.scilab.forge.jlatexmath.SpaceAtom$4:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$5 -> org.scilab.forge.jlatexmath.SpaceAtom$5:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$6 -> org.scilab.forge.jlatexmath.SpaceAtom$6:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$7 -> org.scilab.forge.jlatexmath.SpaceAtom$7:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$8 -> org.scilab.forge.jlatexmath.SpaceAtom$8:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$9 -> org.scilab.forge.jlatexmath.SpaceAtom$9:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion -> org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SsAtom -> org.scilab.forge.jlatexmath.SsAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.StrutBox -> org.scilab.forge.jlatexmath.StrutBox:
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.StyleAtom -> org.scilab.forge.jlatexmath.StyleAtom:
    int style -> d
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SymbolAtom -> org.scilab.forge.jlatexmath.SymbolAtom:
    boolean delimiter -> a
    java.lang.String name -> a
    java.util.Map symbols -> a
    java.util.BitSet validSymbolTypes -> a
    char unicode -> a
    org.scilab.forge.jlatexmath.SymbolAtom setUnicode(char) -> setUnicode
    char getUnicode() -> getUnicode
    void addSymbolAtom(java.lang.String) -> addSymbolAtom
    void addSymbolAtom(java.io.InputStream,java.lang.String) -> addSymbolAtom
    void addSymbolAtom(org.scilab.forge.jlatexmath.SymbolAtom) -> addSymbolAtom
    org.scilab.forge.jlatexmath.SymbolAtom get(java.lang.String) -> get
    boolean isDelimiter() -> isDelimiter
    java.lang.String getName() -> getName
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
org.scilab.forge.jlatexmath.SymbolMappingNotFoundException -> org.scilab.forge.jlatexmath.SymbolMappingNotFoundException:
org.scilab.forge.jlatexmath.SymbolNotFoundException -> org.scilab.forge.jlatexmath.SymbolNotFoundException:
org.scilab.forge.jlatexmath.TStrokeAtom -> org.scilab.forge.jlatexmath.TStrokeAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TeXConstants -> org.scilab.forge.jlatexmath.TeXConstants:
org.scilab.forge.jlatexmath.TeXEnvironment -> org.scilab.forge.jlatexmath.TeXEnvironment:
    java.awt.Color background -> a
    java.awt.Color color -> b
    int style -> a
    org.scilab.forge.jlatexmath.TeXFont tf -> a
    int lastFontId -> b
    float textwidth -> a
    java.lang.String textStyle -> a
    boolean smallCap -> b
    float scaleFactor -> b
    boolean isColored -> a
    void setTextwidth(int,float) -> setTextwidth
    float getTextwidth() -> getTextwidth
    void setScaleFactor(float) -> setScaleFactor
    float getScaleFactor() -> getScaleFactor
    org.scilab.forge.jlatexmath.TeXEnvironment copy() -> copy
    org.scilab.forge.jlatexmath.TeXEnvironment copy(org.scilab.forge.jlatexmath.TeXFont) -> copy
    org.scilab.forge.jlatexmath.TeXEnvironment crampStyle() -> crampStyle
    org.scilab.forge.jlatexmath.TeXEnvironment denomStyle() -> denomStyle
    java.awt.Color getBackground() -> getBackground
    java.awt.Color getColor() -> getColor
    float getSize() -> getSize
    int getStyle() -> getStyle
    void setStyle(int) -> setStyle
    java.lang.String getTextStyle() -> getTextStyle
    void setTextStyle(java.lang.String) -> setTextStyle
    boolean getSmallCap() -> getSmallCap
    void setSmallCap(boolean) -> setSmallCap
    org.scilab.forge.jlatexmath.TeXFont getTeXFont() -> getTeXFont
    org.scilab.forge.jlatexmath.TeXEnvironment numStyle() -> numStyle
    void reset() -> reset
    org.scilab.forge.jlatexmath.TeXEnvironment rootStyle() -> rootStyle
    void setBackground(java.awt.Color) -> setBackground
    void setColor(java.awt.Color) -> setColor
    org.scilab.forge.jlatexmath.TeXEnvironment subStyle() -> subStyle
    org.scilab.forge.jlatexmath.TeXEnvironment supStyle() -> supStyle
    float getSpace() -> getSpace
    void setLastFontId(int) -> setLastFontId
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.TeXFont -> org.scilab.forge.jlatexmath.TeXFont:
    org.scilab.forge.jlatexmath.TeXFont deriveFont(float) -> deriveFont
    org.scilab.forge.jlatexmath.TeXFont scaleFont(float) -> scaleFont
    float getScaleFactor() -> getScaleFactor
    float getAxisHeight(int) -> getAxisHeight
    float getBigOpSpacing1(int) -> getBigOpSpacing1
    float getBigOpSpacing2(int) -> getBigOpSpacing2
    float getBigOpSpacing3(int) -> getBigOpSpacing3
    float getBigOpSpacing4(int) -> getBigOpSpacing4
    float getBigOpSpacing5(int) -> getBigOpSpacing5
    org.scilab.forge.jlatexmath.Char getChar(char,java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.CharFont,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getDefaultChar(char,int) -> getDefaultChar
    float getDefaultRuleThickness(int) -> getDefaultRuleThickness
    float getDenom1(int) -> getDenom1
    float getDenom2(int) -> getDenom2
    org.scilab.forge.jlatexmath.Extension getExtension(org.scilab.forge.jlatexmath.Char,int) -> getExtension
    float getKern(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont,int) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont) -> getLigature
    int getMuFontId() -> getMuFontId
    org.scilab.forge.jlatexmath.Char getNextLarger(org.scilab.forge.jlatexmath.Char,int) -> getNextLarger
    float getNum1(int) -> getNum1
    float getNum2(int) -> getNum2
    float getNum3(int) -> getNum3
    float getQuad(int,int) -> getQuad
    float getSize() -> getSize
    float getSkew(org.scilab.forge.jlatexmath.CharFont,int) -> getSkew
    float getSpace(int) -> getSpace
    float getSub1(int) -> getSub1
    float getSub2(int) -> getSub2
    float getSubDrop(int) -> getSubDrop
    float getSup1(int) -> getSup1
    float getSup2(int) -> getSup2
    float getSup3(int) -> getSup3
    float getSupDrop(int) -> getSupDrop
    float getXHeight(int,int) -> getXHeight
    float getEM(int) -> getEM
    boolean hasNextLarger(org.scilab.forge.jlatexmath.Char) -> hasNextLarger
    boolean hasSpace(int) -> hasSpace
    void setBold(boolean) -> setBold
    boolean getBold() -> getBold
    void setRoman(boolean) -> setRoman
    boolean getRoman() -> getRoman
    void setTt(boolean) -> setTt
    boolean getTt() -> getTt
    void setIt(boolean) -> setIt
    boolean getIt() -> getIt
    void setSs(boolean) -> setSs
    boolean getSs() -> getSs
    boolean isExtensionChar(org.scilab.forge.jlatexmath.Char) -> isExtensionChar
    org.scilab.forge.jlatexmath.TeXFont copy() -> copy
org.scilab.forge.jlatexmath.TeXFormula -> org.scilab.forge.jlatexmath.TeXFormula:
    java.lang.String[][] delimiterNames -> a
    float PIXELS_PER_POINT -> a
    java.util.Map predefinedTeXFormulas -> a
    java.util.Map predefinedTeXFormulasAsString -> b
    java.lang.String[] symbolMappings -> a
    java.lang.String[] symbolTextMappings -> b
    java.lang.String[] symbolFormulaMappings -> c
    java.util.Map externalFontMap -> c
    java.util.List middle -> a
    java.util.Map jlmXMLMap -> d
    org.scilab.forge.jlatexmath.TeXParser parser -> a
    org.scilab.forge.jlatexmath.Atom root -> a
    java.lang.String textStyle -> a
    boolean isColored -> a
    void addSymbolMappings(java.lang.String) -> addSymbolMappings
    void addSymbolMappings(java.io.InputStream,java.lang.String) -> addSymbolMappings
    void registerExternalFont(java.lang.Character$UnicodeBlock,java.lang.String,java.lang.String) -> registerExternalFont
    void registerExternalFont(java.lang.Character$UnicodeBlock,java.lang.String) -> registerExternalFont
    void setDPITarget(float) -> setDPITarget
    void setDefaultDPI() -> setDefaultDPI
    org.scilab.forge.jlatexmath.TeXFormula getAsText(java.lang.String,int) -> getAsText
    org.scilab.forge.jlatexmath.TeXFormula getPartialTeXFormula(java.lang.String) -> getPartialTeXFormula
    void registerFonts(boolean) -> registerFonts
    void setLaTeX(java.lang.String) -> setLaTeX
    org.scilab.forge.jlatexmath.TeXFormula add(org.scilab.forge.jlatexmath.Atom) -> add
    org.scilab.forge.jlatexmath.TeXFormula add(java.lang.String) -> add
    org.scilab.forge.jlatexmath.TeXFormula append(java.lang.String) -> append
    org.scilab.forge.jlatexmath.TeXFormula append(boolean,java.lang.String) -> append
    org.scilab.forge.jlatexmath.TeXFormula add(org.scilab.forge.jlatexmath.TeXFormula) -> add
    void addImpl(org.scilab.forge.jlatexmath.TeXFormula) -> addImpl
    void setLookAtLastAtom(boolean) -> setLookAtLastAtom
    boolean getLookAtLastAtom() -> getLookAtLastAtom
    org.scilab.forge.jlatexmath.TeXFormula centerOnAxis() -> centerOnAxis
    void addPredefinedTeXFormula(java.io.InputStream) -> addPredefinedTeXFormula
    void addPredefinedCommands(java.io.InputStream) -> addPredefinedCommands
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int,float,float,float) -> addStrut
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int) -> addStrut
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int,float,int,float,int,float) -> addStrut
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.DefaultTeXFont createFont(float,int) -> createFont
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,java.awt.Color) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,boolean) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,float,int,int,float) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,int,float,int,int,float) -> createTeXIcon
    void createImage(java.lang.String,int,float,java.lang.String,java.awt.Color,java.awt.Color,boolean) -> createImage
    void createPNG(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createPNG
    void createGIF(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createGIF
    void createJPEG(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createJPEG
    java.awt.Image createBufferedImage(java.lang.String,int,float,java.awt.Color,java.awt.Color) -> createBufferedImage
    java.awt.Image createBufferedImage(int,float,java.awt.Color,java.awt.Color) -> createBufferedImage
    void setDEBUG(boolean) -> setDEBUG
    org.scilab.forge.jlatexmath.TeXFormula setBackground(java.awt.Color) -> setBackground
    org.scilab.forge.jlatexmath.TeXFormula setColor(java.awt.Color) -> setColor
    org.scilab.forge.jlatexmath.TeXFormula setFixedTypes(int,int) -> setFixedTypes
    org.scilab.forge.jlatexmath.TeXFormula get(java.lang.String) -> get
    org.scilab.forge.jlatexmath.DefaultTeXFont access$000(org.scilab.forge.jlatexmath.TeXFormula,float,int) -> access$000
    org.scilab.forge.jlatexmath.Box access$100(org.scilab.forge.jlatexmath.TeXFormula,org.scilab.forge.jlatexmath.TeXEnvironment) -> access$100
org.scilab.forge.jlatexmath.TeXFormula$FontInfos -> org.scilab.forge.jlatexmath.TeXFormula$FontInfos:
    java.lang.String sansserif -> a
    java.lang.String serif -> b
org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder -> org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder:
    java.lang.Integer style -> a
    java.lang.Float size -> a
    java.lang.Integer type -> b
    java.awt.Color fgcolor -> a
    boolean trueValues -> a
    java.lang.Integer widthUnit -> c
    java.lang.Float textWidth -> b
    java.lang.Integer align -> d
    boolean isMaxWidth -> b
    java.lang.Integer interLineUnit -> e
    java.lang.Float interLineSpacing -> c
    org.scilab.forge.jlatexmath.TeXFormula this$0 -> a
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setStyle(int) -> setStyle
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setSize(float) -> setSize
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setType(int) -> setType
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setFGColor(java.awt.Color) -> setFGColor
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setTrueValues(boolean) -> setTrueValues
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setWidth(int,float,int) -> setWidth
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setIsMaxWidth(boolean) -> setIsMaxWidth
    org.scilab.forge.jlatexmath.TeXFormula$TeXIconBuilder setInterLineSpacing(int,float) -> setInterLineSpacing
    org.scilab.forge.jlatexmath.TeXIcon build() -> build
org.scilab.forge.jlatexmath.TeXFormulaParser -> org.scilab.forge.jlatexmath.TeXFormulaParser:
    java.util.Map classMappings -> a
    java.util.Map argValueParsers -> b
    java.util.Map actionParsers -> c
    java.util.Map tempFormulas -> d
    java.util.Map tempCommands -> e
    java.lang.Object result -> a
    java.lang.String formulaName -> a
    org.w3c.dom.Element formula -> a
    int type -> a
    java.lang.Object parse() -> parse
    java.lang.Object[] getArgumentValues(org.w3c.dom.NodeList) -> getArgumentValues
    java.lang.Class[] getArgumentClasses(org.w3c.dom.NodeList) -> getArgumentClasses
    void checkNullValue(java.lang.String,java.lang.String) -> checkNullValue
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
    java.lang.String access$000(java.lang.String,org.w3c.dom.Element) -> access$000
    java.util.Map access$100(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$100
    java.lang.Class[] access$200(org.w3c.dom.NodeList) -> access$200
    java.lang.Object[] access$300(org.scilab.forge.jlatexmath.TeXFormulaParser,org.w3c.dom.NodeList) -> access$300
    java.lang.String access$400(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$400
    java.util.Map access$500(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$500
    void access$600(java.lang.String,java.lang.String) -> access$600
    int access$700(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$700
    java.lang.Object access$802(org.scilab.forge.jlatexmath.TeXFormulaParser,java.lang.Object) -> access$802
org.scilab.forge.jlatexmath.TeXFormulaParser$ActionParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ActionParser:
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$ArgumentValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ArgumentValueParser:
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$BooleanValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$BooleanValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$CharValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CharValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$ColorConstantValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ColorConstantValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$CreateCommandParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CreateCommandParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$CreateTeXFormulaParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CreateTeXFormulaParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$FloatValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$FloatValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$IntValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$IntValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$MethodInvocationParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$MethodInvocationParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$ReturnParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ReturnParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$StringValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$StringValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$TeXConstantsValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$TeXConstantsValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$TeXFormulaValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$TeXFormulaValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaSettingsParser -> org.scilab.forge.jlatexmath.TeXFormulaSettingsParser:
    org.w3c.dom.Element root -> a
    void parseSymbolToFormulaMappings(java.lang.String[],java.lang.String[]) -> parseSymbolToFormulaMappings
    void parseSymbolMappings(java.lang.String[],java.lang.String[]) -> parseSymbolMappings
    void addToMap(org.w3c.dom.NodeList,java.lang.String[],java.lang.String[]) -> addToMap
    void addFormulaToMap(org.w3c.dom.NodeList,java.lang.String[],java.lang.String[]) -> addFormulaToMap
org.scilab.forge.jlatexmath.TeXIcon -> org.scilab.forge.jlatexmath.TeXIcon:
    java.awt.Color defaultColor -> a
    float defaultSize -> a
    float magFactor -> b
    org.scilab.forge.jlatexmath.Box box -> a
    float size -> c
    java.awt.Insets insets -> a
    java.awt.Color fg -> b
    boolean isColored -> a
    void setForeground(java.awt.Color) -> setForeground
    java.awt.Insets getInsets() -> getInsets
    void setInsets(java.awt.Insets,boolean) -> setInsets
    void setInsets(java.awt.Insets) -> setInsets
    void setIconWidth(int,int) -> setIconWidth
    void setIconHeight(int,int) -> setIconHeight
    int getIconHeight() -> getIconHeight
    int getIconDepth() -> getIconDepth
    int getIconWidth() -> getIconWidth
    float getTrueIconHeight() -> getTrueIconHeight
    float getTrueIconDepth() -> getTrueIconDepth
    float getTrueIconWidth() -> getTrueIconWidth
    float getBaseLine() -> getBaseLine
    org.scilab.forge.jlatexmath.Box getBox() -> getBox
    void paintIcon(java.awt.Component,java.awt.Graphics,int,int) -> paintIcon
org.scilab.forge.jlatexmath.TeXParser -> org.scilab.forge.jlatexmath.TeXParser:
    org.scilab.forge.jlatexmath.TeXFormula formula -> a
    java.lang.StringBuffer parseString -> a
    int pos -> a
    int spos -> b
    int line -> c
    int col -> d
    int len -> e
    int group -> f
    boolean insertion -> b
    int atIsLetter -> g
    boolean arrayMode -> c
    boolean ignoreWhiteSpace -> d
    boolean isPartial -> e
    boolean isLoading -> a
    java.util.Set unparsedContents -> a
    void reset(java.lang.String) -> reset
    boolean getIsPartial() -> getIsPartial
    int getLine() -> getLine
    int getCol() -> getCol
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    org.scilab.forge.jlatexmath.Atom getFormulaAtom() -> getFormulaAtom
    void addAtom(org.scilab.forge.jlatexmath.Atom) -> addAtom
    void makeAtLetter() -> makeAtLetter
    void makeAtOther() -> makeAtOther
    boolean isAtLetter() -> isAtLetter
    boolean isArrayMode() -> isArrayMode
    void setArrayMode(boolean) -> setArrayMode
    boolean isIgnoreWhiteSpace() -> isIgnoreWhiteSpace
    boolean isMathMode() -> isMathMode
    int getPos() -> getPos
    int rewind(int) -> rewind
    java.lang.String getStringFromCurrentPos() -> getStringFromCurrentPos
    void finish() -> finish
    void addRow() -> addRow
    void firstpass() -> firstpass
    void parse() -> parse
    org.scilab.forge.jlatexmath.Atom getScripts(char) -> getScripts
    java.lang.String getDollarGroup(char) -> getDollarGroup
    java.lang.String getGroup(char,char) -> getGroup
    java.lang.String getGroup(java.lang.String,java.lang.String) -> getGroup
    org.scilab.forge.jlatexmath.Atom getArgument() -> getArgument
    java.lang.String getOverArgument() -> getOverArgument
    float[] getLength() -> getLength
    org.scilab.forge.jlatexmath.Atom convertCharacter(char,boolean) -> convertCharacter
    java.lang.String getCommand() -> getCommand
    org.scilab.forge.jlatexmath.Atom processEscape() -> processEscape
    void insert(int,int,java.lang.String) -> insert
    java.lang.String[] getOptsArgs(int,int) -> getOptsArgs
    java.lang.String getCommandWithArgs(java.lang.String) -> getCommandWithArgs
    org.scilab.forge.jlatexmath.Atom processCommands(java.lang.String) -> processCommands
    boolean isValidName(java.lang.String) -> isValidName
    boolean isValidCharacterInCommand(char) -> isValidCharacterInCommand
    void skipWhiteSpace() -> skipWhiteSpace
    char convertToRomanNumber(char) -> convertToRomanNumber
org.scilab.forge.jlatexmath.TeXSymbolParser -> org.scilab.forge.jlatexmath.TeXSymbolParser:
    java.util.Map typeMappings -> a
    org.w3c.dom.Element root -> a
    java.util.Map readSymbols() -> readSymbols
    void setTypeMappings() -> setTypeMappings
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.TextCircledAtom -> org.scilab.forge.jlatexmath.TextCircledAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TextStyleAtom -> org.scilab.forge.jlatexmath.TextStyleAtom:
    java.lang.String style -> a
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TextStyleMappingNotFoundException -> org.scilab.forge.jlatexmath.TextStyleMappingNotFoundException:
org.scilab.forge.jlatexmath.TtAtom -> org.scilab.forge.jlatexmath.TtAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TypedAtom -> org.scilab.forge.jlatexmath.TypedAtom:
    int leftType -> d
    int rightType -> e
    org.scilab.forge.jlatexmath.Atom atom -> a
    org.scilab.forge.jlatexmath.Atom getBase() -> getBase
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.URLAlphabetRegistration -> org.scilab.forge.jlatexmath.URLAlphabetRegistration:
    java.net.URL url -> a
    java.lang.String language -> a
    org.scilab.forge.jlatexmath.AlphabetRegistration pack -> a
    java.lang.Character$UnicodeBlock[] blocks -> c
    void register(java.net.URL,java.lang.String,java.lang.Character$UnicodeBlock[]) -> register
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.UnderOverArrowAtom -> org.scilab.forge.jlatexmath.UnderOverArrowAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    java.lang.String arrow -> a
    boolean over -> a
    boolean left -> b
    boolean dble -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.UnderOverAtom -> org.scilab.forge.jlatexmath.UnderOverAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom under -> b
    org.scilab.forge.jlatexmath.Atom over -> c
    float underSpace -> a
    float overSpace -> b
    int underUnit -> d
    int overUnit -> e
    boolean underScriptSize -> a
    boolean overScriptSize -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box changeWidth(org.scilab.forge.jlatexmath.Box,float) -> changeWidth
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.UnderlinedAtom -> org.scilab.forge.jlatexmath.UnderlinedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.UnderscoreAtom -> org.scilab.forge.jlatexmath.UnderscoreAtom:
    org.scilab.forge.jlatexmath.SpaceAtom w -> a
    org.scilab.forge.jlatexmath.SpaceAtom s -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VCenteredAtom -> org.scilab.forge.jlatexmath.VCenteredAtom:
    org.scilab.forge.jlatexmath.Atom atom -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VRowAtom -> org.scilab.forge.jlatexmath.VRowAtom:
    java.util.LinkedList elements -> a
    org.scilab.forge.jlatexmath.SpaceAtom raise -> a
    void setRaise(int,float) -> setRaise
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    void add(org.scilab.forge.jlatexmath.Atom) -> add
    void append(org.scilab.forge.jlatexmath.Atom) -> append
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VdotsAtom -> org.scilab.forge.jlatexmath.VdotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VerticalBox -> org.scilab.forge.jlatexmath.VerticalBox:
    float leftMostPos -> e
    float rightMostPos -> f
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(org.scilab.forge.jlatexmath.Box,float) -> add
    void recalculateWidth(org.scilab.forge.jlatexmath.Box) -> recalculateWidth
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getSize() -> getSize
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.VlineAtom -> org.scilab.forge.jlatexmath.VlineAtom:
    float height -> a
    float shift -> b
    int n -> d
    void setHeight(float) -> setHeight
    void setShift(float) -> setShift
    float getWidth(org.scilab.forge.jlatexmath.TeXEnvironment) -> getWidth
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.WebStartAlphabetRegistration -> org.scilab.forge.jlatexmath.WebStartAlphabetRegistration:
    java.lang.Character$UnicodeBlock[] blocks -> c
    org.scilab.forge.jlatexmath.AlphabetRegistration reg -> a
    void register(java.lang.Character$UnicodeBlock[]) -> register
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.XArrowAtom -> org.scilab.forge.jlatexmath.XArrowAtom:
    org.scilab.forge.jlatexmath.Atom over -> a
    org.scilab.forge.jlatexmath.Atom under -> b
    boolean left -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.XLeftRightArrowFactory -> org.scilab.forge.jlatexmath.XLeftRightArrowFactory:
    org.scilab.forge.jlatexmath.Atom MINUS -> a
    org.scilab.forge.jlatexmath.Atom LEFT -> b
    org.scilab.forge.jlatexmath.Atom RIGHT -> c
    org.scilab.forge.jlatexmath.Box create(boolean,org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
    org.scilab.forge.jlatexmath.Box create(org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
org.scilab.forge.jlatexmath.XMLResourceParseException -> org.scilab.forge.jlatexmath.XMLResourceParseException:
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache -> org.scilab.forge.jlatexmath.a.a:
    java.awt.geom.AffineTransform identity -> a
    java.util.concurrent.ConcurrentMap cache -> a
    int max -> a
    java.lang.ref.ReferenceQueue queue -> a
    void setMaxCachedObjects(int) -> a
    int[] getCachedTeXFormulaDimensions(java.lang.Object) -> a
    java.lang.Object getCachedTeXFormula(java.lang.String,int,int,int,int,java.awt.Color) -> a
    void clearCache() -> a
    void removeCachedTeXFormula(java.lang.Object) -> a
    java.awt.Image getCachedTeXFormulaImage(java.lang.Object) -> a
    java.lang.ref.SoftReference makeImage(org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula) -> a
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedImage -> org.scilab.forge.jlatexmath.a.a$a:
    java.awt.Image image -> a
    org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula cachedTf -> a
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula -> org.scilab.forge.jlatexmath.a.a$b:
    java.lang.String f -> a
    int style -> a
    int type -> b
    int size -> c
    int inset -> d
    int width -> e
    int height -> f
    int depth -> g
    java.awt.Color fgcolor -> a
    void setDimensions(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.scilab.forge.jlatexmath.dynamic.DynamicAtom -> org.scilab.forge.jlatexmath.b.a:
    org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory ecFactory -> a
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter converter -> a
    org.scilab.forge.jlatexmath.TeXFormula formula -> a
    java.lang.String externalCode -> a
    boolean insert -> a
    boolean refreshed -> b
    boolean hasAnExternalConverterFactory() -> a
    void setExternalConverterFactory(org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory) -> a
    boolean getInsertMode() -> b
    org.scilab.forge.jlatexmath.Atom getAtom() -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.dynamic.ExternalConverter -> org.scilab.forge.jlatexmath.b.b:
    java.lang.String getLaTeXString(java.lang.String) -> a
org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory -> org.scilab.forge.jlatexmath.b.c:
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter getExternalConverter() -> a
org.scilab.forge.jlatexmath.tcaronAtom -> org.scilab.forge.jlatexmath.tcaronAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
